// THIS FILE IS AUTOMATICALLY GENERATED, DO NOT EDIT BY HAND!

#include "torch_api_generated.h"

namespace TypeTorch {

Napi::External<torch::Tensor> atg__cast_Byte(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  bool non_blocking = info__[1].As<Napi::Boolean>().Value();
  auto output__ = torch::_cast_Byte(*self, non_blocking);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__cast_Char(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  bool non_blocking = info__[1].As<Napi::Boolean>().Value();
  auto output__ = torch::_cast_Char(*self, non_blocking);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__cast_Double(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  bool non_blocking = info__[1].As<Napi::Boolean>().Value();
  auto output__ = torch::_cast_Double(*self, non_blocking);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__cast_Float(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  bool non_blocking = info__[1].As<Napi::Boolean>().Value();
  auto output__ = torch::_cast_Float(*self, non_blocking);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__cast_Int(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  bool non_blocking = info__[1].As<Napi::Boolean>().Value();
  auto output__ = torch::_cast_Int(*self, non_blocking);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__cast_Long(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  bool non_blocking = info__[1].As<Napi::Boolean>().Value();
  auto output__ = torch::_cast_Long(*self, non_blocking);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__cast_Short(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  bool non_blocking = info__[1].As<Napi::Boolean>().Value();
  auto output__ = torch::_cast_Short(*self, non_blocking);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__cast_Half(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  bool non_blocking = info__[1].As<Napi::Boolean>().Value();
  auto output__ = torch::_cast_Half(*self, non_blocking);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

void atg_set_data(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *new_data = info__[1].As<Napi::External<torch::Tensor>>().Data();
  self->set_data(*new_data);
}

Napi::External<torch::Tensor> atg_data(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = self->data();
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::Boolean atg_is_leaf(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = self->is_leaf();
  return Napi::Boolean::New(env__, output__);
}

Napi::Number atg_output_nr(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = self->output_nr();
  return Napi::Number::New(env__, output__);
}

Napi::Number atg__version(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = self->_version();
  return Napi::Number::New(env__, output__);
}

Napi::External<torch::Tensor> atg_requires_grad_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  bool requires_grad = info__[1].As<Napi::Boolean>().Value();
  auto output__ = self->requires_grad_(requires_grad);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::Boolean atg_retains_grad(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = self->retains_grad();
  return Napi::Boolean::New(env__, output__);
}

Napi::External<torch::Tensor> atg__fw_primal(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t level = info__[1].As<Napi::Number>().Int64Value();
  auto output__ = self->_fw_primal(level);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__make_dual(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *primal = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *tangent = info__[1].As<Napi::External<torch::Tensor>>().Data();
  int64_t level = info__[2].As<Napi::Number>().Int64Value();
  auto output__ = torch::_make_dual(*primal, *tangent, level);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::Array atg__unpack_dual(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *dual = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t level = info__[1].As<Napi::Number>().Int64Value();
  auto output__ = torch::_unpack_dual(*dual, level);
  Napi::Array output__array__ = Napi::Array::New(env__, 2);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  return output__array__;
}

Napi::External<torch::Tensor> atg__new_zeros_with_same_feature_meta(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[1].As<Napi::External<torch::Tensor>>().Data();
  int64_t self_num_batch_dims = info__[2].As<Napi::Number>().Int64Value();
  auto output__ = torch::_new_zeros_with_same_feature_meta(*self, *other, self_num_batch_dims);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__new_zeros_with_same_feature_meta_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[2].As<Napi::External<torch::Tensor>>().Data();
  int64_t self_num_batch_dims = info__[3].As<Napi::Number>().Int64Value();
  auto output__ = torch::_new_zeros_with_same_feature_meta_out(*out, *self, *other, self_num_batch_dims);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::Boolean atg__has_same_storage_numel(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::_has_same_storage_numel(*self, *other);
  return Napi::Boolean::New(env__, output__);
}

Napi::External<torch::Tensor> atg_align_as(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = self->align_as(*other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

void atg__assert_tensor_metadata(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *a = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array size_array__ = info__[1].As<Napi::Array>();
  int size_len = size_array__.Length();
  int64_t *size_data = new int64_t[size_len];
  for (int i = 0; i < size_len; ++i)
    size_data[i] = size_array__.Get(i).ToNumber().Int64Value();
  Napi::Array stride_array__ = info__[2].As<Napi::Array>();
  int stride_len = stride_array__.Length();
  int64_t *stride_data = new int64_t[stride_len];
  for (int i = 0; i < stride_len; ++i)
    stride_data[i] = stride_array__.Get(i).ToNumber().Int64Value();
  int dtype = info__[3].As<Napi::Number>().Int32Value();
  torch::_assert_tensor_metadata(*a, size_data == nullptr ? c10::nullopt : c10::optional<torch::IntArrayRef>(torch::IntArrayRef(size_data, size_len)), stride_data == nullptr ? c10::nullopt : c10::optional<torch::IntArrayRef>(torch::IntArrayRef(stride_data, stride_len)), at::ScalarType(dtype));
}

Napi::Boolean atg__use_cudnn_ctc_loss(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *log_probs = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *targets = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array input_lengths_array__ = info__[2].As<Napi::Array>();
  int input_lengths_len = input_lengths_array__.Length();
  int64_t *input_lengths_data = new int64_t[input_lengths_len];
  for (int i = 0; i < input_lengths_len; ++i)
    input_lengths_data[i] = input_lengths_array__.Get(i).ToNumber().Int64Value();
  Napi::Array target_lengths_array__ = info__[3].As<Napi::Array>();
  int target_lengths_len = target_lengths_array__.Length();
  int64_t *target_lengths_data = new int64_t[target_lengths_len];
  for (int i = 0; i < target_lengths_len; ++i)
    target_lengths_data[i] = target_lengths_array__.Get(i).ToNumber().Int64Value();
  int64_t blank = info__[4].As<Napi::Number>().Int64Value();
  auto output__ = torch::_use_cudnn_ctc_loss(*log_probs, *targets, torch::IntArrayRef(input_lengths_data, input_lengths_len), torch::IntArrayRef(target_lengths_data, target_lengths_len), blank);
  return Napi::Boolean::New(env__, output__);
}

Napi::Boolean atg__use_cudnn_ctc_loss_tensor(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *log_probs = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *targets = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *input_lengths = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *target_lengths = info__[3].As<Napi::External<torch::Tensor>>().Data();
  int64_t blank = info__[4].As<Napi::Number>().Int64Value();
  auto output__ = torch::_use_cudnn_ctc_loss(*log_probs, *targets, *input_lengths, *target_lengths, blank);
  return Napi::Boolean::New(env__, output__);
}

Napi::Array atg__cudnn_ctc_loss(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *log_probs = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *targets = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array input_lengths_array__ = info__[2].As<Napi::Array>();
  int input_lengths_len = input_lengths_array__.Length();
  int64_t *input_lengths_data = new int64_t[input_lengths_len];
  for (int i = 0; i < input_lengths_len; ++i)
    input_lengths_data[i] = input_lengths_array__.Get(i).ToNumber().Int64Value();
  Napi::Array target_lengths_array__ = info__[3].As<Napi::Array>();
  int target_lengths_len = target_lengths_array__.Length();
  int64_t *target_lengths_data = new int64_t[target_lengths_len];
  for (int i = 0; i < target_lengths_len; ++i)
    target_lengths_data[i] = target_lengths_array__.Get(i).ToNumber().Int64Value();
  int64_t blank = info__[4].As<Napi::Number>().Int64Value();
  bool deterministic = info__[5].As<Napi::Boolean>().Value();
  bool zero_infinity = info__[6].As<Napi::Boolean>().Value();
  auto output__ = torch::_cudnn_ctc_loss(*log_probs, *targets, torch::IntArrayRef(input_lengths_data, input_lengths_len), torch::IntArrayRef(target_lengths_data, target_lengths_len), blank, deterministic, zero_infinity);
  Napi::Array output__array__ = Napi::Array::New(env__, 2);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  return output__array__;
}

Napi::Array atg__cudnn_ctc_loss_tensor(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *log_probs = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *targets = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *input_lengths = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *target_lengths = info__[3].As<Napi::External<torch::Tensor>>().Data();
  int64_t blank = info__[4].As<Napi::Number>().Int64Value();
  bool deterministic = info__[5].As<Napi::Boolean>().Value();
  bool zero_infinity = info__[6].As<Napi::Boolean>().Value();
  auto output__ = torch::_cudnn_ctc_loss(*log_probs, *targets, *input_lengths, *target_lengths, blank, deterministic, zero_infinity);
  Napi::Array output__array__ = Napi::Array::New(env__, 2);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  return output__array__;
}

Napi::Array atg__cudnn_ctc_loss_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out0 = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *out1 = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *log_probs = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *targets = info__[3].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array input_lengths_array__ = info__[4].As<Napi::Array>();
  int input_lengths_len = input_lengths_array__.Length();
  int64_t *input_lengths_data = new int64_t[input_lengths_len];
  for (int i = 0; i < input_lengths_len; ++i)
    input_lengths_data[i] = input_lengths_array__.Get(i).ToNumber().Int64Value();
  Napi::Array target_lengths_array__ = info__[5].As<Napi::Array>();
  int target_lengths_len = target_lengths_array__.Length();
  int64_t *target_lengths_data = new int64_t[target_lengths_len];
  for (int i = 0; i < target_lengths_len; ++i)
    target_lengths_data[i] = target_lengths_array__.Get(i).ToNumber().Int64Value();
  int64_t blank = info__[6].As<Napi::Number>().Int64Value();
  bool deterministic = info__[7].As<Napi::Boolean>().Value();
  bool zero_infinity = info__[8].As<Napi::Boolean>().Value();
  auto output__ = torch::_cudnn_ctc_loss_out(*out0, *out1, *log_probs, *targets, torch::IntArrayRef(input_lengths_data, input_lengths_len), torch::IntArrayRef(target_lengths_data, target_lengths_len), blank, deterministic, zero_infinity);
  Napi::Array output__array__ = Napi::Array::New(env__, 2);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  return output__array__;
}

Napi::Boolean atg__use_cudnn_rnn_flatten_weight(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  auto output__ = torch::_use_cudnn_rnn_flatten_weight();
  return Napi::Boolean::New(env__, output__);
}

Napi::External<torch::Tensor> atg__cudnn_rnn_flatten_weight(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  Napi::Array weight_arr_array__ = info__[0].As<Napi::Array>();
  int weight_arr_len = weight_arr_array__.Length();
  torch::Tensor **weight_arr_data = new torch::Tensor *[weight_arr_len];
  for (int i = 0; i < weight_arr_len; ++i)
    weight_arr_data[i] = weight_arr_array__.Get(i).As<Napi::External<torch::Tensor>>().Data();
  int64_t weight_stride0 = info__[1].As<Napi::Number>().Int64Value();
  int64_t input_size = info__[2].As<Napi::Number>().Int64Value();
  int64_t mode = info__[3].As<Napi::Number>().Int64Value();
  int64_t hidden_size = info__[4].As<Napi::Number>().Int64Value();
  int64_t proj_size = info__[5].As<Napi::Number>().Int64Value();
  int64_t num_layers = info__[6].As<Napi::Number>().Int64Value();
  bool batch_first = info__[7].As<Napi::Boolean>().Value();
  bool bidirectional = info__[8].As<Napi::Boolean>().Value();
  auto output__ = torch::_cudnn_rnn_flatten_weight(of_carray_tensor(weight_arr_data, weight_arr_len), weight_stride0, input_size, mode, hidden_size, proj_size, num_layers, batch_first, bidirectional);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__cudnn_rnn_flatten_weight_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array weight_arr_array__ = info__[1].As<Napi::Array>();
  int weight_arr_len = weight_arr_array__.Length();
  torch::Tensor **weight_arr_data = new torch::Tensor *[weight_arr_len];
  for (int i = 0; i < weight_arr_len; ++i)
    weight_arr_data[i] = weight_arr_array__.Get(i).As<Napi::External<torch::Tensor>>().Data();
  int64_t weight_stride0 = info__[2].As<Napi::Number>().Int64Value();
  int64_t input_size = info__[3].As<Napi::Number>().Int64Value();
  int64_t mode = info__[4].As<Napi::Number>().Int64Value();
  int64_t hidden_size = info__[5].As<Napi::Number>().Int64Value();
  int64_t proj_size = info__[6].As<Napi::Number>().Int64Value();
  int64_t num_layers = info__[7].As<Napi::Number>().Int64Value();
  bool batch_first = info__[8].As<Napi::Boolean>().Value();
  bool bidirectional = info__[9].As<Napi::Boolean>().Value();
  auto output__ = torch::_cudnn_rnn_flatten_weight_out(*out, of_carray_tensor(weight_arr_data, weight_arr_len), weight_stride0, input_size, mode, hidden_size, proj_size, num_layers, batch_first, bidirectional);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::Array atg__cudnn_rnn(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *input = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array weight_array__ = info__[1].As<Napi::Array>();
  int weight_len = weight_array__.Length();
  torch::Tensor **weight_data = new torch::Tensor *[weight_len];
  for (int i = 0; i < weight_len; ++i)
    weight_data[i] = weight_array__.Get(i).As<Napi::External<torch::Tensor>>().Data();
  int64_t weight_stride0 = info__[2].As<Napi::Number>().Int64Value();
  bool weight_buf_null = info__[3].IsUndefined();
  torch::Tensor *weight_buf_v = weight_buf_null ? nullptr : info__[3].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *hx = info__[4].As<Napi::External<torch::Tensor>>().Data();
  bool cx_null = info__[5].IsUndefined();
  torch::Tensor *cx_v = cx_null ? nullptr : info__[5].As<Napi::External<torch::Tensor>>().Data();
  int64_t mode = info__[6].As<Napi::Number>().Int64Value();
  int64_t hidden_size = info__[7].As<Napi::Number>().Int64Value();
  int64_t proj_size = info__[8].As<Napi::Number>().Int64Value();
  int64_t num_layers = info__[9].As<Napi::Number>().Int64Value();
  bool batch_first = info__[10].As<Napi::Boolean>().Value();
  double dropout = info__[11].As<Napi::Number>().DoubleValue();
  bool train = info__[12].As<Napi::Boolean>().Value();
  bool bidirectional = info__[13].As<Napi::Boolean>().Value();
  Napi::Array batch_sizes_array__ = info__[14].As<Napi::Array>();
  int batch_sizes_len = batch_sizes_array__.Length();
  int64_t *batch_sizes_data = new int64_t[batch_sizes_len];
  for (int i = 0; i < batch_sizes_len; ++i)
    batch_sizes_data[i] = batch_sizes_array__.Get(i).ToNumber().Int64Value();
  bool dropout_state_null = info__[15].IsUndefined();
  torch::Tensor *dropout_state_v = dropout_state_null ? nullptr : info__[15].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::_cudnn_rnn(*input, of_carray_tensor(weight_data, weight_len), weight_stride0, (weight_buf_null ? *weight_buf_v : torch::Tensor()), *hx, (cx_null ? *cx_v : torch::Tensor()), mode, hidden_size, proj_size, num_layers, batch_first, dropout, train, bidirectional, torch::IntArrayRef(batch_sizes_data, batch_sizes_len), (dropout_state_null ? *dropout_state_v : torch::Tensor()));
  Napi::Array output__array__ = Napi::Array::New(env__, 5);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  output__array__[2u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<2>(output__)));
  output__array__[3u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<3>(output__)));
  output__array__[4u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<4>(output__)));
  return output__array__;
}

Napi::Array atg__cudnn_rnn_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out0 = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *out1 = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *out2 = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *out3 = info__[3].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *out4 = info__[4].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *input = info__[5].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array weight_array__ = info__[6].As<Napi::Array>();
  int weight_len = weight_array__.Length();
  torch::Tensor **weight_data = new torch::Tensor *[weight_len];
  for (int i = 0; i < weight_len; ++i)
    weight_data[i] = weight_array__.Get(i).As<Napi::External<torch::Tensor>>().Data();
  int64_t weight_stride0 = info__[7].As<Napi::Number>().Int64Value();
  bool weight_buf_null = info__[8].IsUndefined();
  torch::Tensor *weight_buf_v = weight_buf_null ? nullptr : info__[8].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *hx = info__[9].As<Napi::External<torch::Tensor>>().Data();
  bool cx_null = info__[10].IsUndefined();
  torch::Tensor *cx_v = cx_null ? nullptr : info__[10].As<Napi::External<torch::Tensor>>().Data();
  int64_t mode = info__[11].As<Napi::Number>().Int64Value();
  int64_t hidden_size = info__[12].As<Napi::Number>().Int64Value();
  int64_t proj_size = info__[13].As<Napi::Number>().Int64Value();
  int64_t num_layers = info__[14].As<Napi::Number>().Int64Value();
  bool batch_first = info__[15].As<Napi::Boolean>().Value();
  double dropout = info__[16].As<Napi::Number>().DoubleValue();
  bool train = info__[17].As<Napi::Boolean>().Value();
  bool bidirectional = info__[18].As<Napi::Boolean>().Value();
  Napi::Array batch_sizes_array__ = info__[19].As<Napi::Array>();
  int batch_sizes_len = batch_sizes_array__.Length();
  int64_t *batch_sizes_data = new int64_t[batch_sizes_len];
  for (int i = 0; i < batch_sizes_len; ++i)
    batch_sizes_data[i] = batch_sizes_array__.Get(i).ToNumber().Int64Value();
  bool dropout_state_null = info__[20].IsUndefined();
  torch::Tensor *dropout_state_v = dropout_state_null ? nullptr : info__[20].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::_cudnn_rnn_out(*out0, *out1, *out2, *out3, *out4, *input, of_carray_tensor(weight_data, weight_len), weight_stride0, (weight_buf_null ? *weight_buf_v : torch::Tensor()), *hx, (cx_null ? *cx_v : torch::Tensor()), mode, hidden_size, proj_size, num_layers, batch_first, dropout, train, bidirectional, torch::IntArrayRef(batch_sizes_data, batch_sizes_len), (dropout_state_null ? *dropout_state_v : torch::Tensor()));
  Napi::Array output__array__ = Napi::Array::New(env__, 5);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  output__array__[2u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<2>(output__)));
  output__array__[3u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<3>(output__)));
  output__array__[4u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<4>(output__)));
  return output__array__;
}

Napi::External<torch::Tensor> atg__cudnn_init_dropout_state(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  double dropout = info__[0].As<Napi::Number>().DoubleValue();
  bool train = info__[1].As<Napi::Boolean>().Value();
  int64_t dropout_seed = info__[2].As<Napi::Number>().Int64Value();
  Napi::Object options_obj__ = info__[3].As<Napi::Object>();
  int options_device = options_obj__.Get("device").ToNumber().Int32Value();
  int options_kind = options_obj__.Get("dtype").ToNumber().Int32Value();
  auto output__ = torch::_cudnn_init_dropout_state(dropout, train, dropout_seed, at::device(device_of_int(options_device)).dtype(at::ScalarType(options_kind)));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__cudnn_init_dropout_state_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  double dropout = info__[1].As<Napi::Number>().DoubleValue();
  bool train = info__[2].As<Napi::Boolean>().Value();
  int64_t dropout_seed = info__[3].As<Napi::Number>().Int64Value();
  auto output__ = torch::_cudnn_init_dropout_state_out(*out, dropout, train, dropout_seed);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::Number atg__debug_has_internal_overlap(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::_debug_has_internal_overlap(*self);
  return Napi::Number::New(env__, output__);
}

Napi::Array atg__fused_dropout(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  double p = info__[1].As<Napi::Number>().DoubleValue();
  auto output__ = torch::_fused_dropout(*self, p);
  Napi::Array output__array__ = Napi::Array::New(env__, 2);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  return output__array__;
}

Napi::Array atg__fused_dropout_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out0 = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *out1 = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[2].As<Napi::External<torch::Tensor>>().Data();
  double p = info__[3].As<Napi::Number>().DoubleValue();
  auto output__ = torch::_fused_dropout_out(*out0, *out1, *self, p);
  Napi::Array output__array__ = Napi::Array::New(env__, 2);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  return output__array__;
}

Napi::External<torch::Tensor> atg__masked_scale(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *mask = info__[1].As<Napi::External<torch::Tensor>>().Data();
  double scale = info__[2].As<Napi::Number>().DoubleValue();
  auto output__ = torch::_masked_scale(*self, *mask, scale);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__masked_scale_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *mask = info__[2].As<Napi::External<torch::Tensor>>().Data();
  double scale = info__[3].As<Napi::Number>().DoubleValue();
  auto output__ = torch::_masked_scale_out(*out, *self, *mask, scale);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::Array atg_native_dropout(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *input = info__[0].As<Napi::External<torch::Tensor>>().Data();
  double p = info__[1].As<Napi::Number>().DoubleValue();
  bool train = info__[2].As<Napi::Boolean>().Value();
  auto output__ = torch::native_dropout(*input, p, train);
  Napi::Array output__array__ = Napi::Array::New(env__, 2);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  return output__array__;
}

Napi::Array atg_native_dropout_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out0 = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *out1 = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *input = info__[2].As<Napi::External<torch::Tensor>>().Data();
  double p = info__[3].As<Napi::Number>().DoubleValue();
  bool train = info__[4].As<Napi::Boolean>().Value();
  auto output__ = torch::native_dropout_out(*out0, *out1, *input, p, train);
  Napi::Array output__array__ = Napi::Array::New(env__, 2);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  return output__array__;
}

Napi::External<torch::Tensor> atg_native_dropout_backward(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *grad_output = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *mask = info__[1].As<Napi::External<torch::Tensor>>().Data();
  double scale = info__[2].As<Napi::Number>().DoubleValue();
  auto output__ = torch::native_dropout_backward(*grad_output, *mask, scale);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_native_dropout_backward_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *grad_output = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *mask = info__[2].As<Napi::External<torch::Tensor>>().Data();
  double scale = info__[3].As<Napi::Number>().DoubleValue();
  auto output__ = torch::native_dropout_backward_out(*out, *grad_output, *mask, scale);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::Array atg__sobol_engine_draw(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *quasi = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t n = info__[1].As<Napi::Number>().Int64Value();
  torch::Tensor *sobolstate = info__[2].As<Napi::External<torch::Tensor>>().Data();
  int64_t dimension = info__[3].As<Napi::Number>().Int64Value();
  int64_t num_generated = info__[4].As<Napi::Number>().Int64Value();
  int dtype = info__[5].As<Napi::Number>().Int32Value();
  auto output__ = torch::_sobol_engine_draw(*quasi, n, *sobolstate, dimension, num_generated, at::ScalarType(dtype));
  Napi::Array output__array__ = Napi::Array::New(env__, 2);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  return output__array__;
}

Napi::External<torch::Tensor> atg__sobol_engine_ff_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t n = info__[1].As<Napi::Number>().Int64Value();
  torch::Tensor *sobolstate = info__[2].As<Napi::External<torch::Tensor>>().Data();
  int64_t dimension = info__[3].As<Napi::Number>().Int64Value();
  int64_t num_generated = info__[4].As<Napi::Number>().Int64Value();
  auto output__ = torch::_sobol_engine_ff_(*self, n, *sobolstate, dimension, num_generated);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__sobol_engine_scramble_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *ltm = info__[1].As<Napi::External<torch::Tensor>>().Data();
  int64_t dimension = info__[2].As<Napi::Number>().Int64Value();
  auto output__ = torch::_sobol_engine_scramble_(*self, *ltm, dimension);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__sobol_engine_initialize_state_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t dimension = info__[1].As<Napi::Number>().Int64Value();
  auto output__ = torch::_sobol_engine_initialize_state_(*self, dimension);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__reshape_from_tensor(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *shape = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::_reshape_from_tensor(*self, *shape);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__shape_as_tensor(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::_shape_as_tensor(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_dropout(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *input = info__[0].As<Napi::External<torch::Tensor>>().Data();
  double p = info__[1].As<Napi::Number>().DoubleValue();
  bool train = info__[2].As<Napi::Boolean>().Value();
  auto output__ = torch::dropout(*input, p, train);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_dropout_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  double p = info__[1].As<Napi::Number>().DoubleValue();
  bool train = info__[2].As<Napi::Boolean>().Value();
  auto output__ = torch::dropout_(*self, p, train);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_feature_dropout(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *input = info__[0].As<Napi::External<torch::Tensor>>().Data();
  double p = info__[1].As<Napi::Number>().DoubleValue();
  bool train = info__[2].As<Napi::Boolean>().Value();
  auto output__ = torch::feature_dropout(*input, p, train);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_feature_dropout_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  double p = info__[1].As<Napi::Number>().DoubleValue();
  bool train = info__[2].As<Napi::Boolean>().Value();
  auto output__ = torch::feature_dropout_(*self, p, train);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_alpha_dropout(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *input = info__[0].As<Napi::External<torch::Tensor>>().Data();
  double p = info__[1].As<Napi::Number>().DoubleValue();
  bool train = info__[2].As<Napi::Boolean>().Value();
  auto output__ = torch::alpha_dropout(*input, p, train);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_alpha_dropout_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  double p = info__[1].As<Napi::Number>().DoubleValue();
  bool train = info__[2].As<Napi::Boolean>().Value();
  auto output__ = torch::alpha_dropout_(*self, p, train);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_feature_alpha_dropout(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *input = info__[0].As<Napi::External<torch::Tensor>>().Data();
  double p = info__[1].As<Napi::Number>().DoubleValue();
  bool train = info__[2].As<Napi::Boolean>().Value();
  auto output__ = torch::feature_alpha_dropout(*input, p, train);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_feature_alpha_dropout_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  double p = info__[1].As<Napi::Number>().DoubleValue();
  bool train = info__[2].As<Napi::Boolean>().Value();
  auto output__ = torch::feature_alpha_dropout_(*self, p, train);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_abs(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::abs(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_abs_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::abs_out(*out, *self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_abs_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::abs_(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_absolute(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::absolute(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_absolute_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::absolute_out(*out, *self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_absolute_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = self->absolute_();
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_angle(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::angle(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_angle_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::angle_out(*out, *self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_view_as_real(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::view_as_real(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_view_as_complex(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::view_as_complex(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_sgn(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::sgn(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_sgn_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::sgn_out(*out, *self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_sgn_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = self->sgn_();
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_chalf(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int memory_format = info__[1].As<Napi::Number>().Int32Value();
  auto output__ = self->chalf((at::MemoryFormat)memory_format);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_real(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::real(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_imag(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::imag(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__conj(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::_conj(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_conj(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::conj(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__conj_physical(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::_conj_physical(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__conj_physical_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::_conj_physical_out(*out, *self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_conj_physical(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::conj_physical(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_conj_physical_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::conj_physical_out(*out, *self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_conj_physical_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::conj_physical_(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_resolve_conj(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::resolve_conj(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_resolve_neg(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::resolve_neg(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__neg_view(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::_neg_view(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_acos(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::acos(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_acos_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::acos_out(*out, *self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_acos_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::acos_(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_arccos(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::arccos(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_arccos_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::arccos_out(*out, *self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_arccos_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::arccos_(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_avg_pool1d(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array kernel_size_array__ = info__[1].As<Napi::Array>();
  int kernel_size_len = kernel_size_array__.Length();
  int64_t *kernel_size_data = new int64_t[kernel_size_len];
  for (int i = 0; i < kernel_size_len; ++i)
    kernel_size_data[i] = kernel_size_array__.Get(i).ToNumber().Int64Value();
  Napi::Array stride_array__ = info__[2].As<Napi::Array>();
  int stride_len = stride_array__.Length();
  int64_t *stride_data = new int64_t[stride_len];
  for (int i = 0; i < stride_len; ++i)
    stride_data[i] = stride_array__.Get(i).ToNumber().Int64Value();
  Napi::Array padding_array__ = info__[3].As<Napi::Array>();
  int padding_len = padding_array__.Length();
  int64_t *padding_data = new int64_t[padding_len];
  for (int i = 0; i < padding_len; ++i)
    padding_data[i] = padding_array__.Get(i).ToNumber().Int64Value();
  bool ceil_mode = info__[4].As<Napi::Boolean>().Value();
  bool count_include_pad = info__[5].As<Napi::Boolean>().Value();
  auto output__ = torch::avg_pool1d(*self, torch::IntArrayRef(kernel_size_data, kernel_size_len), torch::IntArrayRef(stride_data, stride_len), torch::IntArrayRef(padding_data, padding_len), ceil_mode, count_include_pad);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_adaptive_avg_pool1d(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array output_size_array__ = info__[1].As<Napi::Array>();
  int output_size_len = output_size_array__.Length();
  int64_t *output_size_data = new int64_t[output_size_len];
  for (int i = 0; i < output_size_len; ++i)
    output_size_data[i] = output_size_array__.Get(i).ToNumber().Int64Value();
  auto output__ = torch::adaptive_avg_pool1d(*self, torch::IntArrayRef(output_size_data, output_size_len));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::Array atg_adaptive_max_pool1d(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array output_size_array__ = info__[1].As<Napi::Array>();
  int output_size_len = output_size_array__.Length();
  int64_t *output_size_data = new int64_t[output_size_len];
  for (int i = 0; i < output_size_len; ++i)
    output_size_data[i] = output_size_array__.Get(i).ToNumber().Int64Value();
  auto output__ = torch::adaptive_max_pool1d(*self, torch::IntArrayRef(output_size_data, output_size_len));
  Napi::Array output__array__ = Napi::Array::New(env__, 2);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  return output__array__;
}

Napi::External<torch::Tensor> atg_add(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *alpha = info__[2].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::add(*self, *other, *alpha);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_add_scalar(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *other = info__[1].As<Napi::External<torch::Scalar>>().Data();
  torch::Scalar *alpha = info__[2].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::add(*self, *other, *alpha);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_add_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *alpha = info__[3].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::add_out(*out, *self, *other, *alpha);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_add_scalar_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *other = info__[2].As<Napi::External<torch::Scalar>>().Data();
  torch::Scalar *alpha = info__[3].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::add_out(*out, *self, *other, *alpha);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_add_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *alpha = info__[2].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = self->add_(*other, *alpha);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_add_scalar_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *other = info__[1].As<Napi::External<torch::Scalar>>().Data();
  torch::Scalar *alpha = info__[2].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = self->add_(*other, *alpha);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__add_relu(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *alpha = info__[2].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::_add_relu(*self, *other, *alpha);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__add_relu_scalar(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *other = info__[1].As<Napi::External<torch::Scalar>>().Data();
  torch::Scalar *alpha = info__[2].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::_add_relu(*self, *other, *alpha);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__add_relu_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *alpha = info__[3].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::_add_relu_out(*out, *self, *other, *alpha);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__add_relu_scalar_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *other = info__[2].As<Napi::External<torch::Scalar>>().Data();
  torch::Scalar *alpha = info__[3].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::_add_relu_out(*out, *self, *other, *alpha);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__add_relu_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *alpha = info__[2].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::_add_relu_(*self, *other, *alpha);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__add_relu_scalar_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *other = info__[1].As<Napi::External<torch::Scalar>>().Data();
  torch::Scalar *alpha = info__[2].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::_add_relu_(*self, *other, *alpha);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_addmv(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *mat = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *vec = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *beta = info__[3].As<Napi::External<torch::Scalar>>().Data();
  torch::Scalar *alpha = info__[4].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::addmv(*self, *mat, *vec, *beta, *alpha);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_addmv_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *mat = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *vec = info__[3].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *beta = info__[4].As<Napi::External<torch::Scalar>>().Data();
  torch::Scalar *alpha = info__[5].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::addmv_out(*out, *self, *mat, *vec, *beta, *alpha);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_addmv_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *mat = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *vec = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *beta = info__[3].As<Napi::External<torch::Scalar>>().Data();
  torch::Scalar *alpha = info__[4].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::addmv_(*self, *mat, *vec, *beta, *alpha);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_addr(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *vec1 = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *vec2 = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *beta = info__[3].As<Napi::External<torch::Scalar>>().Data();
  torch::Scalar *alpha = info__[4].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::addr(*self, *vec1, *vec2, *beta, *alpha);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_addr_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *vec1 = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *vec2 = info__[3].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *beta = info__[4].As<Napi::External<torch::Scalar>>().Data();
  torch::Scalar *alpha = info__[5].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::addr_out(*out, *self, *vec1, *vec2, *beta, *alpha);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_addr_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *vec1 = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *vec2 = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *beta = info__[3].As<Napi::External<torch::Scalar>>().Data();
  torch::Scalar *alpha = info__[4].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = self->addr_(*vec1, *vec2, *beta, *alpha);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_affine_grid_generator(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *theta = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array size_array__ = info__[1].As<Napi::Array>();
  int size_len = size_array__.Length();
  int64_t *size_data = new int64_t[size_len];
  for (int i = 0; i < size_len; ++i)
    size_data[i] = size_array__.Get(i).ToNumber().Int64Value();
  bool align_corners = info__[2].As<Napi::Boolean>().Value();
  auto output__ = torch::affine_grid_generator(*theta, torch::IntArrayRef(size_data, size_len), align_corners);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_affine_grid_generator_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *theta = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array size_array__ = info__[2].As<Napi::Array>();
  int size_len = size_array__.Length();
  int64_t *size_data = new int64_t[size_len];
  for (int i = 0; i < size_len; ++i)
    size_data[i] = size_array__.Get(i).ToNumber().Int64Value();
  bool align_corners = info__[3].As<Napi::Boolean>().Value();
  auto output__ = torch::affine_grid_generator_out(*out, *theta, torch::IntArrayRef(size_data, size_len), align_corners);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_affine_grid_generator_backward(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *grad = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array size_array__ = info__[1].As<Napi::Array>();
  int size_len = size_array__.Length();
  int64_t *size_data = new int64_t[size_len];
  for (int i = 0; i < size_len; ++i)
    size_data[i] = size_array__.Get(i).ToNumber().Int64Value();
  bool align_corners = info__[2].As<Napi::Boolean>().Value();
  auto output__ = torch::affine_grid_generator_backward(*grad, torch::IntArrayRef(size_data, size_len), align_corners);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__is_all_true(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::_is_all_true(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__is_any_true(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::_is_any_true(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__test_check_tensor(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::_test_check_tensor(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_all(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::all(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_all_dim(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t dim = info__[1].As<Napi::Number>().Int64Value();
  bool keepdim = info__[2].As<Napi::Boolean>().Value();
  auto output__ = torch::all(*self, dim, keepdim);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_all_all_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::all_out(*out, *self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_all_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  int64_t dim = info__[2].As<Napi::Number>().Int64Value();
  bool keepdim = info__[3].As<Napi::Boolean>().Value();
  auto output__ = torch::all_out(*out, *self, dim, keepdim);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::Boolean atg_allclose(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[1].As<Napi::External<torch::Tensor>>().Data();
  double rtol = info__[2].As<Napi::Number>().DoubleValue();
  double atol = info__[3].As<Napi::Number>().DoubleValue();
  bool equal_nan = info__[4].As<Napi::Boolean>().Value();
  auto output__ = torch::allclose(*self, *other, rtol, atol, equal_nan);
  return Napi::Boolean::New(env__, output__);
}

Napi::External<torch::Tensor> atg_any(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::any(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_any_dim(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t dim = info__[1].As<Napi::Number>().Int64Value();
  bool keepdim = info__[2].As<Napi::Boolean>().Value();
  auto output__ = torch::any(*self, dim, keepdim);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_any_all_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::any_out(*out, *self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_any_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  int64_t dim = info__[2].As<Napi::Number>().Int64Value();
  bool keepdim = info__[3].As<Napi::Boolean>().Value();
  auto output__ = torch::any_out(*out, *self, dim, keepdim);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_arange(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Scalar *end = info__[0].As<Napi::External<torch::Scalar>>().Data();
  Napi::Object options_obj__ = info__[1].As<Napi::Object>();
  int options_device = options_obj__.Get("device").ToNumber().Int32Value();
  int options_kind = options_obj__.Get("dtype").ToNumber().Int32Value();
  auto output__ = torch::arange(*end, at::device(device_of_int(options_device)).dtype(at::ScalarType(options_kind)));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_arange_start(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Scalar *start = info__[0].As<Napi::External<torch::Scalar>>().Data();
  torch::Scalar *end = info__[1].As<Napi::External<torch::Scalar>>().Data();
  Napi::Object options_obj__ = info__[2].As<Napi::Object>();
  int options_device = options_obj__.Get("device").ToNumber().Int32Value();
  int options_kind = options_obj__.Get("dtype").ToNumber().Int32Value();
  auto output__ = torch::arange(*start, *end, at::device(device_of_int(options_device)).dtype(at::ScalarType(options_kind)));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_arange_start_step(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Scalar *start = info__[0].As<Napi::External<torch::Scalar>>().Data();
  torch::Scalar *end = info__[1].As<Napi::External<torch::Scalar>>().Data();
  torch::Scalar *step = info__[2].As<Napi::External<torch::Scalar>>().Data();
  Napi::Object options_obj__ = info__[3].As<Napi::Object>();
  int options_device = options_obj__.Get("device").ToNumber().Int32Value();
  int options_kind = options_obj__.Get("dtype").ToNumber().Int32Value();
  auto output__ = torch::arange(*start, *end, *step, at::device(device_of_int(options_device)).dtype(at::ScalarType(options_kind)));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_arange_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *end = info__[1].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::arange_out(*out, *end);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_arange_start_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *start = info__[1].As<Napi::External<torch::Scalar>>().Data();
  torch::Scalar *end = info__[2].As<Napi::External<torch::Scalar>>().Data();
  torch::Scalar *step = info__[3].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::arange_out(*out, *start, *end, *step);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__dim_arange(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *like = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t dim = info__[1].As<Napi::Number>().Int64Value();
  auto output__ = torch::_dim_arange(*like, dim);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_argmax(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  bool dim_null = info__[1].IsUndefined();
  int64_t dim_v = dim_null ? 0 : info__[1].As<Napi::Number>().Int64Value();
  bool keepdim = info__[2].As<Napi::Boolean>().Value();
  auto output__ = torch::argmax(*self, dim_null ? c10::nullopt : c10::optional<int64_t>(dim_v), keepdim);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_argmax_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  bool dim_null = info__[2].IsUndefined();
  int64_t dim_v = dim_null ? 0 : info__[2].As<Napi::Number>().Int64Value();
  bool keepdim = info__[3].As<Napi::Boolean>().Value();
  auto output__ = torch::argmax_out(*out, *self, dim_null ? c10::nullopt : c10::optional<int64_t>(dim_v), keepdim);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_argmin(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  bool dim_null = info__[1].IsUndefined();
  int64_t dim_v = dim_null ? 0 : info__[1].As<Napi::Number>().Int64Value();
  bool keepdim = info__[2].As<Napi::Boolean>().Value();
  auto output__ = torch::argmin(*self, dim_null ? c10::nullopt : c10::optional<int64_t>(dim_v), keepdim);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_argmin_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  bool dim_null = info__[2].IsUndefined();
  int64_t dim_v = dim_null ? 0 : info__[2].As<Napi::Number>().Int64Value();
  bool keepdim = info__[3].As<Napi::Boolean>().Value();
  auto output__ = torch::argmin_out(*out, *self, dim_null ? c10::nullopt : c10::optional<int64_t>(dim_v), keepdim);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_acosh(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::acosh(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_acosh_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::acosh_out(*out, *self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_acosh_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::acosh_(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_arccosh(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::arccosh(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_arccosh_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::arccosh_out(*out, *self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_arccosh_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::arccosh_(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_asinh(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::asinh(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_asinh_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::asinh_out(*out, *self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_asinh_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::asinh_(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_arcsinh(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::arcsinh(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_arcsinh_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::arcsinh_out(*out, *self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_arcsinh_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::arcsinh_(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_atanh(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::atanh(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_atanh_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::atanh_out(*out, *self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_atanh_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::atanh_(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_arctanh(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::arctanh(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_arctanh_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::arctanh_out(*out, *self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_arctanh_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::arctanh_(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_as_strided(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array size_array__ = info__[1].As<Napi::Array>();
  int size_len = size_array__.Length();
  int64_t *size_data = new int64_t[size_len];
  for (int i = 0; i < size_len; ++i)
    size_data[i] = size_array__.Get(i).ToNumber().Int64Value();
  Napi::Array stride_array__ = info__[2].As<Napi::Array>();
  int stride_len = stride_array__.Length();
  int64_t *stride_data = new int64_t[stride_len];
  for (int i = 0; i < stride_len; ++i)
    stride_data[i] = stride_array__.Get(i).ToNumber().Int64Value();
  bool storage_offset_null = info__[3].IsUndefined();
  int64_t storage_offset_v = storage_offset_null ? 0 : info__[3].As<Napi::Number>().Int64Value();
  auto output__ = torch::as_strided(*self, torch::IntArrayRef(size_data, size_len), torch::IntArrayRef(stride_data, stride_len), storage_offset_null ? c10::nullopt : c10::optional<int64_t>(storage_offset_v));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_as_strided_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array size_array__ = info__[1].As<Napi::Array>();
  int size_len = size_array__.Length();
  int64_t *size_data = new int64_t[size_len];
  for (int i = 0; i < size_len; ++i)
    size_data[i] = size_array__.Get(i).ToNumber().Int64Value();
  Napi::Array stride_array__ = info__[2].As<Napi::Array>();
  int stride_len = stride_array__.Length();
  int64_t *stride_data = new int64_t[stride_len];
  for (int i = 0; i < stride_len; ++i)
    stride_data[i] = stride_array__.Get(i).ToNumber().Int64Value();
  bool storage_offset_null = info__[3].IsUndefined();
  int64_t storage_offset_v = storage_offset_null ? 0 : info__[3].As<Napi::Number>().Int64Value();
  auto output__ = torch::as_strided_(*self, torch::IntArrayRef(size_data, size_len), torch::IntArrayRef(stride_data, stride_len), storage_offset_null ? c10::nullopt : c10::optional<int64_t>(storage_offset_v));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_asin(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::asin(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_asin_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::asin_out(*out, *self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_asin_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::asin_(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_arcsin(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::arcsin(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_arcsin_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::arcsin_out(*out, *self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_arcsin_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::arcsin_(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_atan(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::atan(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_atan_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::atan_out(*out, *self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_atan_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::atan_(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_arctan(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::arctan(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_arctan_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::arctan_out(*out, *self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_arctan_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::arctan_(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_atleast_1d(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::atleast_1d(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_atleast_2d(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::atleast_2d(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_atleast_3d(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::atleast_3d(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_baddbmm(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *batch1 = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *batch2 = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *beta = info__[3].As<Napi::External<torch::Scalar>>().Data();
  torch::Scalar *alpha = info__[4].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::baddbmm(*self, *batch1, *batch2, *beta, *alpha);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_baddbmm_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *batch1 = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *batch2 = info__[3].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *beta = info__[4].As<Napi::External<torch::Scalar>>().Data();
  torch::Scalar *alpha = info__[5].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::baddbmm_out(*out, *self, *batch1, *batch2, *beta, *alpha);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_baddbmm_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *batch1 = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *batch2 = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *beta = info__[3].As<Napi::External<torch::Scalar>>().Data();
  torch::Scalar *alpha = info__[4].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = self->baddbmm_(*batch1, *batch2, *beta, *alpha);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_bartlett_window(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  int64_t window_length = info__[0].As<Napi::Number>().Int64Value();
  Napi::Object options_obj__ = info__[1].As<Napi::Object>();
  int options_device = options_obj__.Get("device").ToNumber().Int32Value();
  int options_kind = options_obj__.Get("dtype").ToNumber().Int32Value();
  auto output__ = torch::bartlett_window(window_length, at::device(device_of_int(options_device)).dtype(at::ScalarType(options_kind)));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_bartlett_window_periodic(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  int64_t window_length = info__[0].As<Napi::Number>().Int64Value();
  bool periodic = info__[1].As<Napi::Boolean>().Value();
  Napi::Object options_obj__ = info__[2].As<Napi::Object>();
  int options_device = options_obj__.Get("device").ToNumber().Int32Value();
  int options_kind = options_obj__.Get("dtype").ToNumber().Int32Value();
  auto output__ = torch::bartlett_window(window_length, periodic, at::device(device_of_int(options_device)).dtype(at::ScalarType(options_kind)));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_bartlett_window_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t window_length = info__[1].As<Napi::Number>().Int64Value();
  auto output__ = torch::bartlett_window_out(*out, window_length);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_bartlett_window_periodic_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t window_length = info__[1].As<Napi::Number>().Int64Value();
  bool periodic = info__[2].As<Napi::Boolean>().Value();
  auto output__ = torch::bartlett_window_out(*out, window_length, periodic);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_batch_norm(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *input = info__[0].As<Napi::External<torch::Tensor>>().Data();
  bool weight_null = info__[1].IsUndefined();
  torch::Tensor *weight_v = weight_null ? nullptr : info__[1].As<Napi::External<torch::Tensor>>().Data();
  bool bias_null = info__[2].IsUndefined();
  torch::Tensor *bias_v = bias_null ? nullptr : info__[2].As<Napi::External<torch::Tensor>>().Data();
  bool running_mean_null = info__[3].IsUndefined();
  torch::Tensor *running_mean_v = running_mean_null ? nullptr : info__[3].As<Napi::External<torch::Tensor>>().Data();
  bool running_var_null = info__[4].IsUndefined();
  torch::Tensor *running_var_v = running_var_null ? nullptr : info__[4].As<Napi::External<torch::Tensor>>().Data();
  bool training = info__[5].As<Napi::Boolean>().Value();
  double momentum = info__[6].As<Napi::Number>().DoubleValue();
  double eps = info__[7].As<Napi::Number>().DoubleValue();
  bool cudnn_enabled = info__[8].As<Napi::Boolean>().Value();
  auto output__ = torch::batch_norm(*input, (weight_null ? *weight_v : torch::Tensor()), (bias_null ? *bias_v : torch::Tensor()), (running_mean_null ? *running_mean_v : torch::Tensor()), (running_var_null ? *running_var_v : torch::Tensor()), training, momentum, eps, cudnn_enabled);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_quantized_batch_norm(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *input = info__[0].As<Napi::External<torch::Tensor>>().Data();
  bool weight_null = info__[1].IsUndefined();
  torch::Tensor *weight_v = weight_null ? nullptr : info__[1].As<Napi::External<torch::Tensor>>().Data();
  bool bias_null = info__[2].IsUndefined();
  torch::Tensor *bias_v = bias_null ? nullptr : info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *mean = info__[3].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *var = info__[4].As<Napi::External<torch::Tensor>>().Data();
  double eps = info__[5].As<Napi::Number>().DoubleValue();
  double output_scale = info__[6].As<Napi::Number>().DoubleValue();
  int64_t output_zero_point = info__[7].As<Napi::Number>().Int64Value();
  auto output__ = torch::quantized_batch_norm(*input, (weight_null ? *weight_v : torch::Tensor()), (bias_null ? *bias_v : torch::Tensor()), *mean, *var, eps, output_scale, output_zero_point);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_quantized_batch_norm_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *input = info__[1].As<Napi::External<torch::Tensor>>().Data();
  bool weight_null = info__[2].IsUndefined();
  torch::Tensor *weight_v = weight_null ? nullptr : info__[2].As<Napi::External<torch::Tensor>>().Data();
  bool bias_null = info__[3].IsUndefined();
  torch::Tensor *bias_v = bias_null ? nullptr : info__[3].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *mean = info__[4].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *var = info__[5].As<Napi::External<torch::Tensor>>().Data();
  double eps = info__[6].As<Napi::Number>().DoubleValue();
  double output_scale = info__[7].As<Napi::Number>().DoubleValue();
  int64_t output_zero_point = info__[8].As<Napi::Number>().Int64Value();
  auto output__ = torch::quantized_batch_norm_out(*out, *input, (weight_null ? *weight_v : torch::Tensor()), (bias_null ? *bias_v : torch::Tensor()), *mean, *var, eps, output_scale, output_zero_point);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_bernoulli(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::bernoulli(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_bernoulli_p(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  double p = info__[1].As<Napi::Number>().DoubleValue();
  auto output__ = torch::bernoulli(*self, p);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_bernoulli_tensor(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *p = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::bernoulli(*self, *p);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_bernoulli_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *p = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = self->bernoulli_(*p);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_bernoulli_float_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  double p = info__[1].As<Napi::Number>().DoubleValue();
  auto output__ = self->bernoulli_(p);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_bilinear(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *input1 = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *input2 = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *weight = info__[2].As<Napi::External<torch::Tensor>>().Data();
  bool bias_null = info__[3].IsUndefined();
  torch::Tensor *bias_v = bias_null ? nullptr : info__[3].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::bilinear(*input1, *input2, *weight, (bias_null ? *bias_v : torch::Tensor()));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_binary_cross_entropy(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *target = info__[1].As<Napi::External<torch::Tensor>>().Data();
  bool weight_null = info__[2].IsUndefined();
  torch::Tensor *weight_v = weight_null ? nullptr : info__[2].As<Napi::External<torch::Tensor>>().Data();
  int64_t reduction = info__[3].As<Napi::Number>().Int64Value();
  auto output__ = torch::binary_cross_entropy(*self, *target, (weight_null ? *weight_v : torch::Tensor()), reduction);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_binary_cross_entropy_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *target = info__[2].As<Napi::External<torch::Tensor>>().Data();
  bool weight_null = info__[3].IsUndefined();
  torch::Tensor *weight_v = weight_null ? nullptr : info__[3].As<Napi::External<torch::Tensor>>().Data();
  int64_t reduction = info__[4].As<Napi::Number>().Int64Value();
  auto output__ = torch::binary_cross_entropy_out(*out, *self, *target, (weight_null ? *weight_v : torch::Tensor()), reduction);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_binary_cross_entropy_backward(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *grad_output = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *target = info__[2].As<Napi::External<torch::Tensor>>().Data();
  bool weight_null = info__[3].IsUndefined();
  torch::Tensor *weight_v = weight_null ? nullptr : info__[3].As<Napi::External<torch::Tensor>>().Data();
  int64_t reduction = info__[4].As<Napi::Number>().Int64Value();
  auto output__ = torch::binary_cross_entropy_backward(*grad_output, *self, *target, (weight_null ? *weight_v : torch::Tensor()), reduction);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_binary_cross_entropy_backward_grad_input(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *grad_input = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *grad_output = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *target = info__[3].As<Napi::External<torch::Tensor>>().Data();
  bool weight_null = info__[4].IsUndefined();
  torch::Tensor *weight_v = weight_null ? nullptr : info__[4].As<Napi::External<torch::Tensor>>().Data();
  int64_t reduction = info__[5].As<Napi::Number>().Int64Value();
  auto output__ = torch::binary_cross_entropy_backward_out(*grad_input, *grad_output, *self, *target, (weight_null ? *weight_v : torch::Tensor()), reduction);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_binary_cross_entropy_with_logits(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *target = info__[1].As<Napi::External<torch::Tensor>>().Data();
  bool weight_null = info__[2].IsUndefined();
  torch::Tensor *weight_v = weight_null ? nullptr : info__[2].As<Napi::External<torch::Tensor>>().Data();
  bool pos_weight_null = info__[3].IsUndefined();
  torch::Tensor *pos_weight_v = pos_weight_null ? nullptr : info__[3].As<Napi::External<torch::Tensor>>().Data();
  int64_t reduction = info__[4].As<Napi::Number>().Int64Value();
  auto output__ = torch::binary_cross_entropy_with_logits(*self, *target, (weight_null ? *weight_v : torch::Tensor()), (pos_weight_null ? *pos_weight_v : torch::Tensor()), reduction);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_binary_cross_entropy_with_logits_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *target = info__[2].As<Napi::External<torch::Tensor>>().Data();
  bool weight_null = info__[3].IsUndefined();
  torch::Tensor *weight_v = weight_null ? nullptr : info__[3].As<Napi::External<torch::Tensor>>().Data();
  bool pos_weight_null = info__[4].IsUndefined();
  torch::Tensor *pos_weight_v = pos_weight_null ? nullptr : info__[4].As<Napi::External<torch::Tensor>>().Data();
  int64_t reduction = info__[5].As<Napi::Number>().Int64Value();
  auto output__ = torch::binary_cross_entropy_with_logits_out(*out, *self, *target, (weight_null ? *weight_v : torch::Tensor()), (pos_weight_null ? *pos_weight_v : torch::Tensor()), reduction);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_bincount(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  bool weights_null = info__[1].IsUndefined();
  torch::Tensor *weights_v = weights_null ? nullptr : info__[1].As<Napi::External<torch::Tensor>>().Data();
  int64_t minlength = info__[2].As<Napi::Number>().Int64Value();
  auto output__ = torch::bincount(*self, (weights_null ? *weights_v : torch::Tensor()), minlength);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_bincount_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  bool weights_null = info__[2].IsUndefined();
  torch::Tensor *weights_v = weights_null ? nullptr : info__[2].As<Napi::External<torch::Tensor>>().Data();
  int64_t minlength = info__[3].As<Napi::Number>().Int64Value();
  auto output__ = torch::bincount_out(*out, *self, (weights_null ? *weights_v : torch::Tensor()), minlength);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_bitwise_not(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::bitwise_not(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_bitwise_not_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::bitwise_not_out(*out, *self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_bitwise_not_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = self->bitwise_not_();
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_copysign(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::copysign(*self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_copysign_scalar(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *other = info__[1].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::copysign(*self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_copysign_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[2].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::copysign_out(*out, *self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_copysign_scalar_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *other = info__[2].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::copysign_out(*out, *self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_copysign_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = self->copysign_(*other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_copysign_scalar_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *other = info__[1].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = self->copysign_(*other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_logical_not(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::logical_not(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_logical_not_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::logical_not_out(*out, *self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_logical_not_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = self->logical_not_();
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_logical_xor(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::logical_xor(*self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_logical_xor_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[2].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::logical_xor_out(*out, *self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_logical_xor_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = self->logical_xor_(*other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_logical_and(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::logical_and(*self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_logical_and_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[2].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::logical_and_out(*out, *self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_logical_and_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = self->logical_and_(*other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_logical_or(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::logical_or(*self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_logical_or_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[2].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::logical_or_out(*out, *self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_logical_or_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = self->logical_or_(*other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_blackman_window(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  int64_t window_length = info__[0].As<Napi::Number>().Int64Value();
  Napi::Object options_obj__ = info__[1].As<Napi::Object>();
  int options_device = options_obj__.Get("device").ToNumber().Int32Value();
  int options_kind = options_obj__.Get("dtype").ToNumber().Int32Value();
  auto output__ = torch::blackman_window(window_length, at::device(device_of_int(options_device)).dtype(at::ScalarType(options_kind)));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_blackman_window_periodic(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  int64_t window_length = info__[0].As<Napi::Number>().Int64Value();
  bool periodic = info__[1].As<Napi::Boolean>().Value();
  Napi::Object options_obj__ = info__[2].As<Napi::Object>();
  int options_device = options_obj__.Get("device").ToNumber().Int32Value();
  int options_kind = options_obj__.Get("dtype").ToNumber().Int32Value();
  auto output__ = torch::blackman_window(window_length, periodic, at::device(device_of_int(options_device)).dtype(at::ScalarType(options_kind)));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_blackman_window_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t window_length = info__[1].As<Napi::Number>().Int64Value();
  auto output__ = torch::blackman_window_out(*out, window_length);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_blackman_window_periodic_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t window_length = info__[1].As<Napi::Number>().Int64Value();
  bool periodic = info__[2].As<Napi::Boolean>().Value();
  auto output__ = torch::blackman_window_out(*out, window_length, periodic);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_bmm(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *mat2 = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::bmm(*self, *mat2);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_bmm_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *mat2 = info__[2].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::bmm_out(*out, *self, *mat2);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_broadcast_to(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array size_array__ = info__[1].As<Napi::Array>();
  int size_len = size_array__.Length();
  int64_t *size_data = new int64_t[size_len];
  for (int i = 0; i < size_len; ++i)
    size_data[i] = size_array__.Get(i).ToNumber().Int64Value();
  auto output__ = torch::broadcast_to(*self, torch::IntArrayRef(size_data, size_len));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__sparse_broadcast_to(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array size_array__ = info__[1].As<Napi::Array>();
  int size_len = size_array__.Length();
  int64_t *size_data = new int64_t[size_len];
  for (int i = 0; i < size_len; ++i)
    size_data[i] = size_array__.Get(i).ToNumber().Int64Value();
  auto output__ = torch::_sparse_broadcast_to(*self, torch::IntArrayRef(size_data, size_len));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_cat(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  Napi::Array tensors_array__ = info__[0].As<Napi::Array>();
  int tensors_len = tensors_array__.Length();
  torch::Tensor **tensors_data = new torch::Tensor *[tensors_len];
  for (int i = 0; i < tensors_len; ++i)
    tensors_data[i] = tensors_array__.Get(i).As<Napi::External<torch::Tensor>>().Data();
  int64_t dim = info__[1].As<Napi::Number>().Int64Value();
  auto output__ = torch::cat(of_carray_tensor(tensors_data, tensors_len), dim);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_cat_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array tensors_array__ = info__[1].As<Napi::Array>();
  int tensors_len = tensors_array__.Length();
  torch::Tensor **tensors_data = new torch::Tensor *[tensors_len];
  for (int i = 0; i < tensors_len; ++i)
    tensors_data[i] = tensors_array__.Get(i).As<Napi::External<torch::Tensor>>().Data();
  int64_t dim = info__[2].As<Napi::Number>().Int64Value();
  auto output__ = torch::cat_out(*out, of_carray_tensor(tensors_data, tensors_len), dim);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_concat(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  Napi::Array tensors_array__ = info__[0].As<Napi::Array>();
  int tensors_len = tensors_array__.Length();
  torch::Tensor **tensors_data = new torch::Tensor *[tensors_len];
  for (int i = 0; i < tensors_len; ++i)
    tensors_data[i] = tensors_array__.Get(i).As<Napi::External<torch::Tensor>>().Data();
  int64_t dim = info__[1].As<Napi::Number>().Int64Value();
  auto output__ = torch::concat(of_carray_tensor(tensors_data, tensors_len), dim);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_concat_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array tensors_array__ = info__[1].As<Napi::Array>();
  int tensors_len = tensors_array__.Length();
  torch::Tensor **tensors_data = new torch::Tensor *[tensors_len];
  for (int i = 0; i < tensors_len; ++i)
    tensors_data[i] = tensors_array__.Get(i).As<Napi::External<torch::Tensor>>().Data();
  int64_t dim = info__[2].As<Napi::Number>().Int64Value();
  auto output__ = torch::concat_out(*out, of_carray_tensor(tensors_data, tensors_len), dim);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_concatenate(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  Napi::Array tensors_array__ = info__[0].As<Napi::Array>();
  int tensors_len = tensors_array__.Length();
  torch::Tensor **tensors_data = new torch::Tensor *[tensors_len];
  for (int i = 0; i < tensors_len; ++i)
    tensors_data[i] = tensors_array__.Get(i).As<Napi::External<torch::Tensor>>().Data();
  int64_t dim = info__[1].As<Napi::Number>().Int64Value();
  auto output__ = torch::concatenate(of_carray_tensor(tensors_data, tensors_len), dim);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_concatenate_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array tensors_array__ = info__[1].As<Napi::Array>();
  int tensors_len = tensors_array__.Length();
  torch::Tensor **tensors_data = new torch::Tensor *[tensors_len];
  for (int i = 0; i < tensors_len; ++i)
    tensors_data[i] = tensors_array__.Get(i).As<Napi::External<torch::Tensor>>().Data();
  int64_t dim = info__[2].As<Napi::Number>().Int64Value();
  auto output__ = torch::concatenate_out(*out, of_carray_tensor(tensors_data, tensors_len), dim);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_block_diag(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  Napi::Array tensors_array__ = info__[0].As<Napi::Array>();
  int tensors_len = tensors_array__.Length();
  torch::Tensor **tensors_data = new torch::Tensor *[tensors_len];
  for (int i = 0; i < tensors_len; ++i)
    tensors_data[i] = tensors_array__.Get(i).As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::block_diag(of_carray_tensor(tensors_data, tensors_len));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_block_diag_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array tensors_array__ = info__[1].As<Napi::Array>();
  int tensors_len = tensors_array__.Length();
  torch::Tensor **tensors_data = new torch::Tensor *[tensors_len];
  for (int i = 0; i < tensors_len; ++i)
    tensors_data[i] = tensors_array__.Get(i).As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::block_diag_out(*out, of_carray_tensor(tensors_data, tensors_len));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_ceil(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::ceil(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_ceil_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::ceil_out(*out, *self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_ceil_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::ceil_(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_chain_matmul(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  Napi::Array matrices_array__ = info__[0].As<Napi::Array>();
  int matrices_len = matrices_array__.Length();
  torch::Tensor **matrices_data = new torch::Tensor *[matrices_len];
  for (int i = 0; i < matrices_len; ++i)
    matrices_data[i] = matrices_array__.Get(i).As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::chain_matmul(of_carray_tensor(matrices_data, matrices_len));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_chain_matmul_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array matrices_array__ = info__[1].As<Napi::Array>();
  int matrices_len = matrices_array__.Length();
  torch::Tensor **matrices_data = new torch::Tensor *[matrices_len];
  for (int i = 0; i < matrices_len; ++i)
    matrices_data[i] = matrices_array__.Get(i).As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::chain_matmul_out(*out, of_carray_tensor(matrices_data, matrices_len));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_clamp(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *min = info__[1].As<Napi::External<torch::Scalar>>().Data();
  torch::Scalar *max = info__[2].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::clamp(*self, *min, *max);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_clamp_tensor(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  bool min_null = info__[1].IsUndefined();
  torch::Tensor *min_v = min_null ? nullptr : info__[1].As<Napi::External<torch::Tensor>>().Data();
  bool max_null = info__[2].IsUndefined();
  torch::Tensor *max_v = max_null ? nullptr : info__[2].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::clamp(*self, (min_null ? *min_v : torch::Tensor()), (max_null ? *max_v : torch::Tensor()));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_clamp_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *min = info__[2].As<Napi::External<torch::Scalar>>().Data();
  torch::Scalar *max = info__[3].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::clamp_out(*out, *self, *min, *max);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_clamp_tensor_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  bool min_null = info__[2].IsUndefined();
  torch::Tensor *min_v = min_null ? nullptr : info__[2].As<Napi::External<torch::Tensor>>().Data();
  bool max_null = info__[3].IsUndefined();
  torch::Tensor *max_v = max_null ? nullptr : info__[3].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::clamp_out(*out, *self, (min_null ? *min_v : torch::Tensor()), (max_null ? *max_v : torch::Tensor()));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_clamp_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *min = info__[1].As<Napi::External<torch::Scalar>>().Data();
  torch::Scalar *max = info__[2].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::clamp_(*self, *min, *max);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_clamp_tensor_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  bool min_null = info__[1].IsUndefined();
  torch::Tensor *min_v = min_null ? nullptr : info__[1].As<Napi::External<torch::Tensor>>().Data();
  bool max_null = info__[2].IsUndefined();
  torch::Tensor *max_v = max_null ? nullptr : info__[2].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::clamp_(*self, (min_null ? *min_v : torch::Tensor()), (max_null ? *max_v : torch::Tensor()));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_clamp_max(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *max = info__[1].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::clamp_max(*self, *max);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_clamp_max_tensor(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *max = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::clamp_max(*self, *max);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_clamp_max_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *max = info__[2].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::clamp_max_out(*out, *self, *max);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_clamp_max_tensor_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *max = info__[2].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::clamp_max_out(*out, *self, *max);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_clamp_max_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *max = info__[1].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::clamp_max_(*self, *max);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_clamp_max_tensor_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *max = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::clamp_max_(*self, *max);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_clamp_min(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *min = info__[1].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::clamp_min(*self, *min);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_clamp_min_tensor(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *min = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::clamp_min(*self, *min);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_clamp_min_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *min = info__[2].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::clamp_min_out(*out, *self, *min);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_clamp_min_tensor_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *min = info__[2].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::clamp_min_out(*out, *self, *min);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_clamp_min_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *min = info__[1].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::clamp_min_(*self, *min);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_clamp_min_tensor_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *min = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::clamp_min_(*self, *min);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_clip(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *min = info__[1].As<Napi::External<torch::Scalar>>().Data();
  torch::Scalar *max = info__[2].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::clip(*self, *min, *max);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_clip_tensor(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  bool min_null = info__[1].IsUndefined();
  torch::Tensor *min_v = min_null ? nullptr : info__[1].As<Napi::External<torch::Tensor>>().Data();
  bool max_null = info__[2].IsUndefined();
  torch::Tensor *max_v = max_null ? nullptr : info__[2].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::clip(*self, (min_null ? *min_v : torch::Tensor()), (max_null ? *max_v : torch::Tensor()));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_clip_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *min = info__[2].As<Napi::External<torch::Scalar>>().Data();
  torch::Scalar *max = info__[3].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::clip_out(*out, *self, *min, *max);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_clip_tensor_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  bool min_null = info__[2].IsUndefined();
  torch::Tensor *min_v = min_null ? nullptr : info__[2].As<Napi::External<torch::Tensor>>().Data();
  bool max_null = info__[3].IsUndefined();
  torch::Tensor *max_v = max_null ? nullptr : info__[3].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::clip_out(*out, *self, (min_null ? *min_v : torch::Tensor()), (max_null ? *max_v : torch::Tensor()));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_clip_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *min = info__[1].As<Napi::External<torch::Scalar>>().Data();
  torch::Scalar *max = info__[2].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::clip_(*self, *min, *max);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_clip_tensor_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  bool min_null = info__[1].IsUndefined();
  torch::Tensor *min_v = min_null ? nullptr : info__[1].As<Napi::External<torch::Tensor>>().Data();
  bool max_null = info__[2].IsUndefined();
  torch::Tensor *max_v = max_null ? nullptr : info__[2].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::clip_(*self, (min_null ? *min_v : torch::Tensor()), (max_null ? *max_v : torch::Tensor()));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::Boolean atg_cudnn_is_acceptable(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::cudnn_is_acceptable(*self);
  return Napi::Boolean::New(env__, output__);
}

Napi::External<torch::Tensor> atg_complex(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *real = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *imag = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::complex(*real, *imag);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_complex_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *real = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *imag = info__[2].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::complex_out(*out, *real, *imag);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_polar(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *abs = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *angle = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::polar(*abs, *angle);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_polar_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *abs = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *angle = info__[2].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::polar_out(*out, *abs, *angle);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_constant_pad_nd(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array pad_array__ = info__[1].As<Napi::Array>();
  int pad_len = pad_array__.Length();
  int64_t *pad_data = new int64_t[pad_len];
  for (int i = 0; i < pad_len; ++i)
    pad_data[i] = pad_array__.Get(i).ToNumber().Int64Value();
  torch::Scalar *value = info__[2].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::constant_pad_nd(*self, torch::IntArrayRef(pad_data, pad_len), *value);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_constant_pad_nd_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array pad_array__ = info__[2].As<Napi::Array>();
  int pad_len = pad_array__.Length();
  int64_t *pad_data = new int64_t[pad_len];
  for (int i = 0; i < pad_len; ++i)
    pad_data[i] = pad_array__.Get(i).ToNumber().Int64Value();
  torch::Scalar *value = info__[3].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::constant_pad_nd_out(*out, *self, torch::IntArrayRef(pad_data, pad_len), *value);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_contiguous(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int memory_format = info__[1].As<Napi::Number>().Int32Value();
  auto output__ = self->contiguous((at::MemoryFormat)memory_format);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_convolution(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *input = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *weight = info__[1].As<Napi::External<torch::Tensor>>().Data();
  bool bias_null = info__[2].IsUndefined();
  torch::Tensor *bias_v = bias_null ? nullptr : info__[2].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array stride_array__ = info__[3].As<Napi::Array>();
  int stride_len = stride_array__.Length();
  int64_t *stride_data = new int64_t[stride_len];
  for (int i = 0; i < stride_len; ++i)
    stride_data[i] = stride_array__.Get(i).ToNumber().Int64Value();
  Napi::Array padding_array__ = info__[4].As<Napi::Array>();
  int padding_len = padding_array__.Length();
  int64_t *padding_data = new int64_t[padding_len];
  for (int i = 0; i < padding_len; ++i)
    padding_data[i] = padding_array__.Get(i).ToNumber().Int64Value();
  Napi::Array dilation_array__ = info__[5].As<Napi::Array>();
  int dilation_len = dilation_array__.Length();
  int64_t *dilation_data = new int64_t[dilation_len];
  for (int i = 0; i < dilation_len; ++i)
    dilation_data[i] = dilation_array__.Get(i).ToNumber().Int64Value();
  bool transposed = info__[6].As<Napi::Boolean>().Value();
  Napi::Array output_padding_array__ = info__[7].As<Napi::Array>();
  int output_padding_len = output_padding_array__.Length();
  int64_t *output_padding_data = new int64_t[output_padding_len];
  for (int i = 0; i < output_padding_len; ++i)
    output_padding_data[i] = output_padding_array__.Get(i).ToNumber().Int64Value();
  int64_t groups = info__[8].As<Napi::Number>().Int64Value();
  auto output__ = torch::convolution(*input, *weight, (bias_null ? *bias_v : torch::Tensor()), torch::IntArrayRef(stride_data, stride_len), torch::IntArrayRef(padding_data, padding_len), torch::IntArrayRef(dilation_data, dilation_len), transposed, torch::IntArrayRef(output_padding_data, output_padding_len), groups);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_convolution_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *input = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *weight = info__[2].As<Napi::External<torch::Tensor>>().Data();
  bool bias_null = info__[3].IsUndefined();
  torch::Tensor *bias_v = bias_null ? nullptr : info__[3].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array stride_array__ = info__[4].As<Napi::Array>();
  int stride_len = stride_array__.Length();
  int64_t *stride_data = new int64_t[stride_len];
  for (int i = 0; i < stride_len; ++i)
    stride_data[i] = stride_array__.Get(i).ToNumber().Int64Value();
  Napi::Array padding_array__ = info__[5].As<Napi::Array>();
  int padding_len = padding_array__.Length();
  int64_t *padding_data = new int64_t[padding_len];
  for (int i = 0; i < padding_len; ++i)
    padding_data[i] = padding_array__.Get(i).ToNumber().Int64Value();
  Napi::Array dilation_array__ = info__[6].As<Napi::Array>();
  int dilation_len = dilation_array__.Length();
  int64_t *dilation_data = new int64_t[dilation_len];
  for (int i = 0; i < dilation_len; ++i)
    dilation_data[i] = dilation_array__.Get(i).ToNumber().Int64Value();
  bool transposed = info__[7].As<Napi::Boolean>().Value();
  Napi::Array output_padding_array__ = info__[8].As<Napi::Array>();
  int output_padding_len = output_padding_array__.Length();
  int64_t *output_padding_data = new int64_t[output_padding_len];
  for (int i = 0; i < output_padding_len; ++i)
    output_padding_data[i] = output_padding_array__.Get(i).ToNumber().Int64Value();
  int64_t groups = info__[9].As<Napi::Number>().Int64Value();
  auto output__ = torch::convolution_out(*out, *input, *weight, (bias_null ? *bias_v : torch::Tensor()), torch::IntArrayRef(stride_data, stride_len), torch::IntArrayRef(padding_data, padding_len), torch::IntArrayRef(dilation_data, dilation_len), transposed, torch::IntArrayRef(output_padding_data, output_padding_len), groups);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_convolution_overrideable(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *input = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *weight = info__[1].As<Napi::External<torch::Tensor>>().Data();
  bool bias_null = info__[2].IsUndefined();
  torch::Tensor *bias_v = bias_null ? nullptr : info__[2].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array stride_array__ = info__[3].As<Napi::Array>();
  int stride_len = stride_array__.Length();
  int64_t *stride_data = new int64_t[stride_len];
  for (int i = 0; i < stride_len; ++i)
    stride_data[i] = stride_array__.Get(i).ToNumber().Int64Value();
  Napi::Array padding_array__ = info__[4].As<Napi::Array>();
  int padding_len = padding_array__.Length();
  int64_t *padding_data = new int64_t[padding_len];
  for (int i = 0; i < padding_len; ++i)
    padding_data[i] = padding_array__.Get(i).ToNumber().Int64Value();
  Napi::Array dilation_array__ = info__[5].As<Napi::Array>();
  int dilation_len = dilation_array__.Length();
  int64_t *dilation_data = new int64_t[dilation_len];
  for (int i = 0; i < dilation_len; ++i)
    dilation_data[i] = dilation_array__.Get(i).ToNumber().Int64Value();
  bool transposed = info__[6].As<Napi::Boolean>().Value();
  Napi::Array output_padding_array__ = info__[7].As<Napi::Array>();
  int output_padding_len = output_padding_array__.Length();
  int64_t *output_padding_data = new int64_t[output_padding_len];
  for (int i = 0; i < output_padding_len; ++i)
    output_padding_data[i] = output_padding_array__.Get(i).ToNumber().Int64Value();
  int64_t groups = info__[8].As<Napi::Number>().Int64Value();
  auto output__ = torch::convolution_overrideable(*input, *weight, (bias_null ? *bias_v : torch::Tensor()), torch::IntArrayRef(stride_data, stride_len), torch::IntArrayRef(padding_data, padding_len), torch::IntArrayRef(dilation_data, dilation_len), transposed, torch::IntArrayRef(output_padding_data, output_padding_len), groups);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_convolution_overrideable_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *input = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *weight = info__[2].As<Napi::External<torch::Tensor>>().Data();
  bool bias_null = info__[3].IsUndefined();
  torch::Tensor *bias_v = bias_null ? nullptr : info__[3].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array stride_array__ = info__[4].As<Napi::Array>();
  int stride_len = stride_array__.Length();
  int64_t *stride_data = new int64_t[stride_len];
  for (int i = 0; i < stride_len; ++i)
    stride_data[i] = stride_array__.Get(i).ToNumber().Int64Value();
  Napi::Array padding_array__ = info__[5].As<Napi::Array>();
  int padding_len = padding_array__.Length();
  int64_t *padding_data = new int64_t[padding_len];
  for (int i = 0; i < padding_len; ++i)
    padding_data[i] = padding_array__.Get(i).ToNumber().Int64Value();
  Napi::Array dilation_array__ = info__[6].As<Napi::Array>();
  int dilation_len = dilation_array__.Length();
  int64_t *dilation_data = new int64_t[dilation_len];
  for (int i = 0; i < dilation_len; ++i)
    dilation_data[i] = dilation_array__.Get(i).ToNumber().Int64Value();
  bool transposed = info__[7].As<Napi::Boolean>().Value();
  Napi::Array output_padding_array__ = info__[8].As<Napi::Array>();
  int output_padding_len = output_padding_array__.Length();
  int64_t *output_padding_data = new int64_t[output_padding_len];
  for (int i = 0; i < output_padding_len; ++i)
    output_padding_data[i] = output_padding_array__.Get(i).ToNumber().Int64Value();
  int64_t groups = info__[9].As<Napi::Number>().Int64Value();
  auto output__ = torch::convolution_overrideable_out(*out, *input, *weight, (bias_null ? *bias_v : torch::Tensor()), torch::IntArrayRef(stride_data, stride_len), torch::IntArrayRef(padding_data, padding_len), torch::IntArrayRef(dilation_data, dilation_len), transposed, torch::IntArrayRef(output_padding_data, output_padding_len), groups);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__convolution_deprecated(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *input = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *weight = info__[1].As<Napi::External<torch::Tensor>>().Data();
  bool bias_null = info__[2].IsUndefined();
  torch::Tensor *bias_v = bias_null ? nullptr : info__[2].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array stride_array__ = info__[3].As<Napi::Array>();
  int stride_len = stride_array__.Length();
  int64_t *stride_data = new int64_t[stride_len];
  for (int i = 0; i < stride_len; ++i)
    stride_data[i] = stride_array__.Get(i).ToNumber().Int64Value();
  Napi::Array padding_array__ = info__[4].As<Napi::Array>();
  int padding_len = padding_array__.Length();
  int64_t *padding_data = new int64_t[padding_len];
  for (int i = 0; i < padding_len; ++i)
    padding_data[i] = padding_array__.Get(i).ToNumber().Int64Value();
  Napi::Array dilation_array__ = info__[5].As<Napi::Array>();
  int dilation_len = dilation_array__.Length();
  int64_t *dilation_data = new int64_t[dilation_len];
  for (int i = 0; i < dilation_len; ++i)
    dilation_data[i] = dilation_array__.Get(i).ToNumber().Int64Value();
  bool transposed = info__[6].As<Napi::Boolean>().Value();
  Napi::Array output_padding_array__ = info__[7].As<Napi::Array>();
  int output_padding_len = output_padding_array__.Length();
  int64_t *output_padding_data = new int64_t[output_padding_len];
  for (int i = 0; i < output_padding_len; ++i)
    output_padding_data[i] = output_padding_array__.Get(i).ToNumber().Int64Value();
  int64_t groups = info__[8].As<Napi::Number>().Int64Value();
  bool benchmark = info__[9].As<Napi::Boolean>().Value();
  bool deterministic = info__[10].As<Napi::Boolean>().Value();
  bool cudnn_enabled = info__[11].As<Napi::Boolean>().Value();
  auto output__ = torch::_convolution(*input, *weight, (bias_null ? *bias_v : torch::Tensor()), torch::IntArrayRef(stride_data, stride_len), torch::IntArrayRef(padding_data, padding_len), torch::IntArrayRef(dilation_data, dilation_len), transposed, torch::IntArrayRef(output_padding_data, output_padding_len), groups, benchmark, deterministic, cudnn_enabled);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__convolution(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *input = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *weight = info__[1].As<Napi::External<torch::Tensor>>().Data();
  bool bias_null = info__[2].IsUndefined();
  torch::Tensor *bias_v = bias_null ? nullptr : info__[2].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array stride_array__ = info__[3].As<Napi::Array>();
  int stride_len = stride_array__.Length();
  int64_t *stride_data = new int64_t[stride_len];
  for (int i = 0; i < stride_len; ++i)
    stride_data[i] = stride_array__.Get(i).ToNumber().Int64Value();
  Napi::Array padding_array__ = info__[4].As<Napi::Array>();
  int padding_len = padding_array__.Length();
  int64_t *padding_data = new int64_t[padding_len];
  for (int i = 0; i < padding_len; ++i)
    padding_data[i] = padding_array__.Get(i).ToNumber().Int64Value();
  Napi::Array dilation_array__ = info__[5].As<Napi::Array>();
  int dilation_len = dilation_array__.Length();
  int64_t *dilation_data = new int64_t[dilation_len];
  for (int i = 0; i < dilation_len; ++i)
    dilation_data[i] = dilation_array__.Get(i).ToNumber().Int64Value();
  bool transposed = info__[6].As<Napi::Boolean>().Value();
  Napi::Array output_padding_array__ = info__[7].As<Napi::Array>();
  int output_padding_len = output_padding_array__.Length();
  int64_t *output_padding_data = new int64_t[output_padding_len];
  for (int i = 0; i < output_padding_len; ++i)
    output_padding_data[i] = output_padding_array__.Get(i).ToNumber().Int64Value();
  int64_t groups = info__[8].As<Napi::Number>().Int64Value();
  bool benchmark = info__[9].As<Napi::Boolean>().Value();
  bool deterministic = info__[10].As<Napi::Boolean>().Value();
  bool cudnn_enabled = info__[11].As<Napi::Boolean>().Value();
  bool allow_tf32 = info__[12].As<Napi::Boolean>().Value();
  auto output__ = torch::_convolution(*input, *weight, (bias_null ? *bias_v : torch::Tensor()), torch::IntArrayRef(stride_data, stride_len), torch::IntArrayRef(padding_data, padding_len), torch::IntArrayRef(dilation_data, dilation_len), transposed, torch::IntArrayRef(output_padding_data, output_padding_len), groups, benchmark, deterministic, cudnn_enabled, allow_tf32);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__convolution_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *input = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *weight = info__[2].As<Napi::External<torch::Tensor>>().Data();
  bool bias_null = info__[3].IsUndefined();
  torch::Tensor *bias_v = bias_null ? nullptr : info__[3].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array stride_array__ = info__[4].As<Napi::Array>();
  int stride_len = stride_array__.Length();
  int64_t *stride_data = new int64_t[stride_len];
  for (int i = 0; i < stride_len; ++i)
    stride_data[i] = stride_array__.Get(i).ToNumber().Int64Value();
  Napi::Array padding_array__ = info__[5].As<Napi::Array>();
  int padding_len = padding_array__.Length();
  int64_t *padding_data = new int64_t[padding_len];
  for (int i = 0; i < padding_len; ++i)
    padding_data[i] = padding_array__.Get(i).ToNumber().Int64Value();
  Napi::Array dilation_array__ = info__[6].As<Napi::Array>();
  int dilation_len = dilation_array__.Length();
  int64_t *dilation_data = new int64_t[dilation_len];
  for (int i = 0; i < dilation_len; ++i)
    dilation_data[i] = dilation_array__.Get(i).ToNumber().Int64Value();
  bool transposed = info__[7].As<Napi::Boolean>().Value();
  Napi::Array output_padding_array__ = info__[8].As<Napi::Array>();
  int output_padding_len = output_padding_array__.Length();
  int64_t *output_padding_data = new int64_t[output_padding_len];
  for (int i = 0; i < output_padding_len; ++i)
    output_padding_data[i] = output_padding_array__.Get(i).ToNumber().Int64Value();
  int64_t groups = info__[9].As<Napi::Number>().Int64Value();
  bool benchmark = info__[10].As<Napi::Boolean>().Value();
  bool deterministic = info__[11].As<Napi::Boolean>().Value();
  bool cudnn_enabled = info__[12].As<Napi::Boolean>().Value();
  bool allow_tf32 = info__[13].As<Napi::Boolean>().Value();
  auto output__ = torch::_convolution_out(*out, *input, *weight, (bias_null ? *bias_v : torch::Tensor()), torch::IntArrayRef(stride_data, stride_len), torch::IntArrayRef(padding_data, padding_len), torch::IntArrayRef(dilation_data, dilation_len), transposed, torch::IntArrayRef(output_padding_data, output_padding_len), groups, benchmark, deterministic, cudnn_enabled, allow_tf32);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__convolution_mode(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *input = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *weight = info__[1].As<Napi::External<torch::Tensor>>().Data();
  bool bias_null = info__[2].IsUndefined();
  torch::Tensor *bias_v = bias_null ? nullptr : info__[2].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array stride_array__ = info__[3].As<Napi::Array>();
  int stride_len = stride_array__.Length();
  int64_t *stride_data = new int64_t[stride_len];
  for (int i = 0; i < stride_len; ++i)
    stride_data[i] = stride_array__.Get(i).ToNumber().Int64Value();
  Napi::String padding_str__ = info__[4].As<Napi::String>();
  std::string padding = padding_str__.Utf8Value();
  Napi::Array dilation_array__ = info__[5].As<Napi::Array>();
  int dilation_len = dilation_array__.Length();
  int64_t *dilation_data = new int64_t[dilation_len];
  for (int i = 0; i < dilation_len; ++i)
    dilation_data[i] = dilation_array__.Get(i).ToNumber().Int64Value();
  int64_t groups = info__[6].As<Napi::Number>().Int64Value();
  auto output__ = torch::_convolution_mode(*input, *weight, (bias_null ? *bias_v : torch::Tensor()), torch::IntArrayRef(stride_data, stride_len), padding, torch::IntArrayRef(dilation_data, dilation_len), groups);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_conv1d(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *input = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *weight = info__[1].As<Napi::External<torch::Tensor>>().Data();
  bool bias_null = info__[2].IsUndefined();
  torch::Tensor *bias_v = bias_null ? nullptr : info__[2].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array stride_array__ = info__[3].As<Napi::Array>();
  int stride_len = stride_array__.Length();
  int64_t *stride_data = new int64_t[stride_len];
  for (int i = 0; i < stride_len; ++i)
    stride_data[i] = stride_array__.Get(i).ToNumber().Int64Value();
  Napi::Array padding_array__ = info__[4].As<Napi::Array>();
  int padding_len = padding_array__.Length();
  int64_t *padding_data = new int64_t[padding_len];
  for (int i = 0; i < padding_len; ++i)
    padding_data[i] = padding_array__.Get(i).ToNumber().Int64Value();
  Napi::Array dilation_array__ = info__[5].As<Napi::Array>();
  int dilation_len = dilation_array__.Length();
  int64_t *dilation_data = new int64_t[dilation_len];
  for (int i = 0; i < dilation_len; ++i)
    dilation_data[i] = dilation_array__.Get(i).ToNumber().Int64Value();
  int64_t groups = info__[6].As<Napi::Number>().Int64Value();
  auto output__ = torch::conv1d(*input, *weight, (bias_null ? *bias_v : torch::Tensor()), torch::IntArrayRef(stride_data, stride_len), torch::IntArrayRef(padding_data, padding_len), torch::IntArrayRef(dilation_data, dilation_len), groups);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_conv1d_padding(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *input = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *weight = info__[1].As<Napi::External<torch::Tensor>>().Data();
  bool bias_null = info__[2].IsUndefined();
  torch::Tensor *bias_v = bias_null ? nullptr : info__[2].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array stride_array__ = info__[3].As<Napi::Array>();
  int stride_len = stride_array__.Length();
  int64_t *stride_data = new int64_t[stride_len];
  for (int i = 0; i < stride_len; ++i)
    stride_data[i] = stride_array__.Get(i).ToNumber().Int64Value();
  Napi::String padding_str__ = info__[4].As<Napi::String>();
  std::string padding = padding_str__.Utf8Value();
  Napi::Array dilation_array__ = info__[5].As<Napi::Array>();
  int dilation_len = dilation_array__.Length();
  int64_t *dilation_data = new int64_t[dilation_len];
  for (int i = 0; i < dilation_len; ++i)
    dilation_data[i] = dilation_array__.Get(i).ToNumber().Int64Value();
  int64_t groups = info__[6].As<Napi::Number>().Int64Value();
  auto output__ = torch::conv1d(*input, *weight, (bias_null ? *bias_v : torch::Tensor()), torch::IntArrayRef(stride_data, stride_len), padding, torch::IntArrayRef(dilation_data, dilation_len), groups);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_conv2d(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *input = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *weight = info__[1].As<Napi::External<torch::Tensor>>().Data();
  bool bias_null = info__[2].IsUndefined();
  torch::Tensor *bias_v = bias_null ? nullptr : info__[2].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array stride_array__ = info__[3].As<Napi::Array>();
  int stride_len = stride_array__.Length();
  int64_t *stride_data = new int64_t[stride_len];
  for (int i = 0; i < stride_len; ++i)
    stride_data[i] = stride_array__.Get(i).ToNumber().Int64Value();
  Napi::Array padding_array__ = info__[4].As<Napi::Array>();
  int padding_len = padding_array__.Length();
  int64_t *padding_data = new int64_t[padding_len];
  for (int i = 0; i < padding_len; ++i)
    padding_data[i] = padding_array__.Get(i).ToNumber().Int64Value();
  Napi::Array dilation_array__ = info__[5].As<Napi::Array>();
  int dilation_len = dilation_array__.Length();
  int64_t *dilation_data = new int64_t[dilation_len];
  for (int i = 0; i < dilation_len; ++i)
    dilation_data[i] = dilation_array__.Get(i).ToNumber().Int64Value();
  int64_t groups = info__[6].As<Napi::Number>().Int64Value();
  auto output__ = torch::conv2d(*input, *weight, (bias_null ? *bias_v : torch::Tensor()), torch::IntArrayRef(stride_data, stride_len), torch::IntArrayRef(padding_data, padding_len), torch::IntArrayRef(dilation_data, dilation_len), groups);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_conv2d_padding(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *input = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *weight = info__[1].As<Napi::External<torch::Tensor>>().Data();
  bool bias_null = info__[2].IsUndefined();
  torch::Tensor *bias_v = bias_null ? nullptr : info__[2].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array stride_array__ = info__[3].As<Napi::Array>();
  int stride_len = stride_array__.Length();
  int64_t *stride_data = new int64_t[stride_len];
  for (int i = 0; i < stride_len; ++i)
    stride_data[i] = stride_array__.Get(i).ToNumber().Int64Value();
  Napi::String padding_str__ = info__[4].As<Napi::String>();
  std::string padding = padding_str__.Utf8Value();
  Napi::Array dilation_array__ = info__[5].As<Napi::Array>();
  int dilation_len = dilation_array__.Length();
  int64_t *dilation_data = new int64_t[dilation_len];
  for (int i = 0; i < dilation_len; ++i)
    dilation_data[i] = dilation_array__.Get(i).ToNumber().Int64Value();
  int64_t groups = info__[6].As<Napi::Number>().Int64Value();
  auto output__ = torch::conv2d(*input, *weight, (bias_null ? *bias_v : torch::Tensor()), torch::IntArrayRef(stride_data, stride_len), padding, torch::IntArrayRef(dilation_data, dilation_len), groups);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_conv3d(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *input = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *weight = info__[1].As<Napi::External<torch::Tensor>>().Data();
  bool bias_null = info__[2].IsUndefined();
  torch::Tensor *bias_v = bias_null ? nullptr : info__[2].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array stride_array__ = info__[3].As<Napi::Array>();
  int stride_len = stride_array__.Length();
  int64_t *stride_data = new int64_t[stride_len];
  for (int i = 0; i < stride_len; ++i)
    stride_data[i] = stride_array__.Get(i).ToNumber().Int64Value();
  Napi::Array padding_array__ = info__[4].As<Napi::Array>();
  int padding_len = padding_array__.Length();
  int64_t *padding_data = new int64_t[padding_len];
  for (int i = 0; i < padding_len; ++i)
    padding_data[i] = padding_array__.Get(i).ToNumber().Int64Value();
  Napi::Array dilation_array__ = info__[5].As<Napi::Array>();
  int dilation_len = dilation_array__.Length();
  int64_t *dilation_data = new int64_t[dilation_len];
  for (int i = 0; i < dilation_len; ++i)
    dilation_data[i] = dilation_array__.Get(i).ToNumber().Int64Value();
  int64_t groups = info__[6].As<Napi::Number>().Int64Value();
  auto output__ = torch::conv3d(*input, *weight, (bias_null ? *bias_v : torch::Tensor()), torch::IntArrayRef(stride_data, stride_len), torch::IntArrayRef(padding_data, padding_len), torch::IntArrayRef(dilation_data, dilation_len), groups);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_conv3d_padding(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *input = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *weight = info__[1].As<Napi::External<torch::Tensor>>().Data();
  bool bias_null = info__[2].IsUndefined();
  torch::Tensor *bias_v = bias_null ? nullptr : info__[2].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array stride_array__ = info__[3].As<Napi::Array>();
  int stride_len = stride_array__.Length();
  int64_t *stride_data = new int64_t[stride_len];
  for (int i = 0; i < stride_len; ++i)
    stride_data[i] = stride_array__.Get(i).ToNumber().Int64Value();
  Napi::String padding_str__ = info__[4].As<Napi::String>();
  std::string padding = padding_str__.Utf8Value();
  Napi::Array dilation_array__ = info__[5].As<Napi::Array>();
  int dilation_len = dilation_array__.Length();
  int64_t *dilation_data = new int64_t[dilation_len];
  for (int i = 0; i < dilation_len; ++i)
    dilation_data[i] = dilation_array__.Get(i).ToNumber().Int64Value();
  int64_t groups = info__[6].As<Napi::Number>().Int64Value();
  auto output__ = torch::conv3d(*input, *weight, (bias_null ? *bias_v : torch::Tensor()), torch::IntArrayRef(stride_data, stride_len), padding, torch::IntArrayRef(dilation_data, dilation_len), groups);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_conv_tbc(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *weight = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *bias = info__[2].As<Napi::External<torch::Tensor>>().Data();
  int64_t pad = info__[3].As<Napi::Number>().Int64Value();
  auto output__ = torch::conv_tbc(*self, *weight, *bias, pad);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_conv_tbc_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *weight = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *bias = info__[3].As<Napi::External<torch::Tensor>>().Data();
  int64_t pad = info__[4].As<Napi::Number>().Int64Value();
  auto output__ = torch::conv_tbc_out(*out, *self, *weight, *bias, pad);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::Array atg_conv_tbc_backward(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *input = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *weight = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *bias = info__[3].As<Napi::External<torch::Tensor>>().Data();
  int64_t pad = info__[4].As<Napi::Number>().Int64Value();
  auto output__ = torch::conv_tbc_backward(*self, *input, *weight, *bias, pad);
  Napi::Array output__array__ = Napi::Array::New(env__, 3);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  output__array__[2u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<2>(output__)));
  return output__array__;
}

Napi::External<torch::Tensor> atg_conv_transpose1d(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *input = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *weight = info__[1].As<Napi::External<torch::Tensor>>().Data();
  bool bias_null = info__[2].IsUndefined();
  torch::Tensor *bias_v = bias_null ? nullptr : info__[2].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array stride_array__ = info__[3].As<Napi::Array>();
  int stride_len = stride_array__.Length();
  int64_t *stride_data = new int64_t[stride_len];
  for (int i = 0; i < stride_len; ++i)
    stride_data[i] = stride_array__.Get(i).ToNumber().Int64Value();
  Napi::Array padding_array__ = info__[4].As<Napi::Array>();
  int padding_len = padding_array__.Length();
  int64_t *padding_data = new int64_t[padding_len];
  for (int i = 0; i < padding_len; ++i)
    padding_data[i] = padding_array__.Get(i).ToNumber().Int64Value();
  Napi::Array output_padding_array__ = info__[5].As<Napi::Array>();
  int output_padding_len = output_padding_array__.Length();
  int64_t *output_padding_data = new int64_t[output_padding_len];
  for (int i = 0; i < output_padding_len; ++i)
    output_padding_data[i] = output_padding_array__.Get(i).ToNumber().Int64Value();
  int64_t groups = info__[6].As<Napi::Number>().Int64Value();
  Napi::Array dilation_array__ = info__[7].As<Napi::Array>();
  int dilation_len = dilation_array__.Length();
  int64_t *dilation_data = new int64_t[dilation_len];
  for (int i = 0; i < dilation_len; ++i)
    dilation_data[i] = dilation_array__.Get(i).ToNumber().Int64Value();
  auto output__ = torch::conv_transpose1d(*input, *weight, (bias_null ? *bias_v : torch::Tensor()), torch::IntArrayRef(stride_data, stride_len), torch::IntArrayRef(padding_data, padding_len), torch::IntArrayRef(output_padding_data, output_padding_len), groups, torch::IntArrayRef(dilation_data, dilation_len));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_conv_transpose2d(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *input = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *weight = info__[1].As<Napi::External<torch::Tensor>>().Data();
  bool bias_null = info__[2].IsUndefined();
  torch::Tensor *bias_v = bias_null ? nullptr : info__[2].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array stride_array__ = info__[3].As<Napi::Array>();
  int stride_len = stride_array__.Length();
  int64_t *stride_data = new int64_t[stride_len];
  for (int i = 0; i < stride_len; ++i)
    stride_data[i] = stride_array__.Get(i).ToNumber().Int64Value();
  Napi::Array padding_array__ = info__[4].As<Napi::Array>();
  int padding_len = padding_array__.Length();
  int64_t *padding_data = new int64_t[padding_len];
  for (int i = 0; i < padding_len; ++i)
    padding_data[i] = padding_array__.Get(i).ToNumber().Int64Value();
  Napi::Array output_padding_array__ = info__[5].As<Napi::Array>();
  int output_padding_len = output_padding_array__.Length();
  int64_t *output_padding_data = new int64_t[output_padding_len];
  for (int i = 0; i < output_padding_len; ++i)
    output_padding_data[i] = output_padding_array__.Get(i).ToNumber().Int64Value();
  int64_t groups = info__[6].As<Napi::Number>().Int64Value();
  Napi::Array dilation_array__ = info__[7].As<Napi::Array>();
  int dilation_len = dilation_array__.Length();
  int64_t *dilation_data = new int64_t[dilation_len];
  for (int i = 0; i < dilation_len; ++i)
    dilation_data[i] = dilation_array__.Get(i).ToNumber().Int64Value();
  auto output__ = torch::conv_transpose2d(*input, *weight, (bias_null ? *bias_v : torch::Tensor()), torch::IntArrayRef(stride_data, stride_len), torch::IntArrayRef(padding_data, padding_len), torch::IntArrayRef(output_padding_data, output_padding_len), groups, torch::IntArrayRef(dilation_data, dilation_len));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_conv_transpose3d(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *input = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *weight = info__[1].As<Napi::External<torch::Tensor>>().Data();
  bool bias_null = info__[2].IsUndefined();
  torch::Tensor *bias_v = bias_null ? nullptr : info__[2].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array stride_array__ = info__[3].As<Napi::Array>();
  int stride_len = stride_array__.Length();
  int64_t *stride_data = new int64_t[stride_len];
  for (int i = 0; i < stride_len; ++i)
    stride_data[i] = stride_array__.Get(i).ToNumber().Int64Value();
  Napi::Array padding_array__ = info__[4].As<Napi::Array>();
  int padding_len = padding_array__.Length();
  int64_t *padding_data = new int64_t[padding_len];
  for (int i = 0; i < padding_len; ++i)
    padding_data[i] = padding_array__.Get(i).ToNumber().Int64Value();
  Napi::Array output_padding_array__ = info__[5].As<Napi::Array>();
  int output_padding_len = output_padding_array__.Length();
  int64_t *output_padding_data = new int64_t[output_padding_len];
  for (int i = 0; i < output_padding_len; ++i)
    output_padding_data[i] = output_padding_array__.Get(i).ToNumber().Int64Value();
  int64_t groups = info__[6].As<Napi::Number>().Int64Value();
  Napi::Array dilation_array__ = info__[7].As<Napi::Array>();
  int dilation_len = dilation_array__.Length();
  int64_t *dilation_data = new int64_t[dilation_len];
  for (int i = 0; i < dilation_len; ++i)
    dilation_data[i] = dilation_array__.Get(i).ToNumber().Int64Value();
  auto output__ = torch::conv_transpose3d(*input, *weight, (bias_null ? *bias_v : torch::Tensor()), torch::IntArrayRef(stride_data, stride_len), torch::IntArrayRef(padding_data, padding_len), torch::IntArrayRef(output_padding_data, output_padding_len), groups, torch::IntArrayRef(dilation_data, dilation_len));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__copy_from(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *dst = info__[1].As<Napi::External<torch::Tensor>>().Data();
  bool non_blocking = info__[2].As<Napi::Boolean>().Value();
  auto output__ = torch::_copy_from(*self, *dst, non_blocking);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__copy_from_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *dst = info__[2].As<Napi::External<torch::Tensor>>().Data();
  bool non_blocking = info__[3].As<Napi::Boolean>().Value();
  auto output__ = torch::_copy_from_out(*out, *self, *dst, non_blocking);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__copy_from_and_resize(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *dst = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::_copy_from_and_resize(*self, *dst);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__copy_from_and_resize_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *dst = info__[2].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::_copy_from_and_resize_out(*out, *self, *dst);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_cos(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::cos(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_cos_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::cos_out(*out, *self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_cos_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::cos_(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_cosh(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::cosh(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_cosh_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::cosh_out(*out, *self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_cosh_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::cosh_(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_cosine_embedding_loss(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *input1 = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *input2 = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *target = info__[2].As<Napi::External<torch::Tensor>>().Data();
  double margin = info__[3].As<Napi::Number>().DoubleValue();
  int64_t reduction = info__[4].As<Napi::Number>().Int64Value();
  auto output__ = torch::cosine_embedding_loss(*input1, *input2, *target, margin, reduction);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_count_nonzero_dim_intlist(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array dim_array__ = info__[1].As<Napi::Array>();
  int dim_len = dim_array__.Length();
  int64_t *dim_data = new int64_t[dim_len];
  for (int i = 0; i < dim_len; ++i)
    dim_data[i] = dim_array__.Get(i).ToNumber().Int64Value();
  auto output__ = torch::count_nonzero(*self, torch::IntArrayRef(dim_data, dim_len));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_count_nonzero(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  bool dim_null = info__[1].IsUndefined();
  int64_t dim_v = dim_null ? 0 : info__[1].As<Napi::Number>().Int64Value();
  auto output__ = torch::count_nonzero(*self, dim_null ? c10::nullopt : c10::optional<int64_t>(dim_v));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_count_nonzero_dim_intlist_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array dim_array__ = info__[2].As<Napi::Array>();
  int dim_len = dim_array__.Length();
  int64_t *dim_data = new int64_t[dim_len];
  for (int i = 0; i < dim_len; ++i)
    dim_data[i] = dim_array__.Get(i).ToNumber().Int64Value();
  auto output__ = torch::count_nonzero_out(*out, *self, torch::IntArrayRef(dim_data, dim_len));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_count_nonzero_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  bool dim_null = info__[2].IsUndefined();
  int64_t dim_v = dim_null ? 0 : info__[2].As<Napi::Number>().Int64Value();
  auto output__ = torch::count_nonzero_out(*out, *self, dim_null ? c10::nullopt : c10::optional<int64_t>(dim_v));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_cov(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t correction = info__[1].As<Napi::Number>().Int64Value();
  bool fweights_null = info__[2].IsUndefined();
  torch::Tensor *fweights_v = fweights_null ? nullptr : info__[2].As<Napi::External<torch::Tensor>>().Data();
  bool aweights_null = info__[3].IsUndefined();
  torch::Tensor *aweights_v = aweights_null ? nullptr : info__[3].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::cov(*self, correction, (fweights_null ? *fweights_v : torch::Tensor()), (aweights_null ? *aweights_v : torch::Tensor()));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_corrcoef(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::corrcoef(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_cudnn_affine_grid_generator(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *theta = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t N = info__[1].As<Napi::Number>().Int64Value();
  int64_t C = info__[2].As<Napi::Number>().Int64Value();
  int64_t H = info__[3].As<Napi::Number>().Int64Value();
  int64_t W = info__[4].As<Napi::Number>().Int64Value();
  auto output__ = torch::cudnn_affine_grid_generator(*theta, N, C, H, W);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_cudnn_affine_grid_generator_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *theta = info__[1].As<Napi::External<torch::Tensor>>().Data();
  int64_t N = info__[2].As<Napi::Number>().Int64Value();
  int64_t C = info__[3].As<Napi::Number>().Int64Value();
  int64_t H = info__[4].As<Napi::Number>().Int64Value();
  int64_t W = info__[5].As<Napi::Number>().Int64Value();
  auto output__ = torch::cudnn_affine_grid_generator_out(*out, *theta, N, C, H, W);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_cudnn_affine_grid_generator_backward(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *grad = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t N = info__[1].As<Napi::Number>().Int64Value();
  int64_t C = info__[2].As<Napi::Number>().Int64Value();
  int64_t H = info__[3].As<Napi::Number>().Int64Value();
  int64_t W = info__[4].As<Napi::Number>().Int64Value();
  auto output__ = torch::cudnn_affine_grid_generator_backward(*grad, N, C, H, W);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_cudnn_affine_grid_generator_backward_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *grad = info__[1].As<Napi::External<torch::Tensor>>().Data();
  int64_t N = info__[2].As<Napi::Number>().Int64Value();
  int64_t C = info__[3].As<Napi::Number>().Int64Value();
  int64_t H = info__[4].As<Napi::Number>().Int64Value();
  int64_t W = info__[5].As<Napi::Number>().Int64Value();
  auto output__ = torch::cudnn_affine_grid_generator_backward_out(*out, *grad, N, C, H, W);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::Array atg_cudnn_batch_norm(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *input = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *weight = info__[1].As<Napi::External<torch::Tensor>>().Data();
  bool bias_null = info__[2].IsUndefined();
  torch::Tensor *bias_v = bias_null ? nullptr : info__[2].As<Napi::External<torch::Tensor>>().Data();
  bool running_mean_null = info__[3].IsUndefined();
  torch::Tensor *running_mean_v = running_mean_null ? nullptr : info__[3].As<Napi::External<torch::Tensor>>().Data();
  bool running_var_null = info__[4].IsUndefined();
  torch::Tensor *running_var_v = running_var_null ? nullptr : info__[4].As<Napi::External<torch::Tensor>>().Data();
  bool training = info__[5].As<Napi::Boolean>().Value();
  double exponential_average_factor = info__[6].As<Napi::Number>().DoubleValue();
  double epsilon = info__[7].As<Napi::Number>().DoubleValue();
  auto output__ = torch::cudnn_batch_norm(*input, *weight, (bias_null ? *bias_v : torch::Tensor()), (running_mean_null ? *running_mean_v : torch::Tensor()), (running_var_null ? *running_var_v : torch::Tensor()), training, exponential_average_factor, epsilon);
  Napi::Array output__array__ = Napi::Array::New(env__, 4);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  output__array__[2u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<2>(output__)));
  output__array__[3u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<3>(output__)));
  return output__array__;
}

Napi::Array atg_cudnn_batch_norm_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out0 = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *out1 = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *out2 = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *out3 = info__[3].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *input = info__[4].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *weight = info__[5].As<Napi::External<torch::Tensor>>().Data();
  bool bias_null = info__[6].IsUndefined();
  torch::Tensor *bias_v = bias_null ? nullptr : info__[6].As<Napi::External<torch::Tensor>>().Data();
  bool running_mean_null = info__[7].IsUndefined();
  torch::Tensor *running_mean_v = running_mean_null ? nullptr : info__[7].As<Napi::External<torch::Tensor>>().Data();
  bool running_var_null = info__[8].IsUndefined();
  torch::Tensor *running_var_v = running_var_null ? nullptr : info__[8].As<Napi::External<torch::Tensor>>().Data();
  bool training = info__[9].As<Napi::Boolean>().Value();
  double exponential_average_factor = info__[10].As<Napi::Number>().DoubleValue();
  double epsilon = info__[11].As<Napi::Number>().DoubleValue();
  auto output__ = torch::cudnn_batch_norm_out(*out0, *out1, *out2, *out3, *input, *weight, (bias_null ? *bias_v : torch::Tensor()), (running_mean_null ? *running_mean_v : torch::Tensor()), (running_var_null ? *running_var_v : torch::Tensor()), training, exponential_average_factor, epsilon);
  Napi::Array output__array__ = Napi::Array::New(env__, 4);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  output__array__[2u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<2>(output__)));
  output__array__[3u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<3>(output__)));
  return output__array__;
}

Napi::Array atg_cudnn_batch_norm_backward(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *input = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *grad_output = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *weight = info__[2].As<Napi::External<torch::Tensor>>().Data();
  bool running_mean_null = info__[3].IsUndefined();
  torch::Tensor *running_mean_v = running_mean_null ? nullptr : info__[3].As<Napi::External<torch::Tensor>>().Data();
  bool running_var_null = info__[4].IsUndefined();
  torch::Tensor *running_var_v = running_var_null ? nullptr : info__[4].As<Napi::External<torch::Tensor>>().Data();
  bool save_mean_null = info__[5].IsUndefined();
  torch::Tensor *save_mean_v = save_mean_null ? nullptr : info__[5].As<Napi::External<torch::Tensor>>().Data();
  bool save_var_null = info__[6].IsUndefined();
  torch::Tensor *save_var_v = save_var_null ? nullptr : info__[6].As<Napi::External<torch::Tensor>>().Data();
  double epsilon = info__[7].As<Napi::Number>().DoubleValue();
  torch::Tensor *reserveSpace = info__[8].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::cudnn_batch_norm_backward(*input, *grad_output, *weight, (running_mean_null ? *running_mean_v : torch::Tensor()), (running_var_null ? *running_var_v : torch::Tensor()), (save_mean_null ? *save_mean_v : torch::Tensor()), (save_var_null ? *save_var_v : torch::Tensor()), epsilon, *reserveSpace);
  Napi::Array output__array__ = Napi::Array::New(env__, 3);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  output__array__[2u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<2>(output__)));
  return output__array__;
}

Napi::Array atg_cudnn_batch_norm_backward_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out0 = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *out1 = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *out2 = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *input = info__[3].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *grad_output = info__[4].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *weight = info__[5].As<Napi::External<torch::Tensor>>().Data();
  bool running_mean_null = info__[6].IsUndefined();
  torch::Tensor *running_mean_v = running_mean_null ? nullptr : info__[6].As<Napi::External<torch::Tensor>>().Data();
  bool running_var_null = info__[7].IsUndefined();
  torch::Tensor *running_var_v = running_var_null ? nullptr : info__[7].As<Napi::External<torch::Tensor>>().Data();
  bool save_mean_null = info__[8].IsUndefined();
  torch::Tensor *save_mean_v = save_mean_null ? nullptr : info__[8].As<Napi::External<torch::Tensor>>().Data();
  bool save_var_null = info__[9].IsUndefined();
  torch::Tensor *save_var_v = save_var_null ? nullptr : info__[9].As<Napi::External<torch::Tensor>>().Data();
  double epsilon = info__[10].As<Napi::Number>().DoubleValue();
  torch::Tensor *reserveSpace = info__[11].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::cudnn_batch_norm_backward_out(*out0, *out1, *out2, *input, *grad_output, *weight, (running_mean_null ? *running_mean_v : torch::Tensor()), (running_var_null ? *running_var_v : torch::Tensor()), (save_mean_null ? *save_mean_v : torch::Tensor()), (save_var_null ? *save_var_v : torch::Tensor()), epsilon, *reserveSpace);
  Napi::Array output__array__ = Napi::Array::New(env__, 3);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  output__array__[2u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<2>(output__)));
  return output__array__;
}

Napi::External<torch::Tensor> atg_cudnn_convolution(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *weight = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array padding_array__ = info__[2].As<Napi::Array>();
  int padding_len = padding_array__.Length();
  int64_t *padding_data = new int64_t[padding_len];
  for (int i = 0; i < padding_len; ++i)
    padding_data[i] = padding_array__.Get(i).ToNumber().Int64Value();
  Napi::Array stride_array__ = info__[3].As<Napi::Array>();
  int stride_len = stride_array__.Length();
  int64_t *stride_data = new int64_t[stride_len];
  for (int i = 0; i < stride_len; ++i)
    stride_data[i] = stride_array__.Get(i).ToNumber().Int64Value();
  Napi::Array dilation_array__ = info__[4].As<Napi::Array>();
  int dilation_len = dilation_array__.Length();
  int64_t *dilation_data = new int64_t[dilation_len];
  for (int i = 0; i < dilation_len; ++i)
    dilation_data[i] = dilation_array__.Get(i).ToNumber().Int64Value();
  int64_t groups = info__[5].As<Napi::Number>().Int64Value();
  bool benchmark = info__[6].As<Napi::Boolean>().Value();
  bool deterministic = info__[7].As<Napi::Boolean>().Value();
  bool allow_tf32 = info__[8].As<Napi::Boolean>().Value();
  auto output__ = torch::cudnn_convolution(*self, *weight, torch::IntArrayRef(padding_data, padding_len), torch::IntArrayRef(stride_data, stride_len), torch::IntArrayRef(dilation_data, dilation_len), groups, benchmark, deterministic, allow_tf32);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_cudnn_convolution_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *weight = info__[2].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array padding_array__ = info__[3].As<Napi::Array>();
  int padding_len = padding_array__.Length();
  int64_t *padding_data = new int64_t[padding_len];
  for (int i = 0; i < padding_len; ++i)
    padding_data[i] = padding_array__.Get(i).ToNumber().Int64Value();
  Napi::Array stride_array__ = info__[4].As<Napi::Array>();
  int stride_len = stride_array__.Length();
  int64_t *stride_data = new int64_t[stride_len];
  for (int i = 0; i < stride_len; ++i)
    stride_data[i] = stride_array__.Get(i).ToNumber().Int64Value();
  Napi::Array dilation_array__ = info__[5].As<Napi::Array>();
  int dilation_len = dilation_array__.Length();
  int64_t *dilation_data = new int64_t[dilation_len];
  for (int i = 0; i < dilation_len; ++i)
    dilation_data[i] = dilation_array__.Get(i).ToNumber().Int64Value();
  int64_t groups = info__[6].As<Napi::Number>().Int64Value();
  bool benchmark = info__[7].As<Napi::Boolean>().Value();
  bool deterministic = info__[8].As<Napi::Boolean>().Value();
  bool allow_tf32 = info__[9].As<Napi::Boolean>().Value();
  auto output__ = torch::cudnn_convolution_out(*out, *self, *weight, torch::IntArrayRef(padding_data, padding_len), torch::IntArrayRef(stride_data, stride_len), torch::IntArrayRef(dilation_data, dilation_len), groups, benchmark, deterministic, allow_tf32);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_cudnn_convolution_transpose(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *weight = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array padding_array__ = info__[2].As<Napi::Array>();
  int padding_len = padding_array__.Length();
  int64_t *padding_data = new int64_t[padding_len];
  for (int i = 0; i < padding_len; ++i)
    padding_data[i] = padding_array__.Get(i).ToNumber().Int64Value();
  Napi::Array output_padding_array__ = info__[3].As<Napi::Array>();
  int output_padding_len = output_padding_array__.Length();
  int64_t *output_padding_data = new int64_t[output_padding_len];
  for (int i = 0; i < output_padding_len; ++i)
    output_padding_data[i] = output_padding_array__.Get(i).ToNumber().Int64Value();
  Napi::Array stride_array__ = info__[4].As<Napi::Array>();
  int stride_len = stride_array__.Length();
  int64_t *stride_data = new int64_t[stride_len];
  for (int i = 0; i < stride_len; ++i)
    stride_data[i] = stride_array__.Get(i).ToNumber().Int64Value();
  Napi::Array dilation_array__ = info__[5].As<Napi::Array>();
  int dilation_len = dilation_array__.Length();
  int64_t *dilation_data = new int64_t[dilation_len];
  for (int i = 0; i < dilation_len; ++i)
    dilation_data[i] = dilation_array__.Get(i).ToNumber().Int64Value();
  int64_t groups = info__[6].As<Napi::Number>().Int64Value();
  bool benchmark = info__[7].As<Napi::Boolean>().Value();
  bool deterministic = info__[8].As<Napi::Boolean>().Value();
  bool allow_tf32 = info__[9].As<Napi::Boolean>().Value();
  auto output__ = torch::cudnn_convolution_transpose(*self, *weight, torch::IntArrayRef(padding_data, padding_len), torch::IntArrayRef(output_padding_data, output_padding_len), torch::IntArrayRef(stride_data, stride_len), torch::IntArrayRef(dilation_data, dilation_len), groups, benchmark, deterministic, allow_tf32);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_cudnn_convolution_transpose_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *weight = info__[2].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array padding_array__ = info__[3].As<Napi::Array>();
  int padding_len = padding_array__.Length();
  int64_t *padding_data = new int64_t[padding_len];
  for (int i = 0; i < padding_len; ++i)
    padding_data[i] = padding_array__.Get(i).ToNumber().Int64Value();
  Napi::Array output_padding_array__ = info__[4].As<Napi::Array>();
  int output_padding_len = output_padding_array__.Length();
  int64_t *output_padding_data = new int64_t[output_padding_len];
  for (int i = 0; i < output_padding_len; ++i)
    output_padding_data[i] = output_padding_array__.Get(i).ToNumber().Int64Value();
  Napi::Array stride_array__ = info__[5].As<Napi::Array>();
  int stride_len = stride_array__.Length();
  int64_t *stride_data = new int64_t[stride_len];
  for (int i = 0; i < stride_len; ++i)
    stride_data[i] = stride_array__.Get(i).ToNumber().Int64Value();
  Napi::Array dilation_array__ = info__[6].As<Napi::Array>();
  int dilation_len = dilation_array__.Length();
  int64_t *dilation_data = new int64_t[dilation_len];
  for (int i = 0; i < dilation_len; ++i)
    dilation_data[i] = dilation_array__.Get(i).ToNumber().Int64Value();
  int64_t groups = info__[7].As<Napi::Number>().Int64Value();
  bool benchmark = info__[8].As<Napi::Boolean>().Value();
  bool deterministic = info__[9].As<Napi::Boolean>().Value();
  bool allow_tf32 = info__[10].As<Napi::Boolean>().Value();
  auto output__ = torch::cudnn_convolution_transpose_out(*out, *self, *weight, torch::IntArrayRef(padding_data, padding_len), torch::IntArrayRef(output_padding_data, output_padding_len), torch::IntArrayRef(stride_data, stride_len), torch::IntArrayRef(dilation_data, dilation_len), groups, benchmark, deterministic, allow_tf32);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__mps_convolution_transpose(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *weight = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array padding_array__ = info__[2].As<Napi::Array>();
  int padding_len = padding_array__.Length();
  int64_t *padding_data = new int64_t[padding_len];
  for (int i = 0; i < padding_len; ++i)
    padding_data[i] = padding_array__.Get(i).ToNumber().Int64Value();
  Napi::Array output_padding_array__ = info__[3].As<Napi::Array>();
  int output_padding_len = output_padding_array__.Length();
  int64_t *output_padding_data = new int64_t[output_padding_len];
  for (int i = 0; i < output_padding_len; ++i)
    output_padding_data[i] = output_padding_array__.Get(i).ToNumber().Int64Value();
  Napi::Array stride_array__ = info__[4].As<Napi::Array>();
  int stride_len = stride_array__.Length();
  int64_t *stride_data = new int64_t[stride_len];
  for (int i = 0; i < stride_len; ++i)
    stride_data[i] = stride_array__.Get(i).ToNumber().Int64Value();
  Napi::Array dilation_array__ = info__[5].As<Napi::Array>();
  int dilation_len = dilation_array__.Length();
  int64_t *dilation_data = new int64_t[dilation_len];
  for (int i = 0; i < dilation_len; ++i)
    dilation_data[i] = dilation_array__.Get(i).ToNumber().Int64Value();
  int64_t groups = info__[6].As<Napi::Number>().Int64Value();
  auto output__ = torch::_mps_convolution_transpose(*self, *weight, torch::IntArrayRef(padding_data, padding_len), torch::IntArrayRef(output_padding_data, output_padding_len), torch::IntArrayRef(stride_data, stride_len), torch::IntArrayRef(dilation_data, dilation_len), groups);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__mps_convolution_transpose_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *weight = info__[2].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array padding_array__ = info__[3].As<Napi::Array>();
  int padding_len = padding_array__.Length();
  int64_t *padding_data = new int64_t[padding_len];
  for (int i = 0; i < padding_len; ++i)
    padding_data[i] = padding_array__.Get(i).ToNumber().Int64Value();
  Napi::Array output_padding_array__ = info__[4].As<Napi::Array>();
  int output_padding_len = output_padding_array__.Length();
  int64_t *output_padding_data = new int64_t[output_padding_len];
  for (int i = 0; i < output_padding_len; ++i)
    output_padding_data[i] = output_padding_array__.Get(i).ToNumber().Int64Value();
  Napi::Array stride_array__ = info__[5].As<Napi::Array>();
  int stride_len = stride_array__.Length();
  int64_t *stride_data = new int64_t[stride_len];
  for (int i = 0; i < stride_len; ++i)
    stride_data[i] = stride_array__.Get(i).ToNumber().Int64Value();
  Napi::Array dilation_array__ = info__[6].As<Napi::Array>();
  int dilation_len = dilation_array__.Length();
  int64_t *dilation_data = new int64_t[dilation_len];
  for (int i = 0; i < dilation_len; ++i)
    dilation_data[i] = dilation_array__.Get(i).ToNumber().Int64Value();
  int64_t groups = info__[7].As<Napi::Number>().Int64Value();
  auto output__ = torch::_mps_convolution_transpose_out(*out, *self, *weight, torch::IntArrayRef(padding_data, padding_len), torch::IntArrayRef(output_padding_data, output_padding_len), torch::IntArrayRef(stride_data, stride_len), torch::IntArrayRef(dilation_data, dilation_len), groups);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_cudnn_convolution_relu(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *weight = info__[1].As<Napi::External<torch::Tensor>>().Data();
  bool bias_null = info__[2].IsUndefined();
  torch::Tensor *bias_v = bias_null ? nullptr : info__[2].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array stride_array__ = info__[3].As<Napi::Array>();
  int stride_len = stride_array__.Length();
  int64_t *stride_data = new int64_t[stride_len];
  for (int i = 0; i < stride_len; ++i)
    stride_data[i] = stride_array__.Get(i).ToNumber().Int64Value();
  Napi::Array padding_array__ = info__[4].As<Napi::Array>();
  int padding_len = padding_array__.Length();
  int64_t *padding_data = new int64_t[padding_len];
  for (int i = 0; i < padding_len; ++i)
    padding_data[i] = padding_array__.Get(i).ToNumber().Int64Value();
  Napi::Array dilation_array__ = info__[5].As<Napi::Array>();
  int dilation_len = dilation_array__.Length();
  int64_t *dilation_data = new int64_t[dilation_len];
  for (int i = 0; i < dilation_len; ++i)
    dilation_data[i] = dilation_array__.Get(i).ToNumber().Int64Value();
  int64_t groups = info__[6].As<Napi::Number>().Int64Value();
  auto output__ = torch::cudnn_convolution_relu(*self, *weight, (bias_null ? *bias_v : torch::Tensor()), torch::IntArrayRef(stride_data, stride_len), torch::IntArrayRef(padding_data, padding_len), torch::IntArrayRef(dilation_data, dilation_len), groups);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_cudnn_convolution_relu_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *weight = info__[2].As<Napi::External<torch::Tensor>>().Data();
  bool bias_null = info__[3].IsUndefined();
  torch::Tensor *bias_v = bias_null ? nullptr : info__[3].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array stride_array__ = info__[4].As<Napi::Array>();
  int stride_len = stride_array__.Length();
  int64_t *stride_data = new int64_t[stride_len];
  for (int i = 0; i < stride_len; ++i)
    stride_data[i] = stride_array__.Get(i).ToNumber().Int64Value();
  Napi::Array padding_array__ = info__[5].As<Napi::Array>();
  int padding_len = padding_array__.Length();
  int64_t *padding_data = new int64_t[padding_len];
  for (int i = 0; i < padding_len; ++i)
    padding_data[i] = padding_array__.Get(i).ToNumber().Int64Value();
  Napi::Array dilation_array__ = info__[6].As<Napi::Array>();
  int dilation_len = dilation_array__.Length();
  int64_t *dilation_data = new int64_t[dilation_len];
  for (int i = 0; i < dilation_len; ++i)
    dilation_data[i] = dilation_array__.Get(i).ToNumber().Int64Value();
  int64_t groups = info__[7].As<Napi::Number>().Int64Value();
  auto output__ = torch::cudnn_convolution_relu_out(*out, *self, *weight, (bias_null ? *bias_v : torch::Tensor()), torch::IntArrayRef(stride_data, stride_len), torch::IntArrayRef(padding_data, padding_len), torch::IntArrayRef(dilation_data, dilation_len), groups);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_cudnn_convolution_add_relu(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *weight = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *z = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *alpha = info__[3].As<Napi::External<torch::Scalar>>().Data();
  bool bias_null = info__[4].IsUndefined();
  torch::Tensor *bias_v = bias_null ? nullptr : info__[4].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array stride_array__ = info__[5].As<Napi::Array>();
  int stride_len = stride_array__.Length();
  int64_t *stride_data = new int64_t[stride_len];
  for (int i = 0; i < stride_len; ++i)
    stride_data[i] = stride_array__.Get(i).ToNumber().Int64Value();
  Napi::Array padding_array__ = info__[6].As<Napi::Array>();
  int padding_len = padding_array__.Length();
  int64_t *padding_data = new int64_t[padding_len];
  for (int i = 0; i < padding_len; ++i)
    padding_data[i] = padding_array__.Get(i).ToNumber().Int64Value();
  Napi::Array dilation_array__ = info__[7].As<Napi::Array>();
  int dilation_len = dilation_array__.Length();
  int64_t *dilation_data = new int64_t[dilation_len];
  for (int i = 0; i < dilation_len; ++i)
    dilation_data[i] = dilation_array__.Get(i).ToNumber().Int64Value();
  int64_t groups = info__[8].As<Napi::Number>().Int64Value();
  auto output__ = torch::cudnn_convolution_add_relu(*self, *weight, *z, *alpha, (bias_null ? *bias_v : torch::Tensor()), torch::IntArrayRef(stride_data, stride_len), torch::IntArrayRef(padding_data, padding_len), torch::IntArrayRef(dilation_data, dilation_len), groups);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_cudnn_convolution_add_relu_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *weight = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *z = info__[3].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *alpha = info__[4].As<Napi::External<torch::Scalar>>().Data();
  bool bias_null = info__[5].IsUndefined();
  torch::Tensor *bias_v = bias_null ? nullptr : info__[5].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array stride_array__ = info__[6].As<Napi::Array>();
  int stride_len = stride_array__.Length();
  int64_t *stride_data = new int64_t[stride_len];
  for (int i = 0; i < stride_len; ++i)
    stride_data[i] = stride_array__.Get(i).ToNumber().Int64Value();
  Napi::Array padding_array__ = info__[7].As<Napi::Array>();
  int padding_len = padding_array__.Length();
  int64_t *padding_data = new int64_t[padding_len];
  for (int i = 0; i < padding_len; ++i)
    padding_data[i] = padding_array__.Get(i).ToNumber().Int64Value();
  Napi::Array dilation_array__ = info__[8].As<Napi::Array>();
  int dilation_len = dilation_array__.Length();
  int64_t *dilation_data = new int64_t[dilation_len];
  for (int i = 0; i < dilation_len; ++i)
    dilation_data[i] = dilation_array__.Get(i).ToNumber().Int64Value();
  int64_t groups = info__[9].As<Napi::Number>().Int64Value();
  auto output__ = torch::cudnn_convolution_add_relu_out(*out, *self, *weight, *z, *alpha, (bias_null ? *bias_v : torch::Tensor()), torch::IntArrayRef(stride_data, stride_len), torch::IntArrayRef(padding_data, padding_len), torch::IntArrayRef(dilation_data, dilation_len), groups);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_cudnn_grid_sampler(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *grid = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::cudnn_grid_sampler(*self, *grid);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_cudnn_grid_sampler_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *grid = info__[2].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::cudnn_grid_sampler_out(*out, *self, *grid);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::Array atg_cudnn_grid_sampler_backward(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *grid = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *grad_output = info__[2].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::cudnn_grid_sampler_backward(*self, *grid, *grad_output);
  Napi::Array output__array__ = Napi::Array::New(env__, 2);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  return output__array__;
}

Napi::Array atg_cudnn_grid_sampler_backward_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out0 = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *out1 = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *grid = info__[3].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *grad_output = info__[4].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::cudnn_grid_sampler_backward_out(*out0, *out1, *self, *grid, *grad_output);
  Napi::Array output__array__ = Napi::Array::New(env__, 2);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  return output__array__;
}

Napi::Array atg_cummax(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t dim = info__[1].As<Napi::Number>().Int64Value();
  auto output__ = torch::cummax(*self, dim);
  Napi::Array output__array__ = Napi::Array::New(env__, 2);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  return output__array__;
}

Napi::Array atg_cummax_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *values = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *indices = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[2].As<Napi::External<torch::Tensor>>().Data();
  int64_t dim = info__[3].As<Napi::Number>().Int64Value();
  auto output__ = torch::cummax_out(*values, *indices, *self, dim);
  Napi::Array output__array__ = Napi::Array::New(env__, 2);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  return output__array__;
}

Napi::Array atg_cummin(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t dim = info__[1].As<Napi::Number>().Int64Value();
  auto output__ = torch::cummin(*self, dim);
  Napi::Array output__array__ = Napi::Array::New(env__, 2);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  return output__array__;
}

Napi::Array atg_cummin_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *values = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *indices = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[2].As<Napi::External<torch::Tensor>>().Data();
  int64_t dim = info__[3].As<Napi::Number>().Int64Value();
  auto output__ = torch::cummin_out(*values, *indices, *self, dim);
  Napi::Array output__array__ = Napi::Array::New(env__, 2);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  return output__array__;
}

Napi::External<torch::Tensor> atg_cummaxmin_backward(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *grad = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *input = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *indices = info__[2].As<Napi::External<torch::Tensor>>().Data();
  int64_t dim = info__[3].As<Napi::Number>().Int64Value();
  auto output__ = torch::cummaxmin_backward(*grad, *input, *indices, dim);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_cumprod(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t dim = info__[1].As<Napi::Number>().Int64Value();
  int dtype = info__[2].As<Napi::Number>().Int32Value();
  auto output__ = torch::cumprod(*self, dim, at::ScalarType(dtype));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_cumprod_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  int64_t dim = info__[2].As<Napi::Number>().Int64Value();
  int dtype = info__[3].As<Napi::Number>().Int32Value();
  auto output__ = torch::cumprod_out(*out, *self, dim, at::ScalarType(dtype));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_cumprod_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t dim = info__[1].As<Napi::Number>().Int64Value();
  int dtype = info__[2].As<Napi::Number>().Int32Value();
  auto output__ = self->cumprod_(dim, at::ScalarType(dtype));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_cumprod_backward(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *grad = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *input = info__[1].As<Napi::External<torch::Tensor>>().Data();
  int64_t dim = info__[2].As<Napi::Number>().Int64Value();
  torch::Tensor *output = info__[3].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::cumprod_backward(*grad, *input, dim, *output);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_cumsum(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t dim = info__[1].As<Napi::Number>().Int64Value();
  int dtype = info__[2].As<Napi::Number>().Int32Value();
  auto output__ = torch::cumsum(*self, dim, at::ScalarType(dtype));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_cumsum_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  int64_t dim = info__[2].As<Napi::Number>().Int64Value();
  int dtype = info__[3].As<Napi::Number>().Int32Value();
  auto output__ = torch::cumsum_out(*out, *self, dim, at::ScalarType(dtype));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_cumsum_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t dim = info__[1].As<Napi::Number>().Int64Value();
  int dtype = info__[2].As<Napi::Number>().Int32Value();
  auto output__ = self->cumsum_(dim, at::ScalarType(dtype));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_cumulative_trapezoid(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *y = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *x = info__[1].As<Napi::External<torch::Tensor>>().Data();
  int64_t dim = info__[2].As<Napi::Number>().Int64Value();
  auto output__ = torch::cumulative_trapezoid(*y, *x, dim);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_cumulative_trapezoid_dx(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *y = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *dx = info__[1].As<Napi::External<torch::Scalar>>().Data();
  int64_t dim = info__[2].As<Napi::Number>().Int64Value();
  auto output__ = torch::cumulative_trapezoid(*y, *dx, dim);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_ctc_loss(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *log_probs = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *targets = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array input_lengths_array__ = info__[2].As<Napi::Array>();
  int input_lengths_len = input_lengths_array__.Length();
  int64_t *input_lengths_data = new int64_t[input_lengths_len];
  for (int i = 0; i < input_lengths_len; ++i)
    input_lengths_data[i] = input_lengths_array__.Get(i).ToNumber().Int64Value();
  Napi::Array target_lengths_array__ = info__[3].As<Napi::Array>();
  int target_lengths_len = target_lengths_array__.Length();
  int64_t *target_lengths_data = new int64_t[target_lengths_len];
  for (int i = 0; i < target_lengths_len; ++i)
    target_lengths_data[i] = target_lengths_array__.Get(i).ToNumber().Int64Value();
  int64_t blank = info__[4].As<Napi::Number>().Int64Value();
  int64_t reduction = info__[5].As<Napi::Number>().Int64Value();
  bool zero_infinity = info__[6].As<Napi::Boolean>().Value();
  auto output__ = torch::ctc_loss(*log_probs, *targets, torch::IntArrayRef(input_lengths_data, input_lengths_len), torch::IntArrayRef(target_lengths_data, target_lengths_len), blank, reduction, zero_infinity);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_ctc_loss_tensor(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *log_probs = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *targets = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *input_lengths = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *target_lengths = info__[3].As<Napi::External<torch::Tensor>>().Data();
  int64_t blank = info__[4].As<Napi::Number>().Int64Value();
  int64_t reduction = info__[5].As<Napi::Number>().Int64Value();
  bool zero_infinity = info__[6].As<Napi::Boolean>().Value();
  auto output__ = torch::ctc_loss(*log_probs, *targets, *input_lengths, *target_lengths, blank, reduction, zero_infinity);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::Array atg__ctc_loss(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *log_probs = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *targets = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array input_lengths_array__ = info__[2].As<Napi::Array>();
  int input_lengths_len = input_lengths_array__.Length();
  int64_t *input_lengths_data = new int64_t[input_lengths_len];
  for (int i = 0; i < input_lengths_len; ++i)
    input_lengths_data[i] = input_lengths_array__.Get(i).ToNumber().Int64Value();
  Napi::Array target_lengths_array__ = info__[3].As<Napi::Array>();
  int target_lengths_len = target_lengths_array__.Length();
  int64_t *target_lengths_data = new int64_t[target_lengths_len];
  for (int i = 0; i < target_lengths_len; ++i)
    target_lengths_data[i] = target_lengths_array__.Get(i).ToNumber().Int64Value();
  int64_t blank = info__[4].As<Napi::Number>().Int64Value();
  bool zero_infinity = info__[5].As<Napi::Boolean>().Value();
  auto output__ = torch::_ctc_loss(*log_probs, *targets, torch::IntArrayRef(input_lengths_data, input_lengths_len), torch::IntArrayRef(target_lengths_data, target_lengths_len), blank, zero_infinity);
  Napi::Array output__array__ = Napi::Array::New(env__, 2);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  return output__array__;
}

Napi::Array atg__ctc_loss_tensor(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *log_probs = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *targets = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *input_lengths = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *target_lengths = info__[3].As<Napi::External<torch::Tensor>>().Data();
  int64_t blank = info__[4].As<Napi::Number>().Int64Value();
  bool zero_infinity = info__[5].As<Napi::Boolean>().Value();
  auto output__ = torch::_ctc_loss(*log_probs, *targets, *input_lengths, *target_lengths, blank, zero_infinity);
  Napi::Array output__array__ = Napi::Array::New(env__, 2);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  return output__array__;
}

Napi::Array atg__ctc_loss_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out0 = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *out1 = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *log_probs = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *targets = info__[3].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array input_lengths_array__ = info__[4].As<Napi::Array>();
  int input_lengths_len = input_lengths_array__.Length();
  int64_t *input_lengths_data = new int64_t[input_lengths_len];
  for (int i = 0; i < input_lengths_len; ++i)
    input_lengths_data[i] = input_lengths_array__.Get(i).ToNumber().Int64Value();
  Napi::Array target_lengths_array__ = info__[5].As<Napi::Array>();
  int target_lengths_len = target_lengths_array__.Length();
  int64_t *target_lengths_data = new int64_t[target_lengths_len];
  for (int i = 0; i < target_lengths_len; ++i)
    target_lengths_data[i] = target_lengths_array__.Get(i).ToNumber().Int64Value();
  int64_t blank = info__[6].As<Napi::Number>().Int64Value();
  bool zero_infinity = info__[7].As<Napi::Boolean>().Value();
  auto output__ = torch::_ctc_loss_out(*out0, *out1, *log_probs, *targets, torch::IntArrayRef(input_lengths_data, input_lengths_len), torch::IntArrayRef(target_lengths_data, target_lengths_len), blank, zero_infinity);
  Napi::Array output__array__ = Napi::Array::New(env__, 2);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  return output__array__;
}

Napi::Array atg__ctc_loss_tensor_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out0 = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *out1 = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *log_probs = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *targets = info__[3].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *input_lengths = info__[4].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *target_lengths = info__[5].As<Napi::External<torch::Tensor>>().Data();
  int64_t blank = info__[6].As<Napi::Number>().Int64Value();
  bool zero_infinity = info__[7].As<Napi::Boolean>().Value();
  auto output__ = torch::_ctc_loss_out(*out0, *out1, *log_probs, *targets, *input_lengths, *target_lengths, blank, zero_infinity);
  Napi::Array output__array__ = Napi::Array::New(env__, 2);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  return output__array__;
}

Napi::External<torch::Tensor> atg__ctc_loss_backward(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *grad = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *log_probs = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *targets = info__[2].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array input_lengths_array__ = info__[3].As<Napi::Array>();
  int input_lengths_len = input_lengths_array__.Length();
  int64_t *input_lengths_data = new int64_t[input_lengths_len];
  for (int i = 0; i < input_lengths_len; ++i)
    input_lengths_data[i] = input_lengths_array__.Get(i).ToNumber().Int64Value();
  Napi::Array target_lengths_array__ = info__[4].As<Napi::Array>();
  int target_lengths_len = target_lengths_array__.Length();
  int64_t *target_lengths_data = new int64_t[target_lengths_len];
  for (int i = 0; i < target_lengths_len; ++i)
    target_lengths_data[i] = target_lengths_array__.Get(i).ToNumber().Int64Value();
  torch::Tensor *neg_log_likelihood = info__[5].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *log_alpha = info__[6].As<Napi::External<torch::Tensor>>().Data();
  int64_t blank = info__[7].As<Napi::Number>().Int64Value();
  bool zero_infinity = info__[8].As<Napi::Boolean>().Value();
  auto output__ = torch::_ctc_loss_backward(*grad, *log_probs, *targets, torch::IntArrayRef(input_lengths_data, input_lengths_len), torch::IntArrayRef(target_lengths_data, target_lengths_len), *neg_log_likelihood, *log_alpha, blank, zero_infinity);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__ctc_loss_backward_tensor(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *grad = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *log_probs = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *targets = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *input_lengths = info__[3].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *target_lengths = info__[4].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *neg_log_likelihood = info__[5].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *log_alpha = info__[6].As<Napi::External<torch::Tensor>>().Data();
  int64_t blank = info__[7].As<Napi::Number>().Int64Value();
  bool zero_infinity = info__[8].As<Napi::Boolean>().Value();
  auto output__ = torch::_ctc_loss_backward(*grad, *log_probs, *targets, *input_lengths, *target_lengths, *neg_log_likelihood, *log_alpha, blank, zero_infinity);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__ctc_loss_backward_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *grad = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *log_probs = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *targets = info__[3].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array input_lengths_array__ = info__[4].As<Napi::Array>();
  int input_lengths_len = input_lengths_array__.Length();
  int64_t *input_lengths_data = new int64_t[input_lengths_len];
  for (int i = 0; i < input_lengths_len; ++i)
    input_lengths_data[i] = input_lengths_array__.Get(i).ToNumber().Int64Value();
  Napi::Array target_lengths_array__ = info__[5].As<Napi::Array>();
  int target_lengths_len = target_lengths_array__.Length();
  int64_t *target_lengths_data = new int64_t[target_lengths_len];
  for (int i = 0; i < target_lengths_len; ++i)
    target_lengths_data[i] = target_lengths_array__.Get(i).ToNumber().Int64Value();
  torch::Tensor *neg_log_likelihood = info__[6].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *log_alpha = info__[7].As<Napi::External<torch::Tensor>>().Data();
  int64_t blank = info__[8].As<Napi::Number>().Int64Value();
  bool zero_infinity = info__[9].As<Napi::Boolean>().Value();
  auto output__ = torch::_ctc_loss_backward_out(*out, *grad, *log_probs, *targets, torch::IntArrayRef(input_lengths_data, input_lengths_len), torch::IntArrayRef(target_lengths_data, target_lengths_len), *neg_log_likelihood, *log_alpha, blank, zero_infinity);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_diag_embed(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t offset = info__[1].As<Napi::Number>().Int64Value();
  int64_t dim1 = info__[2].As<Napi::Number>().Int64Value();
  int64_t dim2 = info__[3].As<Napi::Number>().Int64Value();
  auto output__ = torch::diag_embed(*self, offset, dim1, dim2);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_diag_embed_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  int64_t offset = info__[2].As<Napi::Number>().Int64Value();
  int64_t dim1 = info__[3].As<Napi::Number>().Int64Value();
  int64_t dim2 = info__[4].As<Napi::Number>().Int64Value();
  auto output__ = torch::diag_embed_out(*out, *self, offset, dim1, dim2);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_diagflat(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t offset = info__[1].As<Napi::Number>().Int64Value();
  auto output__ = torch::diagflat(*self, offset);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_diagonal(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t offset = info__[1].As<Napi::Number>().Int64Value();
  int64_t dim1 = info__[2].As<Napi::Number>().Int64Value();
  int64_t dim2 = info__[3].As<Napi::Number>().Int64Value();
  auto output__ = torch::diagonal(*self, offset, dim1, dim2);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_linalg_diagonal(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *A = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t offset = info__[1].As<Napi::Number>().Int64Value();
  int64_t dim1 = info__[2].As<Napi::Number>().Int64Value();
  int64_t dim2 = info__[3].As<Napi::Number>().Int64Value();
  auto output__ = torch::linalg_diagonal(*A, offset, dim1, dim2);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_diagonal_backward(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *grad_output = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array input_sizes_array__ = info__[1].As<Napi::Array>();
  int input_sizes_len = input_sizes_array__.Length();
  int64_t *input_sizes_data = new int64_t[input_sizes_len];
  for (int i = 0; i < input_sizes_len; ++i)
    input_sizes_data[i] = input_sizes_array__.Get(i).ToNumber().Int64Value();
  int64_t offset = info__[2].As<Napi::Number>().Int64Value();
  int64_t dim1 = info__[3].As<Napi::Number>().Int64Value();
  int64_t dim2 = info__[4].As<Napi::Number>().Int64Value();
  auto output__ = torch::diagonal_backward(*grad_output, torch::IntArrayRef(input_sizes_data, input_sizes_len), offset, dim1, dim2);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_diagonal_backward_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *grad_output = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array input_sizes_array__ = info__[2].As<Napi::Array>();
  int input_sizes_len = input_sizes_array__.Length();
  int64_t *input_sizes_data = new int64_t[input_sizes_len];
  for (int i = 0; i < input_sizes_len; ++i)
    input_sizes_data[i] = input_sizes_array__.Get(i).ToNumber().Int64Value();
  int64_t offset = info__[3].As<Napi::Number>().Int64Value();
  int64_t dim1 = info__[4].As<Napi::Number>().Int64Value();
  int64_t dim2 = info__[5].As<Napi::Number>().Int64Value();
  auto output__ = torch::diagonal_backward_out(*out, *grad_output, torch::IntArrayRef(input_sizes_data, input_sizes_len), offset, dim1, dim2);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_fill_diagonal_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *fill_value = info__[1].As<Napi::External<torch::Scalar>>().Data();
  bool wrap = info__[2].As<Napi::Boolean>().Value();
  auto output__ = self->fill_diagonal_(*fill_value, wrap);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_diff(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t n = info__[1].As<Napi::Number>().Int64Value();
  int64_t dim = info__[2].As<Napi::Number>().Int64Value();
  bool prepend_null = info__[3].IsUndefined();
  torch::Tensor *prepend_v = prepend_null ? nullptr : info__[3].As<Napi::External<torch::Tensor>>().Data();
  bool append_null = info__[4].IsUndefined();
  torch::Tensor *append_v = append_null ? nullptr : info__[4].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::diff(*self, n, dim, (prepend_null ? *prepend_v : torch::Tensor()), (append_null ? *append_v : torch::Tensor()));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_diff_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  int64_t n = info__[2].As<Napi::Number>().Int64Value();
  int64_t dim = info__[3].As<Napi::Number>().Int64Value();
  bool prepend_null = info__[4].IsUndefined();
  torch::Tensor *prepend_v = prepend_null ? nullptr : info__[4].As<Napi::External<torch::Tensor>>().Data();
  bool append_null = info__[5].IsUndefined();
  torch::Tensor *append_v = append_null ? nullptr : info__[5].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::diff_out(*out, *self, n, dim, (prepend_null ? *prepend_v : torch::Tensor()), (append_null ? *append_v : torch::Tensor()));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_div(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::div(*self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_div_scalar(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *other = info__[1].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::div(*self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_div_tensor_mode(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::String rounding_mode_str__ = info__[2].As<Napi::String>();
  std::string rounding_mode = rounding_mode_str__.Utf8Value();
  auto output__ = torch::div(*self, *other, rounding_mode);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_div_scalar_mode(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *other = info__[1].As<Napi::External<torch::Scalar>>().Data();
  Napi::String rounding_mode_str__ = info__[2].As<Napi::String>();
  std::string rounding_mode = rounding_mode_str__.Utf8Value();
  auto output__ = torch::div(*self, *other, rounding_mode);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_div_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[2].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::div_out(*out, *self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_div_scalar_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *other = info__[2].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::div_out(*out, *self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_div_out_mode(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[2].As<Napi::External<torch::Tensor>>().Data();
  Napi::String rounding_mode_str__ = info__[3].As<Napi::String>();
  std::string rounding_mode = rounding_mode_str__.Utf8Value();
  auto output__ = torch::div_out(*out, *self, *other, rounding_mode);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_div_scalar_mode_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *other = info__[2].As<Napi::External<torch::Scalar>>().Data();
  Napi::String rounding_mode_str__ = info__[3].As<Napi::String>();
  std::string rounding_mode = rounding_mode_str__.Utf8Value();
  auto output__ = torch::div_out(*out, *self, *other, rounding_mode);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_div_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = self->div_(*other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_div_scalar_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *other = info__[1].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = self->div_(*other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_div_tensor_mode_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::String rounding_mode_str__ = info__[2].As<Napi::String>();
  std::string rounding_mode = rounding_mode_str__.Utf8Value();
  auto output__ = self->div_(*other, rounding_mode);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_div_scalar_mode_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *other = info__[1].As<Napi::External<torch::Scalar>>().Data();
  Napi::String rounding_mode_str__ = info__[2].As<Napi::String>();
  std::string rounding_mode = rounding_mode_str__.Utf8Value();
  auto output__ = self->div_(*other, rounding_mode);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_divide(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::divide(*self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_divide_scalar(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *other = info__[1].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::divide(*self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_divide_tensor_mode(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::String rounding_mode_str__ = info__[2].As<Napi::String>();
  std::string rounding_mode = rounding_mode_str__.Utf8Value();
  auto output__ = torch::divide(*self, *other, rounding_mode);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_divide_scalar_mode(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *other = info__[1].As<Napi::External<torch::Scalar>>().Data();
  Napi::String rounding_mode_str__ = info__[2].As<Napi::String>();
  std::string rounding_mode = rounding_mode_str__.Utf8Value();
  auto output__ = torch::divide(*self, *other, rounding_mode);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_divide_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[2].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::divide_out(*out, *self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_divide_out_mode(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[2].As<Napi::External<torch::Tensor>>().Data();
  Napi::String rounding_mode_str__ = info__[3].As<Napi::String>();
  std::string rounding_mode = rounding_mode_str__.Utf8Value();
  auto output__ = torch::divide_out(*out, *self, *other, rounding_mode);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_divide_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = self->divide_(*other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_divide_scalar_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *other = info__[1].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = self->divide_(*other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_divide_tensor_mode_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::String rounding_mode_str__ = info__[2].As<Napi::String>();
  std::string rounding_mode = rounding_mode_str__.Utf8Value();
  auto output__ = self->divide_(*other, rounding_mode);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_divide_scalar_mode_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *other = info__[1].As<Napi::External<torch::Scalar>>().Data();
  Napi::String rounding_mode_str__ = info__[2].As<Napi::String>();
  std::string rounding_mode = rounding_mode_str__.Utf8Value();
  auto output__ = self->divide_(*other, rounding_mode);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_true_divide(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::true_divide(*self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_true_divide_scalar(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *other = info__[1].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::true_divide(*self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_true_divide_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[2].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::true_divide_out(*out, *self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_true_divide_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = self->true_divide_(*other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_true_divide_scalar_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *other = info__[1].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = self->true_divide_(*other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_dot(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *tensor = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::dot(*self, *tensor);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_dot_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *tensor = info__[2].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::dot_out(*out, *self, *tensor);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_vdot(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::vdot(*self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_vdot_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[2].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::vdot_out(*out, *self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_einsum(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  Napi::String equation_str__ = info__[0].As<Napi::String>();
  std::string equation = equation_str__.Utf8Value();
  Napi::Array tensors_array__ = info__[1].As<Napi::Array>();
  int tensors_len = tensors_array__.Length();
  torch::Tensor **tensors_data = new torch::Tensor *[tensors_len];
  for (int i = 0; i < tensors_len; ++i)
    tensors_data[i] = tensors_array__.Get(i).As<Napi::External<torch::Tensor>>().Data();
  Napi::Array path_array__ = info__[2].As<Napi::Array>();
  int path_len = path_array__.Length();
  int64_t *path_data = new int64_t[path_len];
  for (int i = 0; i < path_len; ++i)
    path_data[i] = path_array__.Get(i).ToNumber().Int64Value();
  auto output__ = torch::einsum(equation, of_carray_tensor(tensors_data, tensors_len), path_data == nullptr ? c10::nullopt : c10::optional<torch::IntArrayRef>(torch::IntArrayRef(path_data, path_len)));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_embedding(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *weight = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *indices = info__[1].As<Napi::External<torch::Tensor>>().Data();
  int64_t padding_idx = info__[2].As<Napi::Number>().Int64Value();
  bool scale_grad_by_freq = info__[3].As<Napi::Boolean>().Value();
  bool sparse = info__[4].As<Napi::Boolean>().Value();
  auto output__ = torch::embedding(*weight, *indices, padding_idx, scale_grad_by_freq, sparse);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_embedding_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *weight = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *indices = info__[2].As<Napi::External<torch::Tensor>>().Data();
  int64_t padding_idx = info__[3].As<Napi::Number>().Int64Value();
  bool scale_grad_by_freq = info__[4].As<Napi::Boolean>().Value();
  bool sparse = info__[5].As<Napi::Boolean>().Value();
  auto output__ = torch::embedding_out(*out, *weight, *indices, padding_idx, scale_grad_by_freq, sparse);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_embedding_backward(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *grad = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *indices = info__[1].As<Napi::External<torch::Tensor>>().Data();
  int64_t num_weights = info__[2].As<Napi::Number>().Int64Value();
  int64_t padding_idx = info__[3].As<Napi::Number>().Int64Value();
  bool scale_grad_by_freq = info__[4].As<Napi::Boolean>().Value();
  bool sparse = info__[5].As<Napi::Boolean>().Value();
  auto output__ = torch::embedding_backward(*grad, *indices, num_weights, padding_idx, scale_grad_by_freq, sparse);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_embedding_dense_backward(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *grad_output = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *indices = info__[1].As<Napi::External<torch::Tensor>>().Data();
  int64_t num_weights = info__[2].As<Napi::Number>().Int64Value();
  int64_t padding_idx = info__[3].As<Napi::Number>().Int64Value();
  bool scale_grad_by_freq = info__[4].As<Napi::Boolean>().Value();
  auto output__ = torch::embedding_dense_backward(*grad_output, *indices, num_weights, padding_idx, scale_grad_by_freq);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_embedding_dense_backward_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *grad_output = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *indices = info__[2].As<Napi::External<torch::Tensor>>().Data();
  int64_t num_weights = info__[3].As<Napi::Number>().Int64Value();
  int64_t padding_idx = info__[4].As<Napi::Number>().Int64Value();
  bool scale_grad_by_freq = info__[5].As<Napi::Boolean>().Value();
  auto output__ = torch::embedding_dense_backward_out(*out, *grad_output, *indices, num_weights, padding_idx, scale_grad_by_freq);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_embedding_renorm_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *indices = info__[1].As<Napi::External<torch::Tensor>>().Data();
  double max_norm = info__[2].As<Napi::Number>().DoubleValue();
  double norm_type = info__[3].As<Napi::Number>().DoubleValue();
  auto output__ = torch::embedding_renorm_(*self, *indices, max_norm, norm_type);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_embedding_sparse_backward(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *grad = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *indices = info__[1].As<Napi::External<torch::Tensor>>().Data();
  int64_t num_weights = info__[2].As<Napi::Number>().Int64Value();
  int64_t padding_idx = info__[3].As<Napi::Number>().Int64Value();
  bool scale_grad_by_freq = info__[4].As<Napi::Boolean>().Value();
  auto output__ = torch::embedding_sparse_backward(*grad, *indices, num_weights, padding_idx, scale_grad_by_freq);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::Array atg__embedding_bag_forward_only(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *weight = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *indices = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *offsets = info__[2].As<Napi::External<torch::Tensor>>().Data();
  bool scale_grad_by_freq = info__[3].As<Napi::Boolean>().Value();
  int64_t mode = info__[4].As<Napi::Number>().Int64Value();
  bool sparse = info__[5].As<Napi::Boolean>().Value();
  bool per_sample_weights_null = info__[6].IsUndefined();
  torch::Tensor *per_sample_weights_v = per_sample_weights_null ? nullptr : info__[6].As<Napi::External<torch::Tensor>>().Data();
  bool include_last_offset = info__[7].As<Napi::Boolean>().Value();
  int64_t padding_idx = info__[8].As<Napi::Number>().Int64Value();
  auto output__ = torch::_embedding_bag_forward_only(*weight, *indices, *offsets, scale_grad_by_freq, mode, sparse, (per_sample_weights_null ? *per_sample_weights_v : torch::Tensor()), include_last_offset, padding_idx);
  Napi::Array output__array__ = Napi::Array::New(env__, 4);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  output__array__[2u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<2>(output__)));
  output__array__[3u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<3>(output__)));
  return output__array__;
}

Napi::Array atg__embedding_bag_forward_only_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out0 = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *out1 = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *out2 = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *out3 = info__[3].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *weight = info__[4].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *indices = info__[5].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *offsets = info__[6].As<Napi::External<torch::Tensor>>().Data();
  bool scale_grad_by_freq = info__[7].As<Napi::Boolean>().Value();
  int64_t mode = info__[8].As<Napi::Number>().Int64Value();
  bool sparse = info__[9].As<Napi::Boolean>().Value();
  bool per_sample_weights_null = info__[10].IsUndefined();
  torch::Tensor *per_sample_weights_v = per_sample_weights_null ? nullptr : info__[10].As<Napi::External<torch::Tensor>>().Data();
  bool include_last_offset = info__[11].As<Napi::Boolean>().Value();
  int64_t padding_idx = info__[12].As<Napi::Number>().Int64Value();
  auto output__ = torch::_embedding_bag_forward_only_out(*out0, *out1, *out2, *out3, *weight, *indices, *offsets, scale_grad_by_freq, mode, sparse, (per_sample_weights_null ? *per_sample_weights_v : torch::Tensor()), include_last_offset, padding_idx);
  Napi::Array output__array__ = Napi::Array::New(env__, 4);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  output__array__[2u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<2>(output__)));
  output__array__[3u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<3>(output__)));
  return output__array__;
}

Napi::Array atg__rowwise_prune(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *weight = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *mask = info__[1].As<Napi::External<torch::Tensor>>().Data();
  int compressed_indices_dtype = info__[2].As<Napi::Number>().Int32Value();
  auto output__ = torch::_rowwise_prune(*weight, *mask, at::ScalarType(compressed_indices_dtype));
  Napi::Array output__array__ = Napi::Array::New(env__, 2);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  return output__array__;
}

Napi::External<torch::Tensor> atg_row_stack(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  Napi::Array tensors_array__ = info__[0].As<Napi::Array>();
  int tensors_len = tensors_array__.Length();
  torch::Tensor **tensors_data = new torch::Tensor *[tensors_len];
  for (int i = 0; i < tensors_len; ++i)
    tensors_data[i] = tensors_array__.Get(i).As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::row_stack(of_carray_tensor(tensors_data, tensors_len));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_row_stack_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array tensors_array__ = info__[1].As<Napi::Array>();
  int tensors_len = tensors_array__.Length();
  torch::Tensor **tensors_data = new torch::Tensor *[tensors_len];
  for (int i = 0; i < tensors_len; ++i)
    tensors_data[i] = tensors_array__.Get(i).As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::row_stack_out(*out, of_carray_tensor(tensors_data, tensors_len));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::Array atg_embedding_bag(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *weight = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *indices = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *offsets = info__[2].As<Napi::External<torch::Tensor>>().Data();
  bool scale_grad_by_freq = info__[3].As<Napi::Boolean>().Value();
  int64_t mode = info__[4].As<Napi::Number>().Int64Value();
  bool sparse = info__[5].As<Napi::Boolean>().Value();
  bool per_sample_weights_null = info__[6].IsUndefined();
  torch::Tensor *per_sample_weights_v = per_sample_weights_null ? nullptr : info__[6].As<Napi::External<torch::Tensor>>().Data();
  bool include_last_offset = info__[7].As<Napi::Boolean>().Value();
  auto output__ = torch::embedding_bag(*weight, *indices, *offsets, scale_grad_by_freq, mode, sparse, (per_sample_weights_null ? *per_sample_weights_v : torch::Tensor()), include_last_offset);
  Napi::Array output__array__ = Napi::Array::New(env__, 4);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  output__array__[2u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<2>(output__)));
  output__array__[3u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<3>(output__)));
  return output__array__;
}

Napi::Array atg_embedding_bag_padding_idx(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *weight = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *indices = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *offsets = info__[2].As<Napi::External<torch::Tensor>>().Data();
  bool scale_grad_by_freq = info__[3].As<Napi::Boolean>().Value();
  int64_t mode = info__[4].As<Napi::Number>().Int64Value();
  bool sparse = info__[5].As<Napi::Boolean>().Value();
  bool per_sample_weights_null = info__[6].IsUndefined();
  torch::Tensor *per_sample_weights_v = per_sample_weights_null ? nullptr : info__[6].As<Napi::External<torch::Tensor>>().Data();
  bool include_last_offset = info__[7].As<Napi::Boolean>().Value();
  bool padding_idx_null = info__[8].IsUndefined();
  int64_t padding_idx_v = padding_idx_null ? 0 : info__[8].As<Napi::Number>().Int64Value();
  auto output__ = torch::embedding_bag(*weight, *indices, *offsets, scale_grad_by_freq, mode, sparse, (per_sample_weights_null ? *per_sample_weights_v : torch::Tensor()), include_last_offset, padding_idx_null ? c10::nullopt : c10::optional<int64_t>(padding_idx_v));
  Napi::Array output__array__ = Napi::Array::New(env__, 4);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  output__array__[2u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<2>(output__)));
  output__array__[3u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<3>(output__)));
  return output__array__;
}

Napi::Array atg__embedding_bag(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *weight = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *indices = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *offsets = info__[2].As<Napi::External<torch::Tensor>>().Data();
  bool scale_grad_by_freq = info__[3].As<Napi::Boolean>().Value();
  int64_t mode = info__[4].As<Napi::Number>().Int64Value();
  bool sparse = info__[5].As<Napi::Boolean>().Value();
  bool per_sample_weights_null = info__[6].IsUndefined();
  torch::Tensor *per_sample_weights_v = per_sample_weights_null ? nullptr : info__[6].As<Napi::External<torch::Tensor>>().Data();
  bool include_last_offset = info__[7].As<Napi::Boolean>().Value();
  int64_t padding_idx = info__[8].As<Napi::Number>().Int64Value();
  auto output__ = torch::_embedding_bag(*weight, *indices, *offsets, scale_grad_by_freq, mode, sparse, (per_sample_weights_null ? *per_sample_weights_v : torch::Tensor()), include_last_offset, padding_idx);
  Napi::Array output__array__ = Napi::Array::New(env__, 4);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  output__array__[2u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<2>(output__)));
  output__array__[3u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<3>(output__)));
  return output__array__;
}

Napi::Array atg__embedding_bag_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out0 = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *out1 = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *out2 = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *out3 = info__[3].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *weight = info__[4].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *indices = info__[5].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *offsets = info__[6].As<Napi::External<torch::Tensor>>().Data();
  bool scale_grad_by_freq = info__[7].As<Napi::Boolean>().Value();
  int64_t mode = info__[8].As<Napi::Number>().Int64Value();
  bool sparse = info__[9].As<Napi::Boolean>().Value();
  bool per_sample_weights_null = info__[10].IsUndefined();
  torch::Tensor *per_sample_weights_v = per_sample_weights_null ? nullptr : info__[10].As<Napi::External<torch::Tensor>>().Data();
  bool include_last_offset = info__[11].As<Napi::Boolean>().Value();
  int64_t padding_idx = info__[12].As<Napi::Number>().Int64Value();
  auto output__ = torch::_embedding_bag_out(*out0, *out1, *out2, *out3, *weight, *indices, *offsets, scale_grad_by_freq, mode, sparse, (per_sample_weights_null ? *per_sample_weights_v : torch::Tensor()), include_last_offset, padding_idx);
  Napi::Array output__array__ = Napi::Array::New(env__, 4);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  output__array__[2u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<2>(output__)));
  output__array__[3u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<3>(output__)));
  return output__array__;
}

Napi::External<torch::Tensor> atg__embedding_bag_backward(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *grad = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *indices = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *offsets = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *offset2bag = info__[3].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *bag_size = info__[4].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *maximum_indices = info__[5].As<Napi::External<torch::Tensor>>().Data();
  int64_t num_weights = info__[6].As<Napi::Number>().Int64Value();
  bool scale_grad_by_freq = info__[7].As<Napi::Boolean>().Value();
  int64_t mode = info__[8].As<Napi::Number>().Int64Value();
  bool sparse = info__[9].As<Napi::Boolean>().Value();
  bool per_sample_weights_null = info__[10].IsUndefined();
  torch::Tensor *per_sample_weights_v = per_sample_weights_null ? nullptr : info__[10].As<Napi::External<torch::Tensor>>().Data();
  int64_t padding_idx = info__[11].As<Napi::Number>().Int64Value();
  auto output__ = torch::_embedding_bag_backward(*grad, *indices, *offsets, *offset2bag, *bag_size, *maximum_indices, num_weights, scale_grad_by_freq, mode, sparse, (per_sample_weights_null ? *per_sample_weights_v : torch::Tensor()), padding_idx);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__embedding_bag_sparse_backward(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *grad = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *indices = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *offsets = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *offset2bag = info__[3].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *bag_size = info__[4].As<Napi::External<torch::Tensor>>().Data();
  int64_t num_weights = info__[5].As<Napi::Number>().Int64Value();
  bool scale_grad_by_freq = info__[6].As<Napi::Boolean>().Value();
  int64_t mode = info__[7].As<Napi::Number>().Int64Value();
  bool per_sample_weights_null = info__[8].IsUndefined();
  torch::Tensor *per_sample_weights_v = per_sample_weights_null ? nullptr : info__[8].As<Napi::External<torch::Tensor>>().Data();
  int64_t padding_idx = info__[9].As<Napi::Number>().Int64Value();
  auto output__ = torch::_embedding_bag_sparse_backward(*grad, *indices, *offsets, *offset2bag, *bag_size, num_weights, scale_grad_by_freq, mode, (per_sample_weights_null ? *per_sample_weights_v : torch::Tensor()), padding_idx);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__embedding_bag_dense_backward(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *grad = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *indices = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *offset2bag = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *bag_size = info__[3].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *maximum_indices = info__[4].As<Napi::External<torch::Tensor>>().Data();
  int64_t num_weights = info__[5].As<Napi::Number>().Int64Value();
  bool scale_grad_by_freq = info__[6].As<Napi::Boolean>().Value();
  int64_t mode = info__[7].As<Napi::Number>().Int64Value();
  bool per_sample_weights_null = info__[8].IsUndefined();
  torch::Tensor *per_sample_weights_v = per_sample_weights_null ? nullptr : info__[8].As<Napi::External<torch::Tensor>>().Data();
  int64_t padding_idx = info__[9].As<Napi::Number>().Int64Value();
  auto output__ = torch::_embedding_bag_dense_backward(*grad, *indices, *offset2bag, *bag_size, *maximum_indices, num_weights, scale_grad_by_freq, mode, (per_sample_weights_null ? *per_sample_weights_v : torch::Tensor()), padding_idx);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__embedding_bag_dense_backward_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *grad = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *indices = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *offset2bag = info__[3].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *bag_size = info__[4].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *maximum_indices = info__[5].As<Napi::External<torch::Tensor>>().Data();
  int64_t num_weights = info__[6].As<Napi::Number>().Int64Value();
  bool scale_grad_by_freq = info__[7].As<Napi::Boolean>().Value();
  int64_t mode = info__[8].As<Napi::Number>().Int64Value();
  bool per_sample_weights_null = info__[9].IsUndefined();
  torch::Tensor *per_sample_weights_v = per_sample_weights_null ? nullptr : info__[9].As<Napi::External<torch::Tensor>>().Data();
  int64_t padding_idx = info__[10].As<Napi::Number>().Int64Value();
  auto output__ = torch::_embedding_bag_dense_backward_out(*out, *grad, *indices, *offset2bag, *bag_size, *maximum_indices, num_weights, scale_grad_by_freq, mode, (per_sample_weights_null ? *per_sample_weights_v : torch::Tensor()), padding_idx);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__embedding_bag_per_sample_weights_backward(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *grad = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *weight = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *indices = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *offsets = info__[3].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *offset2bag = info__[4].As<Napi::External<torch::Tensor>>().Data();
  int64_t mode = info__[5].As<Napi::Number>().Int64Value();
  int64_t padding_idx = info__[6].As<Napi::Number>().Int64Value();
  auto output__ = torch::_embedding_bag_per_sample_weights_backward(*grad, *weight, *indices, *offsets, *offset2bag, mode, padding_idx);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__embedding_bag_per_sample_weights_backward_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *grad = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *weight = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *indices = info__[3].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *offsets = info__[4].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *offset2bag = info__[5].As<Napi::External<torch::Tensor>>().Data();
  int64_t mode = info__[6].As<Napi::Number>().Int64Value();
  int64_t padding_idx = info__[7].As<Napi::Number>().Int64Value();
  auto output__ = torch::_embedding_bag_per_sample_weights_backward_out(*out, *grad, *weight, *indices, *offsets, *offset2bag, mode, padding_idx);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_empty(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  Napi::Array size_array__ = info__[0].As<Napi::Array>();
  int size_len = size_array__.Length();
  int64_t *size_data = new int64_t[size_len];
  for (int i = 0; i < size_len; ++i)
    size_data[i] = size_array__.Get(i).ToNumber().Int64Value();
  Napi::Object options_obj__ = info__[1].As<Napi::Object>();
  int options_device = options_obj__.Get("device").ToNumber().Int32Value();
  int options_kind = options_obj__.Get("dtype").ToNumber().Int32Value();
  int memory_format = info__[2].As<Napi::Number>().Int32Value();
  auto output__ = torch::empty(torch::IntArrayRef(size_data, size_len), at::device(device_of_int(options_device)).dtype(at::ScalarType(options_kind)), (at::MemoryFormat)memory_format);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_empty_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array size_array__ = info__[1].As<Napi::Array>();
  int size_len = size_array__.Length();
  int64_t *size_data = new int64_t[size_len];
  for (int i = 0; i < size_len; ++i)
    size_data[i] = size_array__.Get(i).ToNumber().Int64Value();
  int memory_format = info__[2].As<Napi::Number>().Int32Value();
  auto output__ = torch::empty_out(*out, torch::IntArrayRef(size_data, size_len), (at::MemoryFormat)memory_format);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_new_empty(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array size_array__ = info__[1].As<Napi::Array>();
  int size_len = size_array__.Length();
  int64_t *size_data = new int64_t[size_len];
  for (int i = 0; i < size_len; ++i)
    size_data[i] = size_array__.Get(i).ToNumber().Int64Value();
  Napi::Object options_obj__ = info__[2].As<Napi::Object>();
  int options_device = options_obj__.Get("device").ToNumber().Int32Value();
  int options_kind = options_obj__.Get("dtype").ToNumber().Int32Value();
  auto output__ = self->new_empty(torch::IntArrayRef(size_data, size_len), at::device(device_of_int(options_device)).dtype(at::ScalarType(options_kind)));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_new_empty_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array size_array__ = info__[2].As<Napi::Array>();
  int size_len = size_array__.Length();
  int64_t *size_data = new int64_t[size_len];
  for (int i = 0; i < size_len; ++i)
    size_data[i] = size_array__.Get(i).ToNumber().Int64Value();
  auto output__ = torch::new_empty_out(*out, *self, torch::IntArrayRef(size_data, size_len));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_new_empty_strided(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array size_array__ = info__[1].As<Napi::Array>();
  int size_len = size_array__.Length();
  int64_t *size_data = new int64_t[size_len];
  for (int i = 0; i < size_len; ++i)
    size_data[i] = size_array__.Get(i).ToNumber().Int64Value();
  Napi::Array stride_array__ = info__[2].As<Napi::Array>();
  int stride_len = stride_array__.Length();
  int64_t *stride_data = new int64_t[stride_len];
  for (int i = 0; i < stride_len; ++i)
    stride_data[i] = stride_array__.Get(i).ToNumber().Int64Value();
  Napi::Object options_obj__ = info__[3].As<Napi::Object>();
  int options_device = options_obj__.Get("device").ToNumber().Int32Value();
  int options_kind = options_obj__.Get("dtype").ToNumber().Int32Value();
  auto output__ = self->new_empty_strided(torch::IntArrayRef(size_data, size_len), torch::IntArrayRef(stride_data, stride_len), at::device(device_of_int(options_device)).dtype(at::ScalarType(options_kind)));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_new_empty_strided_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array size_array__ = info__[2].As<Napi::Array>();
  int size_len = size_array__.Length();
  int64_t *size_data = new int64_t[size_len];
  for (int i = 0; i < size_len; ++i)
    size_data[i] = size_array__.Get(i).ToNumber().Int64Value();
  Napi::Array stride_array__ = info__[3].As<Napi::Array>();
  int stride_len = stride_array__.Length();
  int64_t *stride_data = new int64_t[stride_len];
  for (int i = 0; i < stride_len; ++i)
    stride_data[i] = stride_array__.Get(i).ToNumber().Int64Value();
  auto output__ = torch::new_empty_strided_out(*out, *self, torch::IntArrayRef(size_data, size_len), torch::IntArrayRef(stride_data, stride_len));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_new_full(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array size_array__ = info__[1].As<Napi::Array>();
  int size_len = size_array__.Length();
  int64_t *size_data = new int64_t[size_len];
  for (int i = 0; i < size_len; ++i)
    size_data[i] = size_array__.Get(i).ToNumber().Int64Value();
  torch::Scalar *fill_value = info__[2].As<Napi::External<torch::Scalar>>().Data();
  Napi::Object options_obj__ = info__[3].As<Napi::Object>();
  int options_device = options_obj__.Get("device").ToNumber().Int32Value();
  int options_kind = options_obj__.Get("dtype").ToNumber().Int32Value();
  auto output__ = self->new_full(torch::IntArrayRef(size_data, size_len), *fill_value, at::device(device_of_int(options_device)).dtype(at::ScalarType(options_kind)));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_new_full_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array size_array__ = info__[2].As<Napi::Array>();
  int size_len = size_array__.Length();
  int64_t *size_data = new int64_t[size_len];
  for (int i = 0; i < size_len; ++i)
    size_data[i] = size_array__.Get(i).ToNumber().Int64Value();
  torch::Scalar *fill_value = info__[3].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::new_full_out(*out, *self, torch::IntArrayRef(size_data, size_len), *fill_value);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_new_zeros(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array size_array__ = info__[1].As<Napi::Array>();
  int size_len = size_array__.Length();
  int64_t *size_data = new int64_t[size_len];
  for (int i = 0; i < size_len; ++i)
    size_data[i] = size_array__.Get(i).ToNumber().Int64Value();
  Napi::Object options_obj__ = info__[2].As<Napi::Object>();
  int options_device = options_obj__.Get("device").ToNumber().Int32Value();
  int options_kind = options_obj__.Get("dtype").ToNumber().Int32Value();
  auto output__ = self->new_zeros(torch::IntArrayRef(size_data, size_len), at::device(device_of_int(options_device)).dtype(at::ScalarType(options_kind)));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_new_zeros_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array size_array__ = info__[2].As<Napi::Array>();
  int size_len = size_array__.Length();
  int64_t *size_data = new int64_t[size_len];
  for (int i = 0; i < size_len; ++i)
    size_data[i] = size_array__.Get(i).ToNumber().Int64Value();
  auto output__ = torch::new_zeros_out(*out, *self, torch::IntArrayRef(size_data, size_len));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_new_ones(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array size_array__ = info__[1].As<Napi::Array>();
  int size_len = size_array__.Length();
  int64_t *size_data = new int64_t[size_len];
  for (int i = 0; i < size_len; ++i)
    size_data[i] = size_array__.Get(i).ToNumber().Int64Value();
  Napi::Object options_obj__ = info__[2].As<Napi::Object>();
  int options_device = options_obj__.Get("device").ToNumber().Int32Value();
  int options_kind = options_obj__.Get("dtype").ToNumber().Int32Value();
  auto output__ = self->new_ones(torch::IntArrayRef(size_data, size_len), at::device(device_of_int(options_device)).dtype(at::ScalarType(options_kind)));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_new_ones_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array size_array__ = info__[2].As<Napi::Array>();
  int size_len = size_array__.Length();
  int64_t *size_data = new int64_t[size_len];
  for (int i = 0; i < size_len; ++i)
    size_data[i] = size_array__.Get(i).ToNumber().Int64Value();
  auto output__ = torch::new_ones_out(*out, *self, torch::IntArrayRef(size_data, size_len));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__empty_affine_quantized(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  Napi::Array size_array__ = info__[0].As<Napi::Array>();
  int size_len = size_array__.Length();
  int64_t *size_data = new int64_t[size_len];
  for (int i = 0; i < size_len; ++i)
    size_data[i] = size_array__.Get(i).ToNumber().Int64Value();
  Napi::Object options_obj__ = info__[1].As<Napi::Object>();
  int options_device = options_obj__.Get("device").ToNumber().Int32Value();
  int options_kind = options_obj__.Get("dtype").ToNumber().Int32Value();
  double scale = info__[2].As<Napi::Number>().DoubleValue();
  int64_t zero_point = info__[3].As<Napi::Number>().Int64Value();
  int memory_format = info__[4].As<Napi::Number>().Int32Value();
  auto output__ = torch::_empty_affine_quantized(torch::IntArrayRef(size_data, size_len), at::device(device_of_int(options_device)).dtype(at::ScalarType(options_kind)), scale, zero_point, (at::MemoryFormat)memory_format);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__empty_affine_quantized_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array size_array__ = info__[1].As<Napi::Array>();
  int size_len = size_array__.Length();
  int64_t *size_data = new int64_t[size_len];
  for (int i = 0; i < size_len; ++i)
    size_data[i] = size_array__.Get(i).ToNumber().Int64Value();
  double scale = info__[2].As<Napi::Number>().DoubleValue();
  int64_t zero_point = info__[3].As<Napi::Number>().Int64Value();
  int memory_format = info__[4].As<Napi::Number>().Int32Value();
  auto output__ = torch::_empty_affine_quantized_out(*out, torch::IntArrayRef(size_data, size_len), scale, zero_point, (at::MemoryFormat)memory_format);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__empty_per_channel_affine_quantized(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  Napi::Array size_array__ = info__[0].As<Napi::Array>();
  int size_len = size_array__.Length();
  int64_t *size_data = new int64_t[size_len];
  for (int i = 0; i < size_len; ++i)
    size_data[i] = size_array__.Get(i).ToNumber().Int64Value();
  torch::Tensor *scales = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *zero_points = info__[2].As<Napi::External<torch::Tensor>>().Data();
  int64_t axis = info__[3].As<Napi::Number>().Int64Value();
  Napi::Object options_obj__ = info__[4].As<Napi::Object>();
  int options_device = options_obj__.Get("device").ToNumber().Int32Value();
  int options_kind = options_obj__.Get("dtype").ToNumber().Int32Value();
  int memory_format = info__[5].As<Napi::Number>().Int32Value();
  auto output__ = torch::_empty_per_channel_affine_quantized(torch::IntArrayRef(size_data, size_len), *scales, *zero_points, axis, at::device(device_of_int(options_device)).dtype(at::ScalarType(options_kind)), (at::MemoryFormat)memory_format);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__empty_per_channel_affine_quantized_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array size_array__ = info__[1].As<Napi::Array>();
  int size_len = size_array__.Length();
  int64_t *size_data = new int64_t[size_len];
  for (int i = 0; i < size_len; ++i)
    size_data[i] = size_array__.Get(i).ToNumber().Int64Value();
  torch::Tensor *scales = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *zero_points = info__[3].As<Napi::External<torch::Tensor>>().Data();
  int64_t axis = info__[4].As<Napi::Number>().Int64Value();
  int memory_format = info__[5].As<Napi::Number>().Int32Value();
  auto output__ = torch::_empty_per_channel_affine_quantized_out(*out, torch::IntArrayRef(size_data, size_len), *scales, *zero_points, axis, (at::MemoryFormat)memory_format);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_resize_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array size_array__ = info__[1].As<Napi::Array>();
  int size_len = size_array__.Length();
  int64_t *size_data = new int64_t[size_len];
  for (int i = 0; i < size_len; ++i)
    size_data[i] = size_array__.Get(i).ToNumber().Int64Value();
  int memory_format = info__[2].As<Napi::Number>().Int32Value();
  auto output__ = self->resize_(torch::IntArrayRef(size_data, size_len), (at::MemoryFormat)memory_format);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__resize_output_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array size_array__ = info__[1].As<Napi::Array>();
  int size_len = size_array__.Length();
  int64_t *size_data = new int64_t[size_len];
  for (int i = 0; i < size_len; ++i)
    size_data[i] = size_array__.Get(i).ToNumber().Int64Value();
  int device = info__[2].As<Napi::Number>().Int32Value();
  auto output__ = torch::_resize_output_(*self, torch::IntArrayRef(size_data, size_len), device_of_int(device));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_empty_quantized(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  Napi::Array size_array__ = info__[0].As<Napi::Array>();
  int size_len = size_array__.Length();
  int64_t *size_data = new int64_t[size_len];
  for (int i = 0; i < size_len; ++i)
    size_data[i] = size_array__.Get(i).ToNumber().Int64Value();
  torch::Tensor *qtensor = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::Object options_obj__ = info__[2].As<Napi::Object>();
  int options_device = options_obj__.Get("device").ToNumber().Int32Value();
  int options_kind = options_obj__.Get("dtype").ToNumber().Int32Value();
  int memory_format = info__[3].As<Napi::Number>().Int32Value();
  auto output__ = torch::empty_quantized(torch::IntArrayRef(size_data, size_len), *qtensor, at::device(device_of_int(options_device)).dtype(at::ScalarType(options_kind)), (at::MemoryFormat)memory_format);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_empty_quantized_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array size_array__ = info__[1].As<Napi::Array>();
  int size_len = size_array__.Length();
  int64_t *size_data = new int64_t[size_len];
  for (int i = 0; i < size_len; ++i)
    size_data[i] = size_array__.Get(i).ToNumber().Int64Value();
  torch::Tensor *qtensor = info__[2].As<Napi::External<torch::Tensor>>().Data();
  int memory_format = info__[3].As<Napi::Number>().Int32Value();
  auto output__ = torch::empty_quantized_out(*out, torch::IntArrayRef(size_data, size_len), *qtensor, (at::MemoryFormat)memory_format);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_empty_like(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Object options_obj__ = info__[1].As<Napi::Object>();
  int options_device = options_obj__.Get("device").ToNumber().Int32Value();
  int options_kind = options_obj__.Get("dtype").ToNumber().Int32Value();
  int memory_format = info__[2].As<Napi::Number>().Int32Value();
  auto output__ = torch::empty_like(*self, at::device(device_of_int(options_device)).dtype(at::ScalarType(options_kind)), (at::MemoryFormat)memory_format);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_empty_like_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  int memory_format = info__[2].As<Napi::Number>().Int32Value();
  auto output__ = torch::empty_like_out(*out, *self, (at::MemoryFormat)memory_format);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_empty_strided(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  Napi::Array size_array__ = info__[0].As<Napi::Array>();
  int size_len = size_array__.Length();
  int64_t *size_data = new int64_t[size_len];
  for (int i = 0; i < size_len; ++i)
    size_data[i] = size_array__.Get(i).ToNumber().Int64Value();
  Napi::Array stride_array__ = info__[1].As<Napi::Array>();
  int stride_len = stride_array__.Length();
  int64_t *stride_data = new int64_t[stride_len];
  for (int i = 0; i < stride_len; ++i)
    stride_data[i] = stride_array__.Get(i).ToNumber().Int64Value();
  Napi::Object options_obj__ = info__[2].As<Napi::Object>();
  int options_device = options_obj__.Get("device").ToNumber().Int32Value();
  int options_kind = options_obj__.Get("dtype").ToNumber().Int32Value();
  auto output__ = torch::empty_strided(torch::IntArrayRef(size_data, size_len), torch::IntArrayRef(stride_data, stride_len), at::device(device_of_int(options_device)).dtype(at::ScalarType(options_kind)));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_empty_strided_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array size_array__ = info__[1].As<Napi::Array>();
  int size_len = size_array__.Length();
  int64_t *size_data = new int64_t[size_len];
  for (int i = 0; i < size_len; ++i)
    size_data[i] = size_array__.Get(i).ToNumber().Int64Value();
  Napi::Array stride_array__ = info__[2].As<Napi::Array>();
  int stride_len = stride_array__.Length();
  int64_t *stride_data = new int64_t[stride_len];
  for (int i = 0; i < stride_len; ++i)
    stride_data[i] = stride_array__.Get(i).ToNumber().Int64Value();
  auto output__ = torch::empty_strided_out(*out, torch::IntArrayRef(size_data, size_len), torch::IntArrayRef(stride_data, stride_len));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_erf(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::erf(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_erf_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::erf_out(*out, *self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_erf_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::erf_(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_erfc(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::erfc(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_erfc_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::erfc_out(*out, *self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_erfc_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::erfc_(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_exp(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::exp(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_exp_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::exp_out(*out, *self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_exp_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::exp_(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_exp2(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::exp2(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_exp2_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::exp2_out(*out, *self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_exp2_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::exp2_(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_expm1(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::expm1(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_expm1_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::expm1_out(*out, *self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_expm1_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::expm1_(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_expand(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array size_array__ = info__[1].As<Napi::Array>();
  int size_len = size_array__.Length();
  int64_t *size_data = new int64_t[size_len];
  for (int i = 0; i < size_len; ++i)
    size_data[i] = size_array__.Get(i).ToNumber().Int64Value();
  bool implicit = info__[2].As<Napi::Boolean>().Value();
  auto output__ = self->expand(torch::IntArrayRef(size_data, size_len), implicit);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_expand_as(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = self->expand_as(*other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_eye(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  int64_t n = info__[0].As<Napi::Number>().Int64Value();
  Napi::Object options_obj__ = info__[1].As<Napi::Object>();
  int options_device = options_obj__.Get("device").ToNumber().Int32Value();
  int options_kind = options_obj__.Get("dtype").ToNumber().Int32Value();
  auto output__ = torch::eye(n, at::device(device_of_int(options_device)).dtype(at::ScalarType(options_kind)));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_eye_m(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  int64_t n = info__[0].As<Napi::Number>().Int64Value();
  int64_t m = info__[1].As<Napi::Number>().Int64Value();
  Napi::Object options_obj__ = info__[2].As<Napi::Object>();
  int options_device = options_obj__.Get("device").ToNumber().Int32Value();
  int options_kind = options_obj__.Get("dtype").ToNumber().Int32Value();
  auto output__ = torch::eye(n, m, at::device(device_of_int(options_device)).dtype(at::ScalarType(options_kind)));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_eye_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t n = info__[1].As<Napi::Number>().Int64Value();
  auto output__ = torch::eye_out(*out, n);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_eye_m_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t n = info__[1].As<Napi::Number>().Int64Value();
  int64_t m = info__[2].As<Napi::Number>().Int64Value();
  auto output__ = torch::eye_out(*out, n, m);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_flatten(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t start_dim = info__[1].As<Napi::Number>().Int64Value();
  int64_t end_dim = info__[2].As<Napi::Number>().Int64Value();
  auto output__ = torch::flatten(*self, start_dim, end_dim);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_unflatten(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t dim = info__[1].As<Napi::Number>().Int64Value();
  Napi::Array sizes_array__ = info__[2].As<Napi::Array>();
  int sizes_len = sizes_array__.Length();
  int64_t *sizes_data = new int64_t[sizes_len];
  for (int i = 0; i < sizes_len; ++i)
    sizes_data[i] = sizes_array__.Get(i).ToNumber().Int64Value();
  auto output__ = torch::unflatten(*self, dim, torch::IntArrayRef(sizes_data, sizes_len));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_fill(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *value = info__[1].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::fill(*self, *value);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_fill_tensor(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *value = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::fill(*self, *value);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_fill_scalar_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *value = info__[2].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::fill_out(*out, *self, *value);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_fill_tensor_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *value = info__[2].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::fill_out(*out, *self, *value);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_fill_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *value = info__[1].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::fill_(*self, *value);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_fill_tensor_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *value = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::fill_(*self, *value);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_floor(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::floor(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_floor_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::floor_out(*out, *self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_floor_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::floor_(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_floor_divide(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::floor_divide(*self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_floor_divide_scalar(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *other = info__[1].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::floor_divide(*self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_floor_divide_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[2].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::floor_divide_out(*out, *self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_floor_divide_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = self->floor_divide_(*other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_floor_divide_scalar_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *other = info__[1].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = self->floor_divide_(*other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_frac(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::frac(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_frac_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::frac_out(*out, *self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_frac_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::frac_(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_full(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  Napi::Array size_array__ = info__[0].As<Napi::Array>();
  int size_len = size_array__.Length();
  int64_t *size_data = new int64_t[size_len];
  for (int i = 0; i < size_len; ++i)
    size_data[i] = size_array__.Get(i).ToNumber().Int64Value();
  torch::Scalar *fill_value = info__[1].As<Napi::External<torch::Scalar>>().Data();
  Napi::Object options_obj__ = info__[2].As<Napi::Object>();
  int options_device = options_obj__.Get("device").ToNumber().Int32Value();
  int options_kind = options_obj__.Get("dtype").ToNumber().Int32Value();
  auto output__ = torch::full(torch::IntArrayRef(size_data, size_len), *fill_value, at::device(device_of_int(options_device)).dtype(at::ScalarType(options_kind)));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_full_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array size_array__ = info__[1].As<Napi::Array>();
  int size_len = size_array__.Length();
  int64_t *size_data = new int64_t[size_len];
  for (int i = 0; i < size_len; ++i)
    size_data[i] = size_array__.Get(i).ToNumber().Int64Value();
  torch::Scalar *fill_value = info__[2].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::full_out(*out, torch::IntArrayRef(size_data, size_len), *fill_value);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_full_like(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *fill_value = info__[1].As<Napi::External<torch::Scalar>>().Data();
  Napi::Object options_obj__ = info__[2].As<Napi::Object>();
  int options_device = options_obj__.Get("device").ToNumber().Int32Value();
  int options_kind = options_obj__.Get("dtype").ToNumber().Int32Value();
  int memory_format = info__[3].As<Napi::Number>().Int32Value();
  auto output__ = torch::full_like(*self, *fill_value, at::device(device_of_int(options_device)).dtype(at::ScalarType(options_kind)), (at::MemoryFormat)memory_format);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_full_like_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *fill_value = info__[2].As<Napi::External<torch::Scalar>>().Data();
  int memory_format = info__[3].As<Napi::Number>().Int32Value();
  auto output__ = torch::full_like_out(*out, *self, *fill_value, (at::MemoryFormat)memory_format);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_from_file(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  Napi::String filename_str__ = info__[0].As<Napi::String>();
  std::string filename = filename_str__.Utf8Value();
  bool shared = info__[1].As<Napi::Boolean>().Value();
  bool size_null = info__[2].IsUndefined();
  int64_t size_v = size_null ? 0 : info__[2].As<Napi::Number>().Int64Value();
  Napi::Object options_obj__ = info__[3].As<Napi::Object>();
  int options_device = options_obj__.Get("device").ToNumber().Int32Value();
  int options_kind = options_obj__.Get("dtype").ToNumber().Int32Value();
  auto output__ = torch::from_file(filename, shared, size_null ? c10::nullopt : c10::optional<int64_t>(size_v), at::device(device_of_int(options_device)).dtype(at::ScalarType(options_kind)));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_from_file_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::String filename_str__ = info__[1].As<Napi::String>();
  std::string filename = filename_str__.Utf8Value();
  bool shared = info__[2].As<Napi::Boolean>().Value();
  bool size_null = info__[3].IsUndefined();
  int64_t size_v = size_null ? 0 : info__[3].As<Napi::Number>().Int64Value();
  auto output__ = torch::from_file_out(*out, filename, shared, size_null ? c10::nullopt : c10::optional<int64_t>(size_v));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_gcd(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::gcd(*self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_gcd_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[2].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::gcd_out(*out, *self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_gcd_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::gcd_(*self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_lcm(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::lcm(*self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_lcm_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[2].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::lcm_out(*out, *self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_lcm_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::lcm_(*self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_grid_sampler(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *input = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *grid = info__[1].As<Napi::External<torch::Tensor>>().Data();
  int64_t interpolation_mode = info__[2].As<Napi::Number>().Int64Value();
  int64_t padding_mode = info__[3].As<Napi::Number>().Int64Value();
  bool align_corners = info__[4].As<Napi::Boolean>().Value();
  auto output__ = torch::grid_sampler(*input, *grid, interpolation_mode, padding_mode, align_corners);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_grid_sampler_2d(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *input = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *grid = info__[1].As<Napi::External<torch::Tensor>>().Data();
  int64_t interpolation_mode = info__[2].As<Napi::Number>().Int64Value();
  int64_t padding_mode = info__[3].As<Napi::Number>().Int64Value();
  bool align_corners = info__[4].As<Napi::Boolean>().Value();
  auto output__ = torch::grid_sampler_2d(*input, *grid, interpolation_mode, padding_mode, align_corners);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_grid_sampler_2d_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *input = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *grid = info__[2].As<Napi::External<torch::Tensor>>().Data();
  int64_t interpolation_mode = info__[3].As<Napi::Number>().Int64Value();
  int64_t padding_mode = info__[4].As<Napi::Number>().Int64Value();
  bool align_corners = info__[5].As<Napi::Boolean>().Value();
  auto output__ = torch::grid_sampler_2d_out(*out, *input, *grid, interpolation_mode, padding_mode, align_corners);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__grid_sampler_2d_cpu_fallback(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *input = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *grid = info__[1].As<Napi::External<torch::Tensor>>().Data();
  int64_t interpolation_mode = info__[2].As<Napi::Number>().Int64Value();
  int64_t padding_mode = info__[3].As<Napi::Number>().Int64Value();
  bool align_corners = info__[4].As<Napi::Boolean>().Value();
  auto output__ = torch::_grid_sampler_2d_cpu_fallback(*input, *grid, interpolation_mode, padding_mode, align_corners);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__grid_sampler_2d_cpu_fallback_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *input = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *grid = info__[2].As<Napi::External<torch::Tensor>>().Data();
  int64_t interpolation_mode = info__[3].As<Napi::Number>().Int64Value();
  int64_t padding_mode = info__[4].As<Napi::Number>().Int64Value();
  bool align_corners = info__[5].As<Napi::Boolean>().Value();
  auto output__ = torch::_grid_sampler_2d_cpu_fallback_out(*out, *input, *grid, interpolation_mode, padding_mode, align_corners);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::Array atg__grid_sampler_2d_cpu_fallback_backward(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *grad_output = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *input = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *grid = info__[2].As<Napi::External<torch::Tensor>>().Data();
  int64_t interpolation_mode = info__[3].As<Napi::Number>().Int64Value();
  int64_t padding_mode = info__[4].As<Napi::Number>().Int64Value();
  bool align_corners = info__[5].As<Napi::Boolean>().Value();
  auto output__ = torch::_grid_sampler_2d_cpu_fallback_backward(*grad_output, *input, *grid, interpolation_mode, padding_mode, align_corners);
  Napi::Array output__array__ = Napi::Array::New(env__, 2);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  return output__array__;
}

Napi::External<torch::Tensor> atg_grid_sampler_3d(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *input = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *grid = info__[1].As<Napi::External<torch::Tensor>>().Data();
  int64_t interpolation_mode = info__[2].As<Napi::Number>().Int64Value();
  int64_t padding_mode = info__[3].As<Napi::Number>().Int64Value();
  bool align_corners = info__[4].As<Napi::Boolean>().Value();
  auto output__ = torch::grid_sampler_3d(*input, *grid, interpolation_mode, padding_mode, align_corners);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_grid_sampler_3d_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *input = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *grid = info__[2].As<Napi::External<torch::Tensor>>().Data();
  int64_t interpolation_mode = info__[3].As<Napi::Number>().Int64Value();
  int64_t padding_mode = info__[4].As<Napi::Number>().Int64Value();
  bool align_corners = info__[5].As<Napi::Boolean>().Value();
  auto output__ = torch::grid_sampler_3d_out(*out, *input, *grid, interpolation_mode, padding_mode, align_corners);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_hann_window(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  int64_t window_length = info__[0].As<Napi::Number>().Int64Value();
  Napi::Object options_obj__ = info__[1].As<Napi::Object>();
  int options_device = options_obj__.Get("device").ToNumber().Int32Value();
  int options_kind = options_obj__.Get("dtype").ToNumber().Int32Value();
  auto output__ = torch::hann_window(window_length, at::device(device_of_int(options_device)).dtype(at::ScalarType(options_kind)));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_hann_window_periodic(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  int64_t window_length = info__[0].As<Napi::Number>().Int64Value();
  bool periodic = info__[1].As<Napi::Boolean>().Value();
  Napi::Object options_obj__ = info__[2].As<Napi::Object>();
  int options_device = options_obj__.Get("device").ToNumber().Int32Value();
  int options_kind = options_obj__.Get("dtype").ToNumber().Int32Value();
  auto output__ = torch::hann_window(window_length, periodic, at::device(device_of_int(options_device)).dtype(at::ScalarType(options_kind)));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_hann_window_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t window_length = info__[1].As<Napi::Number>().Int64Value();
  auto output__ = torch::hann_window_out(*out, window_length);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_hann_window_periodic_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t window_length = info__[1].As<Napi::Number>().Int64Value();
  bool periodic = info__[2].As<Napi::Boolean>().Value();
  auto output__ = torch::hann_window_out(*out, window_length, periodic);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_hamming_window(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  int64_t window_length = info__[0].As<Napi::Number>().Int64Value();
  Napi::Object options_obj__ = info__[1].As<Napi::Object>();
  int options_device = options_obj__.Get("device").ToNumber().Int32Value();
  int options_kind = options_obj__.Get("dtype").ToNumber().Int32Value();
  auto output__ = torch::hamming_window(window_length, at::device(device_of_int(options_device)).dtype(at::ScalarType(options_kind)));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_hamming_window_periodic(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  int64_t window_length = info__[0].As<Napi::Number>().Int64Value();
  bool periodic = info__[1].As<Napi::Boolean>().Value();
  Napi::Object options_obj__ = info__[2].As<Napi::Object>();
  int options_device = options_obj__.Get("device").ToNumber().Int32Value();
  int options_kind = options_obj__.Get("dtype").ToNumber().Int32Value();
  auto output__ = torch::hamming_window(window_length, periodic, at::device(device_of_int(options_device)).dtype(at::ScalarType(options_kind)));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_hamming_window_periodic_alpha(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  int64_t window_length = info__[0].As<Napi::Number>().Int64Value();
  bool periodic = info__[1].As<Napi::Boolean>().Value();
  double alpha = info__[2].As<Napi::Number>().DoubleValue();
  Napi::Object options_obj__ = info__[3].As<Napi::Object>();
  int options_device = options_obj__.Get("device").ToNumber().Int32Value();
  int options_kind = options_obj__.Get("dtype").ToNumber().Int32Value();
  auto output__ = torch::hamming_window(window_length, periodic, alpha, at::device(device_of_int(options_device)).dtype(at::ScalarType(options_kind)));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_hamming_window_periodic_alpha_beta(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  int64_t window_length = info__[0].As<Napi::Number>().Int64Value();
  bool periodic = info__[1].As<Napi::Boolean>().Value();
  double alpha = info__[2].As<Napi::Number>().DoubleValue();
  double beta = info__[3].As<Napi::Number>().DoubleValue();
  Napi::Object options_obj__ = info__[4].As<Napi::Object>();
  int options_device = options_obj__.Get("device").ToNumber().Int32Value();
  int options_kind = options_obj__.Get("dtype").ToNumber().Int32Value();
  auto output__ = torch::hamming_window(window_length, periodic, alpha, beta, at::device(device_of_int(options_device)).dtype(at::ScalarType(options_kind)));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_hamming_window_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t window_length = info__[1].As<Napi::Number>().Int64Value();
  auto output__ = torch::hamming_window_out(*out, window_length);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_hamming_window_periodic_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t window_length = info__[1].As<Napi::Number>().Int64Value();
  bool periodic = info__[2].As<Napi::Boolean>().Value();
  auto output__ = torch::hamming_window_out(*out, window_length, periodic);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_hamming_window_periodic_alpha_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t window_length = info__[1].As<Napi::Number>().Int64Value();
  bool periodic = info__[2].As<Napi::Boolean>().Value();
  double alpha = info__[3].As<Napi::Number>().DoubleValue();
  auto output__ = torch::hamming_window_out(*out, window_length, periodic, alpha);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_hamming_window_periodic_alpha_beta_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t window_length = info__[1].As<Napi::Number>().Int64Value();
  bool periodic = info__[2].As<Napi::Boolean>().Value();
  double alpha = info__[3].As<Napi::Number>().DoubleValue();
  double beta = info__[4].As<Napi::Number>().DoubleValue();
  auto output__ = torch::hamming_window_out(*out, window_length, periodic, alpha, beta);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_kaiser_window(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  int64_t window_length = info__[0].As<Napi::Number>().Int64Value();
  Napi::Object options_obj__ = info__[1].As<Napi::Object>();
  int options_device = options_obj__.Get("device").ToNumber().Int32Value();
  int options_kind = options_obj__.Get("dtype").ToNumber().Int32Value();
  auto output__ = torch::kaiser_window(window_length, at::device(device_of_int(options_device)).dtype(at::ScalarType(options_kind)));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_kaiser_window_periodic(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  int64_t window_length = info__[0].As<Napi::Number>().Int64Value();
  bool periodic = info__[1].As<Napi::Boolean>().Value();
  Napi::Object options_obj__ = info__[2].As<Napi::Object>();
  int options_device = options_obj__.Get("device").ToNumber().Int32Value();
  int options_kind = options_obj__.Get("dtype").ToNumber().Int32Value();
  auto output__ = torch::kaiser_window(window_length, periodic, at::device(device_of_int(options_device)).dtype(at::ScalarType(options_kind)));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_kaiser_window_beta(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  int64_t window_length = info__[0].As<Napi::Number>().Int64Value();
  bool periodic = info__[1].As<Napi::Boolean>().Value();
  double beta = info__[2].As<Napi::Number>().DoubleValue();
  Napi::Object options_obj__ = info__[3].As<Napi::Object>();
  int options_device = options_obj__.Get("device").ToNumber().Int32Value();
  int options_kind = options_obj__.Get("dtype").ToNumber().Int32Value();
  auto output__ = torch::kaiser_window(window_length, periodic, beta, at::device(device_of_int(options_device)).dtype(at::ScalarType(options_kind)));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_kaiser_window_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t window_length = info__[1].As<Napi::Number>().Int64Value();
  auto output__ = torch::kaiser_window_out(*out, window_length);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_kaiser_window_periodic_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t window_length = info__[1].As<Napi::Number>().Int64Value();
  bool periodic = info__[2].As<Napi::Boolean>().Value();
  auto output__ = torch::kaiser_window_out(*out, window_length, periodic);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_kaiser_window_beta_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t window_length = info__[1].As<Napi::Number>().Int64Value();
  bool periodic = info__[2].As<Napi::Boolean>().Value();
  double beta = info__[3].As<Napi::Number>().DoubleValue();
  auto output__ = torch::kaiser_window_out(*out, window_length, periodic, beta);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_hinge_embedding_loss(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *target = info__[1].As<Napi::External<torch::Tensor>>().Data();
  double margin = info__[2].As<Napi::Number>().DoubleValue();
  int64_t reduction = info__[3].As<Napi::Number>().Int64Value();
  auto output__ = torch::hinge_embedding_loss(*self, *target, margin, reduction);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_group_norm(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *input = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t num_groups = info__[1].As<Napi::Number>().Int64Value();
  bool weight_null = info__[2].IsUndefined();
  torch::Tensor *weight_v = weight_null ? nullptr : info__[2].As<Napi::External<torch::Tensor>>().Data();
  bool bias_null = info__[3].IsUndefined();
  torch::Tensor *bias_v = bias_null ? nullptr : info__[3].As<Napi::External<torch::Tensor>>().Data();
  double eps = info__[4].As<Napi::Number>().DoubleValue();
  bool cudnn_enabled = info__[5].As<Napi::Boolean>().Value();
  auto output__ = torch::group_norm(*input, num_groups, (weight_null ? *weight_v : torch::Tensor()), (bias_null ? *bias_v : torch::Tensor()), eps, cudnn_enabled);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::Array atg_native_group_norm(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *input = info__[0].As<Napi::External<torch::Tensor>>().Data();
  bool weight_null = info__[1].IsUndefined();
  torch::Tensor *weight_v = weight_null ? nullptr : info__[1].As<Napi::External<torch::Tensor>>().Data();
  bool bias_null = info__[2].IsUndefined();
  torch::Tensor *bias_v = bias_null ? nullptr : info__[2].As<Napi::External<torch::Tensor>>().Data();
  int64_t N = info__[3].As<Napi::Number>().Int64Value();
  int64_t C = info__[4].As<Napi::Number>().Int64Value();
  int64_t HxW = info__[5].As<Napi::Number>().Int64Value();
  int64_t group = info__[6].As<Napi::Number>().Int64Value();
  double eps = info__[7].As<Napi::Number>().DoubleValue();
  auto output__ = torch::native_group_norm(*input, (weight_null ? *weight_v : torch::Tensor()), (bias_null ? *bias_v : torch::Tensor()), N, C, HxW, group, eps);
  Napi::Array output__array__ = Napi::Array::New(env__, 3);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  output__array__[2u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<2>(output__)));
  return output__array__;
}

Napi::Array atg_native_group_norm_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out0 = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *out1 = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *out2 = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *input = info__[3].As<Napi::External<torch::Tensor>>().Data();
  bool weight_null = info__[4].IsUndefined();
  torch::Tensor *weight_v = weight_null ? nullptr : info__[4].As<Napi::External<torch::Tensor>>().Data();
  bool bias_null = info__[5].IsUndefined();
  torch::Tensor *bias_v = bias_null ? nullptr : info__[5].As<Napi::External<torch::Tensor>>().Data();
  int64_t N = info__[6].As<Napi::Number>().Int64Value();
  int64_t C = info__[7].As<Napi::Number>().Int64Value();
  int64_t HxW = info__[8].As<Napi::Number>().Int64Value();
  int64_t group = info__[9].As<Napi::Number>().Int64Value();
  double eps = info__[10].As<Napi::Number>().DoubleValue();
  auto output__ = torch::native_group_norm_out(*out0, *out1, *out2, *input, (weight_null ? *weight_v : torch::Tensor()), (bias_null ? *bias_v : torch::Tensor()), N, C, HxW, group, eps);
  Napi::Array output__array__ = Napi::Array::New(env__, 3);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  output__array__[2u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<2>(output__)));
  return output__array__;
}

Napi::External<torch::Tensor> atg__fft_r2c(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array dim_array__ = info__[1].As<Napi::Array>();
  int dim_len = dim_array__.Length();
  int64_t *dim_data = new int64_t[dim_len];
  for (int i = 0; i < dim_len; ++i)
    dim_data[i] = dim_array__.Get(i).ToNumber().Int64Value();
  int64_t normalization = info__[2].As<Napi::Number>().Int64Value();
  bool onesided = info__[3].As<Napi::Boolean>().Value();
  auto output__ = torch::_fft_r2c(*self, torch::IntArrayRef(dim_data, dim_len), normalization, onesided);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__fft_r2c_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array dim_array__ = info__[2].As<Napi::Array>();
  int dim_len = dim_array__.Length();
  int64_t *dim_data = new int64_t[dim_len];
  for (int i = 0; i < dim_len; ++i)
    dim_data[i] = dim_array__.Get(i).ToNumber().Int64Value();
  int64_t normalization = info__[3].As<Napi::Number>().Int64Value();
  bool onesided = info__[4].As<Napi::Boolean>().Value();
  auto output__ = torch::_fft_r2c_out(*out, *self, torch::IntArrayRef(dim_data, dim_len), normalization, onesided);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__fft_c2r(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array dim_array__ = info__[1].As<Napi::Array>();
  int dim_len = dim_array__.Length();
  int64_t *dim_data = new int64_t[dim_len];
  for (int i = 0; i < dim_len; ++i)
    dim_data[i] = dim_array__.Get(i).ToNumber().Int64Value();
  int64_t normalization = info__[2].As<Napi::Number>().Int64Value();
  int64_t last_dim_size = info__[3].As<Napi::Number>().Int64Value();
  auto output__ = torch::_fft_c2r(*self, torch::IntArrayRef(dim_data, dim_len), normalization, last_dim_size);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__fft_c2r_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array dim_array__ = info__[2].As<Napi::Array>();
  int dim_len = dim_array__.Length();
  int64_t *dim_data = new int64_t[dim_len];
  for (int i = 0; i < dim_len; ++i)
    dim_data[i] = dim_array__.Get(i).ToNumber().Int64Value();
  int64_t normalization = info__[3].As<Napi::Number>().Int64Value();
  int64_t last_dim_size = info__[4].As<Napi::Number>().Int64Value();
  auto output__ = torch::_fft_c2r_out(*out, *self, torch::IntArrayRef(dim_data, dim_len), normalization, last_dim_size);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__fft_c2c(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array dim_array__ = info__[1].As<Napi::Array>();
  int dim_len = dim_array__.Length();
  int64_t *dim_data = new int64_t[dim_len];
  for (int i = 0; i < dim_len; ++i)
    dim_data[i] = dim_array__.Get(i).ToNumber().Int64Value();
  int64_t normalization = info__[2].As<Napi::Number>().Int64Value();
  bool forward = info__[3].As<Napi::Boolean>().Value();
  auto output__ = torch::_fft_c2c(*self, torch::IntArrayRef(dim_data, dim_len), normalization, forward);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__fft_c2c_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array dim_array__ = info__[2].As<Napi::Array>();
  int dim_len = dim_array__.Length();
  int64_t *dim_data = new int64_t[dim_len];
  for (int i = 0; i < dim_len; ++i)
    dim_data[i] = dim_array__.Get(i).ToNumber().Int64Value();
  int64_t normalization = info__[3].As<Napi::Number>().Int64Value();
  bool forward = info__[4].As<Napi::Boolean>().Value();
  auto output__ = torch::_fft_c2c_out(*out, *self, torch::IntArrayRef(dim_data, dim_len), normalization, forward);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

void atg__validate_compressed_sparse_indices(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  bool is_crow = info__[0].As<Napi::Boolean>().Value();
  torch::Tensor *compressed_idx = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *plain_idx = info__[2].As<Napi::External<torch::Tensor>>().Data();
  int64_t cdim = info__[3].As<Napi::Number>().Int64Value();
  int64_t dim = info__[4].As<Napi::Number>().Int64Value();
  int64_t nnz = info__[5].As<Napi::Number>().Int64Value();
  torch::_validate_compressed_sparse_indices(is_crow, *compressed_idx, *plain_idx, cdim, dim, nnz);
}

Napi::Number atg__cufft_get_plan_cache_size(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  int64_t device_index = info__[0].As<Napi::Number>().Int64Value();
  auto output__ = torch::_cufft_get_plan_cache_size(device_index);
  return Napi::Number::New(env__, output__);
}

Napi::Number atg__cufft_get_plan_cache_max_size(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  int64_t device_index = info__[0].As<Napi::Number>().Int64Value();
  auto output__ = torch::_cufft_get_plan_cache_max_size(device_index);
  return Napi::Number::New(env__, output__);
}

Napi::External<torch::Tensor> atg_index(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array indices_array__ = info__[1].As<Napi::Array>();
  int indices_len = indices_array__.Length();
  torch::Tensor **indices_data = new torch::Tensor *[indices_len];
  for (int i = 0; i < indices_len; ++i)
    indices_data[i] = indices_array__.Get(i).As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::index(*self, of_carray_tensor_opt(indices_data, indices_len));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_index_tensor_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array indices_array__ = info__[2].As<Napi::Array>();
  int indices_len = indices_array__.Length();
  torch::Tensor **indices_data = new torch::Tensor *[indices_len];
  for (int i = 0; i < indices_len; ++i)
    indices_data[i] = indices_array__.Get(i).As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::index_out(*out, *self, of_carray_tensor_opt(indices_data, indices_len));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_index_copy(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t dim = info__[1].As<Napi::Number>().Int64Value();
  torch::Tensor *index = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *source = info__[3].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::index_copy(*self, dim, *index, *source);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_index_copy_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  int64_t dim = info__[2].As<Napi::Number>().Int64Value();
  torch::Tensor *index = info__[3].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *source = info__[4].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::index_copy_out(*out, *self, dim, *index, *source);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_index_copy_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t dim = info__[1].As<Napi::Number>().Int64Value();
  torch::Tensor *index = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *source = info__[3].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = self->index_copy_(dim, *index, *source);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_index_put_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array indices_array__ = info__[1].As<Napi::Array>();
  int indices_len = indices_array__.Length();
  torch::Tensor **indices_data = new torch::Tensor *[indices_len];
  for (int i = 0; i < indices_len; ++i)
    indices_data[i] = indices_array__.Get(i).As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *values = info__[2].As<Napi::External<torch::Tensor>>().Data();
  bool accumulate = info__[3].As<Napi::Boolean>().Value();
  auto output__ = torch::index_put_(*self, of_carray_tensor_opt(indices_data, indices_len), *values, accumulate);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_index_put(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array indices_array__ = info__[1].As<Napi::Array>();
  int indices_len = indices_array__.Length();
  torch::Tensor **indices_data = new torch::Tensor *[indices_len];
  for (int i = 0; i < indices_len; ++i)
    indices_data[i] = indices_array__.Get(i).As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *values = info__[2].As<Napi::External<torch::Tensor>>().Data();
  bool accumulate = info__[3].As<Napi::Boolean>().Value();
  auto output__ = torch::index_put(*self, of_carray_tensor_opt(indices_data, indices_len), *values, accumulate);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_index_put_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array indices_array__ = info__[2].As<Napi::Array>();
  int indices_len = indices_array__.Length();
  torch::Tensor **indices_data = new torch::Tensor *[indices_len];
  for (int i = 0; i < indices_len; ++i)
    indices_data[i] = indices_array__.Get(i).As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *values = info__[3].As<Napi::External<torch::Tensor>>().Data();
  bool accumulate = info__[4].As<Napi::Boolean>().Value();
  auto output__ = torch::index_put_out(*out, *self, of_carray_tensor_opt(indices_data, indices_len), *values, accumulate);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__index_put_impl_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array indices_array__ = info__[1].As<Napi::Array>();
  int indices_len = indices_array__.Length();
  torch::Tensor **indices_data = new torch::Tensor *[indices_len];
  for (int i = 0; i < indices_len; ++i)
    indices_data[i] = indices_array__.Get(i).As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *values = info__[2].As<Napi::External<torch::Tensor>>().Data();
  bool accumulate = info__[3].As<Napi::Boolean>().Value();
  bool unsafe = info__[4].As<Napi::Boolean>().Value();
  auto output__ = torch::_index_put_impl_(*self, of_carray_tensor_opt(indices_data, indices_len), *values, accumulate, unsafe);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_instance_norm(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *input = info__[0].As<Napi::External<torch::Tensor>>().Data();
  bool weight_null = info__[1].IsUndefined();
  torch::Tensor *weight_v = weight_null ? nullptr : info__[1].As<Napi::External<torch::Tensor>>().Data();
  bool bias_null = info__[2].IsUndefined();
  torch::Tensor *bias_v = bias_null ? nullptr : info__[2].As<Napi::External<torch::Tensor>>().Data();
  bool running_mean_null = info__[3].IsUndefined();
  torch::Tensor *running_mean_v = running_mean_null ? nullptr : info__[3].As<Napi::External<torch::Tensor>>().Data();
  bool running_var_null = info__[4].IsUndefined();
  torch::Tensor *running_var_v = running_var_null ? nullptr : info__[4].As<Napi::External<torch::Tensor>>().Data();
  bool use_input_stats = info__[5].As<Napi::Boolean>().Value();
  double momentum = info__[6].As<Napi::Number>().DoubleValue();
  double eps = info__[7].As<Napi::Number>().DoubleValue();
  bool cudnn_enabled = info__[8].As<Napi::Boolean>().Value();
  auto output__ = torch::instance_norm(*input, (weight_null ? *weight_v : torch::Tensor()), (bias_null ? *bias_v : torch::Tensor()), (running_mean_null ? *running_mean_v : torch::Tensor()), (running_var_null ? *running_var_v : torch::Tensor()), use_input_stats, momentum, eps, cudnn_enabled);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_isclose(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[1].As<Napi::External<torch::Tensor>>().Data();
  double rtol = info__[2].As<Napi::Number>().DoubleValue();
  double atol = info__[3].As<Napi::Number>().DoubleValue();
  bool equal_nan = info__[4].As<Napi::Boolean>().Value();
  auto output__ = torch::isclose(*self, *other, rtol, atol, equal_nan);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_isin(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *elements = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *test_elements = info__[1].As<Napi::External<torch::Tensor>>().Data();
  bool assume_unique = info__[2].As<Napi::Boolean>().Value();
  bool invert = info__[3].As<Napi::Boolean>().Value();
  auto output__ = torch::isin(*elements, *test_elements, assume_unique, invert);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_isin_tensor_scalar(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *elements = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *test_element = info__[1].As<Napi::External<torch::Scalar>>().Data();
  bool assume_unique = info__[2].As<Napi::Boolean>().Value();
  bool invert = info__[3].As<Napi::Boolean>().Value();
  auto output__ = torch::isin(*elements, *test_element, assume_unique, invert);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_isin_scalar_tensor(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Scalar *element = info__[0].As<Napi::External<torch::Scalar>>().Data();
  torch::Tensor *test_elements = info__[1].As<Napi::External<torch::Tensor>>().Data();
  bool assume_unique = info__[2].As<Napi::Boolean>().Value();
  bool invert = info__[3].As<Napi::Boolean>().Value();
  auto output__ = torch::isin(*element, *test_elements, assume_unique, invert);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_isin_tensor_tensor_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *elements = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *test_elements = info__[2].As<Napi::External<torch::Tensor>>().Data();
  bool assume_unique = info__[3].As<Napi::Boolean>().Value();
  bool invert = info__[4].As<Napi::Boolean>().Value();
  auto output__ = torch::isin_out(*out, *elements, *test_elements, assume_unique, invert);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_isin_tensor_scalar_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *elements = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *test_element = info__[2].As<Napi::External<torch::Scalar>>().Data();
  bool assume_unique = info__[3].As<Napi::Boolean>().Value();
  bool invert = info__[4].As<Napi::Boolean>().Value();
  auto output__ = torch::isin_out(*out, *elements, *test_element, assume_unique, invert);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_isin_scalar_tensor_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *element = info__[1].As<Napi::External<torch::Scalar>>().Data();
  torch::Tensor *test_elements = info__[2].As<Napi::External<torch::Tensor>>().Data();
  bool assume_unique = info__[3].As<Napi::Boolean>().Value();
  bool invert = info__[4].As<Napi::Boolean>().Value();
  auto output__ = torch::isin_out(*out, *element, *test_elements, assume_unique, invert);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_isnan(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::isnan(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_isnan_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::isnan_out(*out, *self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::Boolean atg_is_distributed(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::is_distributed(*self);
  return Napi::Boolean::New(env__, output__);
}

Napi::Boolean atg_is_floating_point(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::is_floating_point(*self);
  return Napi::Boolean::New(env__, output__);
}

Napi::Boolean atg_is_complex(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::is_complex(*self);
  return Napi::Boolean::New(env__, output__);
}

Napi::Boolean atg_is_conj(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::is_conj(*self);
  return Napi::Boolean::New(env__, output__);
}

Napi::Boolean atg__is_zerotensor(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::_is_zerotensor(*self);
  return Napi::Boolean::New(env__, output__);
}

Napi::Boolean atg_is_neg(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::is_neg(*self);
  return Napi::Boolean::New(env__, output__);
}

Napi::External<torch::Tensor> atg_isreal(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::isreal(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::Boolean atg_is_nonzero(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::is_nonzero(*self);
  return Napi::Boolean::New(env__, output__);
}

Napi::Boolean atg_is_same_size(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::is_same_size(*self, *other);
  return Napi::Boolean::New(env__, output__);
}

Napi::Boolean atg_is_signed(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::is_signed(*self);
  return Napi::Boolean::New(env__, output__);
}

Napi::Boolean atg_is_inference(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::is_inference(*self);
  return Napi::Boolean::New(env__, output__);
}

Napi::External<torch::Tensor> atg_kl_div(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *target = info__[1].As<Napi::External<torch::Tensor>>().Data();
  int64_t reduction = info__[2].As<Napi::Number>().Int64Value();
  bool log_target = info__[3].As<Napi::Boolean>().Value();
  auto output__ = torch::kl_div(*self, *target, reduction, log_target);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_kron(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::kron(*self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_kron_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[2].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::kron_out(*out, *self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::Array atg_kthvalue(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t k = info__[1].As<Napi::Number>().Int64Value();
  int64_t dim = info__[2].As<Napi::Number>().Int64Value();
  bool keepdim = info__[3].As<Napi::Boolean>().Value();
  auto output__ = torch::kthvalue(*self, k, dim, keepdim);
  Napi::Array output__array__ = Napi::Array::New(env__, 2);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  return output__array__;
}

Napi::Array atg_kthvalue_values(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *values = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *indices = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[2].As<Napi::External<torch::Tensor>>().Data();
  int64_t k = info__[3].As<Napi::Number>().Int64Value();
  int64_t dim = info__[4].As<Napi::Number>().Int64Value();
  bool keepdim = info__[5].As<Napi::Boolean>().Value();
  auto output__ = torch::kthvalue_out(*values, *indices, *self, k, dim, keepdim);
  Napi::Array output__array__ = Napi::Array::New(env__, 2);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  return output__array__;
}

Napi::External<torch::Tensor> atg_layer_norm(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *input = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array normalized_shape_array__ = info__[1].As<Napi::Array>();
  int normalized_shape_len = normalized_shape_array__.Length();
  int64_t *normalized_shape_data = new int64_t[normalized_shape_len];
  for (int i = 0; i < normalized_shape_len; ++i)
    normalized_shape_data[i] = normalized_shape_array__.Get(i).ToNumber().Int64Value();
  bool weight_null = info__[2].IsUndefined();
  torch::Tensor *weight_v = weight_null ? nullptr : info__[2].As<Napi::External<torch::Tensor>>().Data();
  bool bias_null = info__[3].IsUndefined();
  torch::Tensor *bias_v = bias_null ? nullptr : info__[3].As<Napi::External<torch::Tensor>>().Data();
  double eps = info__[4].As<Napi::Number>().DoubleValue();
  bool cudnn_enable = info__[5].As<Napi::Boolean>().Value();
  auto output__ = torch::layer_norm(*input, torch::IntArrayRef(normalized_shape_data, normalized_shape_len), (weight_null ? *weight_v : torch::Tensor()), (bias_null ? *bias_v : torch::Tensor()), eps, cudnn_enable);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::Array atg_native_layer_norm(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *input = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array normalized_shape_array__ = info__[1].As<Napi::Array>();
  int normalized_shape_len = normalized_shape_array__.Length();
  int64_t *normalized_shape_data = new int64_t[normalized_shape_len];
  for (int i = 0; i < normalized_shape_len; ++i)
    normalized_shape_data[i] = normalized_shape_array__.Get(i).ToNumber().Int64Value();
  bool weight_null = info__[2].IsUndefined();
  torch::Tensor *weight_v = weight_null ? nullptr : info__[2].As<Napi::External<torch::Tensor>>().Data();
  bool bias_null = info__[3].IsUndefined();
  torch::Tensor *bias_v = bias_null ? nullptr : info__[3].As<Napi::External<torch::Tensor>>().Data();
  double eps = info__[4].As<Napi::Number>().DoubleValue();
  auto output__ = torch::native_layer_norm(*input, torch::IntArrayRef(normalized_shape_data, normalized_shape_len), (weight_null ? *weight_v : torch::Tensor()), (bias_null ? *bias_v : torch::Tensor()), eps);
  Napi::Array output__array__ = Napi::Array::New(env__, 3);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  output__array__[2u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<2>(output__)));
  return output__array__;
}

Napi::Array atg_native_layer_norm_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out0 = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *out1 = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *out2 = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *input = info__[3].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array normalized_shape_array__ = info__[4].As<Napi::Array>();
  int normalized_shape_len = normalized_shape_array__.Length();
  int64_t *normalized_shape_data = new int64_t[normalized_shape_len];
  for (int i = 0; i < normalized_shape_len; ++i)
    normalized_shape_data[i] = normalized_shape_array__.Get(i).ToNumber().Int64Value();
  bool weight_null = info__[5].IsUndefined();
  torch::Tensor *weight_v = weight_null ? nullptr : info__[5].As<Napi::External<torch::Tensor>>().Data();
  bool bias_null = info__[6].IsUndefined();
  torch::Tensor *bias_v = bias_null ? nullptr : info__[6].As<Napi::External<torch::Tensor>>().Data();
  double eps = info__[7].As<Napi::Number>().DoubleValue();
  auto output__ = torch::native_layer_norm_out(*out0, *out1, *out2, *input, torch::IntArrayRef(normalized_shape_data, normalized_shape_len), (weight_null ? *weight_v : torch::Tensor()), (bias_null ? *bias_v : torch::Tensor()), eps);
  Napi::Array output__array__ = Napi::Array::New(env__, 3);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  output__array__[2u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<2>(output__)));
  return output__array__;
}

Napi::External<torch::Tensor> atg_nan_to_num(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  bool nan_null = info__[1].IsUndefined();
  double nan_v = nan_null ? 0 : info__[1].As<Napi::Number>().DoubleValue();
  bool posinf_null = info__[2].IsUndefined();
  double posinf_v = posinf_null ? 0 : info__[2].As<Napi::Number>().DoubleValue();
  bool neginf_null = info__[3].IsUndefined();
  double neginf_v = neginf_null ? 0 : info__[3].As<Napi::Number>().DoubleValue();
  auto output__ = torch::nan_to_num(*self, nan_null ? c10::nullopt : c10::optional<double>(nan_v), posinf_null ? c10::nullopt : c10::optional<double>(posinf_v), neginf_null ? c10::nullopt : c10::optional<double>(neginf_v));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_nan_to_num_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  bool nan_null = info__[2].IsUndefined();
  double nan_v = nan_null ? 0 : info__[2].As<Napi::Number>().DoubleValue();
  bool posinf_null = info__[3].IsUndefined();
  double posinf_v = posinf_null ? 0 : info__[3].As<Napi::Number>().DoubleValue();
  bool neginf_null = info__[4].IsUndefined();
  double neginf_v = neginf_null ? 0 : info__[4].As<Napi::Number>().DoubleValue();
  auto output__ = torch::nan_to_num_out(*out, *self, nan_null ? c10::nullopt : c10::optional<double>(nan_v), posinf_null ? c10::nullopt : c10::optional<double>(posinf_v), neginf_null ? c10::nullopt : c10::optional<double>(neginf_v));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_nan_to_num_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  bool nan_null = info__[1].IsUndefined();
  double nan_v = nan_null ? 0 : info__[1].As<Napi::Number>().DoubleValue();
  bool posinf_null = info__[2].IsUndefined();
  double posinf_v = posinf_null ? 0 : info__[2].As<Napi::Number>().DoubleValue();
  bool neginf_null = info__[3].IsUndefined();
  double neginf_v = neginf_null ? 0 : info__[3].As<Napi::Number>().DoubleValue();
  auto output__ = torch::nan_to_num_(*self, nan_null ? c10::nullopt : c10::optional<double>(nan_v), posinf_null ? c10::nullopt : c10::optional<double>(posinf_v), neginf_null ? c10::nullopt : c10::optional<double>(neginf_v));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_linear(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *input = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *weight = info__[1].As<Napi::External<torch::Tensor>>().Data();
  bool bias_null = info__[2].IsUndefined();
  torch::Tensor *bias_v = bias_null ? nullptr : info__[2].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::linear(*input, *weight, (bias_null ? *bias_v : torch::Tensor()));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_linear_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *input = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *weight = info__[2].As<Napi::External<torch::Tensor>>().Data();
  bool bias_null = info__[3].IsUndefined();
  torch::Tensor *bias_v = bias_null ? nullptr : info__[3].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::linear_out(*out, *input, *weight, (bias_null ? *bias_v : torch::Tensor()));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_mkldnn_linear(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *weight = info__[1].As<Napi::External<torch::Tensor>>().Data();
  bool bias_null = info__[2].IsUndefined();
  torch::Tensor *bias_v = bias_null ? nullptr : info__[2].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::mkldnn_linear(*self, *weight, (bias_null ? *bias_v : torch::Tensor()));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_mkldnn_linear_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *weight = info__[2].As<Napi::External<torch::Tensor>>().Data();
  bool bias_null = info__[3].IsUndefined();
  torch::Tensor *bias_v = bias_null ? nullptr : info__[3].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::mkldnn_linear_out(*out, *self, *weight, (bias_null ? *bias_v : torch::Tensor()));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_mkldnn_linear_backward_input(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  Napi::Array input_size_array__ = info__[0].As<Napi::Array>();
  int input_size_len = input_size_array__.Length();
  int64_t *input_size_data = new int64_t[input_size_len];
  for (int i = 0; i < input_size_len; ++i)
    input_size_data[i] = input_size_array__.Get(i).ToNumber().Int64Value();
  torch::Tensor *grad_output = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *weight = info__[2].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::mkldnn_linear_backward_input(torch::IntArrayRef(input_size_data, input_size_len), *grad_output, *weight);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_mkldnn_linear_backward_input_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array input_size_array__ = info__[1].As<Napi::Array>();
  int input_size_len = input_size_array__.Length();
  int64_t *input_size_data = new int64_t[input_size_len];
  for (int i = 0; i < input_size_len; ++i)
    input_size_data[i] = input_size_array__.Get(i).ToNumber().Int64Value();
  torch::Tensor *grad_output = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *weight = info__[3].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::mkldnn_linear_backward_input_out(*out, torch::IntArrayRef(input_size_data, input_size_len), *grad_output, *weight);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::Array atg_mkldnn_linear_backward_weights(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *grad_output = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *input = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *weight = info__[2].As<Napi::External<torch::Tensor>>().Data();
  bool bias_defined = info__[3].As<Napi::Boolean>().Value();
  auto output__ = torch::mkldnn_linear_backward_weights(*grad_output, *input, *weight, bias_defined);
  Napi::Array output__array__ = Napi::Array::New(env__, 2);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  return output__array__;
}

Napi::Array atg_mkldnn_linear_backward_weights_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out0 = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *out1 = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *grad_output = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *input = info__[3].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *weight = info__[4].As<Napi::External<torch::Tensor>>().Data();
  bool bias_defined = info__[5].As<Napi::Boolean>().Value();
  auto output__ = torch::mkldnn_linear_backward_weights_out(*out0, *out1, *grad_output, *input, *weight, bias_defined);
  Napi::Array output__array__ = Napi::Array::New(env__, 2);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  return output__array__;
}

Napi::External<torch::Tensor> atg_fbgemm_linear_int8_weight_fp32_activation(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *input = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *weight = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *packed = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *col_offsets = info__[3].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *weight_scale = info__[4].As<Napi::External<torch::Scalar>>().Data();
  torch::Scalar *weight_zero_point = info__[5].As<Napi::External<torch::Scalar>>().Data();
  torch::Tensor *bias = info__[6].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::fbgemm_linear_int8_weight_fp32_activation(*input, *weight, *packed, *col_offsets, *weight_scale, *weight_zero_point, *bias);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_fbgemm_linear_int8_weight(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *input = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *weight = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *packed = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *col_offsets = info__[3].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *weight_scale = info__[4].As<Napi::External<torch::Scalar>>().Data();
  torch::Scalar *weight_zero_point = info__[5].As<Napi::External<torch::Scalar>>().Data();
  torch::Tensor *bias = info__[6].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::fbgemm_linear_int8_weight(*input, *weight, *packed, *col_offsets, *weight_scale, *weight_zero_point, *bias);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_fbgemm_pack_gemm_matrix_fp16(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *input = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::fbgemm_pack_gemm_matrix_fp16(*input);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_fbgemm_linear_fp16_weight_fp32_activation(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *input = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *packed_weight = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *bias = info__[2].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::fbgemm_linear_fp16_weight_fp32_activation(*input, *packed_weight, *bias);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_fbgemm_linear_fp16_weight(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *input = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *packed_weight = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *bias = info__[2].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::fbgemm_linear_fp16_weight(*input, *packed_weight, *bias);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_fbgemm_pack_quantized_matrix(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *input = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::fbgemm_pack_quantized_matrix(*input);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_fbgemm_pack_quantized_matrix_kn(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *input = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t K = info__[1].As<Napi::Number>().Int64Value();
  int64_t N = info__[2].As<Napi::Number>().Int64Value();
  auto output__ = torch::fbgemm_pack_quantized_matrix(*input, K, N);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_ldexp(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::ldexp(*self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_ldexp_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[2].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::ldexp_out(*out, *self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_ldexp_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::ldexp_(*self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_linspace(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Scalar *start = info__[0].As<Napi::External<torch::Scalar>>().Data();
  torch::Scalar *end = info__[1].As<Napi::External<torch::Scalar>>().Data();
  int64_t steps = info__[2].As<Napi::Number>().Int64Value();
  Napi::Object options_obj__ = info__[3].As<Napi::Object>();
  int options_device = options_obj__.Get("device").ToNumber().Int32Value();
  int options_kind = options_obj__.Get("dtype").ToNumber().Int32Value();
  auto output__ = torch::linspace(*start, *end, steps, at::device(device_of_int(options_device)).dtype(at::ScalarType(options_kind)));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_linspace_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *start = info__[1].As<Napi::External<torch::Scalar>>().Data();
  torch::Scalar *end = info__[2].As<Napi::External<torch::Scalar>>().Data();
  int64_t steps = info__[3].As<Napi::Number>().Int64Value();
  auto output__ = torch::linspace_out(*out, *start, *end, steps);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_log(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::log(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_log_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::log_out(*out, *self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_log_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::log_(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_log10(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::log10(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_log10_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::log10_out(*out, *self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_log10_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::log10_(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_log1p(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::log1p(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_log1p_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::log1p_out(*out, *self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_log1p_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::log1p_(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_log2(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::log2(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_log2_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::log2_out(*out, *self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_log2_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::log2_(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_logaddexp(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::logaddexp(*self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_logaddexp_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[2].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::logaddexp_out(*out, *self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_logaddexp2(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::logaddexp2(*self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_logaddexp2_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[2].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::logaddexp2_out(*out, *self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_xlogy(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::xlogy(*self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_xlogy_scalar_self(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Scalar *self_scalar = info__[0].As<Napi::External<torch::Scalar>>().Data();
  torch::Tensor *other = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::xlogy(*self_scalar, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_xlogy_scalar_other(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *other = info__[1].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::xlogy(*self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_xlogy_outtensor(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[2].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::xlogy_out(*out, *self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_xlogy_outscalar_self(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *self_scalar = info__[1].As<Napi::External<torch::Scalar>>().Data();
  torch::Tensor *other = info__[2].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::xlogy_out(*out, *self_scalar, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_xlogy_outscalar_other(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *other = info__[2].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::xlogy_out(*out, *self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_xlogy_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::xlogy_(*self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_xlogy_scalar_other_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *other = info__[1].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::xlogy_(*self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_logspace(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Scalar *start = info__[0].As<Napi::External<torch::Scalar>>().Data();
  torch::Scalar *end = info__[1].As<Napi::External<torch::Scalar>>().Data();
  int64_t steps = info__[2].As<Napi::Number>().Int64Value();
  double base = info__[3].As<Napi::Number>().DoubleValue();
  Napi::Object options_obj__ = info__[4].As<Napi::Object>();
  int options_device = options_obj__.Get("device").ToNumber().Int32Value();
  int options_kind = options_obj__.Get("dtype").ToNumber().Int32Value();
  auto output__ = torch::logspace(*start, *end, steps, base, at::device(device_of_int(options_device)).dtype(at::ScalarType(options_kind)));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_logspace_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *start = info__[1].As<Napi::External<torch::Scalar>>().Data();
  torch::Scalar *end = info__[2].As<Napi::External<torch::Scalar>>().Data();
  int64_t steps = info__[3].As<Napi::Number>().Int64Value();
  double base = info__[4].As<Napi::Number>().DoubleValue();
  auto output__ = torch::logspace_out(*out, *start, *end, steps, base);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_log_softmax(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t dim = info__[1].As<Napi::Number>().Int64Value();
  int dtype = info__[2].As<Napi::Number>().Int32Value();
  auto output__ = torch::log_softmax(*self, dim, at::ScalarType(dtype));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_log_softmax_int_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  int64_t dim = info__[2].As<Napi::Number>().Int64Value();
  int dtype = info__[3].As<Napi::Number>().Int32Value();
  auto output__ = torch::log_softmax_out(*out, *self, dim, at::ScalarType(dtype));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__log_softmax(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t dim = info__[1].As<Napi::Number>().Int64Value();
  bool half_to_float = info__[2].As<Napi::Boolean>().Value();
  auto output__ = torch::_log_softmax(*self, dim, half_to_float);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__log_softmax_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  int64_t dim = info__[2].As<Napi::Number>().Int64Value();
  bool half_to_float = info__[3].As<Napi::Boolean>().Value();
  auto output__ = torch::_log_softmax_out(*out, *self, dim, half_to_float);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__log_softmax_backward_data(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *grad_output = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *output = info__[1].As<Napi::External<torch::Tensor>>().Data();
  int64_t dim = info__[2].As<Napi::Number>().Int64Value();
  int input_dtype = info__[3].As<Napi::Number>().Int32Value();
  auto output__ = torch::_log_softmax_backward_data(*grad_output, *output, dim, at::ScalarType(input_dtype));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__log_softmax_backward_data_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *grad_output = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *output = info__[2].As<Napi::External<torch::Tensor>>().Data();
  int64_t dim = info__[3].As<Napi::Number>().Int64Value();
  int input_dtype = info__[4].As<Napi::Number>().Int32Value();
  auto output__ = torch::_log_softmax_backward_data_out(*out, *grad_output, *output, dim, at::ScalarType(input_dtype));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__logcumsumexp(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t dim = info__[1].As<Napi::Number>().Int64Value();
  auto output__ = torch::_logcumsumexp(*self, dim);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__logcumsumexp_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  int64_t dim = info__[2].As<Napi::Number>().Int64Value();
  auto output__ = torch::_logcumsumexp_out(*out, *self, dim);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_logcumsumexp(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t dim = info__[1].As<Napi::Number>().Int64Value();
  auto output__ = torch::logcumsumexp(*self, dim);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_logcumsumexp_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  int64_t dim = info__[2].As<Napi::Number>().Int64Value();
  auto output__ = torch::logcumsumexp_out(*out, *self, dim);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_logsumexp(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array dim_array__ = info__[1].As<Napi::Array>();
  int dim_len = dim_array__.Length();
  int64_t *dim_data = new int64_t[dim_len];
  for (int i = 0; i < dim_len; ++i)
    dim_data[i] = dim_array__.Get(i).ToNumber().Int64Value();
  bool keepdim = info__[2].As<Napi::Boolean>().Value();
  auto output__ = torch::logsumexp(*self, torch::IntArrayRef(dim_data, dim_len), keepdim);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_logsumexp_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array dim_array__ = info__[2].As<Napi::Array>();
  int dim_len = dim_array__.Length();
  int64_t *dim_data = new int64_t[dim_len];
  for (int i = 0; i < dim_len; ++i)
    dim_data[i] = dim_array__.Get(i).ToNumber().Int64Value();
  bool keepdim = info__[3].As<Napi::Boolean>().Value();
  auto output__ = torch::logsumexp_out(*out, *self, torch::IntArrayRef(dim_data, dim_len), keepdim);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_margin_ranking_loss(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *input1 = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *input2 = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *target = info__[2].As<Napi::External<torch::Tensor>>().Data();
  double margin = info__[3].As<Napi::Number>().DoubleValue();
  int64_t reduction = info__[4].As<Napi::Number>().Int64Value();
  auto output__ = torch::margin_ranking_loss(*input1, *input2, *target, margin, reduction);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_matmul(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::matmul(*self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_matmul_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[2].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::matmul_out(*out, *self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_matrix_power(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t n = info__[1].As<Napi::Number>().Int64Value();
  auto output__ = torch::matrix_power(*self, n);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_matrix_power_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  int64_t n = info__[2].As<Napi::Number>().Int64Value();
  auto output__ = torch::matrix_power_out(*out, *self, n);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_matrix_exp(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::matrix_exp(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_matrix_exp_backward(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *grad = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::matrix_exp_backward(*self, *grad);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::Array atg__aminmax(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::_aminmax(*self);
  Napi::Array output__array__ = Napi::Array::New(env__, 2);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  return output__array__;
}

Napi::Array atg__aminmax_dim(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t dim = info__[1].As<Napi::Number>().Int64Value();
  bool keepdim = info__[2].As<Napi::Boolean>().Value();
  auto output__ = torch::_aminmax(*self, dim, keepdim);
  Napi::Array output__array__ = Napi::Array::New(env__, 2);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  return output__array__;
}

Napi::Array atg__aminmax_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out0 = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *out1 = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[2].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::_aminmax_out(*out0, *out1, *self);
  Napi::Array output__array__ = Napi::Array::New(env__, 2);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  return output__array__;
}

Napi::Array atg__aminmax_dim_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out0 = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *out1 = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[2].As<Napi::External<torch::Tensor>>().Data();
  int64_t dim = info__[3].As<Napi::Number>().Int64Value();
  bool keepdim = info__[4].As<Napi::Boolean>().Value();
  auto output__ = torch::_aminmax_out(*out0, *out1, *self, dim, keepdim);
  Napi::Array output__array__ = Napi::Array::New(env__, 2);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  return output__array__;
}

Napi::Array atg_aminmax(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  bool dim_null = info__[1].IsUndefined();
  int64_t dim_v = dim_null ? 0 : info__[1].As<Napi::Number>().Int64Value();
  bool keepdim = info__[2].As<Napi::Boolean>().Value();
  auto output__ = torch::aminmax(*self, dim_null ? c10::nullopt : c10::optional<int64_t>(dim_v), keepdim);
  Napi::Array output__array__ = Napi::Array::New(env__, 2);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  return output__array__;
}

Napi::Array atg_aminmax_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *min = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *max = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[2].As<Napi::External<torch::Tensor>>().Data();
  bool dim_null = info__[3].IsUndefined();
  int64_t dim_v = dim_null ? 0 : info__[3].As<Napi::Number>().Int64Value();
  bool keepdim = info__[4].As<Napi::Boolean>().Value();
  auto output__ = torch::aminmax_out(*min, *max, *self, dim_null ? c10::nullopt : c10::optional<int64_t>(dim_v), keepdim);
  Napi::Array output__array__ = Napi::Array::New(env__, 2);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  return output__array__;
}

Napi::External<torch::Tensor> atg__compute_linear_combination(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *input = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *coefficients = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::_compute_linear_combination(*input, *coefficients);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__compute_linear_combination_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *input = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *coefficients = info__[2].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::_compute_linear_combination_out(*out, *input, *coefficients);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_max(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::max(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_max_other(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::max(*self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::Array atg_max_dim(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t dim = info__[1].As<Napi::Number>().Int64Value();
  bool keepdim = info__[2].As<Napi::Boolean>().Value();
  auto output__ = torch::max(*self, dim, keepdim);
  Napi::Array output__array__ = Napi::Array::New(env__, 2);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  return output__array__;
}

Napi::External<torch::Tensor> atg_max_unary_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::max_out(*out, *self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_max_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[2].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::max_out(*out, *self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::Array atg_max_dim_max(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *max = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *max_values = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[2].As<Napi::External<torch::Tensor>>().Data();
  int64_t dim = info__[3].As<Napi::Number>().Int64Value();
  bool keepdim = info__[4].As<Napi::Boolean>().Value();
  auto output__ = torch::max_out(*max, *max_values, *self, dim, keepdim);
  Napi::Array output__array__ = Napi::Array::New(env__, 2);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  return output__array__;
}

Napi::External<torch::Tensor> atg_value_selecting_reduction_backward(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *grad = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t dim = info__[1].As<Napi::Number>().Int64Value();
  torch::Tensor *indices = info__[2].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array sizes_array__ = info__[3].As<Napi::Array>();
  int sizes_len = sizes_array__.Length();
  int64_t *sizes_data = new int64_t[sizes_len];
  for (int i = 0; i < sizes_len; ++i)
    sizes_data[i] = sizes_array__.Get(i).ToNumber().Int64Value();
  bool keepdim = info__[4].As<Napi::Boolean>().Value();
  auto output__ = torch::value_selecting_reduction_backward(*grad, dim, *indices, torch::IntArrayRef(sizes_data, sizes_len), keepdim);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_amax(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array dim_array__ = info__[1].As<Napi::Array>();
  int dim_len = dim_array__.Length();
  int64_t *dim_data = new int64_t[dim_len];
  for (int i = 0; i < dim_len; ++i)
    dim_data[i] = dim_array__.Get(i).ToNumber().Int64Value();
  bool keepdim = info__[2].As<Napi::Boolean>().Value();
  auto output__ = torch::amax(*self, torch::IntArrayRef(dim_data, dim_len), keepdim);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_amax_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array dim_array__ = info__[2].As<Napi::Array>();
  int dim_len = dim_array__.Length();
  int64_t *dim_data = new int64_t[dim_len];
  for (int i = 0; i < dim_len; ++i)
    dim_data[i] = dim_array__.Get(i).ToNumber().Int64Value();
  bool keepdim = info__[3].As<Napi::Boolean>().Value();
  auto output__ = torch::amax_out(*out, *self, torch::IntArrayRef(dim_data, dim_len), keepdim);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::Array atg_max_pool1d_with_indices(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array kernel_size_array__ = info__[1].As<Napi::Array>();
  int kernel_size_len = kernel_size_array__.Length();
  int64_t *kernel_size_data = new int64_t[kernel_size_len];
  for (int i = 0; i < kernel_size_len; ++i)
    kernel_size_data[i] = kernel_size_array__.Get(i).ToNumber().Int64Value();
  Napi::Array stride_array__ = info__[2].As<Napi::Array>();
  int stride_len = stride_array__.Length();
  int64_t *stride_data = new int64_t[stride_len];
  for (int i = 0; i < stride_len; ++i)
    stride_data[i] = stride_array__.Get(i).ToNumber().Int64Value();
  Napi::Array padding_array__ = info__[3].As<Napi::Array>();
  int padding_len = padding_array__.Length();
  int64_t *padding_data = new int64_t[padding_len];
  for (int i = 0; i < padding_len; ++i)
    padding_data[i] = padding_array__.Get(i).ToNumber().Int64Value();
  Napi::Array dilation_array__ = info__[4].As<Napi::Array>();
  int dilation_len = dilation_array__.Length();
  int64_t *dilation_data = new int64_t[dilation_len];
  for (int i = 0; i < dilation_len; ++i)
    dilation_data[i] = dilation_array__.Get(i).ToNumber().Int64Value();
  bool ceil_mode = info__[5].As<Napi::Boolean>().Value();
  auto output__ = torch::max_pool1d_with_indices(*self, torch::IntArrayRef(kernel_size_data, kernel_size_len), torch::IntArrayRef(stride_data, stride_len), torch::IntArrayRef(padding_data, padding_len), torch::IntArrayRef(dilation_data, dilation_len), ceil_mode);
  Napi::Array output__array__ = Napi::Array::New(env__, 2);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  return output__array__;
}

Napi::External<torch::Tensor> atg_max_pool1d(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array kernel_size_array__ = info__[1].As<Napi::Array>();
  int kernel_size_len = kernel_size_array__.Length();
  int64_t *kernel_size_data = new int64_t[kernel_size_len];
  for (int i = 0; i < kernel_size_len; ++i)
    kernel_size_data[i] = kernel_size_array__.Get(i).ToNumber().Int64Value();
  Napi::Array stride_array__ = info__[2].As<Napi::Array>();
  int stride_len = stride_array__.Length();
  int64_t *stride_data = new int64_t[stride_len];
  for (int i = 0; i < stride_len; ++i)
    stride_data[i] = stride_array__.Get(i).ToNumber().Int64Value();
  Napi::Array padding_array__ = info__[3].As<Napi::Array>();
  int padding_len = padding_array__.Length();
  int64_t *padding_data = new int64_t[padding_len];
  for (int i = 0; i < padding_len; ++i)
    padding_data[i] = padding_array__.Get(i).ToNumber().Int64Value();
  Napi::Array dilation_array__ = info__[4].As<Napi::Array>();
  int dilation_len = dilation_array__.Length();
  int64_t *dilation_data = new int64_t[dilation_len];
  for (int i = 0; i < dilation_len; ++i)
    dilation_data[i] = dilation_array__.Get(i).ToNumber().Int64Value();
  bool ceil_mode = info__[5].As<Napi::Boolean>().Value();
  auto output__ = torch::max_pool1d(*self, torch::IntArrayRef(kernel_size_data, kernel_size_len), torch::IntArrayRef(stride_data, stride_len), torch::IntArrayRef(padding_data, padding_len), torch::IntArrayRef(dilation_data, dilation_len), ceil_mode);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_max_pool2d(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array kernel_size_array__ = info__[1].As<Napi::Array>();
  int kernel_size_len = kernel_size_array__.Length();
  int64_t *kernel_size_data = new int64_t[kernel_size_len];
  for (int i = 0; i < kernel_size_len; ++i)
    kernel_size_data[i] = kernel_size_array__.Get(i).ToNumber().Int64Value();
  Napi::Array stride_array__ = info__[2].As<Napi::Array>();
  int stride_len = stride_array__.Length();
  int64_t *stride_data = new int64_t[stride_len];
  for (int i = 0; i < stride_len; ++i)
    stride_data[i] = stride_array__.Get(i).ToNumber().Int64Value();
  Napi::Array padding_array__ = info__[3].As<Napi::Array>();
  int padding_len = padding_array__.Length();
  int64_t *padding_data = new int64_t[padding_len];
  for (int i = 0; i < padding_len; ++i)
    padding_data[i] = padding_array__.Get(i).ToNumber().Int64Value();
  Napi::Array dilation_array__ = info__[4].As<Napi::Array>();
  int dilation_len = dilation_array__.Length();
  int64_t *dilation_data = new int64_t[dilation_len];
  for (int i = 0; i < dilation_len; ++i)
    dilation_data[i] = dilation_array__.Get(i).ToNumber().Int64Value();
  bool ceil_mode = info__[5].As<Napi::Boolean>().Value();
  auto output__ = torch::max_pool2d(*self, torch::IntArrayRef(kernel_size_data, kernel_size_len), torch::IntArrayRef(stride_data, stride_len), torch::IntArrayRef(padding_data, padding_len), torch::IntArrayRef(dilation_data, dilation_len), ceil_mode);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_max_pool2d_backward(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *grad_output = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array kernel_size_array__ = info__[2].As<Napi::Array>();
  int kernel_size_len = kernel_size_array__.Length();
  int64_t *kernel_size_data = new int64_t[kernel_size_len];
  for (int i = 0; i < kernel_size_len; ++i)
    kernel_size_data[i] = kernel_size_array__.Get(i).ToNumber().Int64Value();
  Napi::Array stride_array__ = info__[3].As<Napi::Array>();
  int stride_len = stride_array__.Length();
  int64_t *stride_data = new int64_t[stride_len];
  for (int i = 0; i < stride_len; ++i)
    stride_data[i] = stride_array__.Get(i).ToNumber().Int64Value();
  Napi::Array padding_array__ = info__[4].As<Napi::Array>();
  int padding_len = padding_array__.Length();
  int64_t *padding_data = new int64_t[padding_len];
  for (int i = 0; i < padding_len; ++i)
    padding_data[i] = padding_array__.Get(i).ToNumber().Int64Value();
  Napi::Array dilation_array__ = info__[5].As<Napi::Array>();
  int dilation_len = dilation_array__.Length();
  int64_t *dilation_data = new int64_t[dilation_len];
  for (int i = 0; i < dilation_len; ++i)
    dilation_data[i] = dilation_array__.Get(i).ToNumber().Int64Value();
  bool ceil_mode = info__[6].As<Napi::Boolean>().Value();
  auto output__ = torch::max_pool2d_backward(*grad_output, *self, torch::IntArrayRef(kernel_size_data, kernel_size_len), torch::IntArrayRef(stride_data, stride_len), torch::IntArrayRef(padding_data, padding_len), torch::IntArrayRef(dilation_data, dilation_len), ceil_mode);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_max_pool2d_backward_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *grad_output = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[2].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array kernel_size_array__ = info__[3].As<Napi::Array>();
  int kernel_size_len = kernel_size_array__.Length();
  int64_t *kernel_size_data = new int64_t[kernel_size_len];
  for (int i = 0; i < kernel_size_len; ++i)
    kernel_size_data[i] = kernel_size_array__.Get(i).ToNumber().Int64Value();
  Napi::Array stride_array__ = info__[4].As<Napi::Array>();
  int stride_len = stride_array__.Length();
  int64_t *stride_data = new int64_t[stride_len];
  for (int i = 0; i < stride_len; ++i)
    stride_data[i] = stride_array__.Get(i).ToNumber().Int64Value();
  Napi::Array padding_array__ = info__[5].As<Napi::Array>();
  int padding_len = padding_array__.Length();
  int64_t *padding_data = new int64_t[padding_len];
  for (int i = 0; i < padding_len; ++i)
    padding_data[i] = padding_array__.Get(i).ToNumber().Int64Value();
  Napi::Array dilation_array__ = info__[6].As<Napi::Array>();
  int dilation_len = dilation_array__.Length();
  int64_t *dilation_data = new int64_t[dilation_len];
  for (int i = 0; i < dilation_len; ++i)
    dilation_data[i] = dilation_array__.Get(i).ToNumber().Int64Value();
  bool ceil_mode = info__[7].As<Napi::Boolean>().Value();
  auto output__ = torch::max_pool2d_backward_out(*out, *grad_output, *self, torch::IntArrayRef(kernel_size_data, kernel_size_len), torch::IntArrayRef(stride_data, stride_len), torch::IntArrayRef(padding_data, padding_len), torch::IntArrayRef(dilation_data, dilation_len), ceil_mode);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_mkldnn_max_pool2d(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array kernel_size_array__ = info__[1].As<Napi::Array>();
  int kernel_size_len = kernel_size_array__.Length();
  int64_t *kernel_size_data = new int64_t[kernel_size_len];
  for (int i = 0; i < kernel_size_len; ++i)
    kernel_size_data[i] = kernel_size_array__.Get(i).ToNumber().Int64Value();
  Napi::Array stride_array__ = info__[2].As<Napi::Array>();
  int stride_len = stride_array__.Length();
  int64_t *stride_data = new int64_t[stride_len];
  for (int i = 0; i < stride_len; ++i)
    stride_data[i] = stride_array__.Get(i).ToNumber().Int64Value();
  Napi::Array padding_array__ = info__[3].As<Napi::Array>();
  int padding_len = padding_array__.Length();
  int64_t *padding_data = new int64_t[padding_len];
  for (int i = 0; i < padding_len; ++i)
    padding_data[i] = padding_array__.Get(i).ToNumber().Int64Value();
  Napi::Array dilation_array__ = info__[4].As<Napi::Array>();
  int dilation_len = dilation_array__.Length();
  int64_t *dilation_data = new int64_t[dilation_len];
  for (int i = 0; i < dilation_len; ++i)
    dilation_data[i] = dilation_array__.Get(i).ToNumber().Int64Value();
  bool ceil_mode = info__[5].As<Napi::Boolean>().Value();
  auto output__ = torch::mkldnn_max_pool2d(*self, torch::IntArrayRef(kernel_size_data, kernel_size_len), torch::IntArrayRef(stride_data, stride_len), torch::IntArrayRef(padding_data, padding_len), torch::IntArrayRef(dilation_data, dilation_len), ceil_mode);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_mkldnn_max_pool2d_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array kernel_size_array__ = info__[2].As<Napi::Array>();
  int kernel_size_len = kernel_size_array__.Length();
  int64_t *kernel_size_data = new int64_t[kernel_size_len];
  for (int i = 0; i < kernel_size_len; ++i)
    kernel_size_data[i] = kernel_size_array__.Get(i).ToNumber().Int64Value();
  Napi::Array stride_array__ = info__[3].As<Napi::Array>();
  int stride_len = stride_array__.Length();
  int64_t *stride_data = new int64_t[stride_len];
  for (int i = 0; i < stride_len; ++i)
    stride_data[i] = stride_array__.Get(i).ToNumber().Int64Value();
  Napi::Array padding_array__ = info__[4].As<Napi::Array>();
  int padding_len = padding_array__.Length();
  int64_t *padding_data = new int64_t[padding_len];
  for (int i = 0; i < padding_len; ++i)
    padding_data[i] = padding_array__.Get(i).ToNumber().Int64Value();
  Napi::Array dilation_array__ = info__[5].As<Napi::Array>();
  int dilation_len = dilation_array__.Length();
  int64_t *dilation_data = new int64_t[dilation_len];
  for (int i = 0; i < dilation_len; ++i)
    dilation_data[i] = dilation_array__.Get(i).ToNumber().Int64Value();
  bool ceil_mode = info__[6].As<Napi::Boolean>().Value();
  auto output__ = torch::mkldnn_max_pool2d_out(*out, *self, torch::IntArrayRef(kernel_size_data, kernel_size_len), torch::IntArrayRef(stride_data, stride_len), torch::IntArrayRef(padding_data, padding_len), torch::IntArrayRef(dilation_data, dilation_len), ceil_mode);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_mkldnn_max_pool2d_backward(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *grad_output = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *output = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *input = info__[2].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array kernel_size_array__ = info__[3].As<Napi::Array>();
  int kernel_size_len = kernel_size_array__.Length();
  int64_t *kernel_size_data = new int64_t[kernel_size_len];
  for (int i = 0; i < kernel_size_len; ++i)
    kernel_size_data[i] = kernel_size_array__.Get(i).ToNumber().Int64Value();
  Napi::Array stride_array__ = info__[4].As<Napi::Array>();
  int stride_len = stride_array__.Length();
  int64_t *stride_data = new int64_t[stride_len];
  for (int i = 0; i < stride_len; ++i)
    stride_data[i] = stride_array__.Get(i).ToNumber().Int64Value();
  Napi::Array padding_array__ = info__[5].As<Napi::Array>();
  int padding_len = padding_array__.Length();
  int64_t *padding_data = new int64_t[padding_len];
  for (int i = 0; i < padding_len; ++i)
    padding_data[i] = padding_array__.Get(i).ToNumber().Int64Value();
  Napi::Array dilation_array__ = info__[6].As<Napi::Array>();
  int dilation_len = dilation_array__.Length();
  int64_t *dilation_data = new int64_t[dilation_len];
  for (int i = 0; i < dilation_len; ++i)
    dilation_data[i] = dilation_array__.Get(i).ToNumber().Int64Value();
  bool ceil_mode = info__[7].As<Napi::Boolean>().Value();
  auto output__ = torch::mkldnn_max_pool2d_backward(*grad_output, *output, *input, torch::IntArrayRef(kernel_size_data, kernel_size_len), torch::IntArrayRef(stride_data, stride_len), torch::IntArrayRef(padding_data, padding_len), torch::IntArrayRef(dilation_data, dilation_len), ceil_mode);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_mkldnn_max_pool2d_backward_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *grad_output = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *output = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *input = info__[3].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array kernel_size_array__ = info__[4].As<Napi::Array>();
  int kernel_size_len = kernel_size_array__.Length();
  int64_t *kernel_size_data = new int64_t[kernel_size_len];
  for (int i = 0; i < kernel_size_len; ++i)
    kernel_size_data[i] = kernel_size_array__.Get(i).ToNumber().Int64Value();
  Napi::Array stride_array__ = info__[5].As<Napi::Array>();
  int stride_len = stride_array__.Length();
  int64_t *stride_data = new int64_t[stride_len];
  for (int i = 0; i < stride_len; ++i)
    stride_data[i] = stride_array__.Get(i).ToNumber().Int64Value();
  Napi::Array padding_array__ = info__[6].As<Napi::Array>();
  int padding_len = padding_array__.Length();
  int64_t *padding_data = new int64_t[padding_len];
  for (int i = 0; i < padding_len; ++i)
    padding_data[i] = padding_array__.Get(i).ToNumber().Int64Value();
  Napi::Array dilation_array__ = info__[7].As<Napi::Array>();
  int dilation_len = dilation_array__.Length();
  int64_t *dilation_data = new int64_t[dilation_len];
  for (int i = 0; i < dilation_len; ++i)
    dilation_data[i] = dilation_array__.Get(i).ToNumber().Int64Value();
  bool ceil_mode = info__[8].As<Napi::Boolean>().Value();
  auto output__ = torch::mkldnn_max_pool2d_backward_out(*out, *grad_output, *output, *input, torch::IntArrayRef(kernel_size_data, kernel_size_len), torch::IntArrayRef(stride_data, stride_len), torch::IntArrayRef(padding_data, padding_len), torch::IntArrayRef(dilation_data, dilation_len), ceil_mode);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_mkldnn_max_pool3d(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array kernel_size_array__ = info__[1].As<Napi::Array>();
  int kernel_size_len = kernel_size_array__.Length();
  int64_t *kernel_size_data = new int64_t[kernel_size_len];
  for (int i = 0; i < kernel_size_len; ++i)
    kernel_size_data[i] = kernel_size_array__.Get(i).ToNumber().Int64Value();
  Napi::Array stride_array__ = info__[2].As<Napi::Array>();
  int stride_len = stride_array__.Length();
  int64_t *stride_data = new int64_t[stride_len];
  for (int i = 0; i < stride_len; ++i)
    stride_data[i] = stride_array__.Get(i).ToNumber().Int64Value();
  Napi::Array padding_array__ = info__[3].As<Napi::Array>();
  int padding_len = padding_array__.Length();
  int64_t *padding_data = new int64_t[padding_len];
  for (int i = 0; i < padding_len; ++i)
    padding_data[i] = padding_array__.Get(i).ToNumber().Int64Value();
  Napi::Array dilation_array__ = info__[4].As<Napi::Array>();
  int dilation_len = dilation_array__.Length();
  int64_t *dilation_data = new int64_t[dilation_len];
  for (int i = 0; i < dilation_len; ++i)
    dilation_data[i] = dilation_array__.Get(i).ToNumber().Int64Value();
  bool ceil_mode = info__[5].As<Napi::Boolean>().Value();
  auto output__ = torch::mkldnn_max_pool3d(*self, torch::IntArrayRef(kernel_size_data, kernel_size_len), torch::IntArrayRef(stride_data, stride_len), torch::IntArrayRef(padding_data, padding_len), torch::IntArrayRef(dilation_data, dilation_len), ceil_mode);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_mkldnn_max_pool3d_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array kernel_size_array__ = info__[2].As<Napi::Array>();
  int kernel_size_len = kernel_size_array__.Length();
  int64_t *kernel_size_data = new int64_t[kernel_size_len];
  for (int i = 0; i < kernel_size_len; ++i)
    kernel_size_data[i] = kernel_size_array__.Get(i).ToNumber().Int64Value();
  Napi::Array stride_array__ = info__[3].As<Napi::Array>();
  int stride_len = stride_array__.Length();
  int64_t *stride_data = new int64_t[stride_len];
  for (int i = 0; i < stride_len; ++i)
    stride_data[i] = stride_array__.Get(i).ToNumber().Int64Value();
  Napi::Array padding_array__ = info__[4].As<Napi::Array>();
  int padding_len = padding_array__.Length();
  int64_t *padding_data = new int64_t[padding_len];
  for (int i = 0; i < padding_len; ++i)
    padding_data[i] = padding_array__.Get(i).ToNumber().Int64Value();
  Napi::Array dilation_array__ = info__[5].As<Napi::Array>();
  int dilation_len = dilation_array__.Length();
  int64_t *dilation_data = new int64_t[dilation_len];
  for (int i = 0; i < dilation_len; ++i)
    dilation_data[i] = dilation_array__.Get(i).ToNumber().Int64Value();
  bool ceil_mode = info__[6].As<Napi::Boolean>().Value();
  auto output__ = torch::mkldnn_max_pool3d_out(*out, *self, torch::IntArrayRef(kernel_size_data, kernel_size_len), torch::IntArrayRef(stride_data, stride_len), torch::IntArrayRef(padding_data, padding_len), torch::IntArrayRef(dilation_data, dilation_len), ceil_mode);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_mkldnn_max_pool3d_backward(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *grad_output = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *output = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *input = info__[2].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array kernel_size_array__ = info__[3].As<Napi::Array>();
  int kernel_size_len = kernel_size_array__.Length();
  int64_t *kernel_size_data = new int64_t[kernel_size_len];
  for (int i = 0; i < kernel_size_len; ++i)
    kernel_size_data[i] = kernel_size_array__.Get(i).ToNumber().Int64Value();
  Napi::Array stride_array__ = info__[4].As<Napi::Array>();
  int stride_len = stride_array__.Length();
  int64_t *stride_data = new int64_t[stride_len];
  for (int i = 0; i < stride_len; ++i)
    stride_data[i] = stride_array__.Get(i).ToNumber().Int64Value();
  Napi::Array padding_array__ = info__[5].As<Napi::Array>();
  int padding_len = padding_array__.Length();
  int64_t *padding_data = new int64_t[padding_len];
  for (int i = 0; i < padding_len; ++i)
    padding_data[i] = padding_array__.Get(i).ToNumber().Int64Value();
  Napi::Array dilation_array__ = info__[6].As<Napi::Array>();
  int dilation_len = dilation_array__.Length();
  int64_t *dilation_data = new int64_t[dilation_len];
  for (int i = 0; i < dilation_len; ++i)
    dilation_data[i] = dilation_array__.Get(i).ToNumber().Int64Value();
  bool ceil_mode = info__[7].As<Napi::Boolean>().Value();
  auto output__ = torch::mkldnn_max_pool3d_backward(*grad_output, *output, *input, torch::IntArrayRef(kernel_size_data, kernel_size_len), torch::IntArrayRef(stride_data, stride_len), torch::IntArrayRef(padding_data, padding_len), torch::IntArrayRef(dilation_data, dilation_len), ceil_mode);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_mkldnn_max_pool3d_backward_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *grad_output = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *output = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *input = info__[3].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array kernel_size_array__ = info__[4].As<Napi::Array>();
  int kernel_size_len = kernel_size_array__.Length();
  int64_t *kernel_size_data = new int64_t[kernel_size_len];
  for (int i = 0; i < kernel_size_len; ++i)
    kernel_size_data[i] = kernel_size_array__.Get(i).ToNumber().Int64Value();
  Napi::Array stride_array__ = info__[5].As<Napi::Array>();
  int stride_len = stride_array__.Length();
  int64_t *stride_data = new int64_t[stride_len];
  for (int i = 0; i < stride_len; ++i)
    stride_data[i] = stride_array__.Get(i).ToNumber().Int64Value();
  Napi::Array padding_array__ = info__[6].As<Napi::Array>();
  int padding_len = padding_array__.Length();
  int64_t *padding_data = new int64_t[padding_len];
  for (int i = 0; i < padding_len; ++i)
    padding_data[i] = padding_array__.Get(i).ToNumber().Int64Value();
  Napi::Array dilation_array__ = info__[7].As<Napi::Array>();
  int dilation_len = dilation_array__.Length();
  int64_t *dilation_data = new int64_t[dilation_len];
  for (int i = 0; i < dilation_len; ++i)
    dilation_data[i] = dilation_array__.Get(i).ToNumber().Int64Value();
  bool ceil_mode = info__[8].As<Napi::Boolean>().Value();
  auto output__ = torch::mkldnn_max_pool3d_backward_out(*out, *grad_output, *output, *input, torch::IntArrayRef(kernel_size_data, kernel_size_len), torch::IntArrayRef(stride_data, stride_len), torch::IntArrayRef(padding_data, padding_len), torch::IntArrayRef(dilation_data, dilation_len), ceil_mode);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_quantized_max_pool1d(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array kernel_size_array__ = info__[1].As<Napi::Array>();
  int kernel_size_len = kernel_size_array__.Length();
  int64_t *kernel_size_data = new int64_t[kernel_size_len];
  for (int i = 0; i < kernel_size_len; ++i)
    kernel_size_data[i] = kernel_size_array__.Get(i).ToNumber().Int64Value();
  Napi::Array stride_array__ = info__[2].As<Napi::Array>();
  int stride_len = stride_array__.Length();
  int64_t *stride_data = new int64_t[stride_len];
  for (int i = 0; i < stride_len; ++i)
    stride_data[i] = stride_array__.Get(i).ToNumber().Int64Value();
  Napi::Array padding_array__ = info__[3].As<Napi::Array>();
  int padding_len = padding_array__.Length();
  int64_t *padding_data = new int64_t[padding_len];
  for (int i = 0; i < padding_len; ++i)
    padding_data[i] = padding_array__.Get(i).ToNumber().Int64Value();
  Napi::Array dilation_array__ = info__[4].As<Napi::Array>();
  int dilation_len = dilation_array__.Length();
  int64_t *dilation_data = new int64_t[dilation_len];
  for (int i = 0; i < dilation_len; ++i)
    dilation_data[i] = dilation_array__.Get(i).ToNumber().Int64Value();
  bool ceil_mode = info__[5].As<Napi::Boolean>().Value();
  auto output__ = torch::quantized_max_pool1d(*self, torch::IntArrayRef(kernel_size_data, kernel_size_len), torch::IntArrayRef(stride_data, stride_len), torch::IntArrayRef(padding_data, padding_len), torch::IntArrayRef(dilation_data, dilation_len), ceil_mode);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_quantized_max_pool1d_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array kernel_size_array__ = info__[2].As<Napi::Array>();
  int kernel_size_len = kernel_size_array__.Length();
  int64_t *kernel_size_data = new int64_t[kernel_size_len];
  for (int i = 0; i < kernel_size_len; ++i)
    kernel_size_data[i] = kernel_size_array__.Get(i).ToNumber().Int64Value();
  Napi::Array stride_array__ = info__[3].As<Napi::Array>();
  int stride_len = stride_array__.Length();
  int64_t *stride_data = new int64_t[stride_len];
  for (int i = 0; i < stride_len; ++i)
    stride_data[i] = stride_array__.Get(i).ToNumber().Int64Value();
  Napi::Array padding_array__ = info__[4].As<Napi::Array>();
  int padding_len = padding_array__.Length();
  int64_t *padding_data = new int64_t[padding_len];
  for (int i = 0; i < padding_len; ++i)
    padding_data[i] = padding_array__.Get(i).ToNumber().Int64Value();
  Napi::Array dilation_array__ = info__[5].As<Napi::Array>();
  int dilation_len = dilation_array__.Length();
  int64_t *dilation_data = new int64_t[dilation_len];
  for (int i = 0; i < dilation_len; ++i)
    dilation_data[i] = dilation_array__.Get(i).ToNumber().Int64Value();
  bool ceil_mode = info__[6].As<Napi::Boolean>().Value();
  auto output__ = torch::quantized_max_pool1d_out(*out, *self, torch::IntArrayRef(kernel_size_data, kernel_size_len), torch::IntArrayRef(stride_data, stride_len), torch::IntArrayRef(padding_data, padding_len), torch::IntArrayRef(dilation_data, dilation_len), ceil_mode);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_quantized_max_pool2d(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array kernel_size_array__ = info__[1].As<Napi::Array>();
  int kernel_size_len = kernel_size_array__.Length();
  int64_t *kernel_size_data = new int64_t[kernel_size_len];
  for (int i = 0; i < kernel_size_len; ++i)
    kernel_size_data[i] = kernel_size_array__.Get(i).ToNumber().Int64Value();
  Napi::Array stride_array__ = info__[2].As<Napi::Array>();
  int stride_len = stride_array__.Length();
  int64_t *stride_data = new int64_t[stride_len];
  for (int i = 0; i < stride_len; ++i)
    stride_data[i] = stride_array__.Get(i).ToNumber().Int64Value();
  Napi::Array padding_array__ = info__[3].As<Napi::Array>();
  int padding_len = padding_array__.Length();
  int64_t *padding_data = new int64_t[padding_len];
  for (int i = 0; i < padding_len; ++i)
    padding_data[i] = padding_array__.Get(i).ToNumber().Int64Value();
  Napi::Array dilation_array__ = info__[4].As<Napi::Array>();
  int dilation_len = dilation_array__.Length();
  int64_t *dilation_data = new int64_t[dilation_len];
  for (int i = 0; i < dilation_len; ++i)
    dilation_data[i] = dilation_array__.Get(i).ToNumber().Int64Value();
  bool ceil_mode = info__[5].As<Napi::Boolean>().Value();
  auto output__ = torch::quantized_max_pool2d(*self, torch::IntArrayRef(kernel_size_data, kernel_size_len), torch::IntArrayRef(stride_data, stride_len), torch::IntArrayRef(padding_data, padding_len), torch::IntArrayRef(dilation_data, dilation_len), ceil_mode);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_quantized_max_pool2d_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array kernel_size_array__ = info__[2].As<Napi::Array>();
  int kernel_size_len = kernel_size_array__.Length();
  int64_t *kernel_size_data = new int64_t[kernel_size_len];
  for (int i = 0; i < kernel_size_len; ++i)
    kernel_size_data[i] = kernel_size_array__.Get(i).ToNumber().Int64Value();
  Napi::Array stride_array__ = info__[3].As<Napi::Array>();
  int stride_len = stride_array__.Length();
  int64_t *stride_data = new int64_t[stride_len];
  for (int i = 0; i < stride_len; ++i)
    stride_data[i] = stride_array__.Get(i).ToNumber().Int64Value();
  Napi::Array padding_array__ = info__[4].As<Napi::Array>();
  int padding_len = padding_array__.Length();
  int64_t *padding_data = new int64_t[padding_len];
  for (int i = 0; i < padding_len; ++i)
    padding_data[i] = padding_array__.Get(i).ToNumber().Int64Value();
  Napi::Array dilation_array__ = info__[5].As<Napi::Array>();
  int dilation_len = dilation_array__.Length();
  int64_t *dilation_data = new int64_t[dilation_len];
  for (int i = 0; i < dilation_len; ++i)
    dilation_data[i] = dilation_array__.Get(i).ToNumber().Int64Value();
  bool ceil_mode = info__[6].As<Napi::Boolean>().Value();
  auto output__ = torch::quantized_max_pool2d_out(*out, *self, torch::IntArrayRef(kernel_size_data, kernel_size_len), torch::IntArrayRef(stride_data, stride_len), torch::IntArrayRef(padding_data, padding_len), torch::IntArrayRef(dilation_data, dilation_len), ceil_mode);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_max_pool3d(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array kernel_size_array__ = info__[1].As<Napi::Array>();
  int kernel_size_len = kernel_size_array__.Length();
  int64_t *kernel_size_data = new int64_t[kernel_size_len];
  for (int i = 0; i < kernel_size_len; ++i)
    kernel_size_data[i] = kernel_size_array__.Get(i).ToNumber().Int64Value();
  Napi::Array stride_array__ = info__[2].As<Napi::Array>();
  int stride_len = stride_array__.Length();
  int64_t *stride_data = new int64_t[stride_len];
  for (int i = 0; i < stride_len; ++i)
    stride_data[i] = stride_array__.Get(i).ToNumber().Int64Value();
  Napi::Array padding_array__ = info__[3].As<Napi::Array>();
  int padding_len = padding_array__.Length();
  int64_t *padding_data = new int64_t[padding_len];
  for (int i = 0; i < padding_len; ++i)
    padding_data[i] = padding_array__.Get(i).ToNumber().Int64Value();
  Napi::Array dilation_array__ = info__[4].As<Napi::Array>();
  int dilation_len = dilation_array__.Length();
  int64_t *dilation_data = new int64_t[dilation_len];
  for (int i = 0; i < dilation_len; ++i)
    dilation_data[i] = dilation_array__.Get(i).ToNumber().Int64Value();
  bool ceil_mode = info__[5].As<Napi::Boolean>().Value();
  auto output__ = torch::max_pool3d(*self, torch::IntArrayRef(kernel_size_data, kernel_size_len), torch::IntArrayRef(stride_data, stride_len), torch::IntArrayRef(padding_data, padding_len), torch::IntArrayRef(dilation_data, dilation_len), ceil_mode);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_mean(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int dtype = info__[1].As<Napi::Number>().Int32Value();
  auto output__ = torch::mean(*self, at::ScalarType(dtype));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_mean_dim(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array dim_array__ = info__[1].As<Napi::Array>();
  int dim_len = dim_array__.Length();
  int64_t *dim_data = new int64_t[dim_len];
  for (int i = 0; i < dim_len; ++i)
    dim_data[i] = dim_array__.Get(i).ToNumber().Int64Value();
  bool keepdim = info__[2].As<Napi::Boolean>().Value();
  int dtype = info__[3].As<Napi::Number>().Int32Value();
  auto output__ = torch::mean(*self, dim_data == nullptr ? c10::nullopt : c10::optional<torch::IntArrayRef>(torch::IntArrayRef(dim_data, dim_len)), keepdim, at::ScalarType(dtype));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_mean_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array dim_array__ = info__[2].As<Napi::Array>();
  int dim_len = dim_array__.Length();
  int64_t *dim_data = new int64_t[dim_len];
  for (int i = 0; i < dim_len; ++i)
    dim_data[i] = dim_array__.Get(i).ToNumber().Int64Value();
  bool keepdim = info__[3].As<Napi::Boolean>().Value();
  int dtype = info__[4].As<Napi::Number>().Int32Value();
  auto output__ = torch::mean_out(*out, *self, dim_data == nullptr ? c10::nullopt : c10::optional<torch::IntArrayRef>(torch::IntArrayRef(dim_data, dim_len)), keepdim, at::ScalarType(dtype));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_nanmean(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array dim_array__ = info__[1].As<Napi::Array>();
  int dim_len = dim_array__.Length();
  int64_t *dim_data = new int64_t[dim_len];
  for (int i = 0; i < dim_len; ++i)
    dim_data[i] = dim_array__.Get(i).ToNumber().Int64Value();
  bool keepdim = info__[2].As<Napi::Boolean>().Value();
  int dtype = info__[3].As<Napi::Number>().Int32Value();
  auto output__ = torch::nanmean(*self, dim_data == nullptr ? c10::nullopt : c10::optional<torch::IntArrayRef>(torch::IntArrayRef(dim_data, dim_len)), keepdim, at::ScalarType(dtype));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_nanmean_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array dim_array__ = info__[2].As<Napi::Array>();
  int dim_len = dim_array__.Length();
  int64_t *dim_data = new int64_t[dim_len];
  for (int i = 0; i < dim_len; ++i)
    dim_data[i] = dim_array__.Get(i).ToNumber().Int64Value();
  bool keepdim = info__[3].As<Napi::Boolean>().Value();
  int dtype = info__[4].As<Napi::Number>().Int32Value();
  auto output__ = torch::nanmean_out(*out, *self, dim_data == nullptr ? c10::nullopt : c10::optional<torch::IntArrayRef>(torch::IntArrayRef(dim_data, dim_len)), keepdim, at::ScalarType(dtype));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_median(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::median(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::Array atg_median_dim(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t dim = info__[1].As<Napi::Number>().Int64Value();
  bool keepdim = info__[2].As<Napi::Boolean>().Value();
  auto output__ = torch::median(*self, dim, keepdim);
  Napi::Array output__array__ = Napi::Array::New(env__, 2);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  return output__array__;
}

Napi::External<torch::Tensor> atg_median_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::median_out(*out, *self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::Array atg_median_dim_values(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *values = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *indices = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[2].As<Napi::External<torch::Tensor>>().Data();
  int64_t dim = info__[3].As<Napi::Number>().Int64Value();
  bool keepdim = info__[4].As<Napi::Boolean>().Value();
  auto output__ = torch::median_out(*values, *indices, *self, dim, keepdim);
  Napi::Array output__array__ = Napi::Array::New(env__, 2);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  return output__array__;
}

Napi::External<torch::Tensor> atg_nanmedian(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::nanmedian(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::Array atg_nanmedian_dim(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t dim = info__[1].As<Napi::Number>().Int64Value();
  bool keepdim = info__[2].As<Napi::Boolean>().Value();
  auto output__ = torch::nanmedian(*self, dim, keepdim);
  Napi::Array output__array__ = Napi::Array::New(env__, 2);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  return output__array__;
}

Napi::External<torch::Tensor> atg_nanmedian_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::nanmedian_out(*out, *self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::Array atg_nanmedian_dim_values(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *values = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *indices = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[2].As<Napi::External<torch::Tensor>>().Data();
  int64_t dim = info__[3].As<Napi::Number>().Int64Value();
  bool keepdim = info__[4].As<Napi::Boolean>().Value();
  auto output__ = torch::nanmedian_out(*values, *indices, *self, dim, keepdim);
  Napi::Array output__array__ = Napi::Array::New(env__, 2);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  return output__array__;
}

Napi::External<torch::Tensor> atg_min(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::min(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_min_other(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::min(*self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::Array atg_min_dim(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t dim = info__[1].As<Napi::Number>().Int64Value();
  bool keepdim = info__[2].As<Napi::Boolean>().Value();
  auto output__ = torch::min(*self, dim, keepdim);
  Napi::Array output__array__ = Napi::Array::New(env__, 2);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  return output__array__;
}

Napi::External<torch::Tensor> atg_min_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[2].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::min_out(*out, *self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::Array atg_min_dim_min(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *min = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *min_indices = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[2].As<Napi::External<torch::Tensor>>().Data();
  int64_t dim = info__[3].As<Napi::Number>().Int64Value();
  bool keepdim = info__[4].As<Napi::Boolean>().Value();
  auto output__ = torch::min_out(*min, *min_indices, *self, dim, keepdim);
  Napi::Array output__array__ = Napi::Array::New(env__, 2);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  return output__array__;
}

Napi::External<torch::Tensor> atg_amin(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array dim_array__ = info__[1].As<Napi::Array>();
  int dim_len = dim_array__.Length();
  int64_t *dim_data = new int64_t[dim_len];
  for (int i = 0; i < dim_len; ++i)
    dim_data[i] = dim_array__.Get(i).ToNumber().Int64Value();
  bool keepdim = info__[2].As<Napi::Boolean>().Value();
  auto output__ = torch::amin(*self, torch::IntArrayRef(dim_data, dim_len), keepdim);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_amin_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array dim_array__ = info__[2].As<Napi::Array>();
  int dim_len = dim_array__.Length();
  int64_t *dim_data = new int64_t[dim_len];
  for (int i = 0; i < dim_len; ++i)
    dim_data[i] = dim_array__.Get(i).ToNumber().Int64Value();
  bool keepdim = info__[3].As<Napi::Boolean>().Value();
  auto output__ = torch::amin_out(*out, *self, torch::IntArrayRef(dim_data, dim_len), keepdim);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__mps_convolution(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *weight = info__[1].As<Napi::External<torch::Tensor>>().Data();
  bool bias_null = info__[2].IsUndefined();
  torch::Tensor *bias_v = bias_null ? nullptr : info__[2].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array padding_array__ = info__[3].As<Napi::Array>();
  int padding_len = padding_array__.Length();
  int64_t *padding_data = new int64_t[padding_len];
  for (int i = 0; i < padding_len; ++i)
    padding_data[i] = padding_array__.Get(i).ToNumber().Int64Value();
  Napi::Array stride_array__ = info__[4].As<Napi::Array>();
  int stride_len = stride_array__.Length();
  int64_t *stride_data = new int64_t[stride_len];
  for (int i = 0; i < stride_len; ++i)
    stride_data[i] = stride_array__.Get(i).ToNumber().Int64Value();
  Napi::Array dilation_array__ = info__[5].As<Napi::Array>();
  int dilation_len = dilation_array__.Length();
  int64_t *dilation_data = new int64_t[dilation_len];
  for (int i = 0; i < dilation_len; ++i)
    dilation_data[i] = dilation_array__.Get(i).ToNumber().Int64Value();
  int64_t groups = info__[6].As<Napi::Number>().Int64Value();
  auto output__ = torch::_mps_convolution(*self, *weight, (bias_null ? *bias_v : torch::Tensor()), torch::IntArrayRef(padding_data, padding_len), torch::IntArrayRef(stride_data, stride_len), torch::IntArrayRef(dilation_data, dilation_len), groups);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__mps_convolution_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *weight = info__[2].As<Napi::External<torch::Tensor>>().Data();
  bool bias_null = info__[3].IsUndefined();
  torch::Tensor *bias_v = bias_null ? nullptr : info__[3].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array padding_array__ = info__[4].As<Napi::Array>();
  int padding_len = padding_array__.Length();
  int64_t *padding_data = new int64_t[padding_len];
  for (int i = 0; i < padding_len; ++i)
    padding_data[i] = padding_array__.Get(i).ToNumber().Int64Value();
  Napi::Array stride_array__ = info__[5].As<Napi::Array>();
  int stride_len = stride_array__.Length();
  int64_t *stride_data = new int64_t[stride_len];
  for (int i = 0; i < stride_len; ++i)
    stride_data[i] = stride_array__.Get(i).ToNumber().Int64Value();
  Napi::Array dilation_array__ = info__[6].As<Napi::Array>();
  int dilation_len = dilation_array__.Length();
  int64_t *dilation_data = new int64_t[dilation_len];
  for (int i = 0; i < dilation_len; ++i)
    dilation_data[i] = dilation_array__.Get(i).ToNumber().Int64Value();
  int64_t groups = info__[7].As<Napi::Number>().Int64Value();
  auto output__ = torch::_mps_convolution_out(*out, *self, *weight, (bias_null ? *bias_v : torch::Tensor()), torch::IntArrayRef(padding_data, padding_len), torch::IntArrayRef(stride_data, stride_len), torch::IntArrayRef(dilation_data, dilation_len), groups);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_mkldnn_convolution(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *weight = info__[1].As<Napi::External<torch::Tensor>>().Data();
  bool bias_null = info__[2].IsUndefined();
  torch::Tensor *bias_v = bias_null ? nullptr : info__[2].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array padding_array__ = info__[3].As<Napi::Array>();
  int padding_len = padding_array__.Length();
  int64_t *padding_data = new int64_t[padding_len];
  for (int i = 0; i < padding_len; ++i)
    padding_data[i] = padding_array__.Get(i).ToNumber().Int64Value();
  Napi::Array stride_array__ = info__[4].As<Napi::Array>();
  int stride_len = stride_array__.Length();
  int64_t *stride_data = new int64_t[stride_len];
  for (int i = 0; i < stride_len; ++i)
    stride_data[i] = stride_array__.Get(i).ToNumber().Int64Value();
  Napi::Array dilation_array__ = info__[5].As<Napi::Array>();
  int dilation_len = dilation_array__.Length();
  int64_t *dilation_data = new int64_t[dilation_len];
  for (int i = 0; i < dilation_len; ++i)
    dilation_data[i] = dilation_array__.Get(i).ToNumber().Int64Value();
  int64_t groups = info__[6].As<Napi::Number>().Int64Value();
  auto output__ = torch::mkldnn_convolution(*self, *weight, (bias_null ? *bias_v : torch::Tensor()), torch::IntArrayRef(padding_data, padding_len), torch::IntArrayRef(stride_data, stride_len), torch::IntArrayRef(dilation_data, dilation_len), groups);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_mkldnn_convolution_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *weight = info__[2].As<Napi::External<torch::Tensor>>().Data();
  bool bias_null = info__[3].IsUndefined();
  torch::Tensor *bias_v = bias_null ? nullptr : info__[3].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array padding_array__ = info__[4].As<Napi::Array>();
  int padding_len = padding_array__.Length();
  int64_t *padding_data = new int64_t[padding_len];
  for (int i = 0; i < padding_len; ++i)
    padding_data[i] = padding_array__.Get(i).ToNumber().Int64Value();
  Napi::Array stride_array__ = info__[5].As<Napi::Array>();
  int stride_len = stride_array__.Length();
  int64_t *stride_data = new int64_t[stride_len];
  for (int i = 0; i < stride_len; ++i)
    stride_data[i] = stride_array__.Get(i).ToNumber().Int64Value();
  Napi::Array dilation_array__ = info__[6].As<Napi::Array>();
  int dilation_len = dilation_array__.Length();
  int64_t *dilation_data = new int64_t[dilation_len];
  for (int i = 0; i < dilation_len; ++i)
    dilation_data[i] = dilation_array__.Get(i).ToNumber().Int64Value();
  int64_t groups = info__[7].As<Napi::Number>().Int64Value();
  auto output__ = torch::mkldnn_convolution_out(*out, *self, *weight, (bias_null ? *bias_v : torch::Tensor()), torch::IntArrayRef(padding_data, padding_len), torch::IntArrayRef(stride_data, stride_len), torch::IntArrayRef(dilation_data, dilation_len), groups);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::Array atg_mkldnn_rnn_layer(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *input = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *weight0 = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *weight1 = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *weight2 = info__[3].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *weight3 = info__[4].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *hx_ = info__[5].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *cx_ = info__[6].As<Napi::External<torch::Tensor>>().Data();
  bool reverse = info__[7].As<Napi::Boolean>().Value();
  Napi::Array batch_sizes_array__ = info__[8].As<Napi::Array>();
  int batch_sizes_len = batch_sizes_array__.Length();
  int64_t *batch_sizes_data = new int64_t[batch_sizes_len];
  for (int i = 0; i < batch_sizes_len; ++i)
    batch_sizes_data[i] = batch_sizes_array__.Get(i).ToNumber().Int64Value();
  int64_t mode = info__[9].As<Napi::Number>().Int64Value();
  int64_t hidden_size = info__[10].As<Napi::Number>().Int64Value();
  int64_t num_layers = info__[11].As<Napi::Number>().Int64Value();
  bool has_biases = info__[12].As<Napi::Boolean>().Value();
  bool bidirectional = info__[13].As<Napi::Boolean>().Value();
  bool batch_first = info__[14].As<Napi::Boolean>().Value();
  bool train = info__[15].As<Napi::Boolean>().Value();
  auto output__ = torch::mkldnn_rnn_layer(*input, *weight0, *weight1, *weight2, *weight3, *hx_, *cx_, reverse, torch::IntArrayRef(batch_sizes_data, batch_sizes_len), mode, hidden_size, num_layers, has_biases, bidirectional, batch_first, train);
  Napi::Array output__array__ = Napi::Array::New(env__, 4);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  output__array__[2u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<2>(output__)));
  output__array__[3u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<3>(output__)));
  return output__array__;
}

Napi::Array atg_mkldnn_rnn_layer_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out0 = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *out1 = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *out2 = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *out3 = info__[3].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *input = info__[4].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *weight0 = info__[5].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *weight1 = info__[6].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *weight2 = info__[7].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *weight3 = info__[8].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *hx_ = info__[9].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *cx_ = info__[10].As<Napi::External<torch::Tensor>>().Data();
  bool reverse = info__[11].As<Napi::Boolean>().Value();
  Napi::Array batch_sizes_array__ = info__[12].As<Napi::Array>();
  int batch_sizes_len = batch_sizes_array__.Length();
  int64_t *batch_sizes_data = new int64_t[batch_sizes_len];
  for (int i = 0; i < batch_sizes_len; ++i)
    batch_sizes_data[i] = batch_sizes_array__.Get(i).ToNumber().Int64Value();
  int64_t mode = info__[13].As<Napi::Number>().Int64Value();
  int64_t hidden_size = info__[14].As<Napi::Number>().Int64Value();
  int64_t num_layers = info__[15].As<Napi::Number>().Int64Value();
  bool has_biases = info__[16].As<Napi::Boolean>().Value();
  bool bidirectional = info__[17].As<Napi::Boolean>().Value();
  bool batch_first = info__[18].As<Napi::Boolean>().Value();
  bool train = info__[19].As<Napi::Boolean>().Value();
  auto output__ = torch::mkldnn_rnn_layer_out(*out0, *out1, *out2, *out3, *input, *weight0, *weight1, *weight2, *weight3, *hx_, *cx_, reverse, torch::IntArrayRef(batch_sizes_data, batch_sizes_len), mode, hidden_size, num_layers, has_biases, bidirectional, batch_first, train);
  Napi::Array output__array__ = Napi::Array::New(env__, 4);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  output__array__[2u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<2>(output__)));
  output__array__[3u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<3>(output__)));
  return output__array__;
}

Napi::Array atg_mkldnn_rnn_layer_backward(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *input = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *weight1 = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *weight2 = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *weight3 = info__[3].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *weight4 = info__[4].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *hx_ = info__[5].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *cx_tmp = info__[6].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *output = info__[7].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *hy_ = info__[8].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *cy_ = info__[9].As<Napi::External<torch::Tensor>>().Data();
  bool grad_output_null = info__[10].IsUndefined();
  torch::Tensor *grad_output_v = grad_output_null ? nullptr : info__[10].As<Napi::External<torch::Tensor>>().Data();
  bool grad_hy_null = info__[11].IsUndefined();
  torch::Tensor *grad_hy_v = grad_hy_null ? nullptr : info__[11].As<Napi::External<torch::Tensor>>().Data();
  bool grad_cy_null = info__[12].IsUndefined();
  torch::Tensor *grad_cy_v = grad_cy_null ? nullptr : info__[12].As<Napi::External<torch::Tensor>>().Data();
  bool reverse = info__[13].As<Napi::Boolean>().Value();
  int64_t mode = info__[14].As<Napi::Number>().Int64Value();
  int64_t hidden_size = info__[15].As<Napi::Number>().Int64Value();
  int64_t num_layers = info__[16].As<Napi::Number>().Int64Value();
  bool has_biases = info__[17].As<Napi::Boolean>().Value();
  bool train = info__[18].As<Napi::Boolean>().Value();
  bool bidirectional = info__[19].As<Napi::Boolean>().Value();
  Napi::Array batch_sizes_array__ = info__[20].As<Napi::Array>();
  int batch_sizes_len = batch_sizes_array__.Length();
  int64_t *batch_sizes_data = new int64_t[batch_sizes_len];
  for (int i = 0; i < batch_sizes_len; ++i)
    batch_sizes_data[i] = batch_sizes_array__.Get(i).ToNumber().Int64Value();
  bool batch_first = info__[21].As<Napi::Boolean>().Value();
  torch::Tensor *workspace = info__[22].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::mkldnn_rnn_layer_backward(*input, *weight1, *weight2, *weight3, *weight4, *hx_, *cx_tmp, *output, *hy_, *cy_, (grad_output_null ? *grad_output_v : torch::Tensor()), (grad_hy_null ? *grad_hy_v : torch::Tensor()), (grad_cy_null ? *grad_cy_v : torch::Tensor()), reverse, mode, hidden_size, num_layers, has_biases, train, bidirectional, torch::IntArrayRef(batch_sizes_data, batch_sizes_len), batch_first, *workspace);
  Napi::Array output__array__ = Napi::Array::New(env__, 7);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  output__array__[2u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<2>(output__)));
  output__array__[3u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<3>(output__)));
  output__array__[4u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<4>(output__)));
  output__array__[5u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<5>(output__)));
  output__array__[6u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<6>(output__)));
  return output__array__;
}

Napi::Array atg_mkldnn_rnn_layer_backward_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out0 = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *out1 = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *out2 = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *out3 = info__[3].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *out4 = info__[4].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *out5 = info__[5].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *out6 = info__[6].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *input = info__[7].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *weight1 = info__[8].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *weight2 = info__[9].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *weight3 = info__[10].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *weight4 = info__[11].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *hx_ = info__[12].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *cx_tmp = info__[13].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *output = info__[14].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *hy_ = info__[15].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *cy_ = info__[16].As<Napi::External<torch::Tensor>>().Data();
  bool grad_output_null = info__[17].IsUndefined();
  torch::Tensor *grad_output_v = grad_output_null ? nullptr : info__[17].As<Napi::External<torch::Tensor>>().Data();
  bool grad_hy_null = info__[18].IsUndefined();
  torch::Tensor *grad_hy_v = grad_hy_null ? nullptr : info__[18].As<Napi::External<torch::Tensor>>().Data();
  bool grad_cy_null = info__[19].IsUndefined();
  torch::Tensor *grad_cy_v = grad_cy_null ? nullptr : info__[19].As<Napi::External<torch::Tensor>>().Data();
  bool reverse = info__[20].As<Napi::Boolean>().Value();
  int64_t mode = info__[21].As<Napi::Number>().Int64Value();
  int64_t hidden_size = info__[22].As<Napi::Number>().Int64Value();
  int64_t num_layers = info__[23].As<Napi::Number>().Int64Value();
  bool has_biases = info__[24].As<Napi::Boolean>().Value();
  bool train = info__[25].As<Napi::Boolean>().Value();
  bool bidirectional = info__[26].As<Napi::Boolean>().Value();
  Napi::Array batch_sizes_array__ = info__[27].As<Napi::Array>();
  int batch_sizes_len = batch_sizes_array__.Length();
  int64_t *batch_sizes_data = new int64_t[batch_sizes_len];
  for (int i = 0; i < batch_sizes_len; ++i)
    batch_sizes_data[i] = batch_sizes_array__.Get(i).ToNumber().Int64Value();
  bool batch_first = info__[28].As<Napi::Boolean>().Value();
  torch::Tensor *workspace = info__[29].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::mkldnn_rnn_layer_backward_out(*out0, *out1, *out2, *out3, *out4, *out5, *out6, *input, *weight1, *weight2, *weight3, *weight4, *hx_, *cx_tmp, *output, *hy_, *cy_, (grad_output_null ? *grad_output_v : torch::Tensor()), (grad_hy_null ? *grad_hy_v : torch::Tensor()), (grad_cy_null ? *grad_cy_v : torch::Tensor()), reverse, mode, hidden_size, num_layers, has_biases, train, bidirectional, torch::IntArrayRef(batch_sizes_data, batch_sizes_len), batch_first, *workspace);
  Napi::Array output__array__ = Napi::Array::New(env__, 7);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  output__array__[2u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<2>(output__)));
  output__array__[3u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<3>(output__)));
  output__array__[4u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<4>(output__)));
  output__array__[5u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<5>(output__)));
  output__array__[6u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<6>(output__)));
  return output__array__;
}

Napi::Array atg_miopen_batch_norm(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *input = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *weight = info__[1].As<Napi::External<torch::Tensor>>().Data();
  bool bias_null = info__[2].IsUndefined();
  torch::Tensor *bias_v = bias_null ? nullptr : info__[2].As<Napi::External<torch::Tensor>>().Data();
  bool running_mean_null = info__[3].IsUndefined();
  torch::Tensor *running_mean_v = running_mean_null ? nullptr : info__[3].As<Napi::External<torch::Tensor>>().Data();
  bool running_var_null = info__[4].IsUndefined();
  torch::Tensor *running_var_v = running_var_null ? nullptr : info__[4].As<Napi::External<torch::Tensor>>().Data();
  bool training = info__[5].As<Napi::Boolean>().Value();
  double exponential_average_factor = info__[6].As<Napi::Number>().DoubleValue();
  double epsilon = info__[7].As<Napi::Number>().DoubleValue();
  auto output__ = torch::miopen_batch_norm(*input, *weight, (bias_null ? *bias_v : torch::Tensor()), (running_mean_null ? *running_mean_v : torch::Tensor()), (running_var_null ? *running_var_v : torch::Tensor()), training, exponential_average_factor, epsilon);
  Napi::Array output__array__ = Napi::Array::New(env__, 3);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  output__array__[2u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<2>(output__)));
  return output__array__;
}

Napi::Array atg_miopen_batch_norm_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out0 = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *out1 = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *out2 = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *input = info__[3].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *weight = info__[4].As<Napi::External<torch::Tensor>>().Data();
  bool bias_null = info__[5].IsUndefined();
  torch::Tensor *bias_v = bias_null ? nullptr : info__[5].As<Napi::External<torch::Tensor>>().Data();
  bool running_mean_null = info__[6].IsUndefined();
  torch::Tensor *running_mean_v = running_mean_null ? nullptr : info__[6].As<Napi::External<torch::Tensor>>().Data();
  bool running_var_null = info__[7].IsUndefined();
  torch::Tensor *running_var_v = running_var_null ? nullptr : info__[7].As<Napi::External<torch::Tensor>>().Data();
  bool training = info__[8].As<Napi::Boolean>().Value();
  double exponential_average_factor = info__[9].As<Napi::Number>().DoubleValue();
  double epsilon = info__[10].As<Napi::Number>().DoubleValue();
  auto output__ = torch::miopen_batch_norm_out(*out0, *out1, *out2, *input, *weight, (bias_null ? *bias_v : torch::Tensor()), (running_mean_null ? *running_mean_v : torch::Tensor()), (running_var_null ? *running_var_v : torch::Tensor()), training, exponential_average_factor, epsilon);
  Napi::Array output__array__ = Napi::Array::New(env__, 3);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  output__array__[2u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<2>(output__)));
  return output__array__;
}

Napi::Array atg_miopen_batch_norm_backward(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *input = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *grad_output = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *weight = info__[2].As<Napi::External<torch::Tensor>>().Data();
  bool running_mean_null = info__[3].IsUndefined();
  torch::Tensor *running_mean_v = running_mean_null ? nullptr : info__[3].As<Napi::External<torch::Tensor>>().Data();
  bool running_var_null = info__[4].IsUndefined();
  torch::Tensor *running_var_v = running_var_null ? nullptr : info__[4].As<Napi::External<torch::Tensor>>().Data();
  bool save_mean_null = info__[5].IsUndefined();
  torch::Tensor *save_mean_v = save_mean_null ? nullptr : info__[5].As<Napi::External<torch::Tensor>>().Data();
  bool save_var_null = info__[6].IsUndefined();
  torch::Tensor *save_var_v = save_var_null ? nullptr : info__[6].As<Napi::External<torch::Tensor>>().Data();
  double epsilon = info__[7].As<Napi::Number>().DoubleValue();
  auto output__ = torch::miopen_batch_norm_backward(*input, *grad_output, *weight, (running_mean_null ? *running_mean_v : torch::Tensor()), (running_var_null ? *running_var_v : torch::Tensor()), (save_mean_null ? *save_mean_v : torch::Tensor()), (save_var_null ? *save_var_v : torch::Tensor()), epsilon);
  Napi::Array output__array__ = Napi::Array::New(env__, 3);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  output__array__[2u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<2>(output__)));
  return output__array__;
}

Napi::Array atg_miopen_batch_norm_backward_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out0 = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *out1 = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *out2 = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *input = info__[3].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *grad_output = info__[4].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *weight = info__[5].As<Napi::External<torch::Tensor>>().Data();
  bool running_mean_null = info__[6].IsUndefined();
  torch::Tensor *running_mean_v = running_mean_null ? nullptr : info__[6].As<Napi::External<torch::Tensor>>().Data();
  bool running_var_null = info__[7].IsUndefined();
  torch::Tensor *running_var_v = running_var_null ? nullptr : info__[7].As<Napi::External<torch::Tensor>>().Data();
  bool save_mean_null = info__[8].IsUndefined();
  torch::Tensor *save_mean_v = save_mean_null ? nullptr : info__[8].As<Napi::External<torch::Tensor>>().Data();
  bool save_var_null = info__[9].IsUndefined();
  torch::Tensor *save_var_v = save_var_null ? nullptr : info__[9].As<Napi::External<torch::Tensor>>().Data();
  double epsilon = info__[10].As<Napi::Number>().DoubleValue();
  auto output__ = torch::miopen_batch_norm_backward_out(*out0, *out1, *out2, *input, *grad_output, *weight, (running_mean_null ? *running_mean_v : torch::Tensor()), (running_var_null ? *running_var_v : torch::Tensor()), (save_mean_null ? *save_mean_v : torch::Tensor()), (save_var_null ? *save_var_v : torch::Tensor()), epsilon);
  Napi::Array output__array__ = Napi::Array::New(env__, 3);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  output__array__[2u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<2>(output__)));
  return output__array__;
}

Napi::External<torch::Tensor> atg_miopen_convolution(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *weight = info__[1].As<Napi::External<torch::Tensor>>().Data();
  bool bias_null = info__[2].IsUndefined();
  torch::Tensor *bias_v = bias_null ? nullptr : info__[2].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array padding_array__ = info__[3].As<Napi::Array>();
  int padding_len = padding_array__.Length();
  int64_t *padding_data = new int64_t[padding_len];
  for (int i = 0; i < padding_len; ++i)
    padding_data[i] = padding_array__.Get(i).ToNumber().Int64Value();
  Napi::Array stride_array__ = info__[4].As<Napi::Array>();
  int stride_len = stride_array__.Length();
  int64_t *stride_data = new int64_t[stride_len];
  for (int i = 0; i < stride_len; ++i)
    stride_data[i] = stride_array__.Get(i).ToNumber().Int64Value();
  Napi::Array dilation_array__ = info__[5].As<Napi::Array>();
  int dilation_len = dilation_array__.Length();
  int64_t *dilation_data = new int64_t[dilation_len];
  for (int i = 0; i < dilation_len; ++i)
    dilation_data[i] = dilation_array__.Get(i).ToNumber().Int64Value();
  int64_t groups = info__[6].As<Napi::Number>().Int64Value();
  bool benchmark = info__[7].As<Napi::Boolean>().Value();
  bool deterministic = info__[8].As<Napi::Boolean>().Value();
  auto output__ = torch::miopen_convolution(*self, *weight, (bias_null ? *bias_v : torch::Tensor()), torch::IntArrayRef(padding_data, padding_len), torch::IntArrayRef(stride_data, stride_len), torch::IntArrayRef(dilation_data, dilation_len), groups, benchmark, deterministic);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_miopen_convolution_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *weight = info__[2].As<Napi::External<torch::Tensor>>().Data();
  bool bias_null = info__[3].IsUndefined();
  torch::Tensor *bias_v = bias_null ? nullptr : info__[3].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array padding_array__ = info__[4].As<Napi::Array>();
  int padding_len = padding_array__.Length();
  int64_t *padding_data = new int64_t[padding_len];
  for (int i = 0; i < padding_len; ++i)
    padding_data[i] = padding_array__.Get(i).ToNumber().Int64Value();
  Napi::Array stride_array__ = info__[5].As<Napi::Array>();
  int stride_len = stride_array__.Length();
  int64_t *stride_data = new int64_t[stride_len];
  for (int i = 0; i < stride_len; ++i)
    stride_data[i] = stride_array__.Get(i).ToNumber().Int64Value();
  Napi::Array dilation_array__ = info__[6].As<Napi::Array>();
  int dilation_len = dilation_array__.Length();
  int64_t *dilation_data = new int64_t[dilation_len];
  for (int i = 0; i < dilation_len; ++i)
    dilation_data[i] = dilation_array__.Get(i).ToNumber().Int64Value();
  int64_t groups = info__[7].As<Napi::Number>().Int64Value();
  bool benchmark = info__[8].As<Napi::Boolean>().Value();
  bool deterministic = info__[9].As<Napi::Boolean>().Value();
  auto output__ = torch::miopen_convolution_out(*out, *self, *weight, (bias_null ? *bias_v : torch::Tensor()), torch::IntArrayRef(padding_data, padding_len), torch::IntArrayRef(stride_data, stride_len), torch::IntArrayRef(dilation_data, dilation_len), groups, benchmark, deterministic);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_miopen_convolution_transpose(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *weight = info__[1].As<Napi::External<torch::Tensor>>().Data();
  bool bias_null = info__[2].IsUndefined();
  torch::Tensor *bias_v = bias_null ? nullptr : info__[2].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array padding_array__ = info__[3].As<Napi::Array>();
  int padding_len = padding_array__.Length();
  int64_t *padding_data = new int64_t[padding_len];
  for (int i = 0; i < padding_len; ++i)
    padding_data[i] = padding_array__.Get(i).ToNumber().Int64Value();
  Napi::Array output_padding_array__ = info__[4].As<Napi::Array>();
  int output_padding_len = output_padding_array__.Length();
  int64_t *output_padding_data = new int64_t[output_padding_len];
  for (int i = 0; i < output_padding_len; ++i)
    output_padding_data[i] = output_padding_array__.Get(i).ToNumber().Int64Value();
  Napi::Array stride_array__ = info__[5].As<Napi::Array>();
  int stride_len = stride_array__.Length();
  int64_t *stride_data = new int64_t[stride_len];
  for (int i = 0; i < stride_len; ++i)
    stride_data[i] = stride_array__.Get(i).ToNumber().Int64Value();
  Napi::Array dilation_array__ = info__[6].As<Napi::Array>();
  int dilation_len = dilation_array__.Length();
  int64_t *dilation_data = new int64_t[dilation_len];
  for (int i = 0; i < dilation_len; ++i)
    dilation_data[i] = dilation_array__.Get(i).ToNumber().Int64Value();
  int64_t groups = info__[7].As<Napi::Number>().Int64Value();
  bool benchmark = info__[8].As<Napi::Boolean>().Value();
  bool deterministic = info__[9].As<Napi::Boolean>().Value();
  auto output__ = torch::miopen_convolution_transpose(*self, *weight, (bias_null ? *bias_v : torch::Tensor()), torch::IntArrayRef(padding_data, padding_len), torch::IntArrayRef(output_padding_data, output_padding_len), torch::IntArrayRef(stride_data, stride_len), torch::IntArrayRef(dilation_data, dilation_len), groups, benchmark, deterministic);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_miopen_convolution_transpose_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *weight = info__[2].As<Napi::External<torch::Tensor>>().Data();
  bool bias_null = info__[3].IsUndefined();
  torch::Tensor *bias_v = bias_null ? nullptr : info__[3].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array padding_array__ = info__[4].As<Napi::Array>();
  int padding_len = padding_array__.Length();
  int64_t *padding_data = new int64_t[padding_len];
  for (int i = 0; i < padding_len; ++i)
    padding_data[i] = padding_array__.Get(i).ToNumber().Int64Value();
  Napi::Array output_padding_array__ = info__[5].As<Napi::Array>();
  int output_padding_len = output_padding_array__.Length();
  int64_t *output_padding_data = new int64_t[output_padding_len];
  for (int i = 0; i < output_padding_len; ++i)
    output_padding_data[i] = output_padding_array__.Get(i).ToNumber().Int64Value();
  Napi::Array stride_array__ = info__[6].As<Napi::Array>();
  int stride_len = stride_array__.Length();
  int64_t *stride_data = new int64_t[stride_len];
  for (int i = 0; i < stride_len; ++i)
    stride_data[i] = stride_array__.Get(i).ToNumber().Int64Value();
  Napi::Array dilation_array__ = info__[7].As<Napi::Array>();
  int dilation_len = dilation_array__.Length();
  int64_t *dilation_data = new int64_t[dilation_len];
  for (int i = 0; i < dilation_len; ++i)
    dilation_data[i] = dilation_array__.Get(i).ToNumber().Int64Value();
  int64_t groups = info__[8].As<Napi::Number>().Int64Value();
  bool benchmark = info__[9].As<Napi::Boolean>().Value();
  bool deterministic = info__[10].As<Napi::Boolean>().Value();
  auto output__ = torch::miopen_convolution_transpose_out(*out, *self, *weight, (bias_null ? *bias_v : torch::Tensor()), torch::IntArrayRef(padding_data, padding_len), torch::IntArrayRef(output_padding_data, output_padding_len), torch::IntArrayRef(stride_data, stride_len), torch::IntArrayRef(dilation_data, dilation_len), groups, benchmark, deterministic);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_miopen_depthwise_convolution(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *weight = info__[1].As<Napi::External<torch::Tensor>>().Data();
  bool bias_null = info__[2].IsUndefined();
  torch::Tensor *bias_v = bias_null ? nullptr : info__[2].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array padding_array__ = info__[3].As<Napi::Array>();
  int padding_len = padding_array__.Length();
  int64_t *padding_data = new int64_t[padding_len];
  for (int i = 0; i < padding_len; ++i)
    padding_data[i] = padding_array__.Get(i).ToNumber().Int64Value();
  Napi::Array stride_array__ = info__[4].As<Napi::Array>();
  int stride_len = stride_array__.Length();
  int64_t *stride_data = new int64_t[stride_len];
  for (int i = 0; i < stride_len; ++i)
    stride_data[i] = stride_array__.Get(i).ToNumber().Int64Value();
  Napi::Array dilation_array__ = info__[5].As<Napi::Array>();
  int dilation_len = dilation_array__.Length();
  int64_t *dilation_data = new int64_t[dilation_len];
  for (int i = 0; i < dilation_len; ++i)
    dilation_data[i] = dilation_array__.Get(i).ToNumber().Int64Value();
  int64_t groups = info__[6].As<Napi::Number>().Int64Value();
  bool benchmark = info__[7].As<Napi::Boolean>().Value();
  bool deterministic = info__[8].As<Napi::Boolean>().Value();
  auto output__ = torch::miopen_depthwise_convolution(*self, *weight, (bias_null ? *bias_v : torch::Tensor()), torch::IntArrayRef(padding_data, padding_len), torch::IntArrayRef(stride_data, stride_len), torch::IntArrayRef(dilation_data, dilation_len), groups, benchmark, deterministic);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_miopen_depthwise_convolution_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *weight = info__[2].As<Napi::External<torch::Tensor>>().Data();
  bool bias_null = info__[3].IsUndefined();
  torch::Tensor *bias_v = bias_null ? nullptr : info__[3].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array padding_array__ = info__[4].As<Napi::Array>();
  int padding_len = padding_array__.Length();
  int64_t *padding_data = new int64_t[padding_len];
  for (int i = 0; i < padding_len; ++i)
    padding_data[i] = padding_array__.Get(i).ToNumber().Int64Value();
  Napi::Array stride_array__ = info__[5].As<Napi::Array>();
  int stride_len = stride_array__.Length();
  int64_t *stride_data = new int64_t[stride_len];
  for (int i = 0; i < stride_len; ++i)
    stride_data[i] = stride_array__.Get(i).ToNumber().Int64Value();
  Napi::Array dilation_array__ = info__[6].As<Napi::Array>();
  int dilation_len = dilation_array__.Length();
  int64_t *dilation_data = new int64_t[dilation_len];
  for (int i = 0; i < dilation_len; ++i)
    dilation_data[i] = dilation_array__.Get(i).ToNumber().Int64Value();
  int64_t groups = info__[7].As<Napi::Number>().Int64Value();
  bool benchmark = info__[8].As<Napi::Boolean>().Value();
  bool deterministic = info__[9].As<Napi::Boolean>().Value();
  auto output__ = torch::miopen_depthwise_convolution_out(*out, *self, *weight, (bias_null ? *bias_v : torch::Tensor()), torch::IntArrayRef(padding_data, padding_len), torch::IntArrayRef(stride_data, stride_len), torch::IntArrayRef(dilation_data, dilation_len), groups, benchmark, deterministic);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_miopen_convolution_relu(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *weight = info__[1].As<Napi::External<torch::Tensor>>().Data();
  bool bias_null = info__[2].IsUndefined();
  torch::Tensor *bias_v = bias_null ? nullptr : info__[2].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array stride_array__ = info__[3].As<Napi::Array>();
  int stride_len = stride_array__.Length();
  int64_t *stride_data = new int64_t[stride_len];
  for (int i = 0; i < stride_len; ++i)
    stride_data[i] = stride_array__.Get(i).ToNumber().Int64Value();
  Napi::Array padding_array__ = info__[4].As<Napi::Array>();
  int padding_len = padding_array__.Length();
  int64_t *padding_data = new int64_t[padding_len];
  for (int i = 0; i < padding_len; ++i)
    padding_data[i] = padding_array__.Get(i).ToNumber().Int64Value();
  Napi::Array dilation_array__ = info__[5].As<Napi::Array>();
  int dilation_len = dilation_array__.Length();
  int64_t *dilation_data = new int64_t[dilation_len];
  for (int i = 0; i < dilation_len; ++i)
    dilation_data[i] = dilation_array__.Get(i).ToNumber().Int64Value();
  int64_t groups = info__[6].As<Napi::Number>().Int64Value();
  auto output__ = torch::miopen_convolution_relu(*self, *weight, (bias_null ? *bias_v : torch::Tensor()), torch::IntArrayRef(stride_data, stride_len), torch::IntArrayRef(padding_data, padding_len), torch::IntArrayRef(dilation_data, dilation_len), groups);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_miopen_convolution_add_relu(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *weight = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *z = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *alpha = info__[3].As<Napi::External<torch::Scalar>>().Data();
  bool bias_null = info__[4].IsUndefined();
  torch::Tensor *bias_v = bias_null ? nullptr : info__[4].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array stride_array__ = info__[5].As<Napi::Array>();
  int stride_len = stride_array__.Length();
  int64_t *stride_data = new int64_t[stride_len];
  for (int i = 0; i < stride_len; ++i)
    stride_data[i] = stride_array__.Get(i).ToNumber().Int64Value();
  Napi::Array padding_array__ = info__[6].As<Napi::Array>();
  int padding_len = padding_array__.Length();
  int64_t *padding_data = new int64_t[padding_len];
  for (int i = 0; i < padding_len; ++i)
    padding_data[i] = padding_array__.Get(i).ToNumber().Int64Value();
  Napi::Array dilation_array__ = info__[7].As<Napi::Array>();
  int dilation_len = dilation_array__.Length();
  int64_t *dilation_data = new int64_t[dilation_len];
  for (int i = 0; i < dilation_len; ++i)
    dilation_data[i] = dilation_array__.Get(i).ToNumber().Int64Value();
  int64_t groups = info__[8].As<Napi::Number>().Int64Value();
  auto output__ = torch::miopen_convolution_add_relu(*self, *weight, *z, *alpha, (bias_null ? *bias_v : torch::Tensor()), torch::IntArrayRef(stride_data, stride_len), torch::IntArrayRef(padding_data, padding_len), torch::IntArrayRef(dilation_data, dilation_len), groups);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::Array atg_miopen_rnn(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *input = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array weight_array__ = info__[1].As<Napi::Array>();
  int weight_len = weight_array__.Length();
  torch::Tensor **weight_data = new torch::Tensor *[weight_len];
  for (int i = 0; i < weight_len; ++i)
    weight_data[i] = weight_array__.Get(i).As<Napi::External<torch::Tensor>>().Data();
  int64_t weight_stride0 = info__[2].As<Napi::Number>().Int64Value();
  torch::Tensor *hx = info__[3].As<Napi::External<torch::Tensor>>().Data();
  bool cx_null = info__[4].IsUndefined();
  torch::Tensor *cx_v = cx_null ? nullptr : info__[4].As<Napi::External<torch::Tensor>>().Data();
  int64_t mode = info__[5].As<Napi::Number>().Int64Value();
  int64_t hidden_size = info__[6].As<Napi::Number>().Int64Value();
  int64_t num_layers = info__[7].As<Napi::Number>().Int64Value();
  bool batch_first = info__[8].As<Napi::Boolean>().Value();
  double dropout = info__[9].As<Napi::Number>().DoubleValue();
  bool train = info__[10].As<Napi::Boolean>().Value();
  bool bidirectional = info__[11].As<Napi::Boolean>().Value();
  Napi::Array batch_sizes_array__ = info__[12].As<Napi::Array>();
  int batch_sizes_len = batch_sizes_array__.Length();
  int64_t *batch_sizes_data = new int64_t[batch_sizes_len];
  for (int i = 0; i < batch_sizes_len; ++i)
    batch_sizes_data[i] = batch_sizes_array__.Get(i).ToNumber().Int64Value();
  bool dropout_state_null = info__[13].IsUndefined();
  torch::Tensor *dropout_state_v = dropout_state_null ? nullptr : info__[13].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::miopen_rnn(*input, of_carray_tensor(weight_data, weight_len), weight_stride0, *hx, (cx_null ? *cx_v : torch::Tensor()), mode, hidden_size, num_layers, batch_first, dropout, train, bidirectional, torch::IntArrayRef(batch_sizes_data, batch_sizes_len), (dropout_state_null ? *dropout_state_v : torch::Tensor()));
  Napi::Array output__array__ = Napi::Array::New(env__, 5);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  output__array__[2u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<2>(output__)));
  output__array__[3u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<3>(output__)));
  output__array__[4u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<4>(output__)));
  return output__array__;
}

Napi::Array atg_miopen_rnn_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out0 = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *out1 = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *out2 = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *out3 = info__[3].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *out4 = info__[4].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *input = info__[5].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array weight_array__ = info__[6].As<Napi::Array>();
  int weight_len = weight_array__.Length();
  torch::Tensor **weight_data = new torch::Tensor *[weight_len];
  for (int i = 0; i < weight_len; ++i)
    weight_data[i] = weight_array__.Get(i).As<Napi::External<torch::Tensor>>().Data();
  int64_t weight_stride0 = info__[7].As<Napi::Number>().Int64Value();
  torch::Tensor *hx = info__[8].As<Napi::External<torch::Tensor>>().Data();
  bool cx_null = info__[9].IsUndefined();
  torch::Tensor *cx_v = cx_null ? nullptr : info__[9].As<Napi::External<torch::Tensor>>().Data();
  int64_t mode = info__[10].As<Napi::Number>().Int64Value();
  int64_t hidden_size = info__[11].As<Napi::Number>().Int64Value();
  int64_t num_layers = info__[12].As<Napi::Number>().Int64Value();
  bool batch_first = info__[13].As<Napi::Boolean>().Value();
  double dropout = info__[14].As<Napi::Number>().DoubleValue();
  bool train = info__[15].As<Napi::Boolean>().Value();
  bool bidirectional = info__[16].As<Napi::Boolean>().Value();
  Napi::Array batch_sizes_array__ = info__[17].As<Napi::Array>();
  int batch_sizes_len = batch_sizes_array__.Length();
  int64_t *batch_sizes_data = new int64_t[batch_sizes_len];
  for (int i = 0; i < batch_sizes_len; ++i)
    batch_sizes_data[i] = batch_sizes_array__.Get(i).ToNumber().Int64Value();
  bool dropout_state_null = info__[18].IsUndefined();
  torch::Tensor *dropout_state_v = dropout_state_null ? nullptr : info__[18].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::miopen_rnn_out(*out0, *out1, *out2, *out3, *out4, *input, of_carray_tensor(weight_data, weight_len), weight_stride0, *hx, (cx_null ? *cx_v : torch::Tensor()), mode, hidden_size, num_layers, batch_first, dropout, train, bidirectional, torch::IntArrayRef(batch_sizes_data, batch_sizes_len), (dropout_state_null ? *dropout_state_v : torch::Tensor()));
  Napi::Array output__array__ = Napi::Array::New(env__, 5);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  output__array__[2u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<2>(output__)));
  output__array__[3u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<3>(output__)));
  output__array__[4u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<4>(output__)));
  return output__array__;
}

Napi::External<torch::Tensor> atg_mm(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *mat2 = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::mm(*self, *mat2);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_mm_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *mat2 = info__[2].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::mm_out(*out, *self, *mat2);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__sparse_mm(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *sparse = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *dense = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::_sparse_mm(*sparse, *dense);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__sparse_mm_reduce(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *sparse = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *dense = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::String reduce_str__ = info__[2].As<Napi::String>();
  std::string reduce = reduce_str__.Utf8Value();
  auto output__ = torch::_sparse_mm(*sparse, *dense, reduce);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__sparse_sparse_matmul(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::_sparse_sparse_matmul(*self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__sparse_sparse_matmul_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[2].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::_sparse_sparse_matmul_out(*out, *self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::Array atg_mode(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t dim = info__[1].As<Napi::Number>().Int64Value();
  bool keepdim = info__[2].As<Napi::Boolean>().Value();
  auto output__ = torch::mode(*self, dim, keepdim);
  Napi::Array output__array__ = Napi::Array::New(env__, 2);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  return output__array__;
}

Napi::Array atg_mode_values(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *values = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *indices = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[2].As<Napi::External<torch::Tensor>>().Data();
  int64_t dim = info__[3].As<Napi::Number>().Int64Value();
  bool keepdim = info__[4].As<Napi::Boolean>().Value();
  auto output__ = torch::mode_out(*values, *indices, *self, dim, keepdim);
  Napi::Array output__array__ = Napi::Array::New(env__, 2);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  return output__array__;
}

Napi::External<torch::Tensor> atg_mul(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::mul(*self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_mul_scalar(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *other = info__[1].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::mul(*self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_mul_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[2].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::mul_out(*out, *self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_mul_scalar_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *other = info__[2].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::mul_out(*out, *self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_mul_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = self->mul_(*other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_mul_scalar_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *other = info__[1].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = self->mul_(*other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_multiply(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::multiply(*self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_multiply_scalar(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *other = info__[1].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::multiply(*self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_multiply_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[2].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::multiply_out(*out, *self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_multiply_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = self->multiply_(*other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_multiply_scalar_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *other = info__[1].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = self->multiply_(*other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_mv(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *vec = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::mv(*self, *vec);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_mv_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *vec = info__[2].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::mv_out(*out, *self, *vec);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_mvlgamma(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t p = info__[1].As<Napi::Number>().Int64Value();
  auto output__ = torch::mvlgamma(*self, p);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_mvlgamma_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  int64_t p = info__[2].As<Napi::Number>().Int64Value();
  auto output__ = torch::mvlgamma_out(*out, *self, p);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_mvlgamma_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t p = info__[1].As<Napi::Number>().Int64Value();
  auto output__ = self->mvlgamma_(p);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_narrow_copy(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t dim = info__[1].As<Napi::Number>().Int64Value();
  int64_t start = info__[2].As<Napi::Number>().Int64Value();
  int64_t length = info__[3].As<Napi::Number>().Int64Value();
  auto output__ = torch::narrow_copy(*self, dim, start, length);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_narrow_copy_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  int64_t dim = info__[2].As<Napi::Number>().Int64Value();
  int64_t start = info__[3].As<Napi::Number>().Int64Value();
  int64_t length = info__[4].As<Napi::Number>().Int64Value();
  auto output__ = torch::narrow_copy_out(*out, *self, dim, start, length);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_narrow(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t dim = info__[1].As<Napi::Number>().Int64Value();
  int64_t start = info__[2].As<Napi::Number>().Int64Value();
  int64_t length = info__[3].As<Napi::Number>().Int64Value();
  auto output__ = torch::narrow(*self, dim, start, length);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_narrow_tensor(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t dim = info__[1].As<Napi::Number>().Int64Value();
  torch::Tensor *start = info__[2].As<Napi::External<torch::Tensor>>().Data();
  int64_t length = info__[3].As<Napi::Number>().Int64Value();
  auto output__ = torch::narrow(*self, dim, *start, length);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::Array atg_native_batch_norm(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *input = info__[0].As<Napi::External<torch::Tensor>>().Data();
  bool weight_null = info__[1].IsUndefined();
  torch::Tensor *weight_v = weight_null ? nullptr : info__[1].As<Napi::External<torch::Tensor>>().Data();
  bool bias_null = info__[2].IsUndefined();
  torch::Tensor *bias_v = bias_null ? nullptr : info__[2].As<Napi::External<torch::Tensor>>().Data();
  bool running_mean_null = info__[3].IsUndefined();
  torch::Tensor *running_mean_v = running_mean_null ? nullptr : info__[3].As<Napi::External<torch::Tensor>>().Data();
  bool running_var_null = info__[4].IsUndefined();
  torch::Tensor *running_var_v = running_var_null ? nullptr : info__[4].As<Napi::External<torch::Tensor>>().Data();
  bool training = info__[5].As<Napi::Boolean>().Value();
  double momentum = info__[6].As<Napi::Number>().DoubleValue();
  double eps = info__[7].As<Napi::Number>().DoubleValue();
  auto output__ = torch::native_batch_norm(*input, (weight_null ? *weight_v : torch::Tensor()), (bias_null ? *bias_v : torch::Tensor()), (running_mean_null ? *running_mean_v : torch::Tensor()), (running_var_null ? *running_var_v : torch::Tensor()), training, momentum, eps);
  Napi::Array output__array__ = Napi::Array::New(env__, 3);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  output__array__[2u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<2>(output__)));
  return output__array__;
}

Napi::Array atg_native_batch_norm_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *save_mean = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *save_invstd = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *input = info__[3].As<Napi::External<torch::Tensor>>().Data();
  bool weight_null = info__[4].IsUndefined();
  torch::Tensor *weight_v = weight_null ? nullptr : info__[4].As<Napi::External<torch::Tensor>>().Data();
  bool bias_null = info__[5].IsUndefined();
  torch::Tensor *bias_v = bias_null ? nullptr : info__[5].As<Napi::External<torch::Tensor>>().Data();
  bool running_mean_null = info__[6].IsUndefined();
  torch::Tensor *running_mean_v = running_mean_null ? nullptr : info__[6].As<Napi::External<torch::Tensor>>().Data();
  bool running_var_null = info__[7].IsUndefined();
  torch::Tensor *running_var_v = running_var_null ? nullptr : info__[7].As<Napi::External<torch::Tensor>>().Data();
  bool training = info__[8].As<Napi::Boolean>().Value();
  double momentum = info__[9].As<Napi::Number>().DoubleValue();
  double eps = info__[10].As<Napi::Number>().DoubleValue();
  auto output__ = torch::native_batch_norm_out(*out, *save_mean, *save_invstd, *input, (weight_null ? *weight_v : torch::Tensor()), (bias_null ? *bias_v : torch::Tensor()), (running_mean_null ? *running_mean_v : torch::Tensor()), (running_var_null ? *running_var_v : torch::Tensor()), training, momentum, eps);
  Napi::Array output__array__ = Napi::Array::New(env__, 3);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  output__array__[2u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<2>(output__)));
  return output__array__;
}

Napi::Array atg__native_batch_norm_legit_no_stats(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *input = info__[0].As<Napi::External<torch::Tensor>>().Data();
  bool weight_null = info__[1].IsUndefined();
  torch::Tensor *weight_v = weight_null ? nullptr : info__[1].As<Napi::External<torch::Tensor>>().Data();
  bool bias_null = info__[2].IsUndefined();
  torch::Tensor *bias_v = bias_null ? nullptr : info__[2].As<Napi::External<torch::Tensor>>().Data();
  bool training = info__[3].As<Napi::Boolean>().Value();
  double momentum = info__[4].As<Napi::Number>().DoubleValue();
  double eps = info__[5].As<Napi::Number>().DoubleValue();
  auto output__ = torch::_native_batch_norm_legit(*input, (weight_null ? *weight_v : torch::Tensor()), (bias_null ? *bias_v : torch::Tensor()), training, momentum, eps);
  Napi::Array output__array__ = Napi::Array::New(env__, 3);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  output__array__[2u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<2>(output__)));
  return output__array__;
}

Napi::Array atg__native_batch_norm_legit(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *input = info__[0].As<Napi::External<torch::Tensor>>().Data();
  bool weight_null = info__[1].IsUndefined();
  torch::Tensor *weight_v = weight_null ? nullptr : info__[1].As<Napi::External<torch::Tensor>>().Data();
  bool bias_null = info__[2].IsUndefined();
  torch::Tensor *bias_v = bias_null ? nullptr : info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *running_mean = info__[3].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *running_var = info__[4].As<Napi::External<torch::Tensor>>().Data();
  bool training = info__[5].As<Napi::Boolean>().Value();
  double momentum = info__[6].As<Napi::Number>().DoubleValue();
  double eps = info__[7].As<Napi::Number>().DoubleValue();
  auto output__ = torch::_native_batch_norm_legit(*input, (weight_null ? *weight_v : torch::Tensor()), (bias_null ? *bias_v : torch::Tensor()), *running_mean, *running_var, training, momentum, eps);
  Napi::Array output__array__ = Napi::Array::New(env__, 3);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  output__array__[2u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<2>(output__)));
  return output__array__;
}

Napi::Array atg__native_batch_norm_legit_no_stats_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *save_mean = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *save_invstd = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *input = info__[3].As<Napi::External<torch::Tensor>>().Data();
  bool weight_null = info__[4].IsUndefined();
  torch::Tensor *weight_v = weight_null ? nullptr : info__[4].As<Napi::External<torch::Tensor>>().Data();
  bool bias_null = info__[5].IsUndefined();
  torch::Tensor *bias_v = bias_null ? nullptr : info__[5].As<Napi::External<torch::Tensor>>().Data();
  bool training = info__[6].As<Napi::Boolean>().Value();
  double momentum = info__[7].As<Napi::Number>().DoubleValue();
  double eps = info__[8].As<Napi::Number>().DoubleValue();
  auto output__ = torch::_native_batch_norm_legit_out(*out, *save_mean, *save_invstd, *input, (weight_null ? *weight_v : torch::Tensor()), (bias_null ? *bias_v : torch::Tensor()), training, momentum, eps);
  Napi::Array output__array__ = Napi::Array::New(env__, 3);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  output__array__[2u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<2>(output__)));
  return output__array__;
}

Napi::Array atg__native_batch_norm_legit_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *save_mean = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *save_invstd = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *input = info__[3].As<Napi::External<torch::Tensor>>().Data();
  bool weight_null = info__[4].IsUndefined();
  torch::Tensor *weight_v = weight_null ? nullptr : info__[4].As<Napi::External<torch::Tensor>>().Data();
  bool bias_null = info__[5].IsUndefined();
  torch::Tensor *bias_v = bias_null ? nullptr : info__[5].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *running_mean = info__[6].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *running_var = info__[7].As<Napi::External<torch::Tensor>>().Data();
  bool training = info__[8].As<Napi::Boolean>().Value();
  double momentum = info__[9].As<Napi::Number>().DoubleValue();
  double eps = info__[10].As<Napi::Number>().DoubleValue();
  auto output__ = torch::_native_batch_norm_legit_out(*out, *save_mean, *save_invstd, *input, (weight_null ? *weight_v : torch::Tensor()), (bias_null ? *bias_v : torch::Tensor()), *running_mean, *running_var, training, momentum, eps);
  Napi::Array output__array__ = Napi::Array::New(env__, 3);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  output__array__[2u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<2>(output__)));
  return output__array__;
}

Napi::Array atg_batch_norm_stats(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *input = info__[0].As<Napi::External<torch::Tensor>>().Data();
  double eps = info__[1].As<Napi::Number>().DoubleValue();
  auto output__ = torch::batch_norm_stats(*input, eps);
  Napi::Array output__array__ = Napi::Array::New(env__, 2);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  return output__array__;
}

Napi::Array atg_batch_norm_stats_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out0 = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *out1 = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *input = info__[2].As<Napi::External<torch::Tensor>>().Data();
  double eps = info__[3].As<Napi::Number>().DoubleValue();
  auto output__ = torch::batch_norm_stats_out(*out0, *out1, *input, eps);
  Napi::Array output__array__ = Napi::Array::New(env__, 2);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  return output__array__;
}

Napi::External<torch::Tensor> atg_batch_norm_elemt(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *input = info__[0].As<Napi::External<torch::Tensor>>().Data();
  bool weight_null = info__[1].IsUndefined();
  torch::Tensor *weight_v = weight_null ? nullptr : info__[1].As<Napi::External<torch::Tensor>>().Data();
  bool bias_null = info__[2].IsUndefined();
  torch::Tensor *bias_v = bias_null ? nullptr : info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *mean = info__[3].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *invstd = info__[4].As<Napi::External<torch::Tensor>>().Data();
  double eps = info__[5].As<Napi::Number>().DoubleValue();
  auto output__ = torch::batch_norm_elemt(*input, (weight_null ? *weight_v : torch::Tensor()), (bias_null ? *bias_v : torch::Tensor()), *mean, *invstd, eps);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_batch_norm_elemt_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *input = info__[1].As<Napi::External<torch::Tensor>>().Data();
  bool weight_null = info__[2].IsUndefined();
  torch::Tensor *weight_v = weight_null ? nullptr : info__[2].As<Napi::External<torch::Tensor>>().Data();
  bool bias_null = info__[3].IsUndefined();
  torch::Tensor *bias_v = bias_null ? nullptr : info__[3].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *mean = info__[4].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *invstd = info__[5].As<Napi::External<torch::Tensor>>().Data();
  double eps = info__[6].As<Napi::Number>().DoubleValue();
  auto output__ = torch::batch_norm_elemt_out(*out, *input, (weight_null ? *weight_v : torch::Tensor()), (bias_null ? *bias_v : torch::Tensor()), *mean, *invstd, eps);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::Array atg_batch_norm_gather_stats(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *input = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *mean = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *invstd = info__[2].As<Napi::External<torch::Tensor>>().Data();
  bool running_mean_null = info__[3].IsUndefined();
  torch::Tensor *running_mean_v = running_mean_null ? nullptr : info__[3].As<Napi::External<torch::Tensor>>().Data();
  bool running_var_null = info__[4].IsUndefined();
  torch::Tensor *running_var_v = running_var_null ? nullptr : info__[4].As<Napi::External<torch::Tensor>>().Data();
  double momentum = info__[5].As<Napi::Number>().DoubleValue();
  double eps = info__[6].As<Napi::Number>().DoubleValue();
  int64_t count = info__[7].As<Napi::Number>().Int64Value();
  auto output__ = torch::batch_norm_gather_stats(*input, *mean, *invstd, (running_mean_null ? *running_mean_v : torch::Tensor()), (running_var_null ? *running_var_v : torch::Tensor()), momentum, eps, count);
  Napi::Array output__array__ = Napi::Array::New(env__, 2);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  return output__array__;
}

Napi::Array atg_batch_norm_gather_stats_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out0 = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *out1 = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *input = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *mean = info__[3].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *invstd = info__[4].As<Napi::External<torch::Tensor>>().Data();
  bool running_mean_null = info__[5].IsUndefined();
  torch::Tensor *running_mean_v = running_mean_null ? nullptr : info__[5].As<Napi::External<torch::Tensor>>().Data();
  bool running_var_null = info__[6].IsUndefined();
  torch::Tensor *running_var_v = running_var_null ? nullptr : info__[6].As<Napi::External<torch::Tensor>>().Data();
  double momentum = info__[7].As<Napi::Number>().DoubleValue();
  double eps = info__[8].As<Napi::Number>().DoubleValue();
  int64_t count = info__[9].As<Napi::Number>().Int64Value();
  auto output__ = torch::batch_norm_gather_stats_out(*out0, *out1, *input, *mean, *invstd, (running_mean_null ? *running_mean_v : torch::Tensor()), (running_var_null ? *running_var_v : torch::Tensor()), momentum, eps, count);
  Napi::Array output__array__ = Napi::Array::New(env__, 2);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  return output__array__;
}

Napi::Array atg_batch_norm_gather_stats_with_counts(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *input = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *mean = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *invstd = info__[2].As<Napi::External<torch::Tensor>>().Data();
  bool running_mean_null = info__[3].IsUndefined();
  torch::Tensor *running_mean_v = running_mean_null ? nullptr : info__[3].As<Napi::External<torch::Tensor>>().Data();
  bool running_var_null = info__[4].IsUndefined();
  torch::Tensor *running_var_v = running_var_null ? nullptr : info__[4].As<Napi::External<torch::Tensor>>().Data();
  double momentum = info__[5].As<Napi::Number>().DoubleValue();
  double eps = info__[6].As<Napi::Number>().DoubleValue();
  torch::Tensor *counts = info__[7].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::batch_norm_gather_stats_with_counts(*input, *mean, *invstd, (running_mean_null ? *running_mean_v : torch::Tensor()), (running_var_null ? *running_var_v : torch::Tensor()), momentum, eps, *counts);
  Napi::Array output__array__ = Napi::Array::New(env__, 2);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  return output__array__;
}

Napi::Array atg_batch_norm_gather_stats_with_counts_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out0 = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *out1 = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *input = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *mean = info__[3].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *invstd = info__[4].As<Napi::External<torch::Tensor>>().Data();
  bool running_mean_null = info__[5].IsUndefined();
  torch::Tensor *running_mean_v = running_mean_null ? nullptr : info__[5].As<Napi::External<torch::Tensor>>().Data();
  bool running_var_null = info__[6].IsUndefined();
  torch::Tensor *running_var_v = running_var_null ? nullptr : info__[6].As<Napi::External<torch::Tensor>>().Data();
  double momentum = info__[7].As<Napi::Number>().DoubleValue();
  double eps = info__[8].As<Napi::Number>().DoubleValue();
  torch::Tensor *counts = info__[9].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::batch_norm_gather_stats_with_counts_out(*out0, *out1, *input, *mean, *invstd, (running_mean_null ? *running_mean_v : torch::Tensor()), (running_var_null ? *running_var_v : torch::Tensor()), momentum, eps, *counts);
  Napi::Array output__array__ = Napi::Array::New(env__, 2);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  return output__array__;
}

Napi::Array atg_batch_norm_backward_reduce(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *grad_out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *input = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *mean = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *invstd = info__[3].As<Napi::External<torch::Tensor>>().Data();
  bool weight_null = info__[4].IsUndefined();
  torch::Tensor *weight_v = weight_null ? nullptr : info__[4].As<Napi::External<torch::Tensor>>().Data();
  bool input_g = info__[5].As<Napi::Boolean>().Value();
  bool weight_g = info__[6].As<Napi::Boolean>().Value();
  bool bias_g = info__[7].As<Napi::Boolean>().Value();
  auto output__ = torch::batch_norm_backward_reduce(*grad_out, *input, *mean, *invstd, (weight_null ? *weight_v : torch::Tensor()), input_g, weight_g, bias_g);
  Napi::Array output__array__ = Napi::Array::New(env__, 4);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  output__array__[2u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<2>(output__)));
  output__array__[3u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<3>(output__)));
  return output__array__;
}

Napi::Array atg_batch_norm_backward_reduce_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out0 = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *out1 = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *out2 = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *out3 = info__[3].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *grad_out = info__[4].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *input = info__[5].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *mean = info__[6].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *invstd = info__[7].As<Napi::External<torch::Tensor>>().Data();
  bool weight_null = info__[8].IsUndefined();
  torch::Tensor *weight_v = weight_null ? nullptr : info__[8].As<Napi::External<torch::Tensor>>().Data();
  bool input_g = info__[9].As<Napi::Boolean>().Value();
  bool weight_g = info__[10].As<Napi::Boolean>().Value();
  bool bias_g = info__[11].As<Napi::Boolean>().Value();
  auto output__ = torch::batch_norm_backward_reduce_out(*out0, *out1, *out2, *out3, *grad_out, *input, *mean, *invstd, (weight_null ? *weight_v : torch::Tensor()), input_g, weight_g, bias_g);
  Napi::Array output__array__ = Napi::Array::New(env__, 4);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  output__array__[2u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<2>(output__)));
  output__array__[3u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<3>(output__)));
  return output__array__;
}

Napi::External<torch::Tensor> atg_batch_norm_backward_elemt(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *grad_out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *input = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *mean = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *invstd = info__[3].As<Napi::External<torch::Tensor>>().Data();
  bool weight_null = info__[4].IsUndefined();
  torch::Tensor *weight_v = weight_null ? nullptr : info__[4].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *mean_dy = info__[5].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *mean_dy_xmu = info__[6].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *count = info__[7].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::batch_norm_backward_elemt(*grad_out, *input, *mean, *invstd, (weight_null ? *weight_v : torch::Tensor()), *mean_dy, *mean_dy_xmu, *count);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_batch_norm_backward_elemt_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *grad_out = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *input = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *mean = info__[3].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *invstd = info__[4].As<Napi::External<torch::Tensor>>().Data();
  bool weight_null = info__[5].IsUndefined();
  torch::Tensor *weight_v = weight_null ? nullptr : info__[5].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *mean_dy = info__[6].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *mean_dy_xmu = info__[7].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *count = info__[8].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::batch_norm_backward_elemt_out(*out, *grad_out, *input, *mean, *invstd, (weight_null ? *weight_v : torch::Tensor()), *mean_dy, *mean_dy_xmu, *count);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::Array atg_batch_norm_update_stats(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *input = info__[0].As<Napi::External<torch::Tensor>>().Data();
  bool running_mean_null = info__[1].IsUndefined();
  torch::Tensor *running_mean_v = running_mean_null ? nullptr : info__[1].As<Napi::External<torch::Tensor>>().Data();
  bool running_var_null = info__[2].IsUndefined();
  torch::Tensor *running_var_v = running_var_null ? nullptr : info__[2].As<Napi::External<torch::Tensor>>().Data();
  double momentum = info__[3].As<Napi::Number>().DoubleValue();
  auto output__ = torch::batch_norm_update_stats(*input, (running_mean_null ? *running_mean_v : torch::Tensor()), (running_var_null ? *running_var_v : torch::Tensor()), momentum);
  Napi::Array output__array__ = Napi::Array::New(env__, 2);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  return output__array__;
}

Napi::Array atg_batch_norm_update_stats_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out0 = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *out1 = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *input = info__[2].As<Napi::External<torch::Tensor>>().Data();
  bool running_mean_null = info__[3].IsUndefined();
  torch::Tensor *running_mean_v = running_mean_null ? nullptr : info__[3].As<Napi::External<torch::Tensor>>().Data();
  bool running_var_null = info__[4].IsUndefined();
  torch::Tensor *running_var_v = running_var_null ? nullptr : info__[4].As<Napi::External<torch::Tensor>>().Data();
  double momentum = info__[5].As<Napi::Number>().DoubleValue();
  auto output__ = torch::batch_norm_update_stats_out(*out0, *out1, *input, (running_mean_null ? *running_mean_v : torch::Tensor()), (running_var_null ? *running_var_v : torch::Tensor()), momentum);
  Napi::Array output__array__ = Napi::Array::New(env__, 2);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  return output__array__;
}

Napi::Boolean atg_is_vulkan_available(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  auto output__ = torch::is_vulkan_available();
  return Napi::Boolean::New(env__, output__);
}

Napi::Boolean atg__nnpack_available(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  auto output__ = torch::_nnpack_available();
  return Napi::Boolean::New(env__, output__);
}

Napi::External<torch::Tensor> atg__nnpack_spatial_convolution(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *input = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *weight = info__[1].As<Napi::External<torch::Tensor>>().Data();
  bool bias_null = info__[2].IsUndefined();
  torch::Tensor *bias_v = bias_null ? nullptr : info__[2].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array padding_array__ = info__[3].As<Napi::Array>();
  int padding_len = padding_array__.Length();
  int64_t *padding_data = new int64_t[padding_len];
  for (int i = 0; i < padding_len; ++i)
    padding_data[i] = padding_array__.Get(i).ToNumber().Int64Value();
  Napi::Array stride_array__ = info__[4].As<Napi::Array>();
  int stride_len = stride_array__.Length();
  int64_t *stride_data = new int64_t[stride_len];
  for (int i = 0; i < stride_len; ++i)
    stride_data[i] = stride_array__.Get(i).ToNumber().Int64Value();
  auto output__ = torch::_nnpack_spatial_convolution(*input, *weight, (bias_null ? *bias_v : torch::Tensor()), torch::IntArrayRef(padding_data, padding_len), torch::IntArrayRef(stride_data, stride_len));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__nnpack_spatial_convolution_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *input = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *weight = info__[2].As<Napi::External<torch::Tensor>>().Data();
  bool bias_null = info__[3].IsUndefined();
  torch::Tensor *bias_v = bias_null ? nullptr : info__[3].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array padding_array__ = info__[4].As<Napi::Array>();
  int padding_len = padding_array__.Length();
  int64_t *padding_data = new int64_t[padding_len];
  for (int i = 0; i < padding_len; ++i)
    padding_data[i] = padding_array__.Get(i).ToNumber().Int64Value();
  Napi::Array stride_array__ = info__[5].As<Napi::Array>();
  int stride_len = stride_array__.Length();
  int64_t *stride_data = new int64_t[stride_len];
  for (int i = 0; i < stride_len; ++i)
    stride_data[i] = stride_array__.Get(i).ToNumber().Int64Value();
  auto output__ = torch::_nnpack_spatial_convolution_out(*out, *input, *weight, (bias_null ? *bias_v : torch::Tensor()), torch::IntArrayRef(padding_data, padding_len), torch::IntArrayRef(stride_data, stride_len));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_ones(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  Napi::Array size_array__ = info__[0].As<Napi::Array>();
  int size_len = size_array__.Length();
  int64_t *size_data = new int64_t[size_len];
  for (int i = 0; i < size_len; ++i)
    size_data[i] = size_array__.Get(i).ToNumber().Int64Value();
  Napi::Object options_obj__ = info__[1].As<Napi::Object>();
  int options_device = options_obj__.Get("device").ToNumber().Int32Value();
  int options_kind = options_obj__.Get("dtype").ToNumber().Int32Value();
  auto output__ = torch::ones(torch::IntArrayRef(size_data, size_len), at::device(device_of_int(options_device)).dtype(at::ScalarType(options_kind)));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_ones_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array size_array__ = info__[1].As<Napi::Array>();
  int size_len = size_array__.Length();
  int64_t *size_data = new int64_t[size_len];
  for (int i = 0; i < size_len; ++i)
    size_data[i] = size_array__.Get(i).ToNumber().Int64Value();
  auto output__ = torch::ones_out(*out, torch::IntArrayRef(size_data, size_len));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_ones_like(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Object options_obj__ = info__[1].As<Napi::Object>();
  int options_device = options_obj__.Get("device").ToNumber().Int32Value();
  int options_kind = options_obj__.Get("dtype").ToNumber().Int32Value();
  int memory_format = info__[2].As<Napi::Number>().Int32Value();
  auto output__ = torch::ones_like(*self, at::device(device_of_int(options_device)).dtype(at::ScalarType(options_kind)), (at::MemoryFormat)memory_format);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_ones_like_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  int memory_format = info__[2].As<Napi::Number>().Int32Value();
  auto output__ = torch::ones_like_out(*out, *self, (at::MemoryFormat)memory_format);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_pairwise_distance(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *x1 = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *x2 = info__[1].As<Napi::External<torch::Tensor>>().Data();
  double p = info__[2].As<Napi::Number>().DoubleValue();
  double eps = info__[3].As<Napi::Number>().DoubleValue();
  bool keepdim = info__[4].As<Napi::Boolean>().Value();
  auto output__ = torch::pairwise_distance(*x1, *x2, p, eps, keepdim);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_cdist(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *x1 = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *x2 = info__[1].As<Napi::External<torch::Tensor>>().Data();
  double p = info__[2].As<Napi::Number>().DoubleValue();
  bool compute_mode_null = info__[3].IsUndefined();
  int64_t compute_mode_v = compute_mode_null ? 0 : info__[3].As<Napi::Number>().Int64Value();
  auto output__ = torch::cdist(*x1, *x2, p, compute_mode_null ? c10::nullopt : c10::optional<int64_t>(compute_mode_v));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__euclidean_dist(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *x1 = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *x2 = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::_euclidean_dist(*x1, *x2);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__euclidean_dist_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *x1 = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *x2 = info__[2].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::_euclidean_dist_out(*out, *x1, *x2);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__cdist_backward(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *grad = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *x1 = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *x2 = info__[2].As<Napi::External<torch::Tensor>>().Data();
  double p = info__[3].As<Napi::Number>().DoubleValue();
  torch::Tensor *cdist = info__[4].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::_cdist_backward(*grad, *x1, *x2, p, *cdist);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__cdist_backward_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *grad = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *x1 = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *x2 = info__[3].As<Napi::External<torch::Tensor>>().Data();
  double p = info__[4].As<Napi::Number>().DoubleValue();
  torch::Tensor *cdist = info__[5].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::_cdist_backward_out(*out, *grad, *x1, *x2, p, *cdist);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_pdist(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  double p = info__[1].As<Napi::Number>().DoubleValue();
  auto output__ = torch::pdist(*self, p);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__pdist_backward(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *grad = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  double p = info__[2].As<Napi::Number>().DoubleValue();
  torch::Tensor *pdist = info__[3].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::_pdist_backward(*grad, *self, p, *pdist);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__pdist_backward_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *grad = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[2].As<Napi::External<torch::Tensor>>().Data();
  double p = info__[3].As<Napi::Number>().DoubleValue();
  torch::Tensor *pdist = info__[4].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::_pdist_backward_out(*out, *grad, *self, p, *pdist);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_cosine_similarity(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *x1 = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *x2 = info__[1].As<Napi::External<torch::Tensor>>().Data();
  int64_t dim = info__[2].As<Napi::Number>().Int64Value();
  double eps = info__[3].As<Napi::Number>().DoubleValue();
  auto output__ = torch::cosine_similarity(*x1, *x2, dim, eps);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_permute(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array dims_array__ = info__[1].As<Napi::Array>();
  int dims_len = dims_array__.Length();
  int64_t *dims_data = new int64_t[dims_len];
  for (int i = 0; i < dims_len; ++i)
    dims_data[i] = dims_array__.Get(i).ToNumber().Int64Value();
  auto output__ = torch::permute(*self, torch::IntArrayRef(dims_data, dims_len));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_movedim(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array source_array__ = info__[1].As<Napi::Array>();
  int source_len = source_array__.Length();
  int64_t *source_data = new int64_t[source_len];
  for (int i = 0; i < source_len; ++i)
    source_data[i] = source_array__.Get(i).ToNumber().Int64Value();
  Napi::Array destination_array__ = info__[2].As<Napi::Array>();
  int destination_len = destination_array__.Length();
  int64_t *destination_data = new int64_t[destination_len];
  for (int i = 0; i < destination_len; ++i)
    destination_data[i] = destination_array__.Get(i).ToNumber().Int64Value();
  auto output__ = torch::movedim(*self, torch::IntArrayRef(source_data, source_len), torch::IntArrayRef(destination_data, destination_len));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_movedim_int(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t source = info__[1].As<Napi::Number>().Int64Value();
  int64_t destination = info__[2].As<Napi::Number>().Int64Value();
  auto output__ = torch::movedim(*self, source, destination);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_moveaxis(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array source_array__ = info__[1].As<Napi::Array>();
  int source_len = source_array__.Length();
  int64_t *source_data = new int64_t[source_len];
  for (int i = 0; i < source_len; ++i)
    source_data[i] = source_array__.Get(i).ToNumber().Int64Value();
  Napi::Array destination_array__ = info__[2].As<Napi::Array>();
  int destination_len = destination_array__.Length();
  int64_t *destination_data = new int64_t[destination_len];
  for (int i = 0; i < destination_len; ++i)
    destination_data[i] = destination_array__.Get(i).ToNumber().Int64Value();
  auto output__ = torch::moveaxis(*self, torch::IntArrayRef(source_data, source_len), torch::IntArrayRef(destination_data, destination_len));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_moveaxis_int(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t source = info__[1].As<Napi::Number>().Int64Value();
  int64_t destination = info__[2].As<Napi::Number>().Int64Value();
  auto output__ = torch::moveaxis(*self, source, destination);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_numpy_T(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = self->numpy_T();
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_matrix_H(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = self->matrix_H();
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_mT(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = self->mT();
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_mH(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = self->mH();
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_adjoint(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::adjoint(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_pixel_shuffle(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t upscale_factor = info__[1].As<Napi::Number>().Int64Value();
  auto output__ = torch::pixel_shuffle(*self, upscale_factor);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_pixel_shuffle_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  int64_t upscale_factor = info__[2].As<Napi::Number>().Int64Value();
  auto output__ = torch::pixel_shuffle_out(*out, *self, upscale_factor);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_pixel_unshuffle(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t downscale_factor = info__[1].As<Napi::Number>().Int64Value();
  auto output__ = torch::pixel_unshuffle(*self, downscale_factor);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_pixel_unshuffle_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  int64_t downscale_factor = info__[2].As<Napi::Number>().Int64Value();
  auto output__ = torch::pixel_unshuffle_out(*out, *self, downscale_factor);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_channel_shuffle(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t groups = info__[1].As<Napi::Number>().Int64Value();
  auto output__ = torch::channel_shuffle(*self, groups);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_channel_shuffle_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  int64_t groups = info__[2].As<Napi::Number>().Int64Value();
  auto output__ = torch::channel_shuffle_out(*out, *self, groups);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_native_channel_shuffle(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t groups = info__[1].As<Napi::Number>().Int64Value();
  auto output__ = torch::native_channel_shuffle(*self, groups);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::Boolean atg_is_pinned(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int device = info__[1].As<Napi::Number>().Int32Value();
  auto output__ = self->is_pinned(device_of_int(device));
  return Napi::Boolean::New(env__, output__);
}

Napi::External<torch::Tensor> atg_pin_memory(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int device = info__[1].As<Napi::Number>().Int32Value();
  auto output__ = self->pin_memory(device_of_int(device));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__pin_memory(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int device = info__[1].As<Napi::Number>().Int32Value();
  auto output__ = torch::_pin_memory(*self, device_of_int(device));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__pin_memory_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  int device = info__[2].As<Napi::Number>().Int32Value();
  auto output__ = torch::_pin_memory_out(*out, *self, device_of_int(device));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_pinverse(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  double rcond = info__[1].As<Napi::Number>().DoubleValue();
  auto output__ = torch::pinverse(*self, rcond);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_poisson_nll_loss(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *input = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *target = info__[1].As<Napi::External<torch::Tensor>>().Data();
  bool log_input = info__[2].As<Napi::Boolean>().Value();
  bool full = info__[3].As<Napi::Boolean>().Value();
  double eps = info__[4].As<Napi::Number>().DoubleValue();
  int64_t reduction = info__[5].As<Napi::Number>().Int64Value();
  auto output__ = torch::poisson_nll_loss(*input, *target, log_input, full, eps, reduction);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_rad2deg(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::rad2deg(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_rad2deg_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::rad2deg_out(*out, *self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_rad2deg_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::rad2deg_(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_deg2rad(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::deg2rad(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_deg2rad_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::deg2rad_out(*out, *self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_deg2rad_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::deg2rad_(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_scalar_tensor(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Scalar *s = info__[0].As<Napi::External<torch::Scalar>>().Data();
  Napi::Object options_obj__ = info__[1].As<Napi::Object>();
  int options_device = options_obj__.Get("device").ToNumber().Int32Value();
  int options_kind = options_obj__.Get("dtype").ToNumber().Int32Value();
  auto output__ = torch::scalar_tensor(*s, at::device(device_of_int(options_device)).dtype(at::ScalarType(options_kind)));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_scalar_tensor_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *s = info__[1].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::scalar_tensor_out(*out, *s);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_rand(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  Napi::Array size_array__ = info__[0].As<Napi::Array>();
  int size_len = size_array__.Length();
  int64_t *size_data = new int64_t[size_len];
  for (int i = 0; i < size_len; ++i)
    size_data[i] = size_array__.Get(i).ToNumber().Int64Value();
  Napi::Object options_obj__ = info__[1].As<Napi::Object>();
  int options_device = options_obj__.Get("device").ToNumber().Int32Value();
  int options_kind = options_obj__.Get("dtype").ToNumber().Int32Value();
  auto output__ = torch::rand(torch::IntArrayRef(size_data, size_len), at::device(device_of_int(options_device)).dtype(at::ScalarType(options_kind)));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_rand_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array size_array__ = info__[1].As<Napi::Array>();
  int size_len = size_array__.Length();
  int64_t *size_data = new int64_t[size_len];
  for (int i = 0; i < size_len; ++i)
    size_data[i] = size_array__.Get(i).ToNumber().Int64Value();
  auto output__ = torch::rand_out(*out, torch::IntArrayRef(size_data, size_len));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_rand_like(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Object options_obj__ = info__[1].As<Napi::Object>();
  int options_device = options_obj__.Get("device").ToNumber().Int32Value();
  int options_kind = options_obj__.Get("dtype").ToNumber().Int32Value();
  int memory_format = info__[2].As<Napi::Number>().Int32Value();
  auto output__ = torch::rand_like(*self, at::device(device_of_int(options_device)).dtype(at::ScalarType(options_kind)), (at::MemoryFormat)memory_format);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_rand_like_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  int memory_format = info__[2].As<Napi::Number>().Int32Value();
  auto output__ = torch::rand_like_out(*out, *self, (at::MemoryFormat)memory_format);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_randint(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  int64_t high = info__[0].As<Napi::Number>().Int64Value();
  Napi::Array size_array__ = info__[1].As<Napi::Array>();
  int size_len = size_array__.Length();
  int64_t *size_data = new int64_t[size_len];
  for (int i = 0; i < size_len; ++i)
    size_data[i] = size_array__.Get(i).ToNumber().Int64Value();
  Napi::Object options_obj__ = info__[2].As<Napi::Object>();
  int options_device = options_obj__.Get("device").ToNumber().Int32Value();
  int options_kind = options_obj__.Get("dtype").ToNumber().Int32Value();
  auto output__ = torch::randint(high, torch::IntArrayRef(size_data, size_len), at::device(device_of_int(options_device)).dtype(at::ScalarType(options_kind)));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_randint_low(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  int64_t low = info__[0].As<Napi::Number>().Int64Value();
  int64_t high = info__[1].As<Napi::Number>().Int64Value();
  Napi::Array size_array__ = info__[2].As<Napi::Array>();
  int size_len = size_array__.Length();
  int64_t *size_data = new int64_t[size_len];
  for (int i = 0; i < size_len; ++i)
    size_data[i] = size_array__.Get(i).ToNumber().Int64Value();
  Napi::Object options_obj__ = info__[3].As<Napi::Object>();
  int options_device = options_obj__.Get("device").ToNumber().Int32Value();
  int options_kind = options_obj__.Get("dtype").ToNumber().Int32Value();
  auto output__ = torch::randint(low, high, torch::IntArrayRef(size_data, size_len), at::device(device_of_int(options_device)).dtype(at::ScalarType(options_kind)));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_randint_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t high = info__[1].As<Napi::Number>().Int64Value();
  Napi::Array size_array__ = info__[2].As<Napi::Array>();
  int size_len = size_array__.Length();
  int64_t *size_data = new int64_t[size_len];
  for (int i = 0; i < size_len; ++i)
    size_data[i] = size_array__.Get(i).ToNumber().Int64Value();
  auto output__ = torch::randint_out(*out, high, torch::IntArrayRef(size_data, size_len));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_randint_low_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t low = info__[1].As<Napi::Number>().Int64Value();
  int64_t high = info__[2].As<Napi::Number>().Int64Value();
  Napi::Array size_array__ = info__[3].As<Napi::Array>();
  int size_len = size_array__.Length();
  int64_t *size_data = new int64_t[size_len];
  for (int i = 0; i < size_len; ++i)
    size_data[i] = size_array__.Get(i).ToNumber().Int64Value();
  auto output__ = torch::randint_out(*out, low, high, torch::IntArrayRef(size_data, size_len));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_randint_like(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t high = info__[1].As<Napi::Number>().Int64Value();
  Napi::Object options_obj__ = info__[2].As<Napi::Object>();
  int options_device = options_obj__.Get("device").ToNumber().Int32Value();
  int options_kind = options_obj__.Get("dtype").ToNumber().Int32Value();
  int memory_format = info__[3].As<Napi::Number>().Int32Value();
  auto output__ = torch::randint_like(*self, high, at::device(device_of_int(options_device)).dtype(at::ScalarType(options_kind)), (at::MemoryFormat)memory_format);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_randint_like_low_dtype(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t low = info__[1].As<Napi::Number>().Int64Value();
  int64_t high = info__[2].As<Napi::Number>().Int64Value();
  Napi::Object options_obj__ = info__[3].As<Napi::Object>();
  int options_device = options_obj__.Get("device").ToNumber().Int32Value();
  int options_kind = options_obj__.Get("dtype").ToNumber().Int32Value();
  int memory_format = info__[4].As<Napi::Number>().Int32Value();
  auto output__ = torch::randint_like(*self, low, high, at::device(device_of_int(options_device)).dtype(at::ScalarType(options_kind)), (at::MemoryFormat)memory_format);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_randint_like_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  int64_t high = info__[2].As<Napi::Number>().Int64Value();
  int memory_format = info__[3].As<Napi::Number>().Int32Value();
  auto output__ = torch::randint_like_out(*out, *self, high, (at::MemoryFormat)memory_format);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_randint_like_low_dtype_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  int64_t low = info__[2].As<Napi::Number>().Int64Value();
  int64_t high = info__[3].As<Napi::Number>().Int64Value();
  int memory_format = info__[4].As<Napi::Number>().Int32Value();
  auto output__ = torch::randint_like_out(*out, *self, low, high, (at::MemoryFormat)memory_format);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_randn(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  Napi::Array size_array__ = info__[0].As<Napi::Array>();
  int size_len = size_array__.Length();
  int64_t *size_data = new int64_t[size_len];
  for (int i = 0; i < size_len; ++i)
    size_data[i] = size_array__.Get(i).ToNumber().Int64Value();
  Napi::Object options_obj__ = info__[1].As<Napi::Object>();
  int options_device = options_obj__.Get("device").ToNumber().Int32Value();
  int options_kind = options_obj__.Get("dtype").ToNumber().Int32Value();
  auto output__ = torch::randn(torch::IntArrayRef(size_data, size_len), at::device(device_of_int(options_device)).dtype(at::ScalarType(options_kind)));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_randn_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array size_array__ = info__[1].As<Napi::Array>();
  int size_len = size_array__.Length();
  int64_t *size_data = new int64_t[size_len];
  for (int i = 0; i < size_len; ++i)
    size_data[i] = size_array__.Get(i).ToNumber().Int64Value();
  auto output__ = torch::randn_out(*out, torch::IntArrayRef(size_data, size_len));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_randn_like(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Object options_obj__ = info__[1].As<Napi::Object>();
  int options_device = options_obj__.Get("device").ToNumber().Int32Value();
  int options_kind = options_obj__.Get("dtype").ToNumber().Int32Value();
  int memory_format = info__[2].As<Napi::Number>().Int32Value();
  auto output__ = torch::randn_like(*self, at::device(device_of_int(options_device)).dtype(at::ScalarType(options_kind)), (at::MemoryFormat)memory_format);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_randn_like_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  int memory_format = info__[2].As<Napi::Number>().Int32Value();
  auto output__ = torch::randn_like_out(*out, *self, (at::MemoryFormat)memory_format);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_randperm(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  int64_t n = info__[0].As<Napi::Number>().Int64Value();
  Napi::Object options_obj__ = info__[1].As<Napi::Object>();
  int options_device = options_obj__.Get("device").ToNumber().Int32Value();
  int options_kind = options_obj__.Get("dtype").ToNumber().Int32Value();
  auto output__ = torch::randperm(n, at::device(device_of_int(options_device)).dtype(at::ScalarType(options_kind)));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_randperm_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t n = info__[1].As<Napi::Number>().Int64Value();
  auto output__ = torch::randperm_out(*out, n);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_range(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Scalar *start = info__[0].As<Napi::External<torch::Scalar>>().Data();
  torch::Scalar *end = info__[1].As<Napi::External<torch::Scalar>>().Data();
  Napi::Object options_obj__ = info__[2].As<Napi::Object>();
  int options_device = options_obj__.Get("device").ToNumber().Int32Value();
  int options_kind = options_obj__.Get("dtype").ToNumber().Int32Value();
  auto output__ = torch::range(*start, *end, at::device(device_of_int(options_device)).dtype(at::ScalarType(options_kind)));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_range_step(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Scalar *start = info__[0].As<Napi::External<torch::Scalar>>().Data();
  torch::Scalar *end = info__[1].As<Napi::External<torch::Scalar>>().Data();
  torch::Scalar *step = info__[2].As<Napi::External<torch::Scalar>>().Data();
  Napi::Object options_obj__ = info__[3].As<Napi::Object>();
  int options_device = options_obj__.Get("device").ToNumber().Int32Value();
  int options_kind = options_obj__.Get("dtype").ToNumber().Int32Value();
  auto output__ = torch::range(*start, *end, *step, at::device(device_of_int(options_device)).dtype(at::ScalarType(options_kind)));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_range_out_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *start = info__[1].As<Napi::External<torch::Scalar>>().Data();
  torch::Scalar *end = info__[2].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::range_out(*out, *start, *end);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_range_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *start = info__[1].As<Napi::External<torch::Scalar>>().Data();
  torch::Scalar *end = info__[2].As<Napi::External<torch::Scalar>>().Data();
  torch::Scalar *step = info__[3].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::range_out(*out, *start, *end, *step);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_ravel(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::ravel(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_reciprocal(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::reciprocal(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_reciprocal_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::reciprocal_out(*out, *self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_reciprocal_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::reciprocal_(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_neg(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::neg(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_neg_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::neg_out(*out, *self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_neg_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::neg_(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_negative(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::negative(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_negative_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::negative_out(*out, *self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_negative_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::negative_(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_repeat(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array repeats_array__ = info__[1].As<Napi::Array>();
  int repeats_len = repeats_array__.Length();
  int64_t *repeats_data = new int64_t[repeats_len];
  for (int i = 0; i < repeats_len; ++i)
    repeats_data[i] = repeats_array__.Get(i).ToNumber().Int64Value();
  auto output__ = self->repeat(torch::IntArrayRef(repeats_data, repeats_len));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_repeat_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array repeats_array__ = info__[2].As<Napi::Array>();
  int repeats_len = repeats_array__.Length();
  int64_t *repeats_data = new int64_t[repeats_len];
  for (int i = 0; i < repeats_len; ++i)
    repeats_data[i] = repeats_array__.Get(i).ToNumber().Int64Value();
  auto output__ = torch::repeat_out(*out, *self, torch::IntArrayRef(repeats_data, repeats_len));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_repeat_interleave(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *repeats = info__[0].As<Napi::External<torch::Tensor>>().Data();
  bool output_size_null = info__[1].IsUndefined();
  int64_t output_size_v = output_size_null ? 0 : info__[1].As<Napi::Number>().Int64Value();
  auto output__ = torch::repeat_interleave(*repeats, output_size_null ? c10::nullopt : c10::optional<int64_t>(output_size_v));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_repeat_interleave_self_tensor(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *repeats = info__[1].As<Napi::External<torch::Tensor>>().Data();
  bool dim_null = info__[2].IsUndefined();
  int64_t dim_v = dim_null ? 0 : info__[2].As<Napi::Number>().Int64Value();
  bool output_size_null = info__[3].IsUndefined();
  int64_t output_size_v = output_size_null ? 0 : info__[3].As<Napi::Number>().Int64Value();
  auto output__ = torch::repeat_interleave(*self, *repeats, dim_null ? c10::nullopt : c10::optional<int64_t>(dim_v), output_size_null ? c10::nullopt : c10::optional<int64_t>(output_size_v));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_repeat_interleave_self_int(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t repeats = info__[1].As<Napi::Number>().Int64Value();
  bool dim_null = info__[2].IsUndefined();
  int64_t dim_v = dim_null ? 0 : info__[2].As<Napi::Number>().Int64Value();
  bool output_size_null = info__[3].IsUndefined();
  int64_t output_size_v = output_size_null ? 0 : info__[3].As<Napi::Number>().Int64Value();
  auto output__ = torch::repeat_interleave(*self, repeats, dim_null ? c10::nullopt : c10::optional<int64_t>(dim_v), output_size_null ? c10::nullopt : c10::optional<int64_t>(output_size_v));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_repeat_interleave_tensor_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *repeats = info__[1].As<Napi::External<torch::Tensor>>().Data();
  bool output_size_null = info__[2].IsUndefined();
  int64_t output_size_v = output_size_null ? 0 : info__[2].As<Napi::Number>().Int64Value();
  auto output__ = torch::repeat_interleave_out(*out, *repeats, output_size_null ? c10::nullopt : c10::optional<int64_t>(output_size_v));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_reshape(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array shape_array__ = info__[1].As<Napi::Array>();
  int shape_len = shape_array__.Length();
  int64_t *shape_data = new int64_t[shape_len];
  for (int i = 0; i < shape_len; ++i)
    shape_data[i] = shape_array__.Get(i).ToNumber().Int64Value();
  auto output__ = torch::reshape(*self, torch::IntArrayRef(shape_data, shape_len));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__reshape_copy(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array size_array__ = info__[1].As<Napi::Array>();
  int size_len = size_array__.Length();
  int64_t *size_data = new int64_t[size_len];
  for (int i = 0; i < size_len; ++i)
    size_data[i] = size_array__.Get(i).ToNumber().Int64Value();
  auto output__ = torch::_reshape_copy(*self, torch::IntArrayRef(size_data, size_len));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__reshape_alias(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array size_array__ = info__[1].As<Napi::Array>();
  int size_len = size_array__.Length();
  int64_t *size_data = new int64_t[size_len];
  for (int i = 0; i < size_len; ++i)
    size_data[i] = size_array__.Get(i).ToNumber().Int64Value();
  Napi::Array stride_array__ = info__[2].As<Napi::Array>();
  int stride_len = stride_array__.Length();
  int64_t *stride_data = new int64_t[stride_len];
  for (int i = 0; i < stride_len; ++i)
    stride_data[i] = stride_array__.Get(i).ToNumber().Int64Value();
  auto output__ = torch::_reshape_alias(*self, torch::IntArrayRef(size_data, size_len), torch::IntArrayRef(stride_data, stride_len));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__mkldnn_reshape(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array shape_array__ = info__[1].As<Napi::Array>();
  int shape_len = shape_array__.Length();
  int64_t *shape_data = new int64_t[shape_len];
  for (int i = 0; i < shape_len; ++i)
    shape_data[i] = shape_array__.Get(i).ToNumber().Int64Value();
  auto output__ = torch::_mkldnn_reshape(*self, torch::IntArrayRef(shape_data, shape_len));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__mkldnn_reshape_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array shape_array__ = info__[2].As<Napi::Array>();
  int shape_len = shape_array__.Length();
  int64_t *shape_data = new int64_t[shape_len];
  for (int i = 0; i < shape_len; ++i)
    shape_data[i] = shape_array__.Get(i).ToNumber().Int64Value();
  auto output__ = torch::_mkldnn_reshape_out(*out, *self, torch::IntArrayRef(shape_data, shape_len));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_reshape_as(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = self->reshape_as(*other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_round(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::round(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_round_decimals(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t decimals = info__[1].As<Napi::Number>().Int64Value();
  auto output__ = torch::round(*self, decimals);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_round_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::round_out(*out, *self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_round_decimals_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  int64_t decimals = info__[2].As<Napi::Number>().Int64Value();
  auto output__ = torch::round_out(*out, *self, decimals);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_round_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::round_(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_round_decimals_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t decimals = info__[1].As<Napi::Number>().Int64Value();
  auto output__ = torch::round_(*self, decimals);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_rrelu(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *lower = info__[1].As<Napi::External<torch::Scalar>>().Data();
  torch::Scalar *upper = info__[2].As<Napi::External<torch::Scalar>>().Data();
  bool training = info__[3].As<Napi::Boolean>().Value();
  auto output__ = torch::rrelu(*self, *lower, *upper, training);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_rrelu_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *lower = info__[1].As<Napi::External<torch::Scalar>>().Data();
  torch::Scalar *upper = info__[2].As<Napi::External<torch::Scalar>>().Data();
  bool training = info__[3].As<Napi::Boolean>().Value();
  auto output__ = torch::rrelu_(*self, *lower, *upper, training);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_relu(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::relu(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_relu_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::relu_out(*out, *self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_relu_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::relu_(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_relu6(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::relu6(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_relu6_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::relu6_(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_prelu(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *weight = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::prelu(*self, *weight);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__prelu_kernel(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *weight = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::_prelu_kernel(*self, *weight);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::Array atg__prelu_kernel_backward(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *grad_output = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *weight = info__[2].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::_prelu_kernel_backward(*grad_output, *self, *weight);
  Napi::Array output__array__ = Napi::Array::New(env__, 2);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  return output__array__;
}

Napi::External<torch::Tensor> atg_gelu(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::String approximate_str__ = info__[1].As<Napi::String>();
  std::string approximate = approximate_str__.Utf8Value();
  auto output__ = torch::gelu(*self, approximate);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_gelu_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::String approximate_str__ = info__[2].As<Napi::String>();
  std::string approximate = approximate_str__.Utf8Value();
  auto output__ = torch::gelu_out(*out, *self, approximate);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_gelu_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::String approximate_str__ = info__[1].As<Napi::String>();
  std::string approximate = approximate_str__.Utf8Value();
  auto output__ = torch::gelu_(*self, approximate);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_gelu_backward(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *grad_output = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::String approximate_str__ = info__[2].As<Napi::String>();
  std::string approximate = approximate_str__.Utf8Value();
  auto output__ = torch::gelu_backward(*grad_output, *self, approximate);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_gelu_backward_grad_input(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *grad_input = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *grad_output = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[2].As<Napi::External<torch::Tensor>>().Data();
  Napi::String approximate_str__ = info__[3].As<Napi::String>();
  std::string approximate = approximate_str__.Utf8Value();
  auto output__ = torch::gelu_backward_out(*grad_input, *grad_output, *self, approximate);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_infinitely_differentiable_gelu_backward(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *grad = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::infinitely_differentiable_gelu_backward(*grad, *self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_hardshrink(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *lambd = info__[1].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::hardshrink(*self, *lambd);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_hardshrink_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *lambd = info__[2].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::hardshrink_out(*out, *self, *lambd);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_hardshrink_backward(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *grad_out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *lambd = info__[2].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::hardshrink_backward(*grad_out, *self, *lambd);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_hardshrink_backward_grad_input(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *grad_input = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *grad_out = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *lambd = info__[3].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::hardshrink_backward_out(*grad_input, *grad_out, *self, *lambd);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_rsqrt(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::rsqrt(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_rsqrt_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::rsqrt_out(*out, *self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_rsqrt_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::rsqrt_(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_select(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t dim = info__[1].As<Napi::Number>().Int64Value();
  int64_t index = info__[2].As<Napi::Number>().Int64Value();
  auto output__ = torch::select(*self, dim, index);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_select_backward(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *grad_output = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array input_sizes_array__ = info__[1].As<Napi::Array>();
  int input_sizes_len = input_sizes_array__.Length();
  int64_t *input_sizes_data = new int64_t[input_sizes_len];
  for (int i = 0; i < input_sizes_len; ++i)
    input_sizes_data[i] = input_sizes_array__.Get(i).ToNumber().Int64Value();
  int64_t dim = info__[2].As<Napi::Number>().Int64Value();
  int64_t index = info__[3].As<Napi::Number>().Int64Value();
  auto output__ = torch::select_backward(*grad_output, torch::IntArrayRef(input_sizes_data, input_sizes_len), dim, index);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_select_backward_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *grad_output = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array input_sizes_array__ = info__[2].As<Napi::Array>();
  int input_sizes_len = input_sizes_array__.Length();
  int64_t *input_sizes_data = new int64_t[input_sizes_len];
  for (int i = 0; i < input_sizes_len; ++i)
    input_sizes_data[i] = input_sizes_array__.Get(i).ToNumber().Int64Value();
  int64_t dim = info__[3].As<Napi::Number>().Int64Value();
  int64_t index = info__[4].As<Napi::Number>().Int64Value();
  auto output__ = torch::select_backward_out(*out, *grad_output, torch::IntArrayRef(input_sizes_data, input_sizes_len), dim, index);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__nested_select_backward(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *grad_output = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  int64_t dim = info__[2].As<Napi::Number>().Int64Value();
  int64_t index = info__[3].As<Napi::Number>().Int64Value();
  auto output__ = torch::_nested_select_backward(*grad_output, *self, dim, index);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_selu(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::selu(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_selu_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::selu_(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_celu(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *alpha = info__[1].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::celu(*self, *alpha);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_celu_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *alpha = info__[2].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::celu_out(*out, *self, *alpha);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_celu_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *alpha = info__[1].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::celu_(*self, *alpha);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_silu(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::silu(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_silu_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::silu_out(*out, *self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_silu_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::silu_(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_silu_backward(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *grad_output = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::silu_backward(*grad_output, *self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_silu_backward_grad_input(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *grad_input = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *grad_output = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[2].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::silu_backward_out(*grad_input, *grad_output, *self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_mish(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::mish(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_mish_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::mish_out(*out, *self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_mish_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::mish_(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_mish_backward(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *grad_output = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::mish_backward(*grad_output, *self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_sigmoid(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::sigmoid(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_sigmoid_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::sigmoid_out(*out, *self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_sigmoid_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::sigmoid_(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_logit(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  bool eps_null = info__[1].IsUndefined();
  double eps_v = eps_null ? 0 : info__[1].As<Napi::Number>().DoubleValue();
  auto output__ = torch::logit(*self, eps_null ? c10::nullopt : c10::optional<double>(eps_v));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_logit_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  bool eps_null = info__[2].IsUndefined();
  double eps_v = eps_null ? 0 : info__[2].As<Napi::Number>().DoubleValue();
  auto output__ = torch::logit_out(*out, *self, eps_null ? c10::nullopt : c10::optional<double>(eps_v));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_logit_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  bool eps_null = info__[1].IsUndefined();
  double eps_v = eps_null ? 0 : info__[1].As<Napi::Number>().DoubleValue();
  auto output__ = torch::logit_(*self, eps_null ? c10::nullopt : c10::optional<double>(eps_v));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_sin(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::sin(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_sin_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::sin_out(*out, *self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_sin_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::sin_(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_sinc(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::sinc(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_sinc_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::sinc_out(*out, *self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_sinc_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::sinc_(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_sinh(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::sinh(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_sinh_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::sinh_out(*out, *self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_sinh_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::sinh_(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_detach(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::detach(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_detach_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::detach_(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_slice(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t dim = info__[1].As<Napi::Number>().Int64Value();
  bool start_null = info__[2].IsUndefined();
  int64_t start_v = start_null ? 0 : info__[2].As<Napi::Number>().Int64Value();
  bool end_null = info__[3].IsUndefined();
  int64_t end_v = end_null ? 0 : info__[3].As<Napi::Number>().Int64Value();
  int64_t step = info__[4].As<Napi::Number>().Int64Value();
  auto output__ = torch::slice(*self, dim, start_null ? c10::nullopt : c10::optional<int64_t>(start_v), end_null ? c10::nullopt : c10::optional<int64_t>(end_v), step);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_slice_backward(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *grad_output = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array input_sizes_array__ = info__[1].As<Napi::Array>();
  int input_sizes_len = input_sizes_array__.Length();
  int64_t *input_sizes_data = new int64_t[input_sizes_len];
  for (int i = 0; i < input_sizes_len; ++i)
    input_sizes_data[i] = input_sizes_array__.Get(i).ToNumber().Int64Value();
  int64_t dim = info__[2].As<Napi::Number>().Int64Value();
  int64_t start = info__[3].As<Napi::Number>().Int64Value();
  int64_t end = info__[4].As<Napi::Number>().Int64Value();
  int64_t step = info__[5].As<Napi::Number>().Int64Value();
  auto output__ = torch::slice_backward(*grad_output, torch::IntArrayRef(input_sizes_data, input_sizes_len), dim, start, end, step);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_slice_backward_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *grad_output = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array input_sizes_array__ = info__[2].As<Napi::Array>();
  int input_sizes_len = input_sizes_array__.Length();
  int64_t *input_sizes_data = new int64_t[input_sizes_len];
  for (int i = 0; i < input_sizes_len; ++i)
    input_sizes_data[i] = input_sizes_array__.Get(i).ToNumber().Int64Value();
  int64_t dim = info__[3].As<Napi::Number>().Int64Value();
  int64_t start = info__[4].As<Napi::Number>().Int64Value();
  int64_t end = info__[5].As<Napi::Number>().Int64Value();
  int64_t step = info__[6].As<Napi::Number>().Int64Value();
  auto output__ = torch::slice_backward_out(*out, *grad_output, torch::IntArrayRef(input_sizes_data, input_sizes_len), dim, start, end, step);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_slice_scatter(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *src = info__[1].As<Napi::External<torch::Tensor>>().Data();
  int64_t dim = info__[2].As<Napi::Number>().Int64Value();
  bool start_null = info__[3].IsUndefined();
  int64_t start_v = start_null ? 0 : info__[3].As<Napi::Number>().Int64Value();
  bool end_null = info__[4].IsUndefined();
  int64_t end_v = end_null ? 0 : info__[4].As<Napi::Number>().Int64Value();
  int64_t step = info__[5].As<Napi::Number>().Int64Value();
  auto output__ = torch::slice_scatter(*self, *src, dim, start_null ? c10::nullopt : c10::optional<int64_t>(start_v), end_null ? c10::nullopt : c10::optional<int64_t>(end_v), step);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_slice_scatter_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *src = info__[2].As<Napi::External<torch::Tensor>>().Data();
  int64_t dim = info__[3].As<Napi::Number>().Int64Value();
  bool start_null = info__[4].IsUndefined();
  int64_t start_v = start_null ? 0 : info__[4].As<Napi::Number>().Int64Value();
  bool end_null = info__[5].IsUndefined();
  int64_t end_v = end_null ? 0 : info__[5].As<Napi::Number>().Int64Value();
  int64_t step = info__[6].As<Napi::Number>().Int64Value();
  auto output__ = torch::slice_scatter_out(*out, *self, *src, dim, start_null ? c10::nullopt : c10::optional<int64_t>(start_v), end_null ? c10::nullopt : c10::optional<int64_t>(end_v), step);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_select_scatter(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *src = info__[1].As<Napi::External<torch::Tensor>>().Data();
  int64_t dim = info__[2].As<Napi::Number>().Int64Value();
  int64_t index = info__[3].As<Napi::Number>().Int64Value();
  auto output__ = torch::select_scatter(*self, *src, dim, index);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_select_scatter_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *src = info__[2].As<Napi::External<torch::Tensor>>().Data();
  int64_t dim = info__[3].As<Napi::Number>().Int64Value();
  int64_t index = info__[4].As<Napi::Number>().Int64Value();
  auto output__ = torch::select_scatter_out(*out, *self, *src, dim, index);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_diagonal_scatter(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *src = info__[1].As<Napi::External<torch::Tensor>>().Data();
  int64_t offset = info__[2].As<Napi::Number>().Int64Value();
  int64_t dim1 = info__[3].As<Napi::Number>().Int64Value();
  int64_t dim2 = info__[4].As<Napi::Number>().Int64Value();
  auto output__ = torch::diagonal_scatter(*self, *src, offset, dim1, dim2);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_diagonal_scatter_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *src = info__[2].As<Napi::External<torch::Tensor>>().Data();
  int64_t offset = info__[3].As<Napi::Number>().Int64Value();
  int64_t dim1 = info__[4].As<Napi::Number>().Int64Value();
  int64_t dim2 = info__[5].As<Napi::Number>().Int64Value();
  auto output__ = torch::diagonal_scatter_out(*out, *self, *src, offset, dim1, dim2);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_as_strided_scatter(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *src = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array size_array__ = info__[2].As<Napi::Array>();
  int size_len = size_array__.Length();
  int64_t *size_data = new int64_t[size_len];
  for (int i = 0; i < size_len; ++i)
    size_data[i] = size_array__.Get(i).ToNumber().Int64Value();
  Napi::Array stride_array__ = info__[3].As<Napi::Array>();
  int stride_len = stride_array__.Length();
  int64_t *stride_data = new int64_t[stride_len];
  for (int i = 0; i < stride_len; ++i)
    stride_data[i] = stride_array__.Get(i).ToNumber().Int64Value();
  bool storage_offset_null = info__[4].IsUndefined();
  int64_t storage_offset_v = storage_offset_null ? 0 : info__[4].As<Napi::Number>().Int64Value();
  auto output__ = torch::as_strided_scatter(*self, *src, torch::IntArrayRef(size_data, size_len), torch::IntArrayRef(stride_data, stride_len), storage_offset_null ? c10::nullopt : c10::optional<int64_t>(storage_offset_v));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_as_strided_scatter_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *src = info__[2].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array size_array__ = info__[3].As<Napi::Array>();
  int size_len = size_array__.Length();
  int64_t *size_data = new int64_t[size_len];
  for (int i = 0; i < size_len; ++i)
    size_data[i] = size_array__.Get(i).ToNumber().Int64Value();
  Napi::Array stride_array__ = info__[4].As<Napi::Array>();
  int stride_len = stride_array__.Length();
  int64_t *stride_data = new int64_t[stride_len];
  for (int i = 0; i < stride_len; ++i)
    stride_data[i] = stride_array__.Get(i).ToNumber().Int64Value();
  bool storage_offset_null = info__[5].IsUndefined();
  int64_t storage_offset_v = storage_offset_null ? 0 : info__[5].As<Napi::Number>().Int64Value();
  auto output__ = torch::as_strided_scatter_out(*out, *self, *src, torch::IntArrayRef(size_data, size_len), torch::IntArrayRef(stride_data, stride_len), storage_offset_null ? c10::nullopt : c10::optional<int64_t>(storage_offset_v));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_smm(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *mat2 = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::smm(*self, *mat2);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_softmax(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t dim = info__[1].As<Napi::Number>().Int64Value();
  int dtype = info__[2].As<Napi::Number>().Int32Value();
  auto output__ = torch::softmax(*self, dim, at::ScalarType(dtype));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_softmax_int_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  int64_t dim = info__[2].As<Napi::Number>().Int64Value();
  int dtype = info__[3].As<Napi::Number>().Int32Value();
  auto output__ = torch::softmax_out(*out, *self, dim, at::ScalarType(dtype));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__softmax(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t dim = info__[1].As<Napi::Number>().Int64Value();
  bool half_to_float = info__[2].As<Napi::Boolean>().Value();
  auto output__ = torch::_softmax(*self, dim, half_to_float);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__softmax_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  int64_t dim = info__[2].As<Napi::Number>().Int64Value();
  bool half_to_float = info__[3].As<Napi::Boolean>().Value();
  auto output__ = torch::_softmax_out(*out, *self, dim, half_to_float);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__softmax_backward_data(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *grad_output = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *output = info__[1].As<Napi::External<torch::Tensor>>().Data();
  int64_t dim = info__[2].As<Napi::Number>().Int64Value();
  int input_dtype = info__[3].As<Napi::Number>().Int32Value();
  auto output__ = torch::_softmax_backward_data(*grad_output, *output, dim, at::ScalarType(input_dtype));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__softmax_backward_data_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *grad_input = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *grad_output = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *output = info__[2].As<Napi::External<torch::Tensor>>().Data();
  int64_t dim = info__[3].As<Napi::Number>().Int64Value();
  int input_dtype = info__[4].As<Napi::Number>().Int32Value();
  auto output__ = torch::_softmax_backward_data_out(*grad_input, *grad_output, *output, dim, at::ScalarType(input_dtype));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_squeeze(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::squeeze(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_squeeze_dim(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t dim = info__[1].As<Napi::Number>().Int64Value();
  auto output__ = torch::squeeze(*self, dim);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_squeeze_dims(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array dim_array__ = info__[1].As<Napi::Array>();
  int dim_len = dim_array__.Length();
  int64_t *dim_data = new int64_t[dim_len];
  for (int i = 0; i < dim_len; ++i)
    dim_data[i] = dim_array__.Get(i).ToNumber().Int64Value();
  auto output__ = torch::squeeze(*self, torch::IntArrayRef(dim_data, dim_len));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_squeeze_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = self->squeeze_();
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_squeeze_dim_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t dim = info__[1].As<Napi::Number>().Int64Value();
  auto output__ = self->squeeze_(dim);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_squeeze_dims_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array dim_array__ = info__[1].As<Napi::Array>();
  int dim_len = dim_array__.Length();
  int64_t *dim_data = new int64_t[dim_len];
  for (int i = 0; i < dim_len; ++i)
    dim_data[i] = dim_array__.Get(i).ToNumber().Int64Value();
  auto output__ = self->squeeze_(torch::IntArrayRef(dim_data, dim_len));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_sspaddmm(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *mat1 = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *mat2 = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *beta = info__[3].As<Napi::External<torch::Scalar>>().Data();
  torch::Scalar *alpha = info__[4].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::sspaddmm(*self, *mat1, *mat2, *beta, *alpha);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_sspaddmm_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *mat1 = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *mat2 = info__[3].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *beta = info__[4].As<Napi::External<torch::Scalar>>().Data();
  torch::Scalar *alpha = info__[5].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::sspaddmm_out(*out, *self, *mat1, *mat2, *beta, *alpha);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_stack(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  Napi::Array tensors_array__ = info__[0].As<Napi::Array>();
  int tensors_len = tensors_array__.Length();
  torch::Tensor **tensors_data = new torch::Tensor *[tensors_len];
  for (int i = 0; i < tensors_len; ++i)
    tensors_data[i] = tensors_array__.Get(i).As<Napi::External<torch::Tensor>>().Data();
  int64_t dim = info__[1].As<Napi::Number>().Int64Value();
  auto output__ = torch::stack(of_carray_tensor(tensors_data, tensors_len), dim);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_stack_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array tensors_array__ = info__[1].As<Napi::Array>();
  int tensors_len = tensors_array__.Length();
  torch::Tensor **tensors_data = new torch::Tensor *[tensors_len];
  for (int i = 0; i < tensors_len; ++i)
    tensors_data[i] = tensors_array__.Get(i).As<Napi::External<torch::Tensor>>().Data();
  int64_t dim = info__[2].As<Napi::Number>().Int64Value();
  auto output__ = torch::stack_out(*out, of_carray_tensor(tensors_data, tensors_len), dim);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__stack(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  Napi::Array tensors_array__ = info__[0].As<Napi::Array>();
  int tensors_len = tensors_array__.Length();
  torch::Tensor **tensors_data = new torch::Tensor *[tensors_len];
  for (int i = 0; i < tensors_len; ++i)
    tensors_data[i] = tensors_array__.Get(i).As<Napi::External<torch::Tensor>>().Data();
  int64_t dim = info__[1].As<Napi::Number>().Int64Value();
  auto output__ = torch::_stack(of_carray_tensor(tensors_data, tensors_len), dim);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__stack_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array tensors_array__ = info__[1].As<Napi::Array>();
  int tensors_len = tensors_array__.Length();
  torch::Tensor **tensors_data = new torch::Tensor *[tensors_len];
  for (int i = 0; i < tensors_len; ++i)
    tensors_data[i] = tensors_array__.Get(i).As<Napi::External<torch::Tensor>>().Data();
  int64_t dim = info__[2].As<Napi::Number>().Int64Value();
  auto output__ = torch::_stack_out(*out, of_carray_tensor(tensors_data, tensors_len), dim);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_hstack(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  Napi::Array tensors_array__ = info__[0].As<Napi::Array>();
  int tensors_len = tensors_array__.Length();
  torch::Tensor **tensors_data = new torch::Tensor *[tensors_len];
  for (int i = 0; i < tensors_len; ++i)
    tensors_data[i] = tensors_array__.Get(i).As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::hstack(of_carray_tensor(tensors_data, tensors_len));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_hstack_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array tensors_array__ = info__[1].As<Napi::Array>();
  int tensors_len = tensors_array__.Length();
  torch::Tensor **tensors_data = new torch::Tensor *[tensors_len];
  for (int i = 0; i < tensors_len; ++i)
    tensors_data[i] = tensors_array__.Get(i).As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::hstack_out(*out, of_carray_tensor(tensors_data, tensors_len));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_vstack(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  Napi::Array tensors_array__ = info__[0].As<Napi::Array>();
  int tensors_len = tensors_array__.Length();
  torch::Tensor **tensors_data = new torch::Tensor *[tensors_len];
  for (int i = 0; i < tensors_len; ++i)
    tensors_data[i] = tensors_array__.Get(i).As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::vstack(of_carray_tensor(tensors_data, tensors_len));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_vstack_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array tensors_array__ = info__[1].As<Napi::Array>();
  int tensors_len = tensors_array__.Length();
  torch::Tensor **tensors_data = new torch::Tensor *[tensors_len];
  for (int i = 0; i < tensors_len; ++i)
    tensors_data[i] = tensors_array__.Get(i).As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::vstack_out(*out, of_carray_tensor(tensors_data, tensors_len));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_dstack(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  Napi::Array tensors_array__ = info__[0].As<Napi::Array>();
  int tensors_len = tensors_array__.Length();
  torch::Tensor **tensors_data = new torch::Tensor *[tensors_len];
  for (int i = 0; i < tensors_len; ++i)
    tensors_data[i] = tensors_array__.Get(i).As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::dstack(of_carray_tensor(tensors_data, tensors_len));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_dstack_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array tensors_array__ = info__[1].As<Napi::Array>();
  int tensors_len = tensors_array__.Length();
  torch::Tensor **tensors_data = new torch::Tensor *[tensors_len];
  for (int i = 0; i < tensors_len; ++i)
    tensors_data[i] = tensors_array__.Get(i).As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::dstack_out(*out, of_carray_tensor(tensors_data, tensors_len));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_stft(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t n_fft = info__[1].As<Napi::Number>().Int64Value();
  bool hop_length_null = info__[2].IsUndefined();
  int64_t hop_length_v = hop_length_null ? 0 : info__[2].As<Napi::Number>().Int64Value();
  bool win_length_null = info__[3].IsUndefined();
  int64_t win_length_v = win_length_null ? 0 : info__[3].As<Napi::Number>().Int64Value();
  bool window_null = info__[4].IsUndefined();
  torch::Tensor *window_v = window_null ? nullptr : info__[4].As<Napi::External<torch::Tensor>>().Data();
  bool normalized = info__[5].As<Napi::Boolean>().Value();
  bool onesided = info__[6].As<Napi::Boolean>().Value();
  bool return_complex = info__[7].As<Napi::Boolean>().Value();
  auto output__ = torch::stft(*self, n_fft, hop_length_null ? c10::nullopt : c10::optional<int64_t>(hop_length_v), win_length_null ? c10::nullopt : c10::optional<int64_t>(win_length_v), (window_null ? *window_v : torch::Tensor()), normalized, onesided, return_complex);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_stft_center(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t n_fft = info__[1].As<Napi::Number>().Int64Value();
  bool hop_length_null = info__[2].IsUndefined();
  int64_t hop_length_v = hop_length_null ? 0 : info__[2].As<Napi::Number>().Int64Value();
  bool win_length_null = info__[3].IsUndefined();
  int64_t win_length_v = win_length_null ? 0 : info__[3].As<Napi::Number>().Int64Value();
  bool window_null = info__[4].IsUndefined();
  torch::Tensor *window_v = window_null ? nullptr : info__[4].As<Napi::External<torch::Tensor>>().Data();
  bool center = info__[5].As<Napi::Boolean>().Value();
  Napi::String pad_mode_str__ = info__[6].As<Napi::String>();
  std::string pad_mode = pad_mode_str__.Utf8Value();
  bool normalized = info__[7].As<Napi::Boolean>().Value();
  bool onesided = info__[8].As<Napi::Boolean>().Value();
  bool return_complex = info__[9].As<Napi::Boolean>().Value();
  auto output__ = torch::stft(*self, n_fft, hop_length_null ? c10::nullopt : c10::optional<int64_t>(hop_length_v), win_length_null ? c10::nullopt : c10::optional<int64_t>(win_length_v), (window_null ? *window_v : torch::Tensor()), center, pad_mode, normalized, onesided, return_complex);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_istft(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t n_fft = info__[1].As<Napi::Number>().Int64Value();
  bool hop_length_null = info__[2].IsUndefined();
  int64_t hop_length_v = hop_length_null ? 0 : info__[2].As<Napi::Number>().Int64Value();
  bool win_length_null = info__[3].IsUndefined();
  int64_t win_length_v = win_length_null ? 0 : info__[3].As<Napi::Number>().Int64Value();
  bool window_null = info__[4].IsUndefined();
  torch::Tensor *window_v = window_null ? nullptr : info__[4].As<Napi::External<torch::Tensor>>().Data();
  bool center = info__[5].As<Napi::Boolean>().Value();
  bool normalized = info__[6].As<Napi::Boolean>().Value();
  bool onesided = info__[7].As<Napi::Boolean>().Value();
  bool length_null = info__[8].IsUndefined();
  int64_t length_v = length_null ? 0 : info__[8].As<Napi::Number>().Int64Value();
  bool return_complex = info__[9].As<Napi::Boolean>().Value();
  auto output__ = torch::istft(*self, n_fft, hop_length_null ? c10::nullopt : c10::optional<int64_t>(hop_length_v), win_length_null ? c10::nullopt : c10::optional<int64_t>(win_length_v), (window_null ? *window_v : torch::Tensor()), center, normalized, onesided, length_null ? c10::nullopt : c10::optional<int64_t>(length_v), return_complex);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_sum(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int dtype = info__[1].As<Napi::Number>().Int32Value();
  auto output__ = torch::sum(*self, at::ScalarType(dtype));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_sum_dim_intlist(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array dim_array__ = info__[1].As<Napi::Array>();
  int dim_len = dim_array__.Length();
  int64_t *dim_data = new int64_t[dim_len];
  for (int i = 0; i < dim_len; ++i)
    dim_data[i] = dim_array__.Get(i).ToNumber().Int64Value();
  bool keepdim = info__[2].As<Napi::Boolean>().Value();
  int dtype = info__[3].As<Napi::Number>().Int32Value();
  auto output__ = torch::sum(*self, dim_data == nullptr ? c10::nullopt : c10::optional<torch::IntArrayRef>(torch::IntArrayRef(dim_data, dim_len)), keepdim, at::ScalarType(dtype));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_sum_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  int dtype = info__[2].As<Napi::Number>().Int32Value();
  auto output__ = torch::sum_out(*out, *self, at::ScalarType(dtype));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_sum_intlist_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array dim_array__ = info__[2].As<Napi::Array>();
  int dim_len = dim_array__.Length();
  int64_t *dim_data = new int64_t[dim_len];
  for (int i = 0; i < dim_len; ++i)
    dim_data[i] = dim_array__.Get(i).ToNumber().Int64Value();
  bool keepdim = info__[3].As<Napi::Boolean>().Value();
  int dtype = info__[4].As<Napi::Number>().Int32Value();
  auto output__ = torch::sum_out(*out, *self, dim_data == nullptr ? c10::nullopt : c10::optional<torch::IntArrayRef>(torch::IntArrayRef(dim_data, dim_len)), keepdim, at::ScalarType(dtype));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__nested_sum_backward(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *grad = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array dim_array__ = info__[2].As<Napi::Array>();
  int dim_len = dim_array__.Length();
  int64_t *dim_data = new int64_t[dim_len];
  for (int i = 0; i < dim_len; ++i)
    dim_data[i] = dim_array__.Get(i).ToNumber().Int64Value();
  bool keepdim = info__[3].As<Napi::Boolean>().Value();
  auto output__ = torch::_nested_sum_backward(*grad, *self, dim_data == nullptr ? c10::nullopt : c10::optional<torch::IntArrayRef>(torch::IntArrayRef(dim_data, dim_len)), keepdim);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_nansum(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array dim_array__ = info__[1].As<Napi::Array>();
  int dim_len = dim_array__.Length();
  int64_t *dim_data = new int64_t[dim_len];
  for (int i = 0; i < dim_len; ++i)
    dim_data[i] = dim_array__.Get(i).ToNumber().Int64Value();
  bool keepdim = info__[2].As<Napi::Boolean>().Value();
  int dtype = info__[3].As<Napi::Number>().Int32Value();
  auto output__ = torch::nansum(*self, dim_data == nullptr ? c10::nullopt : c10::optional<torch::IntArrayRef>(torch::IntArrayRef(dim_data, dim_len)), keepdim, at::ScalarType(dtype));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_nansum_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array dim_array__ = info__[2].As<Napi::Array>();
  int dim_len = dim_array__.Length();
  int64_t *dim_data = new int64_t[dim_len];
  for (int i = 0; i < dim_len; ++i)
    dim_data[i] = dim_array__.Get(i).ToNumber().Int64Value();
  bool keepdim = info__[3].As<Napi::Boolean>().Value();
  int dtype = info__[4].As<Napi::Number>().Int32Value();
  auto output__ = torch::nansum_out(*out, *self, dim_data == nullptr ? c10::nullopt : c10::optional<torch::IntArrayRef>(torch::IntArrayRef(dim_data, dim_len)), keepdim, at::ScalarType(dtype));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_sum_to_size(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array size_array__ = info__[1].As<Napi::Array>();
  int size_len = size_array__.Length();
  int64_t *size_data = new int64_t[size_len];
  for (int i = 0; i < size_len; ++i)
    size_data[i] = size_array__.Get(i).ToNumber().Int64Value();
  auto output__ = self->sum_to_size(torch::IntArrayRef(size_data, size_len));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_sqrt(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::sqrt(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_sqrt_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::sqrt_out(*out, *self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_sqrt_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::sqrt_(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_square(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::square(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_square_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::square_out(*out, *self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_square_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::square_(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_std(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  bool unbiased = info__[1].As<Napi::Boolean>().Value();
  auto output__ = torch::std(*self, unbiased);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_std_dim(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array dim_array__ = info__[1].As<Napi::Array>();
  int dim_len = dim_array__.Length();
  int64_t *dim_data = new int64_t[dim_len];
  for (int i = 0; i < dim_len; ++i)
    dim_data[i] = dim_array__.Get(i).ToNumber().Int64Value();
  bool unbiased = info__[2].As<Napi::Boolean>().Value();
  bool keepdim = info__[3].As<Napi::Boolean>().Value();
  auto output__ = torch::std(*self, dim_data == nullptr ? c10::nullopt : c10::optional<torch::IntArrayRef>(torch::IntArrayRef(dim_data, dim_len)), unbiased, keepdim);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_std_correction(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array dim_array__ = info__[1].As<Napi::Array>();
  int dim_len = dim_array__.Length();
  int64_t *dim_data = new int64_t[dim_len];
  for (int i = 0; i < dim_len; ++i)
    dim_data[i] = dim_array__.Get(i).ToNumber().Int64Value();
  bool correction_null = info__[2].IsUndefined();
  int64_t correction_v = correction_null ? 0 : info__[2].As<Napi::Number>().Int64Value();
  bool keepdim = info__[3].As<Napi::Boolean>().Value();
  auto output__ = torch::std(*self, dim_data == nullptr ? c10::nullopt : c10::optional<torch::IntArrayRef>(torch::IntArrayRef(dim_data, dim_len)), correction_null ? c10::nullopt : c10::optional<int64_t>(correction_v), keepdim);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_std_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array dim_array__ = info__[2].As<Napi::Array>();
  int dim_len = dim_array__.Length();
  int64_t *dim_data = new int64_t[dim_len];
  for (int i = 0; i < dim_len; ++i)
    dim_data[i] = dim_array__.Get(i).ToNumber().Int64Value();
  bool unbiased = info__[3].As<Napi::Boolean>().Value();
  bool keepdim = info__[4].As<Napi::Boolean>().Value();
  auto output__ = torch::std_out(*out, *self, dim_data == nullptr ? c10::nullopt : c10::optional<torch::IntArrayRef>(torch::IntArrayRef(dim_data, dim_len)), unbiased, keepdim);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_std_correction_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array dim_array__ = info__[2].As<Napi::Array>();
  int dim_len = dim_array__.Length();
  int64_t *dim_data = new int64_t[dim_len];
  for (int i = 0; i < dim_len; ++i)
    dim_data[i] = dim_array__.Get(i).ToNumber().Int64Value();
  bool correction_null = info__[3].IsUndefined();
  int64_t correction_v = correction_null ? 0 : info__[3].As<Napi::Number>().Int64Value();
  bool keepdim = info__[4].As<Napi::Boolean>().Value();
  auto output__ = torch::std_out(*out, *self, dim_data == nullptr ? c10::nullopt : c10::optional<torch::IntArrayRef>(torch::IntArrayRef(dim_data, dim_len)), correction_null ? c10::nullopt : c10::optional<int64_t>(correction_v), keepdim);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::Array atg_std_mean(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  bool unbiased = info__[1].As<Napi::Boolean>().Value();
  auto output__ = torch::std_mean(*self, unbiased);
  Napi::Array output__array__ = Napi::Array::New(env__, 2);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  return output__array__;
}

Napi::Array atg_std_mean_dim(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array dim_array__ = info__[1].As<Napi::Array>();
  int dim_len = dim_array__.Length();
  int64_t *dim_data = new int64_t[dim_len];
  for (int i = 0; i < dim_len; ++i)
    dim_data[i] = dim_array__.Get(i).ToNumber().Int64Value();
  bool unbiased = info__[2].As<Napi::Boolean>().Value();
  bool keepdim = info__[3].As<Napi::Boolean>().Value();
  auto output__ = torch::std_mean(*self, dim_data == nullptr ? c10::nullopt : c10::optional<torch::IntArrayRef>(torch::IntArrayRef(dim_data, dim_len)), unbiased, keepdim);
  Napi::Array output__array__ = Napi::Array::New(env__, 2);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  return output__array__;
}

Napi::Array atg_std_mean_correction(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array dim_array__ = info__[1].As<Napi::Array>();
  int dim_len = dim_array__.Length();
  int64_t *dim_data = new int64_t[dim_len];
  for (int i = 0; i < dim_len; ++i)
    dim_data[i] = dim_array__.Get(i).ToNumber().Int64Value();
  bool correction_null = info__[2].IsUndefined();
  int64_t correction_v = correction_null ? 0 : info__[2].As<Napi::Number>().Int64Value();
  bool keepdim = info__[3].As<Napi::Boolean>().Value();
  auto output__ = torch::std_mean(*self, dim_data == nullptr ? c10::nullopt : c10::optional<torch::IntArrayRef>(torch::IntArrayRef(dim_data, dim_len)), correction_null ? c10::nullopt : c10::optional<int64_t>(correction_v), keepdim);
  Napi::Array output__array__ = Napi::Array::New(env__, 2);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  return output__array__;
}

Napi::Array atg_std_mean_correction_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out0 = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *out1 = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[2].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array dim_array__ = info__[3].As<Napi::Array>();
  int dim_len = dim_array__.Length();
  int64_t *dim_data = new int64_t[dim_len];
  for (int i = 0; i < dim_len; ++i)
    dim_data[i] = dim_array__.Get(i).ToNumber().Int64Value();
  bool correction_null = info__[4].IsUndefined();
  int64_t correction_v = correction_null ? 0 : info__[4].As<Napi::Number>().Int64Value();
  bool keepdim = info__[5].As<Napi::Boolean>().Value();
  auto output__ = torch::std_mean_out(*out0, *out1, *self, dim_data == nullptr ? c10::nullopt : c10::optional<torch::IntArrayRef>(torch::IntArrayRef(dim_data, dim_len)), correction_null ? c10::nullopt : c10::optional<int64_t>(correction_v), keepdim);
  Napi::Array output__array__ = Napi::Array::New(env__, 2);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  return output__array__;
}

Napi::External<torch::Tensor> atg_prod(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int dtype = info__[1].As<Napi::Number>().Int32Value();
  auto output__ = torch::prod(*self, at::ScalarType(dtype));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_prod_dim_int(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t dim = info__[1].As<Napi::Number>().Int64Value();
  bool keepdim = info__[2].As<Napi::Boolean>().Value();
  int dtype = info__[3].As<Napi::Number>().Int32Value();
  auto output__ = torch::prod(*self, dim, keepdim, at::ScalarType(dtype));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_prod_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  int dtype = info__[2].As<Napi::Number>().Int32Value();
  auto output__ = torch::prod_out(*out, *self, at::ScalarType(dtype));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_prod_int_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  int64_t dim = info__[2].As<Napi::Number>().Int64Value();
  bool keepdim = info__[3].As<Napi::Boolean>().Value();
  int dtype = info__[4].As<Napi::Number>().Int32Value();
  auto output__ = torch::prod_out(*out, *self, dim, keepdim, at::ScalarType(dtype));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_t(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::t(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_t_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = self->t_();
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_tan(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::tan(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_tan_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::tan_out(*out, *self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_tan_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::tan_(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_tanh(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::tanh(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_tanh_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::tanh_out(*out, *self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_tanh_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::tanh_(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_tensordot(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array dims_self_array__ = info__[2].As<Napi::Array>();
  int dims_self_len = dims_self_array__.Length();
  int64_t *dims_self_data = new int64_t[dims_self_len];
  for (int i = 0; i < dims_self_len; ++i)
    dims_self_data[i] = dims_self_array__.Get(i).ToNumber().Int64Value();
  Napi::Array dims_other_array__ = info__[3].As<Napi::Array>();
  int dims_other_len = dims_other_array__.Length();
  int64_t *dims_other_data = new int64_t[dims_other_len];
  for (int i = 0; i < dims_other_len; ++i)
    dims_other_data[i] = dims_other_array__.Get(i).ToNumber().Int64Value();
  auto output__ = torch::tensordot(*self, *other, torch::IntArrayRef(dims_self_data, dims_self_len), torch::IntArrayRef(dims_other_data, dims_other_len));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_tensordot_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[2].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array dims_self_array__ = info__[3].As<Napi::Array>();
  int dims_self_len = dims_self_array__.Length();
  int64_t *dims_self_data = new int64_t[dims_self_len];
  for (int i = 0; i < dims_self_len; ++i)
    dims_self_data[i] = dims_self_array__.Get(i).ToNumber().Int64Value();
  Napi::Array dims_other_array__ = info__[4].As<Napi::Array>();
  int dims_other_len = dims_other_array__.Length();
  int64_t *dims_other_data = new int64_t[dims_other_len];
  for (int i = 0; i < dims_other_len; ++i)
    dims_other_data[i] = dims_other_array__.Get(i).ToNumber().Int64Value();
  auto output__ = torch::tensordot_out(*out, *self, *other, torch::IntArrayRef(dims_self_data, dims_self_len), torch::IntArrayRef(dims_other_data, dims_other_len));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_threshold(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *threshold = info__[1].As<Napi::External<torch::Scalar>>().Data();
  torch::Scalar *value = info__[2].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::threshold(*self, *threshold, *value);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_threshold_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *threshold = info__[2].As<Napi::External<torch::Scalar>>().Data();
  torch::Scalar *value = info__[3].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::threshold_out(*out, *self, *threshold, *value);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_threshold_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *threshold = info__[1].As<Napi::External<torch::Scalar>>().Data();
  torch::Scalar *value = info__[2].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::threshold_(*self, *threshold, *value);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_threshold_backward(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *grad_output = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *threshold = info__[2].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::threshold_backward(*grad_output, *self, *threshold);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_threshold_backward_grad_input(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *grad_input = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *grad_output = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *threshold = info__[3].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::threshold_backward_out(*grad_input, *grad_output, *self, *threshold);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_tile(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array dims_array__ = info__[1].As<Napi::Array>();
  int dims_len = dims_array__.Length();
  int64_t *dims_data = new int64_t[dims_len];
  for (int i = 0; i < dims_len; ++i)
    dims_data[i] = dims_array__.Get(i).ToNumber().Int64Value();
  auto output__ = torch::tile(*self, torch::IntArrayRef(dims_data, dims_len));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_transpose(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t dim0 = info__[1].As<Napi::Number>().Int64Value();
  int64_t dim1 = info__[2].As<Napi::Number>().Int64Value();
  auto output__ = torch::transpose(*self, dim0, dim1);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__mkldnn_transpose(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t dim0 = info__[1].As<Napi::Number>().Int64Value();
  int64_t dim1 = info__[2].As<Napi::Number>().Int64Value();
  auto output__ = torch::_mkldnn_transpose(*self, dim0, dim1);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__mkldnn_transpose_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  int64_t dim0 = info__[2].As<Napi::Number>().Int64Value();
  int64_t dim1 = info__[3].As<Napi::Number>().Int64Value();
  auto output__ = torch::_mkldnn_transpose_out(*out, *self, dim0, dim1);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_transpose_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t dim0 = info__[1].As<Napi::Number>().Int64Value();
  int64_t dim1 = info__[2].As<Napi::Number>().Int64Value();
  auto output__ = self->transpose_(dim0, dim1);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__mkldnn_transpose_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t dim0 = info__[1].As<Napi::Number>().Int64Value();
  int64_t dim1 = info__[2].As<Napi::Number>().Int64Value();
  auto output__ = torch::_mkldnn_transpose_(*self, dim0, dim1);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_one_hot(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t num_classes = info__[1].As<Napi::Number>().Int64Value();
  auto output__ = torch::one_hot(*self, num_classes);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_flip(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array dims_array__ = info__[1].As<Napi::Array>();
  int dims_len = dims_array__.Length();
  int64_t *dims_data = new int64_t[dims_len];
  for (int i = 0; i < dims_len; ++i)
    dims_data[i] = dims_array__.Get(i).ToNumber().Int64Value();
  auto output__ = torch::flip(*self, torch::IntArrayRef(dims_data, dims_len));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_flip_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array dims_array__ = info__[2].As<Napi::Array>();
  int dims_len = dims_array__.Length();
  int64_t *dims_data = new int64_t[dims_len];
  for (int i = 0; i < dims_len; ++i)
    dims_data[i] = dims_array__.Get(i).ToNumber().Int64Value();
  auto output__ = torch::flip_out(*out, *self, torch::IntArrayRef(dims_data, dims_len));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_fliplr(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::fliplr(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_flipud(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::flipud(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_roll(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array shifts_array__ = info__[1].As<Napi::Array>();
  int shifts_len = shifts_array__.Length();
  int64_t *shifts_data = new int64_t[shifts_len];
  for (int i = 0; i < shifts_len; ++i)
    shifts_data[i] = shifts_array__.Get(i).ToNumber().Int64Value();
  Napi::Array dims_array__ = info__[2].As<Napi::Array>();
  int dims_len = dims_array__.Length();
  int64_t *dims_data = new int64_t[dims_len];
  for (int i = 0; i < dims_len; ++i)
    dims_data[i] = dims_array__.Get(i).ToNumber().Int64Value();
  auto output__ = torch::roll(*self, torch::IntArrayRef(shifts_data, shifts_len), torch::IntArrayRef(dims_data, dims_len));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_roll_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array shifts_array__ = info__[2].As<Napi::Array>();
  int shifts_len = shifts_array__.Length();
  int64_t *shifts_data = new int64_t[shifts_len];
  for (int i = 0; i < shifts_len; ++i)
    shifts_data[i] = shifts_array__.Get(i).ToNumber().Int64Value();
  Napi::Array dims_array__ = info__[3].As<Napi::Array>();
  int dims_len = dims_array__.Length();
  int64_t *dims_data = new int64_t[dims_len];
  for (int i = 0; i < dims_len; ++i)
    dims_data[i] = dims_array__.Get(i).ToNumber().Int64Value();
  auto output__ = torch::roll_out(*out, *self, torch::IntArrayRef(shifts_data, shifts_len), torch::IntArrayRef(dims_data, dims_len));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_rot90(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t k = info__[1].As<Napi::Number>().Int64Value();
  Napi::Array dims_array__ = info__[2].As<Napi::Array>();
  int dims_len = dims_array__.Length();
  int64_t *dims_data = new int64_t[dims_len];
  for (int i = 0; i < dims_len; ++i)
    dims_data[i] = dims_array__.Get(i).ToNumber().Int64Value();
  auto output__ = torch::rot90(*self, k, torch::IntArrayRef(dims_data, dims_len));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_rot90_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  int64_t k = info__[2].As<Napi::Number>().Int64Value();
  Napi::Array dims_array__ = info__[3].As<Napi::Array>();
  int dims_len = dims_array__.Length();
  int64_t *dims_data = new int64_t[dims_len];
  for (int i = 0; i < dims_len; ++i)
    dims_data[i] = dims_array__.Get(i).ToNumber().Int64Value();
  auto output__ = torch::rot90_out(*out, *self, k, torch::IntArrayRef(dims_data, dims_len));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_trapezoid(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *y = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *x = info__[1].As<Napi::External<torch::Tensor>>().Data();
  int64_t dim = info__[2].As<Napi::Number>().Int64Value();
  auto output__ = torch::trapezoid(*y, *x, dim);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_trapezoid_dx(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *y = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *dx = info__[1].As<Napi::External<torch::Scalar>>().Data();
  int64_t dim = info__[2].As<Napi::Number>().Int64Value();
  auto output__ = torch::trapezoid(*y, *dx, dim);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_trapz(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *y = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *x = info__[1].As<Napi::External<torch::Tensor>>().Data();
  int64_t dim = info__[2].As<Napi::Number>().Int64Value();
  auto output__ = torch::trapz(*y, *x, dim);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_trapz_dx(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *y = info__[0].As<Napi::External<torch::Tensor>>().Data();
  double dx = info__[1].As<Napi::Number>().DoubleValue();
  int64_t dim = info__[2].As<Napi::Number>().Int64Value();
  auto output__ = torch::trapz(*y, dx, dim);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::Array atg__transform_bias_rescale_qkv(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *qkv = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *qkv_bias = info__[1].As<Napi::External<torch::Tensor>>().Data();
  int64_t num_heads = info__[2].As<Napi::Number>().Int64Value();
  auto output__ = torch::_transform_bias_rescale_qkv(*qkv, *qkv_bias, num_heads);
  Napi::Array output__array__ = Napi::Array::New(env__, 3);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  output__array__[2u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<2>(output__)));
  return output__array__;
}

Napi::Array atg__transform_bias_rescale_qkv_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out0 = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *out1 = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *out2 = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *qkv = info__[3].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *qkv_bias = info__[4].As<Napi::External<torch::Tensor>>().Data();
  int64_t num_heads = info__[5].As<Napi::Number>().Int64Value();
  auto output__ = torch::_transform_bias_rescale_qkv_out(*out0, *out1, *out2, *qkv, *qkv_bias, num_heads);
  Napi::Array output__array__ = Napi::Array::New(env__, 3);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  output__array__[2u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<2>(output__)));
  return output__array__;
}

Napi::External<torch::Tensor> atg__nested_tensor_from_mask(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *t = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *mask = info__[1].As<Napi::External<torch::Tensor>>().Data();
  bool mask_check = info__[2].As<Napi::Boolean>().Value();
  auto output__ = torch::_nested_tensor_from_mask(*t, *mask, mask_check);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__nested_tensor_from_mask_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *t = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *mask = info__[2].As<Napi::External<torch::Tensor>>().Data();
  bool mask_check = info__[3].As<Napi::Boolean>().Value();
  auto output__ = torch::_nested_tensor_from_mask_out(*out, *t, *mask, mask_check);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::Boolean atg__nested_tensor_from_mask_left_aligned(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *t = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *mask = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::_nested_tensor_from_mask_left_aligned(*t, *mask);
  return Napi::Boolean::New(env__, output__);
}

Napi::External<torch::Tensor> atg__nested_from_padded(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *padded = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *cpu_nested_shape_example = info__[1].As<Napi::External<torch::Tensor>>().Data();
  bool fuse_transform_0213 = info__[2].As<Napi::Boolean>().Value();
  auto output__ = torch::_nested_from_padded(*padded, *cpu_nested_shape_example, fuse_transform_0213);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__nested_from_padded_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *padded = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *cpu_nested_shape_example = info__[2].As<Napi::External<torch::Tensor>>().Data();
  bool fuse_transform_0213 = info__[3].As<Napi::Boolean>().Value();
  auto output__ = torch::_nested_from_padded_out(*out, *padded, *cpu_nested_shape_example, fuse_transform_0213);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__nested_tensor_size(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = self->_nested_tensor_size();
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__nested_tensor_size_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::_nested_tensor_size_out(*out, *self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__nested_tensor_strides(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = self->_nested_tensor_strides();
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__nested_tensor_strides_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::_nested_tensor_strides_out(*out, *self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__nested_from_padded_and_nested_example(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *padded = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *nt_example = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::_nested_from_padded_and_nested_example(*padded, *nt_example);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__nested_from_padded_and_nested_example_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *padded = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *nt_example = info__[2].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::_nested_from_padded_and_nested_example_out(*out, *padded, *nt_example);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__nested_view_from_buffer(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *nested_size = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *nested_strides = info__[2].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array offsets_array__ = info__[3].As<Napi::Array>();
  int offsets_len = offsets_array__.Length();
  int64_t *offsets_data = new int64_t[offsets_len];
  for (int i = 0; i < offsets_len; ++i)
    offsets_data[i] = offsets_array__.Get(i).ToNumber().Int64Value();
  auto output__ = torch::_nested_view_from_buffer(*self, *nested_size, *nested_strides, torch::IntArrayRef(offsets_data, offsets_len));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__nested_view_from_buffer_copy(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *nested_size = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *nested_strides = info__[2].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array offsets_array__ = info__[3].As<Napi::Array>();
  int offsets_len = offsets_array__.Length();
  int64_t *offsets_data = new int64_t[offsets_len];
  for (int i = 0; i < offsets_len; ++i)
    offsets_data[i] = offsets_array__.Get(i).ToNumber().Int64Value();
  auto output__ = torch::_nested_view_from_buffer_copy(*self, *nested_size, *nested_strides, torch::IntArrayRef(offsets_data, offsets_len));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__nested_view_from_buffer_copy_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *nested_size = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *nested_strides = info__[3].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array offsets_array__ = info__[4].As<Napi::Array>();
  int offsets_len = offsets_array__.Length();
  int64_t *offsets_data = new int64_t[offsets_len];
  for (int i = 0; i < offsets_len; ++i)
    offsets_data[i] = offsets_array__.Get(i).ToNumber().Int64Value();
  auto output__ = torch::_nested_view_from_buffer_copy_out(*out, *self, *nested_size, *nested_strides, torch::IntArrayRef(offsets_data, offsets_len));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__trilinear(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *i1 = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *i2 = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *i3 = info__[2].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array expand1_array__ = info__[3].As<Napi::Array>();
  int expand1_len = expand1_array__.Length();
  int64_t *expand1_data = new int64_t[expand1_len];
  for (int i = 0; i < expand1_len; ++i)
    expand1_data[i] = expand1_array__.Get(i).ToNumber().Int64Value();
  Napi::Array expand2_array__ = info__[4].As<Napi::Array>();
  int expand2_len = expand2_array__.Length();
  int64_t *expand2_data = new int64_t[expand2_len];
  for (int i = 0; i < expand2_len; ++i)
    expand2_data[i] = expand2_array__.Get(i).ToNumber().Int64Value();
  Napi::Array expand3_array__ = info__[5].As<Napi::Array>();
  int expand3_len = expand3_array__.Length();
  int64_t *expand3_data = new int64_t[expand3_len];
  for (int i = 0; i < expand3_len; ++i)
    expand3_data[i] = expand3_array__.Get(i).ToNumber().Int64Value();
  Napi::Array sumdim_array__ = info__[6].As<Napi::Array>();
  int sumdim_len = sumdim_array__.Length();
  int64_t *sumdim_data = new int64_t[sumdim_len];
  for (int i = 0; i < sumdim_len; ++i)
    sumdim_data[i] = sumdim_array__.Get(i).ToNumber().Int64Value();
  int64_t unroll_dim = info__[7].As<Napi::Number>().Int64Value();
  auto output__ = torch::_trilinear(*i1, *i2, *i3, torch::IntArrayRef(expand1_data, expand1_len), torch::IntArrayRef(expand2_data, expand2_len), torch::IntArrayRef(expand3_data, expand3_len), torch::IntArrayRef(sumdim_data, sumdim_len), unroll_dim);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__trilinear_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *i1 = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *i2 = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *i3 = info__[3].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array expand1_array__ = info__[4].As<Napi::Array>();
  int expand1_len = expand1_array__.Length();
  int64_t *expand1_data = new int64_t[expand1_len];
  for (int i = 0; i < expand1_len; ++i)
    expand1_data[i] = expand1_array__.Get(i).ToNumber().Int64Value();
  Napi::Array expand2_array__ = info__[5].As<Napi::Array>();
  int expand2_len = expand2_array__.Length();
  int64_t *expand2_data = new int64_t[expand2_len];
  for (int i = 0; i < expand2_len; ++i)
    expand2_data[i] = expand2_array__.Get(i).ToNumber().Int64Value();
  Napi::Array expand3_array__ = info__[6].As<Napi::Array>();
  int expand3_len = expand3_array__.Length();
  int64_t *expand3_data = new int64_t[expand3_len];
  for (int i = 0; i < expand3_len; ++i)
    expand3_data[i] = expand3_array__.Get(i).ToNumber().Int64Value();
  Napi::Array sumdim_array__ = info__[7].As<Napi::Array>();
  int sumdim_len = sumdim_array__.Length();
  int64_t *sumdim_data = new int64_t[sumdim_len];
  for (int i = 0; i < sumdim_len; ++i)
    sumdim_data[i] = sumdim_array__.Get(i).ToNumber().Int64Value();
  int64_t unroll_dim = info__[8].As<Napi::Number>().Int64Value();
  auto output__ = torch::_trilinear_out(*out, *i1, *i2, *i3, torch::IntArrayRef(expand1_data, expand1_len), torch::IntArrayRef(expand2_data, expand2_len), torch::IntArrayRef(expand3_data, expand3_len), torch::IntArrayRef(sumdim_data, sumdim_len), unroll_dim);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_triplet_margin_loss(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *anchor = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *positive = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *negative = info__[2].As<Napi::External<torch::Tensor>>().Data();
  double margin = info__[3].As<Napi::Number>().DoubleValue();
  double p = info__[4].As<Napi::Number>().DoubleValue();
  double eps = info__[5].As<Napi::Number>().DoubleValue();
  bool swap = info__[6].As<Napi::Boolean>().Value();
  int64_t reduction = info__[7].As<Napi::Number>().Int64Value();
  auto output__ = torch::triplet_margin_loss(*anchor, *positive, *negative, margin, p, eps, swap, reduction);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_trunc(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::trunc(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_trunc_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::trunc_out(*out, *self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_trunc_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::trunc_(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_fix(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::fix(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_fix_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::fix_out(*out, *self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_fix_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::fix_(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_type_as(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = self->type_as(*other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::Boolean atg__has_compatible_shallow_copy_type(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *from = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::_has_compatible_shallow_copy_type(*self, *from);
  return Napi::Boolean::New(env__, output__);
}

Napi::Array atg__unique(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  bool sorted = info__[1].As<Napi::Boolean>().Value();
  bool return_inverse = info__[2].As<Napi::Boolean>().Value();
  auto output__ = torch::_unique(*self, sorted, return_inverse);
  Napi::Array output__array__ = Napi::Array::New(env__, 2);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  return output__array__;
}

Napi::Array atg__unique_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out0 = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *out1 = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[2].As<Napi::External<torch::Tensor>>().Data();
  bool sorted = info__[3].As<Napi::Boolean>().Value();
  bool return_inverse = info__[4].As<Napi::Boolean>().Value();
  auto output__ = torch::_unique_out(*out0, *out1, *self, sorted, return_inverse);
  Napi::Array output__array__ = Napi::Array::New(env__, 2);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  return output__array__;
}

Napi::Array atg_unique_dim(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t dim = info__[1].As<Napi::Number>().Int64Value();
  bool sorted = info__[2].As<Napi::Boolean>().Value();
  bool return_inverse = info__[3].As<Napi::Boolean>().Value();
  bool return_counts = info__[4].As<Napi::Boolean>().Value();
  auto output__ = torch::unique_dim(*self, dim, sorted, return_inverse, return_counts);
  Napi::Array output__array__ = Napi::Array::New(env__, 3);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  output__array__[2u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<2>(output__)));
  return output__array__;
}

Napi::Array atg_unique_dim_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out0 = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *out1 = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *out2 = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[3].As<Napi::External<torch::Tensor>>().Data();
  int64_t dim = info__[4].As<Napi::Number>().Int64Value();
  bool sorted = info__[5].As<Napi::Boolean>().Value();
  bool return_inverse = info__[6].As<Napi::Boolean>().Value();
  bool return_counts = info__[7].As<Napi::Boolean>().Value();
  auto output__ = torch::unique_dim_out(*out0, *out1, *out2, *self, dim, sorted, return_inverse, return_counts);
  Napi::Array output__array__ = Napi::Array::New(env__, 3);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  output__array__[2u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<2>(output__)));
  return output__array__;
}

Napi::Array atg_unique_consecutive(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  bool return_inverse = info__[1].As<Napi::Boolean>().Value();
  bool return_counts = info__[2].As<Napi::Boolean>().Value();
  bool dim_null = info__[3].IsUndefined();
  int64_t dim_v = dim_null ? 0 : info__[3].As<Napi::Number>().Int64Value();
  auto output__ = torch::unique_consecutive(*self, return_inverse, return_counts, dim_null ? c10::nullopt : c10::optional<int64_t>(dim_v));
  Napi::Array output__array__ = Napi::Array::New(env__, 3);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  output__array__[2u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<2>(output__)));
  return output__array__;
}

Napi::Array atg_unique_consecutive_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out0 = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *out1 = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *out2 = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[3].As<Napi::External<torch::Tensor>>().Data();
  bool return_inverse = info__[4].As<Napi::Boolean>().Value();
  bool return_counts = info__[5].As<Napi::Boolean>().Value();
  bool dim_null = info__[6].IsUndefined();
  int64_t dim_v = dim_null ? 0 : info__[6].As<Napi::Number>().Int64Value();
  auto output__ = torch::unique_consecutive_out(*out0, *out1, *out2, *self, return_inverse, return_counts, dim_null ? c10::nullopt : c10::optional<int64_t>(dim_v));
  Napi::Array output__array__ = Napi::Array::New(env__, 3);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  output__array__[2u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<2>(output__)));
  return output__array__;
}

Napi::Array atg_unique_dim_consecutive(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t dim = info__[1].As<Napi::Number>().Int64Value();
  bool return_inverse = info__[2].As<Napi::Boolean>().Value();
  bool return_counts = info__[3].As<Napi::Boolean>().Value();
  auto output__ = torch::unique_dim_consecutive(*self, dim, return_inverse, return_counts);
  Napi::Array output__array__ = Napi::Array::New(env__, 3);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  output__array__[2u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<2>(output__)));
  return output__array__;
}

Napi::Array atg_unique_dim_consecutive_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out0 = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *out1 = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *out2 = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[3].As<Napi::External<torch::Tensor>>().Data();
  int64_t dim = info__[4].As<Napi::Number>().Int64Value();
  bool return_inverse = info__[5].As<Napi::Boolean>().Value();
  bool return_counts = info__[6].As<Napi::Boolean>().Value();
  auto output__ = torch::unique_dim_consecutive_out(*out0, *out1, *out2, *self, dim, return_inverse, return_counts);
  Napi::Array output__array__ = Napi::Array::New(env__, 3);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  output__array__[2u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<2>(output__)));
  return output__array__;
}

Napi::Array atg__unique2(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  bool sorted = info__[1].As<Napi::Boolean>().Value();
  bool return_inverse = info__[2].As<Napi::Boolean>().Value();
  bool return_counts = info__[3].As<Napi::Boolean>().Value();
  auto output__ = torch::_unique2(*self, sorted, return_inverse, return_counts);
  Napi::Array output__array__ = Napi::Array::New(env__, 3);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  output__array__[2u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<2>(output__)));
  return output__array__;
}

Napi::Array atg__unique2_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out0 = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *out1 = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *out2 = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[3].As<Napi::External<torch::Tensor>>().Data();
  bool sorted = info__[4].As<Napi::Boolean>().Value();
  bool return_inverse = info__[5].As<Napi::Boolean>().Value();
  bool return_counts = info__[6].As<Napi::Boolean>().Value();
  auto output__ = torch::_unique2_out(*out0, *out1, *out2, *self, sorted, return_inverse, return_counts);
  Napi::Array output__array__ = Napi::Array::New(env__, 3);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  output__array__[2u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<2>(output__)));
  return output__array__;
}

Napi::External<torch::Tensor> atg__unsafe_view(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array size_array__ = info__[1].As<Napi::Array>();
  int size_len = size_array__.Length();
  int64_t *size_data = new int64_t[size_len];
  for (int i = 0; i < size_len; ++i)
    size_data[i] = size_array__.Get(i).ToNumber().Int64Value();
  auto output__ = torch::_unsafe_view(*self, torch::IntArrayRef(size_data, size_len));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__unsafe_view_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array size_array__ = info__[2].As<Napi::Array>();
  int size_len = size_array__.Length();
  int64_t *size_data = new int64_t[size_len];
  for (int i = 0; i < size_len; ++i)
    size_data[i] = size_array__.Get(i).ToNumber().Int64Value();
  auto output__ = torch::_unsafe_view_out(*out, *self, torch::IntArrayRef(size_data, size_len));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_unsqueeze(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t dim = info__[1].As<Napi::Number>().Int64Value();
  auto output__ = torch::unsqueeze(*self, dim);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_unsqueeze_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t dim = info__[1].As<Napi::Number>().Int64Value();
  auto output__ = self->unsqueeze_(dim);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_vander(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *x = info__[0].As<Napi::External<torch::Tensor>>().Data();
  bool N_null = info__[1].IsUndefined();
  int64_t N_v = N_null ? 0 : info__[1].As<Napi::Number>().Int64Value();
  bool increasing = info__[2].As<Napi::Boolean>().Value();
  auto output__ = torch::vander(*x, N_null ? c10::nullopt : c10::optional<int64_t>(N_v), increasing);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_var(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  bool unbiased = info__[1].As<Napi::Boolean>().Value();
  auto output__ = torch::var(*self, unbiased);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_var_dim(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array dim_array__ = info__[1].As<Napi::Array>();
  int dim_len = dim_array__.Length();
  int64_t *dim_data = new int64_t[dim_len];
  for (int i = 0; i < dim_len; ++i)
    dim_data[i] = dim_array__.Get(i).ToNumber().Int64Value();
  bool unbiased = info__[2].As<Napi::Boolean>().Value();
  bool keepdim = info__[3].As<Napi::Boolean>().Value();
  auto output__ = torch::var(*self, dim_data == nullptr ? c10::nullopt : c10::optional<torch::IntArrayRef>(torch::IntArrayRef(dim_data, dim_len)), unbiased, keepdim);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_var_correction(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array dim_array__ = info__[1].As<Napi::Array>();
  int dim_len = dim_array__.Length();
  int64_t *dim_data = new int64_t[dim_len];
  for (int i = 0; i < dim_len; ++i)
    dim_data[i] = dim_array__.Get(i).ToNumber().Int64Value();
  bool correction_null = info__[2].IsUndefined();
  int64_t correction_v = correction_null ? 0 : info__[2].As<Napi::Number>().Int64Value();
  bool keepdim = info__[3].As<Napi::Boolean>().Value();
  auto output__ = torch::var(*self, dim_data == nullptr ? c10::nullopt : c10::optional<torch::IntArrayRef>(torch::IntArrayRef(dim_data, dim_len)), correction_null ? c10::nullopt : c10::optional<int64_t>(correction_v), keepdim);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_var_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array dim_array__ = info__[2].As<Napi::Array>();
  int dim_len = dim_array__.Length();
  int64_t *dim_data = new int64_t[dim_len];
  for (int i = 0; i < dim_len; ++i)
    dim_data[i] = dim_array__.Get(i).ToNumber().Int64Value();
  bool unbiased = info__[3].As<Napi::Boolean>().Value();
  bool keepdim = info__[4].As<Napi::Boolean>().Value();
  auto output__ = torch::var_out(*out, *self, dim_data == nullptr ? c10::nullopt : c10::optional<torch::IntArrayRef>(torch::IntArrayRef(dim_data, dim_len)), unbiased, keepdim);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_var_correction_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array dim_array__ = info__[2].As<Napi::Array>();
  int dim_len = dim_array__.Length();
  int64_t *dim_data = new int64_t[dim_len];
  for (int i = 0; i < dim_len; ++i)
    dim_data[i] = dim_array__.Get(i).ToNumber().Int64Value();
  bool correction_null = info__[3].IsUndefined();
  int64_t correction_v = correction_null ? 0 : info__[3].As<Napi::Number>().Int64Value();
  bool keepdim = info__[4].As<Napi::Boolean>().Value();
  auto output__ = torch::var_out(*out, *self, dim_data == nullptr ? c10::nullopt : c10::optional<torch::IntArrayRef>(torch::IntArrayRef(dim_data, dim_len)), correction_null ? c10::nullopt : c10::optional<int64_t>(correction_v), keepdim);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::Array atg_var_mean(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  bool unbiased = info__[1].As<Napi::Boolean>().Value();
  auto output__ = torch::var_mean(*self, unbiased);
  Napi::Array output__array__ = Napi::Array::New(env__, 2);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  return output__array__;
}

Napi::Array atg_var_mean_dim(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array dim_array__ = info__[1].As<Napi::Array>();
  int dim_len = dim_array__.Length();
  int64_t *dim_data = new int64_t[dim_len];
  for (int i = 0; i < dim_len; ++i)
    dim_data[i] = dim_array__.Get(i).ToNumber().Int64Value();
  bool unbiased = info__[2].As<Napi::Boolean>().Value();
  bool keepdim = info__[3].As<Napi::Boolean>().Value();
  auto output__ = torch::var_mean(*self, dim_data == nullptr ? c10::nullopt : c10::optional<torch::IntArrayRef>(torch::IntArrayRef(dim_data, dim_len)), unbiased, keepdim);
  Napi::Array output__array__ = Napi::Array::New(env__, 2);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  return output__array__;
}

Napi::Array atg_var_mean_correction(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array dim_array__ = info__[1].As<Napi::Array>();
  int dim_len = dim_array__.Length();
  int64_t *dim_data = new int64_t[dim_len];
  for (int i = 0; i < dim_len; ++i)
    dim_data[i] = dim_array__.Get(i).ToNumber().Int64Value();
  bool correction_null = info__[2].IsUndefined();
  int64_t correction_v = correction_null ? 0 : info__[2].As<Napi::Number>().Int64Value();
  bool keepdim = info__[3].As<Napi::Boolean>().Value();
  auto output__ = torch::var_mean(*self, dim_data == nullptr ? c10::nullopt : c10::optional<torch::IntArrayRef>(torch::IntArrayRef(dim_data, dim_len)), correction_null ? c10::nullopt : c10::optional<int64_t>(correction_v), keepdim);
  Napi::Array output__array__ = Napi::Array::New(env__, 2);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  return output__array__;
}

Napi::Array atg_var_mean_correction_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out0 = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *out1 = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[2].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array dim_array__ = info__[3].As<Napi::Array>();
  int dim_len = dim_array__.Length();
  int64_t *dim_data = new int64_t[dim_len];
  for (int i = 0; i < dim_len; ++i)
    dim_data[i] = dim_array__.Get(i).ToNumber().Int64Value();
  bool correction_null = info__[4].IsUndefined();
  int64_t correction_v = correction_null ? 0 : info__[4].As<Napi::Number>().Int64Value();
  bool keepdim = info__[5].As<Napi::Boolean>().Value();
  auto output__ = torch::var_mean_out(*out0, *out1, *self, dim_data == nullptr ? c10::nullopt : c10::optional<torch::IntArrayRef>(torch::IntArrayRef(dim_data, dim_len)), correction_null ? c10::nullopt : c10::optional<int64_t>(correction_v), keepdim);
  Napi::Array output__array__ = Napi::Array::New(env__, 2);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  return output__array__;
}

Napi::External<torch::Tensor> atg_view_as(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = self->view_as(*other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_where(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *condition = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[2].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::where(*condition, *self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_where_scalarself(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *condition = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *self_scalar = info__[1].As<Napi::External<torch::Scalar>>().Data();
  torch::Tensor *other = info__[2].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::where(*condition, *self_scalar, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_where_scalarother(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *condition = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *other = info__[2].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::where(*condition, *self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_where_scalar(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *condition = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *self_scalar = info__[1].As<Napi::External<torch::Scalar>>().Data();
  torch::Scalar *other = info__[2].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::where(*condition, *self_scalar, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_where_self_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *condition = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[3].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::where_out(*out, *condition, *self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_norm_except_dim(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *v = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t pow = info__[1].As<Napi::Number>().Int64Value();
  int64_t dim = info__[2].As<Napi::Number>().Int64Value();
  auto output__ = torch::norm_except_dim(*v, pow, dim);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__weight_norm(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *v = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *g = info__[1].As<Napi::External<torch::Tensor>>().Data();
  int64_t dim = info__[2].As<Napi::Number>().Int64Value();
  auto output__ = torch::_weight_norm(*v, *g, dim);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::Array atg__weight_norm_interface(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *v = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *g = info__[1].As<Napi::External<torch::Tensor>>().Data();
  int64_t dim = info__[2].As<Napi::Number>().Int64Value();
  auto output__ = torch::_weight_norm_interface(*v, *g, dim);
  Napi::Array output__array__ = Napi::Array::New(env__, 2);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  return output__array__;
}

Napi::Array atg__weight_norm_interface_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out0 = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *out1 = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *v = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *g = info__[3].As<Napi::External<torch::Tensor>>().Data();
  int64_t dim = info__[4].As<Napi::Number>().Int64Value();
  auto output__ = torch::_weight_norm_interface_out(*out0, *out1, *v, *g, dim);
  Napi::Array output__array__ = Napi::Array::New(env__, 2);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  return output__array__;
}

Napi::Array atg__weight_norm_interface_backward(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *grad_w = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *saved_v = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *saved_g = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *saved_norms = info__[3].As<Napi::External<torch::Tensor>>().Data();
  int64_t dim = info__[4].As<Napi::Number>().Int64Value();
  auto output__ = torch::_weight_norm_interface_backward(*grad_w, *saved_v, *saved_g, *saved_norms, dim);
  Napi::Array output__array__ = Napi::Array::New(env__, 2);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  return output__array__;
}

Napi::Array atg__weight_norm_interface_backward_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out0 = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *out1 = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *grad_w = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *saved_v = info__[3].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *saved_g = info__[4].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *saved_norms = info__[5].As<Napi::External<torch::Tensor>>().Data();
  int64_t dim = info__[6].As<Napi::Number>().Int64Value();
  auto output__ = torch::_weight_norm_interface_backward_out(*out0, *out1, *grad_w, *saved_v, *saved_g, *saved_norms, dim);
  Napi::Array output__array__ = Napi::Array::New(env__, 2);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  return output__array__;
}

Napi::Array atg__weight_norm_differentiable_backward(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *grad_w = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *saved_v = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *saved_g = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *saved_norms = info__[3].As<Napi::External<torch::Tensor>>().Data();
  int64_t dim = info__[4].As<Napi::Number>().Int64Value();
  auto output__ = torch::_weight_norm_differentiable_backward(*grad_w, *saved_v, *saved_g, *saved_norms, dim);
  Napi::Array output__array__ = Napi::Array::New(env__, 2);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  return output__array__;
}

Napi::External<torch::Tensor> atg__efficientzerotensor(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  Napi::Array size_array__ = info__[0].As<Napi::Array>();
  int size_len = size_array__.Length();
  int64_t *size_data = new int64_t[size_len];
  for (int i = 0; i < size_len; ++i)
    size_data[i] = size_array__.Get(i).ToNumber().Int64Value();
  Napi::Object options_obj__ = info__[1].As<Napi::Object>();
  int options_device = options_obj__.Get("device").ToNumber().Int32Value();
  int options_kind = options_obj__.Get("dtype").ToNumber().Int32Value();
  auto output__ = torch::_efficientzerotensor(torch::IntArrayRef(size_data, size_len), at::device(device_of_int(options_device)).dtype(at::ScalarType(options_kind)));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__efficientzerotensor_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array size_array__ = info__[1].As<Napi::Array>();
  int size_len = size_array__.Length();
  int64_t *size_data = new int64_t[size_len];
  for (int i = 0; i < size_len; ++i)
    size_data[i] = size_array__.Get(i).ToNumber().Int64Value();
  auto output__ = torch::_efficientzerotensor_out(*out, torch::IntArrayRef(size_data, size_len));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_zeros(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  Napi::Array size_array__ = info__[0].As<Napi::Array>();
  int size_len = size_array__.Length();
  int64_t *size_data = new int64_t[size_len];
  for (int i = 0; i < size_len; ++i)
    size_data[i] = size_array__.Get(i).ToNumber().Int64Value();
  Napi::Object options_obj__ = info__[1].As<Napi::Object>();
  int options_device = options_obj__.Get("device").ToNumber().Int32Value();
  int options_kind = options_obj__.Get("dtype").ToNumber().Int32Value();
  auto output__ = torch::zeros(torch::IntArrayRef(size_data, size_len), at::device(device_of_int(options_device)).dtype(at::ScalarType(options_kind)));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_zeros_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array size_array__ = info__[1].As<Napi::Array>();
  int size_len = size_array__.Length();
  int64_t *size_data = new int64_t[size_len];
  for (int i = 0; i < size_len; ++i)
    size_data[i] = size_array__.Get(i).ToNumber().Int64Value();
  auto output__ = torch::zeros_out(*out, torch::IntArrayRef(size_data, size_len));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_zeros_like(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Object options_obj__ = info__[1].As<Napi::Object>();
  int options_device = options_obj__.Get("device").ToNumber().Int32Value();
  int options_kind = options_obj__.Get("dtype").ToNumber().Int32Value();
  int memory_format = info__[2].As<Napi::Number>().Int32Value();
  auto output__ = torch::zeros_like(*self, at::device(device_of_int(options_device)).dtype(at::ScalarType(options_kind)), (at::MemoryFormat)memory_format);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_zeros_like_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  int memory_format = info__[2].As<Napi::Number>().Int32Value();
  auto output__ = torch::zeros_like_out(*out, *self, (at::MemoryFormat)memory_format);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__standard_gamma_grad(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *output = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::_standard_gamma_grad(*self, *output);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__standard_gamma_grad_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *output = info__[2].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::_standard_gamma_grad_out(*out, *self, *output);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__standard_gamma(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::_standard_gamma(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__standard_gamma_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::_standard_gamma_out(*out, *self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__dirichlet_grad(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *x = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *alpha = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *total = info__[2].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::_dirichlet_grad(*x, *alpha, *total);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__dirichlet_grad_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *x = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *alpha = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *total = info__[3].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::_dirichlet_grad_out(*out, *x, *alpha, *total);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__sample_dirichlet(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::_sample_dirichlet(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__sample_dirichlet_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::_sample_dirichlet_out(*out, *self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_poisson(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::poisson(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_poisson_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::poisson_out(*out, *self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_binomial(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *count = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *prob = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::binomial(*count, *prob);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_binomial_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *count = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *prob = info__[2].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::binomial_out(*out, *count, *prob);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_native_norm(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *p = info__[1].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::native_norm(*self, *p);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_native_norm_scalaropt_dim_dtype(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *p = info__[1].As<Napi::External<torch::Scalar>>().Data();
  Napi::Array dim_array__ = info__[2].As<Napi::Array>();
  int dim_len = dim_array__.Length();
  int64_t *dim_data = new int64_t[dim_len];
  for (int i = 0; i < dim_len; ++i)
    dim_data[i] = dim_array__.Get(i).ToNumber().Int64Value();
  bool keepdim = info__[3].As<Napi::Boolean>().Value();
  int dtype = info__[4].As<Napi::Number>().Int32Value();
  auto output__ = torch::native_norm(*self, *p, torch::IntArrayRef(dim_data, dim_len), keepdim, at::ScalarType(dtype));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_native_norm_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *p = info__[2].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::native_norm_out(*out, *self, *p);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_native_norm_scalaropt_dim_dtype_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *p = info__[2].As<Napi::External<torch::Scalar>>().Data();
  Napi::Array dim_array__ = info__[3].As<Napi::Array>();
  int dim_len = dim_array__.Length();
  int64_t *dim_data = new int64_t[dim_len];
  for (int i = 0; i < dim_len; ++i)
    dim_data[i] = dim_array__.Get(i).ToNumber().Int64Value();
  bool keepdim = info__[4].As<Napi::Boolean>().Value();
  int dtype = info__[5].As<Napi::Number>().Int32Value();
  auto output__ = torch::native_norm_out(*out, *self, *p, torch::IntArrayRef(dim_data, dim_len), keepdim, at::ScalarType(dtype));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__sparse_sum(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::_sparse_sum(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__sparse_sum_dtype(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int dtype = info__[1].As<Napi::Number>().Int32Value();
  auto output__ = torch::_sparse_sum(*self, at::ScalarType(dtype));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__sparse_sum_dim(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array dim_array__ = info__[1].As<Napi::Array>();
  int dim_len = dim_array__.Length();
  int64_t *dim_data = new int64_t[dim_len];
  for (int i = 0; i < dim_len; ++i)
    dim_data[i] = dim_array__.Get(i).ToNumber().Int64Value();
  auto output__ = torch::_sparse_sum(*self, torch::IntArrayRef(dim_data, dim_len));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__sparse_sum_dim_dtype(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array dim_array__ = info__[1].As<Napi::Array>();
  int dim_len = dim_array__.Length();
  int64_t *dim_data = new int64_t[dim_len];
  for (int i = 0; i < dim_len; ++i)
    dim_data[i] = dim_array__.Get(i).ToNumber().Int64Value();
  int dtype = info__[2].As<Napi::Number>().Int32Value();
  auto output__ = torch::_sparse_sum(*self, torch::IntArrayRef(dim_data, dim_len), at::ScalarType(dtype));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__sparse_sum_dim_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array dim_array__ = info__[2].As<Napi::Array>();
  int dim_len = dim_array__.Length();
  int64_t *dim_data = new int64_t[dim_len];
  for (int i = 0; i < dim_len; ++i)
    dim_data[i] = dim_array__.Get(i).ToNumber().Int64Value();
  auto output__ = torch::_sparse_sum_out(*out, *self, torch::IntArrayRef(dim_data, dim_len));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__sparse_sum_backward(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *grad = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array dim_array__ = info__[2].As<Napi::Array>();
  int dim_len = dim_array__.Length();
  int64_t *dim_data = new int64_t[dim_len];
  for (int i = 0; i < dim_len; ++i)
    dim_data[i] = dim_array__.Get(i).ToNumber().Int64Value();
  auto output__ = torch::_sparse_sum_backward(*grad, *self, torch::IntArrayRef(dim_data, dim_len));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__sparse_sum_backward_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *grad = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[2].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array dim_array__ = info__[3].As<Napi::Array>();
  int dim_len = dim_array__.Length();
  int64_t *dim_data = new int64_t[dim_len];
  for (int i = 0; i < dim_len; ++i)
    dim_data[i] = dim_array__.Get(i).ToNumber().Int64Value();
  auto output__ = torch::_sparse_sum_backward_out(*out, *grad, *self, torch::IntArrayRef(dim_data, dim_len));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__sparse_csr_sum(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array dim_array__ = info__[1].As<Napi::Array>();
  int dim_len = dim_array__.Length();
  int64_t *dim_data = new int64_t[dim_len];
  for (int i = 0; i < dim_len; ++i)
    dim_data[i] = dim_array__.Get(i).ToNumber().Int64Value();
  bool keepdim = info__[2].As<Napi::Boolean>().Value();
  int dtype = info__[3].As<Napi::Number>().Int32Value();
  auto output__ = torch::_sparse_csr_sum(*self, torch::IntArrayRef(dim_data, dim_len), keepdim, at::ScalarType(dtype));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__sparse_csr_sum_dim_dtype_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array dim_array__ = info__[2].As<Napi::Array>();
  int dim_len = dim_array__.Length();
  int64_t *dim_data = new int64_t[dim_len];
  for (int i = 0; i < dim_len; ++i)
    dim_data[i] = dim_array__.Get(i).ToNumber().Int64Value();
  bool keepdim = info__[3].As<Napi::Boolean>().Value();
  int dtype = info__[4].As<Napi::Number>().Int32Value();
  auto output__ = torch::_sparse_csr_sum_out(*out, *self, torch::IntArrayRef(dim_data, dim_len), keepdim, at::ScalarType(dtype));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__sparse_csr_prod(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array dim_array__ = info__[1].As<Napi::Array>();
  int dim_len = dim_array__.Length();
  int64_t *dim_data = new int64_t[dim_len];
  for (int i = 0; i < dim_len; ++i)
    dim_data[i] = dim_array__.Get(i).ToNumber().Int64Value();
  bool keepdim = info__[2].As<Napi::Boolean>().Value();
  int dtype = info__[3].As<Napi::Number>().Int32Value();
  auto output__ = torch::_sparse_csr_prod(*self, torch::IntArrayRef(dim_data, dim_len), keepdim, at::ScalarType(dtype));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__sparse_csr_prod_dim_dtype_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array dim_array__ = info__[2].As<Napi::Array>();
  int dim_len = dim_array__.Length();
  int64_t *dim_data = new int64_t[dim_len];
  for (int i = 0; i < dim_len; ++i)
    dim_data[i] = dim_array__.Get(i).ToNumber().Int64Value();
  bool keepdim = info__[3].As<Napi::Boolean>().Value();
  int dtype = info__[4].As<Napi::Number>().Int32Value();
  auto output__ = torch::_sparse_csr_prod_out(*out, *self, torch::IntArrayRef(dim_data, dim_len), keepdim, at::ScalarType(dtype));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__sparse_softmax_int(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t dim = info__[1].As<Napi::Number>().Int64Value();
  int dtype = info__[2].As<Napi::Number>().Int32Value();
  auto output__ = torch::_sparse_softmax(*self, dim, at::ScalarType(dtype));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__sparse_softmax(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t dim = info__[1].As<Napi::Number>().Int64Value();
  bool half_to_float = info__[2].As<Napi::Boolean>().Value();
  auto output__ = torch::_sparse_softmax(*self, dim, half_to_float);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__sparse_softmax_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  int64_t dim = info__[2].As<Napi::Number>().Int64Value();
  bool half_to_float = info__[3].As<Napi::Boolean>().Value();
  auto output__ = torch::_sparse_softmax_out(*out, *self, dim, half_to_float);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__sparse_softmax_backward_data(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *grad_output = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *output = info__[1].As<Napi::External<torch::Tensor>>().Data();
  int64_t dim = info__[2].As<Napi::Number>().Int64Value();
  torch::Tensor *self = info__[3].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::_sparse_softmax_backward_data(*grad_output, *output, dim, *self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__sparse_softmax_backward_data_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *grad_output = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *output = info__[2].As<Napi::External<torch::Tensor>>().Data();
  int64_t dim = info__[3].As<Napi::Number>().Int64Value();
  torch::Tensor *self = info__[4].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::_sparse_softmax_backward_data_out(*out, *grad_output, *output, dim, *self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__sparse_log_softmax_int(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t dim = info__[1].As<Napi::Number>().Int64Value();
  int dtype = info__[2].As<Napi::Number>().Int32Value();
  auto output__ = torch::_sparse_log_softmax(*self, dim, at::ScalarType(dtype));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__sparse_log_softmax(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t dim = info__[1].As<Napi::Number>().Int64Value();
  bool half_to_float = info__[2].As<Napi::Boolean>().Value();
  auto output__ = torch::_sparse_log_softmax(*self, dim, half_to_float);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__sparse_log_softmax_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  int64_t dim = info__[2].As<Napi::Number>().Int64Value();
  bool half_to_float = info__[3].As<Napi::Boolean>().Value();
  auto output__ = torch::_sparse_log_softmax_out(*out, *self, dim, half_to_float);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__sparse_log_softmax_backward_data(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *grad_output = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *output = info__[1].As<Napi::External<torch::Tensor>>().Data();
  int64_t dim = info__[2].As<Napi::Number>().Int64Value();
  torch::Tensor *self = info__[3].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::_sparse_log_softmax_backward_data(*grad_output, *output, dim, *self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__sparse_log_softmax_backward_data_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *grad_output = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *output = info__[2].As<Napi::External<torch::Tensor>>().Data();
  int64_t dim = info__[3].As<Napi::Number>().Int64Value();
  torch::Tensor *self = info__[4].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::_sparse_log_softmax_backward_data_out(*out, *grad_output, *output, dim, *self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__spdiags(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *diagonals = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *offsets = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array shape_array__ = info__[2].As<Napi::Array>();
  int shape_len = shape_array__.Length();
  int64_t *shape_data = new int64_t[shape_len];
  for (int i = 0; i < shape_len; ++i)
    shape_data[i] = shape_array__.Get(i).ToNumber().Int64Value();
  int layout = info__[3].As<Napi::Number>().Int32Value();
  auto output__ = torch::_spdiags(*diagonals, *offsets, torch::IntArrayRef(shape_data, shape_len), (at::Layout)layout);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__spdiags_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *diagonals = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *offsets = info__[2].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array shape_array__ = info__[3].As<Napi::Array>();
  int shape_len = shape_array__.Length();
  int64_t *shape_data = new int64_t[shape_len];
  for (int i = 0; i < shape_len; ++i)
    shape_data[i] = shape_array__.Get(i).ToNumber().Int64Value();
  int layout = info__[4].As<Napi::Number>().Int32Value();
  auto output__ = torch::_spdiags_out(*out, *diagonals, *offsets, torch::IntArrayRef(shape_data, shape_len), (at::Layout)layout);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_norm(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *p = info__[1].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::norm(*self, *p);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_norm_scalaropt_dtype(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *p = info__[1].As<Napi::External<torch::Scalar>>().Data();
  int dtype = info__[2].As<Napi::Number>().Int32Value();
  auto output__ = torch::norm(*self, *p, at::ScalarType(dtype));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_norm_scalaropt_dim(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *p = info__[1].As<Napi::External<torch::Scalar>>().Data();
  Napi::Array dim_array__ = info__[2].As<Napi::Array>();
  int dim_len = dim_array__.Length();
  int64_t *dim_data = new int64_t[dim_len];
  for (int i = 0; i < dim_len; ++i)
    dim_data[i] = dim_array__.Get(i).ToNumber().Int64Value();
  bool keepdim = info__[3].As<Napi::Boolean>().Value();
  auto output__ = torch::norm(*self, *p, torch::IntArrayRef(dim_data, dim_len), keepdim);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_norm_scalaropt_dim_dtype(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *p = info__[1].As<Napi::External<torch::Scalar>>().Data();
  Napi::Array dim_array__ = info__[2].As<Napi::Array>();
  int dim_len = dim_array__.Length();
  int64_t *dim_data = new int64_t[dim_len];
  for (int i = 0; i < dim_len; ++i)
    dim_data[i] = dim_array__.Get(i).ToNumber().Int64Value();
  bool keepdim = info__[3].As<Napi::Boolean>().Value();
  int dtype = info__[4].As<Napi::Number>().Int32Value();
  auto output__ = torch::norm(*self, *p, torch::IntArrayRef(dim_data, dim_len), keepdim, at::ScalarType(dtype));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_norm_scalar_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *p = info__[2].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::norm_out(*out, *self, *p);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_norm_scalaropt_dtype_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *p = info__[2].As<Napi::External<torch::Scalar>>().Data();
  int dtype = info__[3].As<Napi::Number>().Int32Value();
  auto output__ = torch::norm_out(*out, *self, *p, at::ScalarType(dtype));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_norm_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *p = info__[2].As<Napi::External<torch::Scalar>>().Data();
  Napi::Array dim_array__ = info__[3].As<Napi::Array>();
  int dim_len = dim_array__.Length();
  int64_t *dim_data = new int64_t[dim_len];
  for (int i = 0; i < dim_len; ++i)
    dim_data[i] = dim_array__.Get(i).ToNumber().Int64Value();
  bool keepdim = info__[4].As<Napi::Boolean>().Value();
  auto output__ = torch::norm_out(*out, *self, *p, torch::IntArrayRef(dim_data, dim_len), keepdim);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_norm_dtype_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *p = info__[2].As<Napi::External<torch::Scalar>>().Data();
  Napi::Array dim_array__ = info__[3].As<Napi::Array>();
  int dim_len = dim_array__.Length();
  int64_t *dim_data = new int64_t[dim_len];
  for (int i = 0; i < dim_len; ++i)
    dim_data[i] = dim_array__.Get(i).ToNumber().Int64Value();
  bool keepdim = info__[4].As<Napi::Boolean>().Value();
  int dtype = info__[5].As<Napi::Number>().Int32Value();
  auto output__ = torch::norm_out(*out, *self, *p, torch::IntArrayRef(dim_data, dim_len), keepdim, at::ScalarType(dtype));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::Array atg_frexp(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::frexp(*self);
  Napi::Array output__array__ = Napi::Array::New(env__, 2);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  return output__array__;
}

Napi::Array atg_frexp_tensor_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *mantissa = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *exponent = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[2].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::frexp_out(*mantissa, *exponent, *self);
  Napi::Array output__array__ = Napi::Array::New(env__, 2);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  return output__array__;
}

Napi::External<torch::Tensor> atg_frobenius_norm(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array dim_array__ = info__[1].As<Napi::Array>();
  int dim_len = dim_array__.Length();
  int64_t *dim_data = new int64_t[dim_len];
  for (int i = 0; i < dim_len; ++i)
    dim_data[i] = dim_array__.Get(i).ToNumber().Int64Value();
  bool keepdim = info__[2].As<Napi::Boolean>().Value();
  auto output__ = torch::frobenius_norm(*self, torch::IntArrayRef(dim_data, dim_len), keepdim);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_frobenius_norm_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array dim_array__ = info__[2].As<Napi::Array>();
  int dim_len = dim_array__.Length();
  int64_t *dim_data = new int64_t[dim_len];
  for (int i = 0; i < dim_len; ++i)
    dim_data[i] = dim_array__.Get(i).ToNumber().Int64Value();
  bool keepdim = info__[3].As<Napi::Boolean>().Value();
  auto output__ = torch::frobenius_norm_out(*out, *self, torch::IntArrayRef(dim_data, dim_len), keepdim);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_nuclear_norm(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  bool keepdim = info__[1].As<Napi::Boolean>().Value();
  auto output__ = torch::nuclear_norm(*self, keepdim);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_nuclear_norm_dim(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array dim_array__ = info__[1].As<Napi::Array>();
  int dim_len = dim_array__.Length();
  int64_t *dim_data = new int64_t[dim_len];
  for (int i = 0; i < dim_len; ++i)
    dim_data[i] = dim_array__.Get(i).ToNumber().Int64Value();
  bool keepdim = info__[2].As<Napi::Boolean>().Value();
  auto output__ = torch::nuclear_norm(*self, torch::IntArrayRef(dim_data, dim_len), keepdim);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_nuclear_norm_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  bool keepdim = info__[2].As<Napi::Boolean>().Value();
  auto output__ = torch::nuclear_norm_out(*out, *self, keepdim);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_nuclear_norm_dim_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array dim_array__ = info__[2].As<Napi::Array>();
  int dim_len = dim_array__.Length();
  int64_t *dim_data = new int64_t[dim_len];
  for (int i = 0; i < dim_len; ++i)
    dim_data[i] = dim_array__.Get(i).ToNumber().Int64Value();
  bool keepdim = info__[3].As<Napi::Boolean>().Value();
  auto output__ = torch::nuclear_norm_out(*out, *self, torch::IntArrayRef(dim_data, dim_len), keepdim);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_positive(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::positive(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_resize_as_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *the_template = info__[1].As<Napi::External<torch::Tensor>>().Data();
  int memory_format = info__[2].As<Napi::Number>().Int32Value();
  auto output__ = torch::resize_as_(*self, *the_template, (at::MemoryFormat)memory_format);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_resize_as_sparse_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *the_template = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::resize_as_sparse_(*self, *the_template);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_zero_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::zero_(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_sub(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *alpha = info__[2].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::sub(*self, *other, *alpha);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_sub_scalar(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *other = info__[1].As<Napi::External<torch::Scalar>>().Data();
  torch::Scalar *alpha = info__[2].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::sub(*self, *other, *alpha);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_sub_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *alpha = info__[3].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::sub_out(*out, *self, *other, *alpha);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_sub_scalar_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *other = info__[2].As<Napi::External<torch::Scalar>>().Data();
  torch::Scalar *alpha = info__[3].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::sub_out(*out, *self, *other, *alpha);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_sub_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *alpha = info__[2].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = self->sub_(*other, *alpha);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_sub_scalar_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *other = info__[1].As<Napi::External<torch::Scalar>>().Data();
  torch::Scalar *alpha = info__[2].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = self->sub_(*other, *alpha);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_subtract(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *alpha = info__[2].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::subtract(*self, *other, *alpha);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_subtract_scalar(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *other = info__[1].As<Napi::External<torch::Scalar>>().Data();
  torch::Scalar *alpha = info__[2].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::subtract(*self, *other, *alpha);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_subtract_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *alpha = info__[3].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::subtract_out(*out, *self, *other, *alpha);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_subtract_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *alpha = info__[2].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = self->subtract_(*other, *alpha);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_subtract_scalar_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *other = info__[1].As<Napi::External<torch::Scalar>>().Data();
  torch::Scalar *alpha = info__[2].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = self->subtract_(*other, *alpha);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_rsub(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *alpha = info__[2].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::rsub(*self, *other, *alpha);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_rsub_scalar(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *other = info__[1].As<Napi::External<torch::Scalar>>().Data();
  torch::Scalar *alpha = info__[2].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::rsub(*self, *other, *alpha);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_rsub_tensor_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *alpha = info__[3].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::rsub_out(*out, *self, *other, *alpha);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_rsub_scalar_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *other = info__[2].As<Napi::External<torch::Scalar>>().Data();
  torch::Scalar *alpha = info__[3].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::rsub_out(*out, *self, *other, *alpha);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_heaviside(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *values = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::heaviside(*self, *values);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_heaviside_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *values = info__[2].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::heaviside_out(*out, *self, *values);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_heaviside_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *values = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = self->heaviside_(*values);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__sparse_addmm(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *mat1 = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *mat2 = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *beta = info__[3].As<Napi::External<torch::Scalar>>().Data();
  torch::Scalar *alpha = info__[4].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::_sparse_addmm(*self, *mat1, *mat2, *beta, *alpha);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__sparse_addmm_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *mat1 = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *mat2 = info__[3].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *beta = info__[4].As<Napi::External<torch::Scalar>>().Data();
  torch::Scalar *alpha = info__[5].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::_sparse_addmm_out(*out, *self, *mat1, *mat2, *beta, *alpha);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_sparse_sampled_addmm(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *mat1 = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *mat2 = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *beta = info__[3].As<Napi::External<torch::Scalar>>().Data();
  torch::Scalar *alpha = info__[4].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::sparse_sampled_addmm(*self, *mat1, *mat2, *beta, *alpha);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_sparse_sampled_addmm_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *mat1 = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *mat2 = info__[3].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *beta = info__[4].As<Napi::External<torch::Scalar>>().Data();
  torch::Scalar *alpha = info__[5].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::sparse_sampled_addmm_out(*out, *self, *mat1, *mat2, *beta, *alpha);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::Array atg__sparse_mm_reduce_impl(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::String reduce_str__ = info__[2].As<Napi::String>();
  std::string reduce = reduce_str__.Utf8Value();
  auto output__ = torch::_sparse_mm_reduce_impl(*self, *other, reduce);
  Napi::Array output__array__ = Napi::Array::New(env__, 2);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  return output__array__;
}

Napi::External<torch::Tensor> atg_addmm(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *mat1 = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *mat2 = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *beta = info__[3].As<Napi::External<torch::Scalar>>().Data();
  torch::Scalar *alpha = info__[4].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::addmm(*self, *mat1, *mat2, *beta, *alpha);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_addmm_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *mat1 = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *mat2 = info__[3].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *beta = info__[4].As<Napi::External<torch::Scalar>>().Data();
  torch::Scalar *alpha = info__[5].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::addmm_out(*out, *self, *mat1, *mat2, *beta, *alpha);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_addmm_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *mat1 = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *mat2 = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *beta = info__[3].As<Napi::External<torch::Scalar>>().Data();
  torch::Scalar *alpha = info__[4].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = self->addmm_(*mat1, *mat2, *beta, *alpha);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__addmm_activation(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *mat1 = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *mat2 = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *beta = info__[3].As<Napi::External<torch::Scalar>>().Data();
  torch::Scalar *alpha = info__[4].As<Napi::External<torch::Scalar>>().Data();
  bool use_gelu = info__[5].As<Napi::Boolean>().Value();
  auto output__ = torch::_addmm_activation(*self, *mat1, *mat2, *beta, *alpha, use_gelu);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__addmm_activation_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *mat1 = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *mat2 = info__[3].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *beta = info__[4].As<Napi::External<torch::Scalar>>().Data();
  torch::Scalar *alpha = info__[5].As<Napi::External<torch::Scalar>>().Data();
  bool use_gelu = info__[6].As<Napi::Boolean>().Value();
  auto output__ = torch::_addmm_activation_out(*out, *self, *mat1, *mat2, *beta, *alpha, use_gelu);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_sparse_compressed_tensor(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *compressed_indices = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *plain_indices = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *values = info__[2].As<Napi::External<torch::Tensor>>().Data();
  Napi::Object options_obj__ = info__[3].As<Napi::Object>();
  int options_device = options_obj__.Get("device").ToNumber().Int32Value();
  int options_kind = options_obj__.Get("dtype").ToNumber().Int32Value();
  auto output__ = torch::sparse_compressed_tensor(*compressed_indices, *plain_indices, *values, at::device(device_of_int(options_device)).dtype(at::ScalarType(options_kind)));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_sparse_compressed_tensor_comp_plain_value_size(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *compressed_indices = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *plain_indices = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *values = info__[2].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array size_array__ = info__[3].As<Napi::Array>();
  int size_len = size_array__.Length();
  int64_t *size_data = new int64_t[size_len];
  for (int i = 0; i < size_len; ++i)
    size_data[i] = size_array__.Get(i).ToNumber().Int64Value();
  Napi::Object options_obj__ = info__[4].As<Napi::Object>();
  int options_device = options_obj__.Get("device").ToNumber().Int32Value();
  int options_kind = options_obj__.Get("dtype").ToNumber().Int32Value();
  auto output__ = torch::sparse_compressed_tensor(*compressed_indices, *plain_indices, *values, torch::IntArrayRef(size_data, size_len), at::device(device_of_int(options_device)).dtype(at::ScalarType(options_kind)));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_sparse_csr_tensor(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *crow_indices = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *col_indices = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *values = info__[2].As<Napi::External<torch::Tensor>>().Data();
  Napi::Object options_obj__ = info__[3].As<Napi::Object>();
  int options_device = options_obj__.Get("device").ToNumber().Int32Value();
  int options_kind = options_obj__.Get("dtype").ToNumber().Int32Value();
  auto output__ = torch::sparse_csr_tensor(*crow_indices, *col_indices, *values, at::device(device_of_int(options_device)).dtype(at::ScalarType(options_kind)));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_sparse_csr_tensor_crow_col_value_size(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *crow_indices = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *col_indices = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *values = info__[2].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array size_array__ = info__[3].As<Napi::Array>();
  int size_len = size_array__.Length();
  int64_t *size_data = new int64_t[size_len];
  for (int i = 0; i < size_len; ++i)
    size_data[i] = size_array__.Get(i).ToNumber().Int64Value();
  Napi::Object options_obj__ = info__[4].As<Napi::Object>();
  int options_device = options_obj__.Get("device").ToNumber().Int32Value();
  int options_kind = options_obj__.Get("dtype").ToNumber().Int32Value();
  auto output__ = torch::sparse_csr_tensor(*crow_indices, *col_indices, *values, torch::IntArrayRef(size_data, size_len), at::device(device_of_int(options_device)).dtype(at::ScalarType(options_kind)));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_sparse_csc_tensor(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *ccol_indices = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *row_indices = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *values = info__[2].As<Napi::External<torch::Tensor>>().Data();
  Napi::Object options_obj__ = info__[3].As<Napi::Object>();
  int options_device = options_obj__.Get("device").ToNumber().Int32Value();
  int options_kind = options_obj__.Get("dtype").ToNumber().Int32Value();
  auto output__ = torch::sparse_csc_tensor(*ccol_indices, *row_indices, *values, at::device(device_of_int(options_device)).dtype(at::ScalarType(options_kind)));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_sparse_csc_tensor_ccol_row_value_size(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *ccol_indices = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *row_indices = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *values = info__[2].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array size_array__ = info__[3].As<Napi::Array>();
  int size_len = size_array__.Length();
  int64_t *size_data = new int64_t[size_len];
  for (int i = 0; i < size_len; ++i)
    size_data[i] = size_array__.Get(i).ToNumber().Int64Value();
  Napi::Object options_obj__ = info__[4].As<Napi::Object>();
  int options_device = options_obj__.Get("device").ToNumber().Int32Value();
  int options_kind = options_obj__.Get("dtype").ToNumber().Int32Value();
  auto output__ = torch::sparse_csc_tensor(*ccol_indices, *row_indices, *values, torch::IntArrayRef(size_data, size_len), at::device(device_of_int(options_device)).dtype(at::ScalarType(options_kind)));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_sparse_bsr_tensor(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *crow_indices = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *col_indices = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *values = info__[2].As<Napi::External<torch::Tensor>>().Data();
  Napi::Object options_obj__ = info__[3].As<Napi::Object>();
  int options_device = options_obj__.Get("device").ToNumber().Int32Value();
  int options_kind = options_obj__.Get("dtype").ToNumber().Int32Value();
  auto output__ = torch::sparse_bsr_tensor(*crow_indices, *col_indices, *values, at::device(device_of_int(options_device)).dtype(at::ScalarType(options_kind)));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_sparse_bsr_tensor_crow_col_value_size(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *crow_indices = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *col_indices = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *values = info__[2].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array size_array__ = info__[3].As<Napi::Array>();
  int size_len = size_array__.Length();
  int64_t *size_data = new int64_t[size_len];
  for (int i = 0; i < size_len; ++i)
    size_data[i] = size_array__.Get(i).ToNumber().Int64Value();
  Napi::Object options_obj__ = info__[4].As<Napi::Object>();
  int options_device = options_obj__.Get("device").ToNumber().Int32Value();
  int options_kind = options_obj__.Get("dtype").ToNumber().Int32Value();
  auto output__ = torch::sparse_bsr_tensor(*crow_indices, *col_indices, *values, torch::IntArrayRef(size_data, size_len), at::device(device_of_int(options_device)).dtype(at::ScalarType(options_kind)));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_sparse_bsc_tensor(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *ccol_indices = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *row_indices = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *values = info__[2].As<Napi::External<torch::Tensor>>().Data();
  Napi::Object options_obj__ = info__[3].As<Napi::Object>();
  int options_device = options_obj__.Get("device").ToNumber().Int32Value();
  int options_kind = options_obj__.Get("dtype").ToNumber().Int32Value();
  auto output__ = torch::sparse_bsc_tensor(*ccol_indices, *row_indices, *values, at::device(device_of_int(options_device)).dtype(at::ScalarType(options_kind)));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_sparse_bsc_tensor_ccol_row_value_size(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *ccol_indices = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *row_indices = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *values = info__[2].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array size_array__ = info__[3].As<Napi::Array>();
  int size_len = size_array__.Length();
  int64_t *size_data = new int64_t[size_len];
  for (int i = 0; i < size_len; ++i)
    size_data[i] = size_array__.Get(i).ToNumber().Int64Value();
  Napi::Object options_obj__ = info__[4].As<Napi::Object>();
  int options_device = options_obj__.Get("device").ToNumber().Int32Value();
  int options_kind = options_obj__.Get("dtype").ToNumber().Int32Value();
  auto output__ = torch::sparse_bsc_tensor(*ccol_indices, *row_indices, *values, torch::IntArrayRef(size_data, size_len), at::device(device_of_int(options_device)).dtype(at::ScalarType(options_kind)));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__sparse_compressed_tensor_unsafe(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *compressed_indices = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *plain_indices = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *values = info__[2].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array size_array__ = info__[3].As<Napi::Array>();
  int size_len = size_array__.Length();
  int64_t *size_data = new int64_t[size_len];
  for (int i = 0; i < size_len; ++i)
    size_data[i] = size_array__.Get(i).ToNumber().Int64Value();
  Napi::Object options_obj__ = info__[4].As<Napi::Object>();
  int options_device = options_obj__.Get("device").ToNumber().Int32Value();
  int options_kind = options_obj__.Get("dtype").ToNumber().Int32Value();
  auto output__ = torch::_sparse_compressed_tensor_unsafe(*compressed_indices, *plain_indices, *values, torch::IntArrayRef(size_data, size_len), at::device(device_of_int(options_device)).dtype(at::ScalarType(options_kind)));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__sparse_csr_tensor_unsafe(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *crow_indices = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *col_indices = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *values = info__[2].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array size_array__ = info__[3].As<Napi::Array>();
  int size_len = size_array__.Length();
  int64_t *size_data = new int64_t[size_len];
  for (int i = 0; i < size_len; ++i)
    size_data[i] = size_array__.Get(i).ToNumber().Int64Value();
  Napi::Object options_obj__ = info__[4].As<Napi::Object>();
  int options_device = options_obj__.Get("device").ToNumber().Int32Value();
  int options_kind = options_obj__.Get("dtype").ToNumber().Int32Value();
  auto output__ = torch::_sparse_csr_tensor_unsafe(*crow_indices, *col_indices, *values, torch::IntArrayRef(size_data, size_len), at::device(device_of_int(options_device)).dtype(at::ScalarType(options_kind)));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__sparse_csc_tensor_unsafe(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *ccol_indices = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *row_indices = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *values = info__[2].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array size_array__ = info__[3].As<Napi::Array>();
  int size_len = size_array__.Length();
  int64_t *size_data = new int64_t[size_len];
  for (int i = 0; i < size_len; ++i)
    size_data[i] = size_array__.Get(i).ToNumber().Int64Value();
  Napi::Object options_obj__ = info__[4].As<Napi::Object>();
  int options_device = options_obj__.Get("device").ToNumber().Int32Value();
  int options_kind = options_obj__.Get("dtype").ToNumber().Int32Value();
  auto output__ = torch::_sparse_csc_tensor_unsafe(*ccol_indices, *row_indices, *values, torch::IntArrayRef(size_data, size_len), at::device(device_of_int(options_device)).dtype(at::ScalarType(options_kind)));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__sparse_bsr_tensor_unsafe(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *crow_indices = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *col_indices = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *values = info__[2].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array size_array__ = info__[3].As<Napi::Array>();
  int size_len = size_array__.Length();
  int64_t *size_data = new int64_t[size_len];
  for (int i = 0; i < size_len; ++i)
    size_data[i] = size_array__.Get(i).ToNumber().Int64Value();
  Napi::Object options_obj__ = info__[4].As<Napi::Object>();
  int options_device = options_obj__.Get("device").ToNumber().Int32Value();
  int options_kind = options_obj__.Get("dtype").ToNumber().Int32Value();
  auto output__ = torch::_sparse_bsr_tensor_unsafe(*crow_indices, *col_indices, *values, torch::IntArrayRef(size_data, size_len), at::device(device_of_int(options_device)).dtype(at::ScalarType(options_kind)));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__sparse_bsc_tensor_unsafe(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *ccol_indices = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *row_indices = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *values = info__[2].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array size_array__ = info__[3].As<Napi::Array>();
  int size_len = size_array__.Length();
  int64_t *size_data = new int64_t[size_len];
  for (int i = 0; i < size_len; ++i)
    size_data[i] = size_array__.Get(i).ToNumber().Int64Value();
  Napi::Object options_obj__ = info__[4].As<Napi::Object>();
  int options_device = options_obj__.Get("device").ToNumber().Int32Value();
  int options_kind = options_obj__.Get("dtype").ToNumber().Int32Value();
  auto output__ = torch::_sparse_bsc_tensor_unsafe(*ccol_indices, *row_indices, *values, torch::IntArrayRef(size_data, size_len), at::device(device_of_int(options_device)).dtype(at::ScalarType(options_kind)));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_sparse_coo_tensor(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  Napi::Array size_array__ = info__[0].As<Napi::Array>();
  int size_len = size_array__.Length();
  int64_t *size_data = new int64_t[size_len];
  for (int i = 0; i < size_len; ++i)
    size_data[i] = size_array__.Get(i).ToNumber().Int64Value();
  Napi::Object options_obj__ = info__[1].As<Napi::Object>();
  int options_device = options_obj__.Get("device").ToNumber().Int32Value();
  int options_kind = options_obj__.Get("dtype").ToNumber().Int32Value();
  auto output__ = torch::sparse_coo_tensor(torch::IntArrayRef(size_data, size_len), at::device(device_of_int(options_device)).dtype(at::ScalarType(options_kind)));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_sparse_coo_tensor_indices(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *indices = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *values = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::Object options_obj__ = info__[2].As<Napi::Object>();
  int options_device = options_obj__.Get("device").ToNumber().Int32Value();
  int options_kind = options_obj__.Get("dtype").ToNumber().Int32Value();
  auto output__ = torch::sparse_coo_tensor(*indices, *values, at::device(device_of_int(options_device)).dtype(at::ScalarType(options_kind)));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_sparse_coo_tensor_indices_size(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *indices = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *values = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array size_array__ = info__[2].As<Napi::Array>();
  int size_len = size_array__.Length();
  int64_t *size_data = new int64_t[size_len];
  for (int i = 0; i < size_len; ++i)
    size_data[i] = size_array__.Get(i).ToNumber().Int64Value();
  Napi::Object options_obj__ = info__[3].As<Napi::Object>();
  int options_device = options_obj__.Get("device").ToNumber().Int32Value();
  int options_kind = options_obj__.Get("dtype").ToNumber().Int32Value();
  auto output__ = torch::sparse_coo_tensor(*indices, *values, torch::IntArrayRef(size_data, size_len), at::device(device_of_int(options_device)).dtype(at::ScalarType(options_kind)));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_sparse_coo_tensor_size_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array size_array__ = info__[1].As<Napi::Array>();
  int size_len = size_array__.Length();
  int64_t *size_data = new int64_t[size_len];
  for (int i = 0; i < size_len; ++i)
    size_data[i] = size_array__.Get(i).ToNumber().Int64Value();
  auto output__ = torch::sparse_coo_tensor_out(*out, torch::IntArrayRef(size_data, size_len));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__sparse_coo_tensor_unsafe(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *indices = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *values = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array size_array__ = info__[2].As<Napi::Array>();
  int size_len = size_array__.Length();
  int64_t *size_data = new int64_t[size_len];
  for (int i = 0; i < size_len; ++i)
    size_data[i] = size_array__.Get(i).ToNumber().Int64Value();
  Napi::Object options_obj__ = info__[3].As<Napi::Object>();
  int options_device = options_obj__.Get("device").ToNumber().Int32Value();
  int options_kind = options_obj__.Get("dtype").ToNumber().Int32Value();
  auto output__ = torch::_sparse_coo_tensor_unsafe(*indices, *values, torch::IntArrayRef(size_data, size_len), at::device(device_of_int(options_device)).dtype(at::ScalarType(options_kind)));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

void atg__validate_sparse_compressed_tensor_args(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *compressed_indices = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *plain_indices = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *values = info__[2].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array size_array__ = info__[3].As<Napi::Array>();
  int size_len = size_array__.Length();
  int64_t *size_data = new int64_t[size_len];
  for (int i = 0; i < size_len; ++i)
    size_data[i] = size_array__.Get(i).ToNumber().Int64Value();
  int layout = info__[4].As<Napi::Number>().Int32Value();
  torch::_validate_sparse_compressed_tensor_args(*compressed_indices, *plain_indices, *values, torch::IntArrayRef(size_data, size_len), (at::Layout)layout);
}

void atg__validate_sparse_csr_tensor_args(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *crow_indices = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *col_indices = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *values = info__[2].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array size_array__ = info__[3].As<Napi::Array>();
  int size_len = size_array__.Length();
  int64_t *size_data = new int64_t[size_len];
  for (int i = 0; i < size_len; ++i)
    size_data[i] = size_array__.Get(i).ToNumber().Int64Value();
  torch::_validate_sparse_csr_tensor_args(*crow_indices, *col_indices, *values, torch::IntArrayRef(size_data, size_len));
}

void atg__validate_sparse_csc_tensor_args(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *ccol_indices = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *row_indices = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *values = info__[2].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array size_array__ = info__[3].As<Napi::Array>();
  int size_len = size_array__.Length();
  int64_t *size_data = new int64_t[size_len];
  for (int i = 0; i < size_len; ++i)
    size_data[i] = size_array__.Get(i).ToNumber().Int64Value();
  torch::_validate_sparse_csc_tensor_args(*ccol_indices, *row_indices, *values, torch::IntArrayRef(size_data, size_len));
}

void atg__validate_sparse_bsr_tensor_args(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *crow_indices = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *col_indices = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *values = info__[2].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array size_array__ = info__[3].As<Napi::Array>();
  int size_len = size_array__.Length();
  int64_t *size_data = new int64_t[size_len];
  for (int i = 0; i < size_len; ++i)
    size_data[i] = size_array__.Get(i).ToNumber().Int64Value();
  torch::_validate_sparse_bsr_tensor_args(*crow_indices, *col_indices, *values, torch::IntArrayRef(size_data, size_len));
}

void atg__validate_sparse_bsc_tensor_args(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *ccol_indices = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *row_indices = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *values = info__[2].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array size_array__ = info__[3].As<Napi::Array>();
  int size_len = size_array__.Length();
  int64_t *size_data = new int64_t[size_len];
  for (int i = 0; i < size_len; ++i)
    size_data[i] = size_array__.Get(i).ToNumber().Int64Value();
  torch::_validate_sparse_bsc_tensor_args(*ccol_indices, *row_indices, *values, torch::IntArrayRef(size_data, size_len));
}

Napi::External<torch::Tensor> atg__sparse_coo_tensor_with_dims(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  int64_t sparse_dim = info__[0].As<Napi::Number>().Int64Value();
  int64_t dense_dim = info__[1].As<Napi::Number>().Int64Value();
  Napi::Array size_array__ = info__[2].As<Napi::Array>();
  int size_len = size_array__.Length();
  int64_t *size_data = new int64_t[size_len];
  for (int i = 0; i < size_len; ++i)
    size_data[i] = size_array__.Get(i).ToNumber().Int64Value();
  Napi::Object options_obj__ = info__[3].As<Napi::Object>();
  int options_device = options_obj__.Get("device").ToNumber().Int32Value();
  int options_kind = options_obj__.Get("dtype").ToNumber().Int32Value();
  auto output__ = torch::_sparse_coo_tensor_with_dims(sparse_dim, dense_dim, torch::IntArrayRef(size_data, size_len), at::device(device_of_int(options_device)).dtype(at::ScalarType(options_kind)));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__sparse_coo_tensor_with_dims_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t sparse_dim = info__[1].As<Napi::Number>().Int64Value();
  int64_t dense_dim = info__[2].As<Napi::Number>().Int64Value();
  Napi::Array size_array__ = info__[3].As<Napi::Array>();
  int size_len = size_array__.Length();
  int64_t *size_data = new int64_t[size_len];
  for (int i = 0; i < size_len; ++i)
    size_data[i] = size_array__.Get(i).ToNumber().Int64Value();
  auto output__ = torch::_sparse_coo_tensor_with_dims_out(*out, sparse_dim, dense_dim, torch::IntArrayRef(size_data, size_len));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__sparse_coo_tensor_with_dims_and_tensors(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  int64_t sparse_dim = info__[0].As<Napi::Number>().Int64Value();
  int64_t dense_dim = info__[1].As<Napi::Number>().Int64Value();
  Napi::Array size_array__ = info__[2].As<Napi::Array>();
  int size_len = size_array__.Length();
  int64_t *size_data = new int64_t[size_len];
  for (int i = 0; i < size_len; ++i)
    size_data[i] = size_array__.Get(i).ToNumber().Int64Value();
  torch::Tensor *indices = info__[3].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *values = info__[4].As<Napi::External<torch::Tensor>>().Data();
  Napi::Object options_obj__ = info__[5].As<Napi::Object>();
  int options_device = options_obj__.Get("device").ToNumber().Int32Value();
  int options_kind = options_obj__.Get("dtype").ToNumber().Int32Value();
  auto output__ = torch::_sparse_coo_tensor_with_dims_and_tensors(sparse_dim, dense_dim, torch::IntArrayRef(size_data, size_len), *indices, *values, at::device(device_of_int(options_device)).dtype(at::ScalarType(options_kind)));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__sparse_coo_tensor_with_dims_and_tensors_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t sparse_dim = info__[1].As<Napi::Number>().Int64Value();
  int64_t dense_dim = info__[2].As<Napi::Number>().Int64Value();
  Napi::Array size_array__ = info__[3].As<Napi::Array>();
  int size_len = size_array__.Length();
  int64_t *size_data = new int64_t[size_len];
  for (int i = 0; i < size_len; ++i)
    size_data[i] = size_array__.Get(i).ToNumber().Int64Value();
  torch::Tensor *indices = info__[4].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *values = info__[5].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::_sparse_coo_tensor_with_dims_and_tensors_out(*out, sparse_dim, dense_dim, torch::IntArrayRef(size_data, size_len), *indices, *values);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_sparse_resize_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array size_array__ = info__[1].As<Napi::Array>();
  int size_len = size_array__.Length();
  int64_t *size_data = new int64_t[size_len];
  for (int i = 0; i < size_len; ++i)
    size_data[i] = size_array__.Get(i).ToNumber().Int64Value();
  int64_t sparse_dim = info__[2].As<Napi::Number>().Int64Value();
  int64_t dense_dim = info__[3].As<Napi::Number>().Int64Value();
  auto output__ = self->sparse_resize_(torch::IntArrayRef(size_data, size_len), sparse_dim, dense_dim);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_sparse_resize_and_clear_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array size_array__ = info__[1].As<Napi::Array>();
  int size_len = size_array__.Length();
  int64_t *size_data = new int64_t[size_len];
  for (int i = 0; i < size_len; ++i)
    size_data[i] = size_array__.Get(i).ToNumber().Int64Value();
  int64_t sparse_dim = info__[2].As<Napi::Number>().Int64Value();
  int64_t dense_dim = info__[3].As<Napi::Number>().Int64Value();
  auto output__ = self->sparse_resize_and_clear_(torch::IntArrayRef(size_data, size_len), sparse_dim, dense_dim);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_sparse_mask(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *mask = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = self->sparse_mask(*mask);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_sparse_mask_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *mask = info__[2].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::sparse_mask_out(*out, *self, *mask);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_to_dense(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int dtype = info__[1].As<Napi::Number>().Int32Value();
  auto output__ = self->to_dense(at::ScalarType(dtype));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__to_dense(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int dtype = info__[1].As<Napi::Number>().Int32Value();
  auto output__ = self->_to_dense(at::ScalarType(dtype));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__to_dense_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  int dtype = info__[2].As<Napi::Number>().Int32Value();
  auto output__ = torch::_to_dense_out(*out, *self, at::ScalarType(dtype));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_to_dense_backward(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *grad = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *input = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::to_dense_backward(*grad, *input);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::Number atg_sparse_dim(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = self->sparse_dim();
  return Napi::Number::New(env__, output__);
}

Napi::Number atg__dimI(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = self->_dimI();
  return Napi::Number::New(env__, output__);
}

Napi::Number atg_dense_dim(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = self->dense_dim();
  return Napi::Number::New(env__, output__);
}

Napi::Number atg__dimV(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = self->_dimV();
  return Napi::Number::New(env__, output__);
}

Napi::Number atg__nnz(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = self->_nnz();
  return Napi::Number::New(env__, output__);
}

Napi::External<torch::Tensor> atg_coalesce(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = self->coalesce();
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__coalesce(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::_coalesce(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__coalesce_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::_coalesce_out(*out, *self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::Boolean atg_is_coalesced(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = self->is_coalesced();
  return Napi::Boolean::New(env__, output__);
}

Napi::External<torch::Tensor> atg__indices(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = self->_indices();
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__values(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = self->_values();
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__coalesced_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  bool coalesced = info__[1].As<Napi::Boolean>().Value();
  auto output__ = self->_coalesced_(coalesced);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_indices(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = self->indices();
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_values(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = self->values();
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_crow_indices(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = self->crow_indices();
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_col_indices(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = self->col_indices();
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_ccol_indices(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = self->ccol_indices();
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_row_indices(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = self->row_indices();
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_hspmm(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *mat1 = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *mat2 = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::hspmm(*mat1, *mat2);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_hspmm_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *mat1 = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *mat2 = info__[2].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::hspmm_out(*out, *mat1, *mat2);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_copy_sparse_to_sparse_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *src = info__[1].As<Napi::External<torch::Tensor>>().Data();
  bool non_blocking = info__[2].As<Napi::Boolean>().Value();
  auto output__ = torch::copy_sparse_to_sparse_(*self, *src, non_blocking);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_to_sparse_sparse_dim(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t sparse_dim = info__[1].As<Napi::Number>().Int64Value();
  auto output__ = self->to_sparse(sparse_dim);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_to_sparse(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int layout = info__[1].As<Napi::Number>().Int32Value();
  Napi::Array blocksize_array__ = info__[2].As<Napi::Array>();
  int blocksize_len = blocksize_array__.Length();
  int64_t *blocksize_data = new int64_t[blocksize_len];
  for (int i = 0; i < blocksize_len; ++i)
    blocksize_data[i] = blocksize_array__.Get(i).ToNumber().Int64Value();
  bool dense_dim_null = info__[3].IsUndefined();
  int64_t dense_dim_v = dense_dim_null ? 0 : info__[3].As<Napi::Number>().Int64Value();
  auto output__ = self->to_sparse((at::Layout)layout, blocksize_data == nullptr ? c10::nullopt : c10::optional<torch::IntArrayRef>(torch::IntArrayRef(blocksize_data, blocksize_len)), dense_dim_null ? c10::nullopt : c10::optional<int64_t>(dense_dim_v));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_to_sparse_sparse_dim_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  int64_t sparse_dim = info__[2].As<Napi::Number>().Int64Value();
  auto output__ = torch::to_sparse_out(*out, *self, sparse_dim);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_to_sparse_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  int layout = info__[2].As<Napi::Number>().Int32Value();
  Napi::Array blocksize_array__ = info__[3].As<Napi::Array>();
  int blocksize_len = blocksize_array__.Length();
  int64_t *blocksize_data = new int64_t[blocksize_len];
  for (int i = 0; i < blocksize_len; ++i)
    blocksize_data[i] = blocksize_array__.Get(i).ToNumber().Int64Value();
  bool dense_dim_null = info__[4].IsUndefined();
  int64_t dense_dim_v = dense_dim_null ? 0 : info__[4].As<Napi::Number>().Int64Value();
  auto output__ = torch::to_sparse_out(*out, *self, (at::Layout)layout, blocksize_data == nullptr ? c10::nullopt : c10::optional<torch::IntArrayRef>(torch::IntArrayRef(blocksize_data, blocksize_len)), dense_dim_null ? c10::nullopt : c10::optional<int64_t>(dense_dim_v));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_to_sparse_csr(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  bool dense_dim_null = info__[1].IsUndefined();
  int64_t dense_dim_v = dense_dim_null ? 0 : info__[1].As<Napi::Number>().Int64Value();
  auto output__ = self->to_sparse_csr(dense_dim_null ? c10::nullopt : c10::optional<int64_t>(dense_dim_v));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_to_sparse_csr_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  bool dense_dim_null = info__[2].IsUndefined();
  int64_t dense_dim_v = dense_dim_null ? 0 : info__[2].As<Napi::Number>().Int64Value();
  auto output__ = torch::to_sparse_csr_out(*out, *self, dense_dim_null ? c10::nullopt : c10::optional<int64_t>(dense_dim_v));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_to_sparse_csc(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  bool dense_dim_null = info__[1].IsUndefined();
  int64_t dense_dim_v = dense_dim_null ? 0 : info__[1].As<Napi::Number>().Int64Value();
  auto output__ = self->to_sparse_csc(dense_dim_null ? c10::nullopt : c10::optional<int64_t>(dense_dim_v));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_to_sparse_csc_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  bool dense_dim_null = info__[2].IsUndefined();
  int64_t dense_dim_v = dense_dim_null ? 0 : info__[2].As<Napi::Number>().Int64Value();
  auto output__ = torch::to_sparse_csc_out(*out, *self, dense_dim_null ? c10::nullopt : c10::optional<int64_t>(dense_dim_v));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_to_sparse_bsr(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array blocksize_array__ = info__[1].As<Napi::Array>();
  int blocksize_len = blocksize_array__.Length();
  int64_t *blocksize_data = new int64_t[blocksize_len];
  for (int i = 0; i < blocksize_len; ++i)
    blocksize_data[i] = blocksize_array__.Get(i).ToNumber().Int64Value();
  bool dense_dim_null = info__[2].IsUndefined();
  int64_t dense_dim_v = dense_dim_null ? 0 : info__[2].As<Napi::Number>().Int64Value();
  auto output__ = self->to_sparse_bsr(torch::IntArrayRef(blocksize_data, blocksize_len), dense_dim_null ? c10::nullopt : c10::optional<int64_t>(dense_dim_v));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_to_sparse_bsr_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array blocksize_array__ = info__[2].As<Napi::Array>();
  int blocksize_len = blocksize_array__.Length();
  int64_t *blocksize_data = new int64_t[blocksize_len];
  for (int i = 0; i < blocksize_len; ++i)
    blocksize_data[i] = blocksize_array__.Get(i).ToNumber().Int64Value();
  bool dense_dim_null = info__[3].IsUndefined();
  int64_t dense_dim_v = dense_dim_null ? 0 : info__[3].As<Napi::Number>().Int64Value();
  auto output__ = torch::to_sparse_bsr_out(*out, *self, torch::IntArrayRef(blocksize_data, blocksize_len), dense_dim_null ? c10::nullopt : c10::optional<int64_t>(dense_dim_v));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_to_sparse_bsc(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array blocksize_array__ = info__[1].As<Napi::Array>();
  int blocksize_len = blocksize_array__.Length();
  int64_t *blocksize_data = new int64_t[blocksize_len];
  for (int i = 0; i < blocksize_len; ++i)
    blocksize_data[i] = blocksize_array__.Get(i).ToNumber().Int64Value();
  bool dense_dim_null = info__[2].IsUndefined();
  int64_t dense_dim_v = dense_dim_null ? 0 : info__[2].As<Napi::Number>().Int64Value();
  auto output__ = self->to_sparse_bsc(torch::IntArrayRef(blocksize_data, blocksize_len), dense_dim_null ? c10::nullopt : c10::optional<int64_t>(dense_dim_v));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_to_sparse_bsc_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array blocksize_array__ = info__[2].As<Napi::Array>();
  int blocksize_len = blocksize_array__.Length();
  int64_t *blocksize_data = new int64_t[blocksize_len];
  for (int i = 0; i < blocksize_len; ++i)
    blocksize_data[i] = blocksize_array__.Get(i).ToNumber().Int64Value();
  bool dense_dim_null = info__[3].IsUndefined();
  int64_t dense_dim_v = dense_dim_null ? 0 : info__[3].As<Napi::Number>().Int64Value();
  auto output__ = torch::to_sparse_bsc_out(*out, *self, torch::IntArrayRef(blocksize_data, blocksize_len), dense_dim_null ? c10::nullopt : c10::optional<int64_t>(dense_dim_v));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_to_mkldnn(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int dtype = info__[1].As<Napi::Number>().Int32Value();
  auto output__ = self->to_mkldnn(at::ScalarType(dtype));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_to_mkldnn_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  int dtype = info__[2].As<Napi::Number>().Int32Value();
  auto output__ = torch::to_mkldnn_out(*out, *self, at::ScalarType(dtype));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_mkldnn_reorder_conv2d_weight(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array padding_array__ = info__[1].As<Napi::Array>();
  int padding_len = padding_array__.Length();
  int64_t *padding_data = new int64_t[padding_len];
  for (int i = 0; i < padding_len; ++i)
    padding_data[i] = padding_array__.Get(i).ToNumber().Int64Value();
  Napi::Array stride_array__ = info__[2].As<Napi::Array>();
  int stride_len = stride_array__.Length();
  int64_t *stride_data = new int64_t[stride_len];
  for (int i = 0; i < stride_len; ++i)
    stride_data[i] = stride_array__.Get(i).ToNumber().Int64Value();
  Napi::Array dilation_array__ = info__[3].As<Napi::Array>();
  int dilation_len = dilation_array__.Length();
  int64_t *dilation_data = new int64_t[dilation_len];
  for (int i = 0; i < dilation_len; ++i)
    dilation_data[i] = dilation_array__.Get(i).ToNumber().Int64Value();
  int64_t groups = info__[4].As<Napi::Number>().Int64Value();
  Napi::Array input_size_array__ = info__[5].As<Napi::Array>();
  int input_size_len = input_size_array__.Length();
  int64_t *input_size_data = new int64_t[input_size_len];
  for (int i = 0; i < input_size_len; ++i)
    input_size_data[i] = input_size_array__.Get(i).ToNumber().Int64Value();
  auto output__ = torch::mkldnn_reorder_conv2d_weight(*self, torch::IntArrayRef(padding_data, padding_len), torch::IntArrayRef(stride_data, stride_len), torch::IntArrayRef(dilation_data, dilation_len), groups, input_size_data == nullptr ? c10::nullopt : c10::optional<torch::IntArrayRef>(torch::IntArrayRef(input_size_data, input_size_len)));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_mkldnn_reorder_conv2d_weight_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array padding_array__ = info__[2].As<Napi::Array>();
  int padding_len = padding_array__.Length();
  int64_t *padding_data = new int64_t[padding_len];
  for (int i = 0; i < padding_len; ++i)
    padding_data[i] = padding_array__.Get(i).ToNumber().Int64Value();
  Napi::Array stride_array__ = info__[3].As<Napi::Array>();
  int stride_len = stride_array__.Length();
  int64_t *stride_data = new int64_t[stride_len];
  for (int i = 0; i < stride_len; ++i)
    stride_data[i] = stride_array__.Get(i).ToNumber().Int64Value();
  Napi::Array dilation_array__ = info__[4].As<Napi::Array>();
  int dilation_len = dilation_array__.Length();
  int64_t *dilation_data = new int64_t[dilation_len];
  for (int i = 0; i < dilation_len; ++i)
    dilation_data[i] = dilation_array__.Get(i).ToNumber().Int64Value();
  int64_t groups = info__[5].As<Napi::Number>().Int64Value();
  Napi::Array input_size_array__ = info__[6].As<Napi::Array>();
  int input_size_len = input_size_array__.Length();
  int64_t *input_size_data = new int64_t[input_size_len];
  for (int i = 0; i < input_size_len; ++i)
    input_size_data[i] = input_size_array__.Get(i).ToNumber().Int64Value();
  auto output__ = torch::mkldnn_reorder_conv2d_weight_out(*out, *self, torch::IntArrayRef(padding_data, padding_len), torch::IntArrayRef(stride_data, stride_len), torch::IntArrayRef(dilation_data, dilation_len), groups, input_size_data == nullptr ? c10::nullopt : c10::optional<torch::IntArrayRef>(torch::IntArrayRef(input_size_data, input_size_len)));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_mkldnn_reorder_conv3d_weight(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array padding_array__ = info__[1].As<Napi::Array>();
  int padding_len = padding_array__.Length();
  int64_t *padding_data = new int64_t[padding_len];
  for (int i = 0; i < padding_len; ++i)
    padding_data[i] = padding_array__.Get(i).ToNumber().Int64Value();
  Napi::Array stride_array__ = info__[2].As<Napi::Array>();
  int stride_len = stride_array__.Length();
  int64_t *stride_data = new int64_t[stride_len];
  for (int i = 0; i < stride_len; ++i)
    stride_data[i] = stride_array__.Get(i).ToNumber().Int64Value();
  Napi::Array dilation_array__ = info__[3].As<Napi::Array>();
  int dilation_len = dilation_array__.Length();
  int64_t *dilation_data = new int64_t[dilation_len];
  for (int i = 0; i < dilation_len; ++i)
    dilation_data[i] = dilation_array__.Get(i).ToNumber().Int64Value();
  int64_t groups = info__[4].As<Napi::Number>().Int64Value();
  auto output__ = torch::mkldnn_reorder_conv3d_weight(*self, torch::IntArrayRef(padding_data, padding_len), torch::IntArrayRef(stride_data, stride_len), torch::IntArrayRef(dilation_data, dilation_len), groups);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_mkldnn_reorder_conv3d_weight_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array padding_array__ = info__[2].As<Napi::Array>();
  int padding_len = padding_array__.Length();
  int64_t *padding_data = new int64_t[padding_len];
  for (int i = 0; i < padding_len; ++i)
    padding_data[i] = padding_array__.Get(i).ToNumber().Int64Value();
  Napi::Array stride_array__ = info__[3].As<Napi::Array>();
  int stride_len = stride_array__.Length();
  int64_t *stride_data = new int64_t[stride_len];
  for (int i = 0; i < stride_len; ++i)
    stride_data[i] = stride_array__.Get(i).ToNumber().Int64Value();
  Napi::Array dilation_array__ = info__[4].As<Napi::Array>();
  int dilation_len = dilation_array__.Length();
  int64_t *dilation_data = new int64_t[dilation_len];
  for (int i = 0; i < dilation_len; ++i)
    dilation_data[i] = dilation_array__.Get(i).ToNumber().Int64Value();
  int64_t groups = info__[5].As<Napi::Number>().Int64Value();
  auto output__ = torch::mkldnn_reorder_conv3d_weight_out(*out, *self, torch::IntArrayRef(padding_data, padding_len), torch::IntArrayRef(stride_data, stride_len), torch::IntArrayRef(dilation_data, dilation_len), groups);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_to_mkldnn_backward(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *grad = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *input = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::to_mkldnn_backward(*grad, *input);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_quantize_per_tensor_dynamic(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int dtype = info__[1].As<Napi::Number>().Int32Value();
  bool reduce_range = info__[2].As<Napi::Boolean>().Value();
  auto output__ = torch::quantize_per_tensor_dynamic(*self, at::ScalarType(dtype), reduce_range);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_quantize_per_tensor_dynamic_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  int dtype = info__[2].As<Napi::Number>().Int32Value();
  bool reduce_range = info__[3].As<Napi::Boolean>().Value();
  auto output__ = torch::quantize_per_tensor_dynamic_out(*out, *self, at::ScalarType(dtype), reduce_range);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_quantize_per_tensor(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  double scale = info__[1].As<Napi::Number>().DoubleValue();
  int64_t zero_point = info__[2].As<Napi::Number>().Int64Value();
  int dtype = info__[3].As<Napi::Number>().Int32Value();
  auto output__ = torch::quantize_per_tensor(*self, scale, zero_point, at::ScalarType(dtype));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_quantize_per_tensor_tensor_qparams(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *scale = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *zero_point = info__[2].As<Napi::External<torch::Tensor>>().Data();
  int dtype = info__[3].As<Napi::Number>().Int32Value();
  auto output__ = torch::quantize_per_tensor(*self, *scale, *zero_point, at::ScalarType(dtype));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_quantize_per_tensor_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  double scale = info__[2].As<Napi::Number>().DoubleValue();
  int64_t zero_point = info__[3].As<Napi::Number>().Int64Value();
  int dtype = info__[4].As<Napi::Number>().Int32Value();
  auto output__ = torch::quantize_per_tensor_out(*out, *self, scale, zero_point, at::ScalarType(dtype));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_quantize_per_tensor_tensor_qparams_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *scale = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *zero_point = info__[3].As<Napi::External<torch::Tensor>>().Data();
  int dtype = info__[4].As<Napi::Number>().Int32Value();
  auto output__ = torch::quantize_per_tensor_out(*out, *self, *scale, *zero_point, at::ScalarType(dtype));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

void atg_quantize_per_tensor_tensors_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  Napi::Array out_array__ = info__[0].As<Napi::Array>();
  int out_len = out_array__.Length();
  torch::Tensor **out_data = new torch::Tensor *[out_len];
  for (int i = 0; i < out_len; ++i)
    out_data[i] = out_array__.Get(i).As<Napi::External<torch::Tensor>>().Data();
  Napi::Array tensors_array__ = info__[1].As<Napi::Array>();
  int tensors_len = tensors_array__.Length();
  torch::Tensor **tensors_data = new torch::Tensor *[tensors_len];
  for (int i = 0; i < tensors_len; ++i)
    tensors_data[i] = tensors_array__.Get(i).As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *scales = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *zero_points = info__[3].As<Napi::External<torch::Tensor>>().Data();
  int dtype = info__[4].As<Napi::Number>().Int32Value();
  torch::quantize_per_tensor_out(of_carray_tensor(out_data, out_len), of_carray_tensor(tensors_data, tensors_len), *scales, *zero_points, at::ScalarType(dtype));
}

Napi::External<torch::Tensor> atg_quantize_per_channel(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *scales = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *zero_points = info__[2].As<Napi::External<torch::Tensor>>().Data();
  int64_t axis = info__[3].As<Napi::Number>().Int64Value();
  int dtype = info__[4].As<Napi::Number>().Int32Value();
  auto output__ = torch::quantize_per_channel(*self, *scales, *zero_points, axis, at::ScalarType(dtype));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_quantize_per_channel_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *scales = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *zero_points = info__[3].As<Napi::External<torch::Tensor>>().Data();
  int64_t axis = info__[4].As<Napi::Number>().Int64Value();
  int dtype = info__[5].As<Napi::Number>().Int32Value();
  auto output__ = torch::quantize_per_channel_out(*out, *self, *scales, *zero_points, axis, at::ScalarType(dtype));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_dequantize(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::dequantize(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_dequantize_self_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::dequantize_out(*out, *self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

void atg_dequantize_tensors_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  Napi::Array out_array__ = info__[0].As<Napi::Array>();
  int out_len = out_array__.Length();
  torch::Tensor **out_data = new torch::Tensor *[out_len];
  for (int i = 0; i < out_len; ++i)
    out_data[i] = out_array__.Get(i).As<Napi::External<torch::Tensor>>().Data();
  Napi::Array tensors_array__ = info__[1].As<Napi::Array>();
  int tensors_len = tensors_array__.Length();
  torch::Tensor **tensors_data = new torch::Tensor *[tensors_len];
  for (int i = 0; i < tensors_len; ++i)
    tensors_data[i] = tensors_array__.Get(i).As<Napi::External<torch::Tensor>>().Data();
  torch::dequantize_out(of_carray_tensor(out_data, out_len), of_carray_tensor(tensors_data, tensors_len));
}

Napi::Number atg_q_scale(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::q_scale(*self);
  return Napi::Number::New(env__, output__);
}

Napi::Number atg_q_zero_point(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::q_zero_point(*self);
  return Napi::Number::New(env__, output__);
}

Napi::External<torch::Tensor> atg_q_per_channel_scales(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::q_per_channel_scales(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_q_per_channel_scales_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::q_per_channel_scales_out(*out, *self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_q_per_channel_zero_points(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::q_per_channel_zero_points(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_q_per_channel_zero_points_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::q_per_channel_zero_points_out(*out, *self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::Number atg_q_per_channel_axis(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::q_per_channel_axis(*self);
  return Napi::Number::New(env__, output__);
}

Napi::External<torch::Tensor> atg_int_repr(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::int_repr(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_int_repr_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::int_repr_out(*out, *self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__make_per_tensor_quantized_tensor(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  double scale = info__[1].As<Napi::Number>().DoubleValue();
  int64_t zero_point = info__[2].As<Napi::Number>().Int64Value();
  auto output__ = torch::_make_per_tensor_quantized_tensor(*self, scale, zero_point);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__make_per_tensor_quantized_tensor_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  double scale = info__[2].As<Napi::Number>().DoubleValue();
  int64_t zero_point = info__[3].As<Napi::Number>().Int64Value();
  auto output__ = torch::_make_per_tensor_quantized_tensor_out(*out, *self, scale, zero_point);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__make_per_channel_quantized_tensor(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *scale = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *zero_point = info__[2].As<Napi::External<torch::Tensor>>().Data();
  int64_t axis = info__[3].As<Napi::Number>().Int64Value();
  auto output__ = torch::_make_per_channel_quantized_tensor(*self, *scale, *zero_point, axis);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__make_per_channel_quantized_tensor_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *scale = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *zero_point = info__[3].As<Napi::External<torch::Tensor>>().Data();
  int64_t axis = info__[4].As<Napi::Number>().Int64Value();
  auto output__ = torch::_make_per_channel_quantized_tensor_out(*out, *self, *scale, *zero_point, axis);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_fake_quantize_per_tensor_affine(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  double scale = info__[1].As<Napi::Number>().DoubleValue();
  int64_t zero_point = info__[2].As<Napi::Number>().Int64Value();
  int64_t quant_min = info__[3].As<Napi::Number>().Int64Value();
  int64_t quant_max = info__[4].As<Napi::Number>().Int64Value();
  auto output__ = torch::fake_quantize_per_tensor_affine(*self, scale, zero_point, quant_min, quant_max);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_fake_quantize_per_tensor_affine_tensor_qparams(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *scale = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *zero_point = info__[2].As<Napi::External<torch::Tensor>>().Data();
  int64_t quant_min = info__[3].As<Napi::Number>().Int64Value();
  int64_t quant_max = info__[4].As<Napi::Number>().Int64Value();
  auto output__ = torch::fake_quantize_per_tensor_affine(*self, *scale, *zero_point, quant_min, quant_max);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::Array atg_fake_quantize_per_tensor_affine_cachemask(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  double scale = info__[1].As<Napi::Number>().DoubleValue();
  int64_t zero_point = info__[2].As<Napi::Number>().Int64Value();
  int64_t quant_min = info__[3].As<Napi::Number>().Int64Value();
  int64_t quant_max = info__[4].As<Napi::Number>().Int64Value();
  auto output__ = torch::fake_quantize_per_tensor_affine_cachemask(*self, scale, zero_point, quant_min, quant_max);
  Napi::Array output__array__ = Napi::Array::New(env__, 2);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  return output__array__;
}

Napi::Array atg_fake_quantize_per_tensor_affine_cachemask_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out0 = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *out1 = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[2].As<Napi::External<torch::Tensor>>().Data();
  double scale = info__[3].As<Napi::Number>().DoubleValue();
  int64_t zero_point = info__[4].As<Napi::Number>().Int64Value();
  int64_t quant_min = info__[5].As<Napi::Number>().Int64Value();
  int64_t quant_max = info__[6].As<Napi::Number>().Int64Value();
  auto output__ = torch::fake_quantize_per_tensor_affine_cachemask_out(*out0, *out1, *self, scale, zero_point, quant_min, quant_max);
  Napi::Array output__array__ = Napi::Array::New(env__, 2);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  return output__array__;
}

Napi::Array atg__fake_quantize_per_tensor_affine_cachemask_tensor_qparams(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *scale = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *zero_point = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *fake_quant_enabled = info__[3].As<Napi::External<torch::Tensor>>().Data();
  int64_t quant_min = info__[4].As<Napi::Number>().Int64Value();
  int64_t quant_max = info__[5].As<Napi::Number>().Int64Value();
  auto output__ = torch::_fake_quantize_per_tensor_affine_cachemask_tensor_qparams(*self, *scale, *zero_point, *fake_quant_enabled, quant_min, quant_max);
  Napi::Array output__array__ = Napi::Array::New(env__, 2);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  return output__array__;
}

Napi::Array atg__fake_quantize_per_tensor_affine_cachemask_tensor_qparams_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out0 = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *out1 = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *scale = info__[3].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *zero_point = info__[4].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *fake_quant_enabled = info__[5].As<Napi::External<torch::Tensor>>().Data();
  int64_t quant_min = info__[6].As<Napi::Number>().Int64Value();
  int64_t quant_max = info__[7].As<Napi::Number>().Int64Value();
  auto output__ = torch::_fake_quantize_per_tensor_affine_cachemask_tensor_qparams_out(*out0, *out1, *self, *scale, *zero_point, *fake_quant_enabled, quant_min, quant_max);
  Napi::Array output__array__ = Napi::Array::New(env__, 2);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  return output__array__;
}

Napi::External<torch::Tensor> atg_fake_quantize_per_tensor_affine_cachemask_backward(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *grad = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *mask = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::fake_quantize_per_tensor_affine_cachemask_backward(*grad, *mask);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__fake_quantize_learnable_per_tensor_affine(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *scale = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *zero_point = info__[2].As<Napi::External<torch::Tensor>>().Data();
  int64_t quant_min = info__[3].As<Napi::Number>().Int64Value();
  int64_t quant_max = info__[4].As<Napi::Number>().Int64Value();
  double grad_factor = info__[5].As<Napi::Number>().DoubleValue();
  auto output__ = torch::_fake_quantize_learnable_per_tensor_affine(*self, *scale, *zero_point, quant_min, quant_max, grad_factor);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__fake_quantize_learnable_per_tensor_affine_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *scale = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *zero_point = info__[3].As<Napi::External<torch::Tensor>>().Data();
  int64_t quant_min = info__[4].As<Napi::Number>().Int64Value();
  int64_t quant_max = info__[5].As<Napi::Number>().Int64Value();
  double grad_factor = info__[6].As<Napi::Number>().DoubleValue();
  auto output__ = torch::_fake_quantize_learnable_per_tensor_affine_out(*out, *self, *scale, *zero_point, quant_min, quant_max, grad_factor);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::Array atg__fake_quantize_learnable_per_tensor_affine_backward(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *grad = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *scale = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *zero_point = info__[3].As<Napi::External<torch::Tensor>>().Data();
  int64_t quant_min = info__[4].As<Napi::Number>().Int64Value();
  int64_t quant_max = info__[5].As<Napi::Number>().Int64Value();
  double grad_factor = info__[6].As<Napi::Number>().DoubleValue();
  auto output__ = torch::_fake_quantize_learnable_per_tensor_affine_backward(*grad, *self, *scale, *zero_point, quant_min, quant_max, grad_factor);
  Napi::Array output__array__ = Napi::Array::New(env__, 3);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  output__array__[2u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<2>(output__)));
  return output__array__;
}

Napi::External<torch::Tensor> atg_fake_quantize_per_channel_affine(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *scale = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *zero_point = info__[2].As<Napi::External<torch::Tensor>>().Data();
  int64_t axis = info__[3].As<Napi::Number>().Int64Value();
  int64_t quant_min = info__[4].As<Napi::Number>().Int64Value();
  int64_t quant_max = info__[5].As<Napi::Number>().Int64Value();
  auto output__ = torch::fake_quantize_per_channel_affine(*self, *scale, *zero_point, axis, quant_min, quant_max);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::Array atg_fake_quantize_per_channel_affine_cachemask(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *scale = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *zero_point = info__[2].As<Napi::External<torch::Tensor>>().Data();
  int64_t axis = info__[3].As<Napi::Number>().Int64Value();
  int64_t quant_min = info__[4].As<Napi::Number>().Int64Value();
  int64_t quant_max = info__[5].As<Napi::Number>().Int64Value();
  auto output__ = torch::fake_quantize_per_channel_affine_cachemask(*self, *scale, *zero_point, axis, quant_min, quant_max);
  Napi::Array output__array__ = Napi::Array::New(env__, 2);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  return output__array__;
}

Napi::Array atg_fake_quantize_per_channel_affine_cachemask_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out0 = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *out1 = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *scale = info__[3].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *zero_point = info__[4].As<Napi::External<torch::Tensor>>().Data();
  int64_t axis = info__[5].As<Napi::Number>().Int64Value();
  int64_t quant_min = info__[6].As<Napi::Number>().Int64Value();
  int64_t quant_max = info__[7].As<Napi::Number>().Int64Value();
  auto output__ = torch::fake_quantize_per_channel_affine_cachemask_out(*out0, *out1, *self, *scale, *zero_point, axis, quant_min, quant_max);
  Napi::Array output__array__ = Napi::Array::New(env__, 2);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  return output__array__;
}

Napi::External<torch::Tensor> atg_fake_quantize_per_channel_affine_cachemask_backward(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *grad = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *mask = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::fake_quantize_per_channel_affine_cachemask_backward(*grad, *mask);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__fake_quantize_learnable_per_channel_affine(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *scale = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *zero_point = info__[2].As<Napi::External<torch::Tensor>>().Data();
  int64_t axis = info__[3].As<Napi::Number>().Int64Value();
  int64_t quant_min = info__[4].As<Napi::Number>().Int64Value();
  int64_t quant_max = info__[5].As<Napi::Number>().Int64Value();
  double grad_factor = info__[6].As<Napi::Number>().DoubleValue();
  auto output__ = torch::_fake_quantize_learnable_per_channel_affine(*self, *scale, *zero_point, axis, quant_min, quant_max, grad_factor);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__fake_quantize_learnable_per_channel_affine_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *scale = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *zero_point = info__[3].As<Napi::External<torch::Tensor>>().Data();
  int64_t axis = info__[4].As<Napi::Number>().Int64Value();
  int64_t quant_min = info__[5].As<Napi::Number>().Int64Value();
  int64_t quant_max = info__[6].As<Napi::Number>().Int64Value();
  double grad_factor = info__[7].As<Napi::Number>().DoubleValue();
  auto output__ = torch::_fake_quantize_learnable_per_channel_affine_out(*out, *self, *scale, *zero_point, axis, quant_min, quant_max, grad_factor);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::Array atg__fake_quantize_learnable_per_channel_affine_backward(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *grad = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *scale = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *zero_point = info__[3].As<Napi::External<torch::Tensor>>().Data();
  int64_t axis = info__[4].As<Napi::Number>().Int64Value();
  int64_t quant_min = info__[5].As<Napi::Number>().Int64Value();
  int64_t quant_max = info__[6].As<Napi::Number>().Int64Value();
  double grad_factor = info__[7].As<Napi::Number>().DoubleValue();
  auto output__ = torch::_fake_quantize_learnable_per_channel_affine_backward(*grad, *self, *scale, *zero_point, axis, quant_min, quant_max, grad_factor);
  Napi::Array output__array__ = Napi::Array::New(env__, 3);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  output__array__[2u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<2>(output__)));
  return output__array__;
}

Napi::External<torch::Tensor> atg_fused_moving_avg_obs_fake_quant(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *observer_on = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *fake_quant_on = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *running_min = info__[3].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *running_max = info__[4].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *scale = info__[5].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *zero_point = info__[6].As<Napi::External<torch::Tensor>>().Data();
  double averaging_const = info__[7].As<Napi::Number>().DoubleValue();
  int64_t quant_min = info__[8].As<Napi::Number>().Int64Value();
  int64_t quant_max = info__[9].As<Napi::Number>().Int64Value();
  int64_t ch_axis = info__[10].As<Napi::Number>().Int64Value();
  bool per_row_fake_quant = info__[11].As<Napi::Boolean>().Value();
  bool symmetric_quant = info__[12].As<Napi::Boolean>().Value();
  auto output__ = torch::fused_moving_avg_obs_fake_quant(*self, *observer_on, *fake_quant_on, *running_min, *running_max, *scale, *zero_point, averaging_const, quant_min, quant_max, ch_axis, per_row_fake_quant, symmetric_quant);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::Array atg__fused_moving_avg_obs_fq_helper(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *observer_on = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *fake_quant_on = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *running_min = info__[3].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *running_max = info__[4].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *scale = info__[5].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *zero_point = info__[6].As<Napi::External<torch::Tensor>>().Data();
  double averaging_const = info__[7].As<Napi::Number>().DoubleValue();
  int64_t quant_min = info__[8].As<Napi::Number>().Int64Value();
  int64_t quant_max = info__[9].As<Napi::Number>().Int64Value();
  int64_t ch_axis = info__[10].As<Napi::Number>().Int64Value();
  bool per_row_fake_quant = info__[11].As<Napi::Boolean>().Value();
  bool symmetric_quant = info__[12].As<Napi::Boolean>().Value();
  auto output__ = torch::_fused_moving_avg_obs_fq_helper(*self, *observer_on, *fake_quant_on, *running_min, *running_max, *scale, *zero_point, averaging_const, quant_min, quant_max, ch_axis, per_row_fake_quant, symmetric_quant);
  Napi::Array output__array__ = Napi::Array::New(env__, 2);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  return output__array__;
}

Napi::Array atg__fused_moving_avg_obs_fq_helper_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out0 = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *out1 = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *observer_on = info__[3].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *fake_quant_on = info__[4].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *running_min = info__[5].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *running_max = info__[6].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *scale = info__[7].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *zero_point = info__[8].As<Napi::External<torch::Tensor>>().Data();
  double averaging_const = info__[9].As<Napi::Number>().DoubleValue();
  int64_t quant_min = info__[10].As<Napi::Number>().Int64Value();
  int64_t quant_max = info__[11].As<Napi::Number>().Int64Value();
  int64_t ch_axis = info__[12].As<Napi::Number>().Int64Value();
  bool per_row_fake_quant = info__[13].As<Napi::Boolean>().Value();
  bool symmetric_quant = info__[14].As<Napi::Boolean>().Value();
  auto output__ = torch::_fused_moving_avg_obs_fq_helper_out(*out0, *out1, *self, *observer_on, *fake_quant_on, *running_min, *running_max, *scale, *zero_point, averaging_const, quant_min, quant_max, ch_axis, per_row_fake_quant, symmetric_quant);
  Napi::Array output__array__ = Napi::Array::New(env__, 2);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  return output__array__;
}

Napi::External<torch::Tensor> atg__saturate_weight_to_fp16(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *weight = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::_saturate_weight_to_fp16(*weight);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::Array atg_choose_qparams_optimized(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *input = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t numel = info__[1].As<Napi::Number>().Int64Value();
  int64_t n_bins = info__[2].As<Napi::Number>().Int64Value();
  double ratio = info__[3].As<Napi::Number>().DoubleValue();
  int64_t bit_width = info__[4].As<Napi::Number>().Int64Value();
  auto output__ = torch::choose_qparams_optimized(*input, numel, n_bins, ratio, bit_width);
  Napi::Array output__array__ = Napi::Array::New(env__, 2);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  return output__array__;
}

Napi::External<torch::Tensor> atg__autocast_to_reduced_precision(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  bool cuda_enabled = info__[1].As<Napi::Boolean>().Value();
  bool cpu_enabled = info__[2].As<Napi::Boolean>().Value();
  int cuda_dtype = info__[3].As<Napi::Number>().Int32Value();
  int cpu_dtype = info__[4].As<Napi::Number>().Int32Value();
  auto output__ = self->_autocast_to_reduced_precision(cuda_enabled, cpu_enabled, at::ScalarType(cuda_dtype), at::ScalarType(cpu_dtype));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__autocast_to_full_precision(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  bool cuda_enabled = info__[1].As<Napi::Boolean>().Value();
  bool cpu_enabled = info__[2].As<Napi::Boolean>().Value();
  auto output__ = self->_autocast_to_full_precision(cuda_enabled, cpu_enabled);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__to_copy(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Object options_obj__ = info__[1].As<Napi::Object>();
  int options_device = options_obj__.Get("device").ToNumber().Int32Value();
  int options_kind = options_obj__.Get("dtype").ToNumber().Int32Value();
  bool non_blocking = info__[2].As<Napi::Boolean>().Value();
  int memory_format = info__[3].As<Napi::Number>().Int32Value();
  auto output__ = torch::_to_copy(*self, at::device(device_of_int(options_device)).dtype(at::ScalarType(options_kind)), non_blocking, (at::MemoryFormat)memory_format);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__to_copy_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  bool non_blocking = info__[2].As<Napi::Boolean>().Value();
  int memory_format = info__[3].As<Napi::Number>().Int32Value();
  auto output__ = torch::_to_copy_out(*out, *self, non_blocking, (at::MemoryFormat)memory_format);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_to(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Object options_obj__ = info__[1].As<Napi::Object>();
  int options_device = options_obj__.Get("device").ToNumber().Int32Value();
  int options_kind = options_obj__.Get("dtype").ToNumber().Int32Value();
  bool non_blocking = info__[2].As<Napi::Boolean>().Value();
  bool copy = info__[3].As<Napi::Boolean>().Value();
  int memory_format = info__[4].As<Napi::Number>().Int32Value();
  auto output__ = self->to(at::device(device_of_int(options_device)).dtype(at::ScalarType(options_kind)), non_blocking, copy, (at::MemoryFormat)memory_format);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_to_dtype(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int dtype = info__[1].As<Napi::Number>().Int32Value();
  bool non_blocking = info__[2].As<Napi::Boolean>().Value();
  bool copy = info__[3].As<Napi::Boolean>().Value();
  int memory_format = info__[4].As<Napi::Number>().Int32Value();
  auto output__ = self->to(at::ScalarType(dtype), non_blocking, copy, (at::MemoryFormat)memory_format);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_to_other(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[1].As<Napi::External<torch::Tensor>>().Data();
  bool non_blocking = info__[2].As<Napi::Boolean>().Value();
  bool copy = info__[3].As<Napi::Boolean>().Value();
  int memory_format = info__[4].As<Napi::Number>().Int32Value();
  auto output__ = self->to(*other, non_blocking, copy, (at::MemoryFormat)memory_format);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_to_device(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int device = info__[1].As<Napi::Number>().Int32Value();
  int dtype = info__[2].As<Napi::Number>().Int32Value();
  bool non_blocking = info__[3].As<Napi::Boolean>().Value();
  bool copy = info__[4].As<Napi::Boolean>().Value();
  int memory_format = info__[5].As<Napi::Number>().Int32Value();
  auto output__ = self->to(device_of_int(device), at::ScalarType(dtype), non_blocking, copy, (at::MemoryFormat)memory_format);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_cartesian_prod(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  Napi::Array tensors_array__ = info__[0].As<Napi::Array>();
  int tensors_len = tensors_array__.Length();
  torch::Tensor **tensors_data = new torch::Tensor *[tensors_len];
  for (int i = 0; i < tensors_len; ++i)
    tensors_data[i] = tensors_array__.Get(i).As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::cartesian_prod(of_carray_tensor(tensors_data, tensors_len));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_combinations(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t r = info__[1].As<Napi::Number>().Int64Value();
  bool with_replacement = info__[2].As<Napi::Boolean>().Value();
  auto output__ = torch::combinations(*self, r, with_replacement);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::Boolean atg_can_cast(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  int from = info__[0].As<Napi::Number>().Int32Value();
  int to = info__[1].As<Napi::Number>().Int32Value();
  auto output__ = torch::can_cast(at::ScalarType(from), at::ScalarType(to));
  return Napi::Boolean::New(env__, output__);
}

Napi::Array atg__lstm_mps(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *input = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array hx_array__ = info__[1].As<Napi::Array>();
  int hx_len = hx_array__.Length();
  torch::Tensor **hx_data = new torch::Tensor *[hx_len];
  for (int i = 0; i < hx_len; ++i)
    hx_data[i] = hx_array__.Get(i).As<Napi::External<torch::Tensor>>().Data();
  Napi::Array params_array__ = info__[2].As<Napi::Array>();
  int params_len = params_array__.Length();
  torch::Tensor **params_data = new torch::Tensor *[params_len];
  for (int i = 0; i < params_len; ++i)
    params_data[i] = params_array__.Get(i).As<Napi::External<torch::Tensor>>().Data();
  bool has_biases = info__[3].As<Napi::Boolean>().Value();
  int64_t num_layers = info__[4].As<Napi::Number>().Int64Value();
  double dropout = info__[5].As<Napi::Number>().DoubleValue();
  bool train = info__[6].As<Napi::Boolean>().Value();
  bool bidirectional = info__[7].As<Napi::Boolean>().Value();
  bool batch_first = info__[8].As<Napi::Boolean>().Value();
  auto output__ = torch::_lstm_mps(*input, of_carray_tensor(hx_data, hx_len), of_carray_tensor(params_data, params_len), has_biases, num_layers, dropout, train, bidirectional, batch_first);
  Napi::Array output__array__ = Napi::Array::New(env__, 6);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  output__array__[2u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<2>(output__)));
  output__array__[3u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<3>(output__)));
  output__array__[4u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<4>(output__)));
  output__array__[5u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<5>(output__)));
  return output__array__;
}

Napi::Array atg__lstm_mps_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out0 = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *out1 = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *out2 = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *out3 = info__[3].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *out4 = info__[4].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *out5 = info__[5].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *input = info__[6].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array hx_array__ = info__[7].As<Napi::Array>();
  int hx_len = hx_array__.Length();
  torch::Tensor **hx_data = new torch::Tensor *[hx_len];
  for (int i = 0; i < hx_len; ++i)
    hx_data[i] = hx_array__.Get(i).As<Napi::External<torch::Tensor>>().Data();
  Napi::Array params_array__ = info__[8].As<Napi::Array>();
  int params_len = params_array__.Length();
  torch::Tensor **params_data = new torch::Tensor *[params_len];
  for (int i = 0; i < params_len; ++i)
    params_data[i] = params_array__.Get(i).As<Napi::External<torch::Tensor>>().Data();
  bool has_biases = info__[9].As<Napi::Boolean>().Value();
  int64_t num_layers = info__[10].As<Napi::Number>().Int64Value();
  double dropout = info__[11].As<Napi::Number>().DoubleValue();
  bool train = info__[12].As<Napi::Boolean>().Value();
  bool bidirectional = info__[13].As<Napi::Boolean>().Value();
  bool batch_first = info__[14].As<Napi::Boolean>().Value();
  auto output__ = torch::_lstm_mps_out(*out0, *out1, *out2, *out3, *out4, *out5, *input, of_carray_tensor(hx_data, hx_len), of_carray_tensor(params_data, params_len), has_biases, num_layers, dropout, train, bidirectional, batch_first);
  Napi::Array output__array__ = Napi::Array::New(env__, 6);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  output__array__[2u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<2>(output__)));
  output__array__[3u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<3>(output__)));
  output__array__[4u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<4>(output__)));
  output__array__[5u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<5>(output__)));
  return output__array__;
}

Napi::Array atg_lstm(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *input = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array hx_array__ = info__[1].As<Napi::Array>();
  int hx_len = hx_array__.Length();
  torch::Tensor **hx_data = new torch::Tensor *[hx_len];
  for (int i = 0; i < hx_len; ++i)
    hx_data[i] = hx_array__.Get(i).As<Napi::External<torch::Tensor>>().Data();
  Napi::Array params_array__ = info__[2].As<Napi::Array>();
  int params_len = params_array__.Length();
  torch::Tensor **params_data = new torch::Tensor *[params_len];
  for (int i = 0; i < params_len; ++i)
    params_data[i] = params_array__.Get(i).As<Napi::External<torch::Tensor>>().Data();
  bool has_biases = info__[3].As<Napi::Boolean>().Value();
  int64_t num_layers = info__[4].As<Napi::Number>().Int64Value();
  double dropout = info__[5].As<Napi::Number>().DoubleValue();
  bool train = info__[6].As<Napi::Boolean>().Value();
  bool bidirectional = info__[7].As<Napi::Boolean>().Value();
  bool batch_first = info__[8].As<Napi::Boolean>().Value();
  auto output__ = torch::lstm(*input, of_carray_tensor(hx_data, hx_len), of_carray_tensor(params_data, params_len), has_biases, num_layers, dropout, train, bidirectional, batch_first);
  Napi::Array output__array__ = Napi::Array::New(env__, 3);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  output__array__[2u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<2>(output__)));
  return output__array__;
}

Napi::Array atg_lstm_data(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *data = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *batch_sizes = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array hx_array__ = info__[2].As<Napi::Array>();
  int hx_len = hx_array__.Length();
  torch::Tensor **hx_data = new torch::Tensor *[hx_len];
  for (int i = 0; i < hx_len; ++i)
    hx_data[i] = hx_array__.Get(i).As<Napi::External<torch::Tensor>>().Data();
  Napi::Array params_array__ = info__[3].As<Napi::Array>();
  int params_len = params_array__.Length();
  torch::Tensor **params_data = new torch::Tensor *[params_len];
  for (int i = 0; i < params_len; ++i)
    params_data[i] = params_array__.Get(i).As<Napi::External<torch::Tensor>>().Data();
  bool has_biases = info__[4].As<Napi::Boolean>().Value();
  int64_t num_layers = info__[5].As<Napi::Number>().Int64Value();
  double dropout = info__[6].As<Napi::Number>().DoubleValue();
  bool train = info__[7].As<Napi::Boolean>().Value();
  bool bidirectional = info__[8].As<Napi::Boolean>().Value();
  auto output__ = torch::lstm(*data, *batch_sizes, of_carray_tensor(hx_data, hx_len), of_carray_tensor(params_data, params_len), has_biases, num_layers, dropout, train, bidirectional);
  Napi::Array output__array__ = Napi::Array::New(env__, 3);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  output__array__[2u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<2>(output__)));
  return output__array__;
}

Napi::Array atg_gru(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *input = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *hx = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array params_array__ = info__[2].As<Napi::Array>();
  int params_len = params_array__.Length();
  torch::Tensor **params_data = new torch::Tensor *[params_len];
  for (int i = 0; i < params_len; ++i)
    params_data[i] = params_array__.Get(i).As<Napi::External<torch::Tensor>>().Data();
  bool has_biases = info__[3].As<Napi::Boolean>().Value();
  int64_t num_layers = info__[4].As<Napi::Number>().Int64Value();
  double dropout = info__[5].As<Napi::Number>().DoubleValue();
  bool train = info__[6].As<Napi::Boolean>().Value();
  bool bidirectional = info__[7].As<Napi::Boolean>().Value();
  bool batch_first = info__[8].As<Napi::Boolean>().Value();
  auto output__ = torch::gru(*input, *hx, of_carray_tensor(params_data, params_len), has_biases, num_layers, dropout, train, bidirectional, batch_first);
  Napi::Array output__array__ = Napi::Array::New(env__, 2);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  return output__array__;
}

Napi::Array atg_gru_data(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *data = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *batch_sizes = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *hx = info__[2].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array params_array__ = info__[3].As<Napi::Array>();
  int params_len = params_array__.Length();
  torch::Tensor **params_data = new torch::Tensor *[params_len];
  for (int i = 0; i < params_len; ++i)
    params_data[i] = params_array__.Get(i).As<Napi::External<torch::Tensor>>().Data();
  bool has_biases = info__[4].As<Napi::Boolean>().Value();
  int64_t num_layers = info__[5].As<Napi::Number>().Int64Value();
  double dropout = info__[6].As<Napi::Number>().DoubleValue();
  bool train = info__[7].As<Napi::Boolean>().Value();
  bool bidirectional = info__[8].As<Napi::Boolean>().Value();
  auto output__ = torch::gru(*data, *batch_sizes, *hx, of_carray_tensor(params_data, params_len), has_biases, num_layers, dropout, train, bidirectional);
  Napi::Array output__array__ = Napi::Array::New(env__, 2);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  return output__array__;
}

Napi::Array atg_rnn_tanh(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *input = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *hx = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array params_array__ = info__[2].As<Napi::Array>();
  int params_len = params_array__.Length();
  torch::Tensor **params_data = new torch::Tensor *[params_len];
  for (int i = 0; i < params_len; ++i)
    params_data[i] = params_array__.Get(i).As<Napi::External<torch::Tensor>>().Data();
  bool has_biases = info__[3].As<Napi::Boolean>().Value();
  int64_t num_layers = info__[4].As<Napi::Number>().Int64Value();
  double dropout = info__[5].As<Napi::Number>().DoubleValue();
  bool train = info__[6].As<Napi::Boolean>().Value();
  bool bidirectional = info__[7].As<Napi::Boolean>().Value();
  bool batch_first = info__[8].As<Napi::Boolean>().Value();
  auto output__ = torch::rnn_tanh(*input, *hx, of_carray_tensor(params_data, params_len), has_biases, num_layers, dropout, train, bidirectional, batch_first);
  Napi::Array output__array__ = Napi::Array::New(env__, 2);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  return output__array__;
}

Napi::Array atg_rnn_tanh_data(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *data = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *batch_sizes = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *hx = info__[2].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array params_array__ = info__[3].As<Napi::Array>();
  int params_len = params_array__.Length();
  torch::Tensor **params_data = new torch::Tensor *[params_len];
  for (int i = 0; i < params_len; ++i)
    params_data[i] = params_array__.Get(i).As<Napi::External<torch::Tensor>>().Data();
  bool has_biases = info__[4].As<Napi::Boolean>().Value();
  int64_t num_layers = info__[5].As<Napi::Number>().Int64Value();
  double dropout = info__[6].As<Napi::Number>().DoubleValue();
  bool train = info__[7].As<Napi::Boolean>().Value();
  bool bidirectional = info__[8].As<Napi::Boolean>().Value();
  auto output__ = torch::rnn_tanh(*data, *batch_sizes, *hx, of_carray_tensor(params_data, params_len), has_biases, num_layers, dropout, train, bidirectional);
  Napi::Array output__array__ = Napi::Array::New(env__, 2);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  return output__array__;
}

Napi::Array atg_rnn_relu(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *input = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *hx = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array params_array__ = info__[2].As<Napi::Array>();
  int params_len = params_array__.Length();
  torch::Tensor **params_data = new torch::Tensor *[params_len];
  for (int i = 0; i < params_len; ++i)
    params_data[i] = params_array__.Get(i).As<Napi::External<torch::Tensor>>().Data();
  bool has_biases = info__[3].As<Napi::Boolean>().Value();
  int64_t num_layers = info__[4].As<Napi::Number>().Int64Value();
  double dropout = info__[5].As<Napi::Number>().DoubleValue();
  bool train = info__[6].As<Napi::Boolean>().Value();
  bool bidirectional = info__[7].As<Napi::Boolean>().Value();
  bool batch_first = info__[8].As<Napi::Boolean>().Value();
  auto output__ = torch::rnn_relu(*input, *hx, of_carray_tensor(params_data, params_len), has_biases, num_layers, dropout, train, bidirectional, batch_first);
  Napi::Array output__array__ = Napi::Array::New(env__, 2);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  return output__array__;
}

Napi::Array atg_rnn_relu_data(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *data = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *batch_sizes = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *hx = info__[2].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array params_array__ = info__[3].As<Napi::Array>();
  int params_len = params_array__.Length();
  torch::Tensor **params_data = new torch::Tensor *[params_len];
  for (int i = 0; i < params_len; ++i)
    params_data[i] = params_array__.Get(i).As<Napi::External<torch::Tensor>>().Data();
  bool has_biases = info__[4].As<Napi::Boolean>().Value();
  int64_t num_layers = info__[5].As<Napi::Number>().Int64Value();
  double dropout = info__[6].As<Napi::Number>().DoubleValue();
  bool train = info__[7].As<Napi::Boolean>().Value();
  bool bidirectional = info__[8].As<Napi::Boolean>().Value();
  auto output__ = torch::rnn_relu(*data, *batch_sizes, *hx, of_carray_tensor(params_data, params_len), has_biases, num_layers, dropout, train, bidirectional);
  Napi::Array output__array__ = Napi::Array::New(env__, 2);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  return output__array__;
}

Napi::Array atg_lstm_cell(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *input = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array hx_array__ = info__[1].As<Napi::Array>();
  int hx_len = hx_array__.Length();
  torch::Tensor **hx_data = new torch::Tensor *[hx_len];
  for (int i = 0; i < hx_len; ++i)
    hx_data[i] = hx_array__.Get(i).As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *w_ih = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *w_hh = info__[3].As<Napi::External<torch::Tensor>>().Data();
  bool b_ih_null = info__[4].IsUndefined();
  torch::Tensor *b_ih_v = b_ih_null ? nullptr : info__[4].As<Napi::External<torch::Tensor>>().Data();
  bool b_hh_null = info__[5].IsUndefined();
  torch::Tensor *b_hh_v = b_hh_null ? nullptr : info__[5].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::lstm_cell(*input, of_carray_tensor(hx_data, hx_len), *w_ih, *w_hh, (b_ih_null ? *b_ih_v : torch::Tensor()), (b_hh_null ? *b_hh_v : torch::Tensor()));
  Napi::Array output__array__ = Napi::Array::New(env__, 2);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  return output__array__;
}

Napi::External<torch::Tensor> atg_gru_cell(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *input = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *hx = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *w_ih = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *w_hh = info__[3].As<Napi::External<torch::Tensor>>().Data();
  bool b_ih_null = info__[4].IsUndefined();
  torch::Tensor *b_ih_v = b_ih_null ? nullptr : info__[4].As<Napi::External<torch::Tensor>>().Data();
  bool b_hh_null = info__[5].IsUndefined();
  torch::Tensor *b_hh_v = b_hh_null ? nullptr : info__[5].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::gru_cell(*input, *hx, *w_ih, *w_hh, (b_ih_null ? *b_ih_v : torch::Tensor()), (b_hh_null ? *b_hh_v : torch::Tensor()));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_rnn_tanh_cell(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *input = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *hx = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *w_ih = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *w_hh = info__[3].As<Napi::External<torch::Tensor>>().Data();
  bool b_ih_null = info__[4].IsUndefined();
  torch::Tensor *b_ih_v = b_ih_null ? nullptr : info__[4].As<Napi::External<torch::Tensor>>().Data();
  bool b_hh_null = info__[5].IsUndefined();
  torch::Tensor *b_hh_v = b_hh_null ? nullptr : info__[5].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::rnn_tanh_cell(*input, *hx, *w_ih, *w_hh, (b_ih_null ? *b_ih_v : torch::Tensor()), (b_hh_null ? *b_hh_v : torch::Tensor()));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_rnn_relu_cell(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *input = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *hx = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *w_ih = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *w_hh = info__[3].As<Napi::External<torch::Tensor>>().Data();
  bool b_ih_null = info__[4].IsUndefined();
  torch::Tensor *b_ih_v = b_ih_null ? nullptr : info__[4].As<Napi::External<torch::Tensor>>().Data();
  bool b_hh_null = info__[5].IsUndefined();
  torch::Tensor *b_hh_v = b_hh_null ? nullptr : info__[5].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::rnn_relu_cell(*input, *hx, *w_ih, *w_hh, (b_ih_null ? *b_ih_v : torch::Tensor()), (b_hh_null ? *b_hh_v : torch::Tensor()));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::Array atg_quantized_lstm_cell(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *input = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array hx_array__ = info__[1].As<Napi::Array>();
  int hx_len = hx_array__.Length();
  torch::Tensor **hx_data = new torch::Tensor *[hx_len];
  for (int i = 0; i < hx_len; ++i)
    hx_data[i] = hx_array__.Get(i).As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *w_ih = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *w_hh = info__[3].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *b_ih = info__[4].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *b_hh = info__[5].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *packed_ih = info__[6].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *packed_hh = info__[7].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *col_offsets_ih = info__[8].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *col_offsets_hh = info__[9].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *scale_ih = info__[10].As<Napi::External<torch::Scalar>>().Data();
  torch::Scalar *scale_hh = info__[11].As<Napi::External<torch::Scalar>>().Data();
  torch::Scalar *zero_point_ih = info__[12].As<Napi::External<torch::Scalar>>().Data();
  torch::Scalar *zero_point_hh = info__[13].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::quantized_lstm_cell(*input, of_carray_tensor(hx_data, hx_len), *w_ih, *w_hh, *b_ih, *b_hh, *packed_ih, *packed_hh, *col_offsets_ih, *col_offsets_hh, *scale_ih, *scale_hh, *zero_point_ih, *zero_point_hh);
  Napi::Array output__array__ = Napi::Array::New(env__, 2);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  return output__array__;
}

Napi::External<torch::Tensor> atg_quantized_gru_cell(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *input = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *hx = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *w_ih = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *w_hh = info__[3].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *b_ih = info__[4].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *b_hh = info__[5].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *packed_ih = info__[6].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *packed_hh = info__[7].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *col_offsets_ih = info__[8].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *col_offsets_hh = info__[9].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *scale_ih = info__[10].As<Napi::External<torch::Scalar>>().Data();
  torch::Scalar *scale_hh = info__[11].As<Napi::External<torch::Scalar>>().Data();
  torch::Scalar *zero_point_ih = info__[12].As<Napi::External<torch::Scalar>>().Data();
  torch::Scalar *zero_point_hh = info__[13].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::quantized_gru_cell(*input, *hx, *w_ih, *w_hh, *b_ih, *b_hh, *packed_ih, *packed_hh, *col_offsets_ih, *col_offsets_hh, *scale_ih, *scale_hh, *zero_point_ih, *zero_point_hh);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_quantized_rnn_relu_cell(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *input = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *hx = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *w_ih = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *w_hh = info__[3].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *b_ih = info__[4].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *b_hh = info__[5].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *packed_ih = info__[6].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *packed_hh = info__[7].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *col_offsets_ih = info__[8].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *col_offsets_hh = info__[9].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *scale_ih = info__[10].As<Napi::External<torch::Scalar>>().Data();
  torch::Scalar *scale_hh = info__[11].As<Napi::External<torch::Scalar>>().Data();
  torch::Scalar *zero_point_ih = info__[12].As<Napi::External<torch::Scalar>>().Data();
  torch::Scalar *zero_point_hh = info__[13].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::quantized_rnn_relu_cell(*input, *hx, *w_ih, *w_hh, *b_ih, *b_hh, *packed_ih, *packed_hh, *col_offsets_ih, *col_offsets_hh, *scale_ih, *scale_hh, *zero_point_ih, *zero_point_hh);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_quantized_rnn_tanh_cell(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *input = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *hx = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *w_ih = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *w_hh = info__[3].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *b_ih = info__[4].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *b_hh = info__[5].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *packed_ih = info__[6].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *packed_hh = info__[7].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *col_offsets_ih = info__[8].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *col_offsets_hh = info__[9].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *scale_ih = info__[10].As<Napi::External<torch::Scalar>>().Data();
  torch::Scalar *scale_hh = info__[11].As<Napi::External<torch::Scalar>>().Data();
  torch::Scalar *zero_point_ih = info__[12].As<Napi::External<torch::Scalar>>().Data();
  torch::Scalar *zero_point_hh = info__[13].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::quantized_rnn_tanh_cell(*input, *hx, *w_ih, *w_hh, *b_ih, *b_hh, *packed_ih, *packed_hh, *col_offsets_ih, *col_offsets_hh, *scale_ih, *scale_hh, *zero_point_ih, *zero_point_hh);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::Array atg__pack_padded_sequence(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *input = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *lengths = info__[1].As<Napi::External<torch::Tensor>>().Data();
  bool batch_first = info__[2].As<Napi::Boolean>().Value();
  auto output__ = torch::_pack_padded_sequence(*input, *lengths, batch_first);
  Napi::Array output__array__ = Napi::Array::New(env__, 2);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  return output__array__;
}

Napi::Array atg__pack_padded_sequence_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out0 = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *out1 = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *input = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *lengths = info__[3].As<Napi::External<torch::Tensor>>().Data();
  bool batch_first = info__[4].As<Napi::Boolean>().Value();
  auto output__ = torch::_pack_padded_sequence_out(*out0, *out1, *input, *lengths, batch_first);
  Napi::Array output__array__ = Napi::Array::New(env__, 2);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  return output__array__;
}

Napi::External<torch::Tensor> atg__pack_padded_sequence_backward(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *grad = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array input_size_array__ = info__[1].As<Napi::Array>();
  int input_size_len = input_size_array__.Length();
  int64_t *input_size_data = new int64_t[input_size_len];
  for (int i = 0; i < input_size_len; ++i)
    input_size_data[i] = input_size_array__.Get(i).ToNumber().Int64Value();
  torch::Tensor *batch_sizes = info__[2].As<Napi::External<torch::Tensor>>().Data();
  bool batch_first = info__[3].As<Napi::Boolean>().Value();
  auto output__ = torch::_pack_padded_sequence_backward(*grad, torch::IntArrayRef(input_size_data, input_size_len), *batch_sizes, batch_first);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::Array atg__pad_packed_sequence(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *data = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *batch_sizes = info__[1].As<Napi::External<torch::Tensor>>().Data();
  bool batch_first = info__[2].As<Napi::Boolean>().Value();
  torch::Scalar *padding_value = info__[3].As<Napi::External<torch::Scalar>>().Data();
  int64_t total_length = info__[4].As<Napi::Number>().Int64Value();
  auto output__ = torch::_pad_packed_sequence(*data, *batch_sizes, batch_first, *padding_value, total_length);
  Napi::Array output__array__ = Napi::Array::New(env__, 2);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  return output__array__;
}

Napi::External<torch::Tensor> atg_set_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = self->set_();
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_set_source_tensor_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *source = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = self->set_(*source);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_set_source_tensor_storage_offset_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *source = info__[1].As<Napi::External<torch::Tensor>>().Data();
  int64_t storage_offset = info__[2].As<Napi::Number>().Int64Value();
  Napi::Array size_array__ = info__[3].As<Napi::Array>();
  int size_len = size_array__.Length();
  int64_t *size_data = new int64_t[size_len];
  for (int i = 0; i < size_len; ++i)
    size_data[i] = size_array__.Get(i).ToNumber().Int64Value();
  Napi::Array stride_array__ = info__[4].As<Napi::Array>();
  int stride_len = stride_array__.Length();
  int64_t *stride_data = new int64_t[stride_len];
  for (int i = 0; i < stride_len; ++i)
    stride_data[i] = stride_array__.Get(i).ToNumber().Int64Value();
  auto output__ = self->set_(*source, storage_offset, torch::IntArrayRef(size_data, size_len), torch::IntArrayRef(stride_data, stride_len));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_lift(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::lift(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_lift_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::lift_out(*out, *self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_lift_fresh(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::lift_fresh(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_lift_fresh_copy(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::lift_fresh_copy(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_lift_fresh_copy_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::lift_fresh_copy_out(*out, *self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::Boolean atg_is_set_to(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *tensor = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = self->is_set_to(*tensor);
  return Napi::Boolean::New(env__, output__);
}

Napi::External<torch::Tensor> atg_masked_fill_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *mask = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *value = info__[2].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = self->masked_fill_(*mask, *value);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_masked_fill_tensor_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *mask = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *value = info__[2].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = self->masked_fill_(*mask, *value);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_masked_fill(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *mask = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *value = info__[2].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::masked_fill(*self, *mask, *value);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_masked_fill_tensor(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *mask = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *value = info__[2].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::masked_fill(*self, *mask, *value);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_masked_fill_scalar_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *mask = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *value = info__[3].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::masked_fill_out(*out, *self, *mask, *value);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_masked_fill_tensor_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *mask = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *value = info__[3].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::masked_fill_out(*out, *self, *mask, *value);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_masked_scatter_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *mask = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *source = info__[2].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = self->masked_scatter_(*mask, *source);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_masked_scatter(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *mask = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *source = info__[2].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::masked_scatter(*self, *mask, *source);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_masked_scatter_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *mask = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *source = info__[3].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::masked_scatter_out(*out, *self, *mask, *source);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__masked_softmax(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *mask = info__[1].As<Napi::External<torch::Tensor>>().Data();
  bool dim_null = info__[2].IsUndefined();
  int64_t dim_v = dim_null ? 0 : info__[2].As<Napi::Number>().Int64Value();
  bool mask_type_null = info__[3].IsUndefined();
  int64_t mask_type_v = mask_type_null ? 0 : info__[3].As<Napi::Number>().Int64Value();
  auto output__ = torch::_masked_softmax(*self, *mask, dim_null ? c10::nullopt : c10::optional<int64_t>(dim_v), mask_type_null ? c10::nullopt : c10::optional<int64_t>(mask_type_v));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__masked_softmax_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *mask = info__[2].As<Napi::External<torch::Tensor>>().Data();
  bool dim_null = info__[3].IsUndefined();
  int64_t dim_v = dim_null ? 0 : info__[3].As<Napi::Number>().Int64Value();
  bool mask_type_null = info__[4].IsUndefined();
  int64_t mask_type_v = mask_type_null ? 0 : info__[4].As<Napi::Number>().Int64Value();
  auto output__ = torch::_masked_softmax_out(*out, *self, *mask, dim_null ? c10::nullopt : c10::optional<int64_t>(dim_v), mask_type_null ? c10::nullopt : c10::optional<int64_t>(mask_type_v));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__masked_softmax_backward(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *grad_output = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *output = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *mask = info__[2].As<Napi::External<torch::Tensor>>().Data();
  bool dim_null = info__[3].IsUndefined();
  int64_t dim_v = dim_null ? 0 : info__[3].As<Napi::Number>().Int64Value();
  auto output__ = torch::_masked_softmax_backward(*grad_output, *output, *mask, dim_null ? c10::nullopt : c10::optional<int64_t>(dim_v));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__masked_softmax_backward_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *grad_output = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *output = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *mask = info__[3].As<Napi::External<torch::Tensor>>().Data();
  bool dim_null = info__[4].IsUndefined();
  int64_t dim_v = dim_null ? 0 : info__[4].As<Napi::Number>().Int64Value();
  auto output__ = torch::_masked_softmax_backward_out(*out, *grad_output, *output, *mask, dim_null ? c10::nullopt : c10::optional<int64_t>(dim_v));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_view(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array size_array__ = info__[1].As<Napi::Array>();
  int size_len = size_array__.Length();
  int64_t *size_data = new int64_t[size_len];
  for (int i = 0; i < size_len; ++i)
    size_data[i] = size_array__.Get(i).ToNumber().Int64Value();
  auto output__ = self->view(torch::IntArrayRef(size_data, size_len));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_view_dtype(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int dtype = info__[1].As<Napi::Number>().Int32Value();
  auto output__ = self->view(at::ScalarType(dtype));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_put_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *index = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *source = info__[2].As<Napi::External<torch::Tensor>>().Data();
  bool accumulate = info__[3].As<Napi::Boolean>().Value();
  auto output__ = self->put_(*index, *source, accumulate);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_put(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *index = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *source = info__[2].As<Napi::External<torch::Tensor>>().Data();
  bool accumulate = info__[3].As<Napi::Boolean>().Value();
  auto output__ = torch::put(*self, *index, *source, accumulate);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_put_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *index = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *source = info__[3].As<Napi::External<torch::Tensor>>().Data();
  bool accumulate = info__[4].As<Napi::Boolean>().Value();
  auto output__ = torch::put_out(*out, *self, *index, *source, accumulate);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_index_add(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t dim = info__[1].As<Napi::Number>().Int64Value();
  torch::Tensor *index = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *source = info__[3].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *alpha = info__[4].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::index_add(*self, dim, *index, *source, *alpha);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_index_add_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  int64_t dim = info__[2].As<Napi::Number>().Int64Value();
  torch::Tensor *index = info__[3].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *source = info__[4].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *alpha = info__[5].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::index_add_out(*out, *self, dim, *index, *source, *alpha);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_index_add_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t dim = info__[1].As<Napi::Number>().Int64Value();
  torch::Tensor *index = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *source = info__[3].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *alpha = info__[4].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = self->index_add_(dim, *index, *source, *alpha);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_index_reduce(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t dim = info__[1].As<Napi::Number>().Int64Value();
  torch::Tensor *index = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *source = info__[3].As<Napi::External<torch::Tensor>>().Data();
  Napi::String reduce_str__ = info__[4].As<Napi::String>();
  std::string reduce = reduce_str__.Utf8Value();
  bool include_self = info__[5].As<Napi::Boolean>().Value();
  auto output__ = torch::index_reduce(*self, dim, *index, *source, reduce, include_self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_index_reduce_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  int64_t dim = info__[2].As<Napi::Number>().Int64Value();
  torch::Tensor *index = info__[3].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *source = info__[4].As<Napi::External<torch::Tensor>>().Data();
  Napi::String reduce_str__ = info__[5].As<Napi::String>();
  std::string reduce = reduce_str__.Utf8Value();
  bool include_self = info__[6].As<Napi::Boolean>().Value();
  auto output__ = torch::index_reduce_out(*out, *self, dim, *index, *source, reduce, include_self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_index_reduce_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t dim = info__[1].As<Napi::Number>().Int64Value();
  torch::Tensor *index = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *source = info__[3].As<Napi::External<torch::Tensor>>().Data();
  Napi::String reduce_str__ = info__[4].As<Napi::String>();
  std::string reduce = reduce_str__.Utf8Value();
  bool include_self = info__[5].As<Napi::Boolean>().Value();
  auto output__ = self->index_reduce_(dim, *index, *source, reduce, include_self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_index_fill_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t dim = info__[1].As<Napi::Number>().Int64Value();
  torch::Tensor *index = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *value = info__[3].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = self->index_fill_(dim, *index, *value);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_index_fill_int_tensor_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t dim = info__[1].As<Napi::Number>().Int64Value();
  torch::Tensor *index = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *value = info__[3].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = self->index_fill_(dim, *index, *value);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_index_fill(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t dim = info__[1].As<Napi::Number>().Int64Value();
  torch::Tensor *index = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *value = info__[3].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::index_fill(*self, dim, *index, *value);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_index_fill_int_tensor(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t dim = info__[1].As<Napi::Number>().Int64Value();
  torch::Tensor *index = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *value = info__[3].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::index_fill(*self, dim, *index, *value);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_index_fill_int_scalar_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  int64_t dim = info__[2].As<Napi::Number>().Int64Value();
  torch::Tensor *index = info__[3].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *value = info__[4].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::index_fill_out(*out, *self, dim, *index, *value);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_index_fill_int_tensor_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  int64_t dim = info__[2].As<Napi::Number>().Int64Value();
  torch::Tensor *index = info__[3].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *value = info__[4].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::index_fill_out(*out, *self, dim, *index, *value);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_scatter(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t dim = info__[1].As<Napi::Number>().Int64Value();
  torch::Tensor *index = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *src = info__[3].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::scatter(*self, dim, *index, *src);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_scatter_value(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t dim = info__[1].As<Napi::Number>().Int64Value();
  torch::Tensor *index = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *value = info__[3].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::scatter(*self, dim, *index, *value);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_scatter_reduce(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t dim = info__[1].As<Napi::Number>().Int64Value();
  torch::Tensor *index = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *src = info__[3].As<Napi::External<torch::Tensor>>().Data();
  Napi::String reduce_str__ = info__[4].As<Napi::String>();
  std::string reduce = reduce_str__.Utf8Value();
  bool include_self = info__[5].As<Napi::Boolean>().Value();
  auto output__ = torch::scatter_reduce(*self, dim, *index, *src, reduce, include_self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_scatter_value_reduce(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t dim = info__[1].As<Napi::Number>().Int64Value();
  torch::Tensor *index = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *value = info__[3].As<Napi::External<torch::Scalar>>().Data();
  Napi::String reduce_str__ = info__[4].As<Napi::String>();
  std::string reduce = reduce_str__.Utf8Value();
  auto output__ = torch::scatter(*self, dim, *index, *value, reduce);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_scatter_src_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  int64_t dim = info__[2].As<Napi::Number>().Int64Value();
  torch::Tensor *index = info__[3].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *src = info__[4].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::scatter_out(*out, *self, dim, *index, *src);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_scatter_value_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  int64_t dim = info__[2].As<Napi::Number>().Int64Value();
  torch::Tensor *index = info__[3].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *value = info__[4].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::scatter_out(*out, *self, dim, *index, *value);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_scatter_reduce_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  int64_t dim = info__[2].As<Napi::Number>().Int64Value();
  torch::Tensor *index = info__[3].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *src = info__[4].As<Napi::External<torch::Tensor>>().Data();
  Napi::String reduce_str__ = info__[5].As<Napi::String>();
  std::string reduce = reduce_str__.Utf8Value();
  auto output__ = torch::scatter_out(*out, *self, dim, *index, *src, reduce);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_scatter_value_reduce_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  int64_t dim = info__[2].As<Napi::Number>().Int64Value();
  torch::Tensor *index = info__[3].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *value = info__[4].As<Napi::External<torch::Scalar>>().Data();
  Napi::String reduce_str__ = info__[5].As<Napi::String>();
  std::string reduce = reduce_str__.Utf8Value();
  auto output__ = torch::scatter_out(*out, *self, dim, *index, *value, reduce);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_scatter_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t dim = info__[1].As<Napi::Number>().Int64Value();
  torch::Tensor *index = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *src = info__[3].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = self->scatter_(dim, *index, *src);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_scatter_value_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t dim = info__[1].As<Napi::Number>().Int64Value();
  torch::Tensor *index = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *value = info__[3].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = self->scatter_(dim, *index, *value);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_scatter_reduce_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t dim = info__[1].As<Napi::Number>().Int64Value();
  torch::Tensor *index = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *src = info__[3].As<Napi::External<torch::Tensor>>().Data();
  Napi::String reduce_str__ = info__[4].As<Napi::String>();
  std::string reduce = reduce_str__.Utf8Value();
  auto output__ = self->scatter_(dim, *index, *src, reduce);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_scatter_value_reduce_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t dim = info__[1].As<Napi::Number>().Int64Value();
  torch::Tensor *index = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *value = info__[3].As<Napi::External<torch::Scalar>>().Data();
  Napi::String reduce_str__ = info__[4].As<Napi::String>();
  std::string reduce = reduce_str__.Utf8Value();
  auto output__ = self->scatter_(dim, *index, *value, reduce);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_scatter_add(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t dim = info__[1].As<Napi::Number>().Int64Value();
  torch::Tensor *index = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *src = info__[3].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::scatter_add(*self, dim, *index, *src);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_scatter_add_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  int64_t dim = info__[2].As<Napi::Number>().Int64Value();
  torch::Tensor *index = info__[3].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *src = info__[4].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::scatter_add_out(*out, *self, dim, *index, *src);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_scatter_add_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t dim = info__[1].As<Napi::Number>().Int64Value();
  torch::Tensor *index = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *src = info__[3].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = self->scatter_add_(dim, *index, *src);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_scatter_reduce_two_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  int64_t dim = info__[2].As<Napi::Number>().Int64Value();
  torch::Tensor *index = info__[3].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *src = info__[4].As<Napi::External<torch::Tensor>>().Data();
  Napi::String reduce_str__ = info__[5].As<Napi::String>();
  std::string reduce = reduce_str__.Utf8Value();
  bool include_self = info__[6].As<Napi::Boolean>().Value();
  auto output__ = torch::scatter_reduce_out(*out, *self, dim, *index, *src, reduce, include_self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__scatter_reduce_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t dim = info__[1].As<Napi::Number>().Int64Value();
  torch::Tensor *index = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *src = info__[3].As<Napi::External<torch::Tensor>>().Data();
  Napi::String reduce_str__ = info__[4].As<Napi::String>();
  std::string reduce = reduce_str__.Utf8Value();
  bool include_self = info__[5].As<Napi::Boolean>().Value();
  auto output__ = self->scatter_reduce_(dim, *index, *src, reduce, include_self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_eq_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *other = info__[1].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = self->eq_(*other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_eq_tensor_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = self->eq_(*other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_bitwise_and(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *other = info__[1].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::bitwise_and(*self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_bitwise_and_scalar_tensor(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Scalar *self_scalar = info__[0].As<Napi::External<torch::Scalar>>().Data();
  torch::Tensor *other = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::bitwise_and(*self_scalar, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_bitwise_and_tensor(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::bitwise_and(*self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_bitwise_and_tensor_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[2].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::bitwise_and_out(*out, *self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_bitwise_and_scalar_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *other = info__[2].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::bitwise_and_out(*out, *self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_bitwise_and_scalar_tensor_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *self_scalar = info__[1].As<Napi::External<torch::Scalar>>().Data();
  torch::Tensor *other = info__[2].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::bitwise_and_out(*out, *self_scalar, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_bitwise_and_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *other = info__[1].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = self->bitwise_and_(*other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_bitwise_and_tensor_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = self->bitwise_and_(*other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg___and__(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *other = info__[1].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::__and__(*self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg___and__tensor_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::__and__(*self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg___iand__(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *other = info__[1].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = self->__iand__(*other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg___iand__tensor_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = self->__iand__(*other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_bitwise_or(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *other = info__[1].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::bitwise_or(*self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_bitwise_or_scalar_tensor(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Scalar *self_scalar = info__[0].As<Napi::External<torch::Scalar>>().Data();
  torch::Tensor *other = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::bitwise_or(*self_scalar, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_bitwise_or_tensor(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::bitwise_or(*self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_bitwise_or_tensor_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[2].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::bitwise_or_out(*out, *self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_bitwise_or_scalar_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *other = info__[2].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::bitwise_or_out(*out, *self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_bitwise_or_scalar_tensor_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *self_scalar = info__[1].As<Napi::External<torch::Scalar>>().Data();
  torch::Tensor *other = info__[2].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::bitwise_or_out(*out, *self_scalar, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_bitwise_or_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *other = info__[1].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = self->bitwise_or_(*other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_bitwise_or_tensor_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = self->bitwise_or_(*other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg___or__(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *other = info__[1].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::__or__(*self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg___or__tensor_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::__or__(*self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg___ior__(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *other = info__[1].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = self->__ior__(*other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg___ior__tensor_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = self->__ior__(*other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_bitwise_xor(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *other = info__[1].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::bitwise_xor(*self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_bitwise_xor_scalar_tensor(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Scalar *self_scalar = info__[0].As<Napi::External<torch::Scalar>>().Data();
  torch::Tensor *other = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::bitwise_xor(*self_scalar, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_bitwise_xor_tensor(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::bitwise_xor(*self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_bitwise_xor_tensor_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[2].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::bitwise_xor_out(*out, *self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_bitwise_xor_scalar_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *other = info__[2].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::bitwise_xor_out(*out, *self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_bitwise_xor_scalar_tensor_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *self_scalar = info__[1].As<Napi::External<torch::Scalar>>().Data();
  torch::Tensor *other = info__[2].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::bitwise_xor_out(*out, *self_scalar, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_bitwise_xor_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *other = info__[1].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = self->bitwise_xor_(*other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_bitwise_xor_tensor_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = self->bitwise_xor_(*other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg___xor__(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *other = info__[1].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::__xor__(*self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg___xor__tensor_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::__xor__(*self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg___ixor__(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *other = info__[1].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = self->__ixor__(*other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg___ixor__tensor_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = self->__ixor__(*other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg___lshift__(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *other = info__[1].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::__lshift__(*self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg___lshift__tensor_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::__lshift__(*self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg___lshift__scalar_out_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *other = info__[2].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::__lshift___out(*out, *self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg___lshift__tensor_out_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[2].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::__lshift___out(*out, *self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg___ilshift__(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *other = info__[1].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = self->__ilshift__(*other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg___ilshift__tensor_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = self->__ilshift__(*other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_bitwise_left_shift(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::bitwise_left_shift(*self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_bitwise_left_shift_tensor_scalar(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *other = info__[1].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::bitwise_left_shift(*self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_bitwise_left_shift_scalar_tensor(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Scalar *self_scalar = info__[0].As<Napi::External<torch::Scalar>>().Data();
  torch::Tensor *other = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::bitwise_left_shift(*self_scalar, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_bitwise_left_shift_tensor_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[2].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::bitwise_left_shift_out(*out, *self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_bitwise_left_shift_tensor_scalar_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *other = info__[2].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::bitwise_left_shift_out(*out, *self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_bitwise_left_shift_scalar_tensor_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *self_scalar = info__[1].As<Napi::External<torch::Scalar>>().Data();
  torch::Tensor *other = info__[2].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::bitwise_left_shift_out(*out, *self_scalar, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_bitwise_left_shift_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = self->bitwise_left_shift_(*other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_bitwise_left_shift_tensor_scalar_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *other = info__[1].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = self->bitwise_left_shift_(*other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg___rshift__(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *other = info__[1].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::__rshift__(*self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg___rshift__tensor_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::__rshift__(*self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg___rshift__scalar_out_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *other = info__[2].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::__rshift___out(*out, *self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg___rshift__tensor_out_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[2].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::__rshift___out(*out, *self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg___irshift__(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *other = info__[1].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = self->__irshift__(*other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg___irshift__tensor_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = self->__irshift__(*other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_bitwise_right_shift(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::bitwise_right_shift(*self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_bitwise_right_shift_tensor_scalar(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *other = info__[1].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::bitwise_right_shift(*self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_bitwise_right_shift_scalar_tensor(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Scalar *self_scalar = info__[0].As<Napi::External<torch::Scalar>>().Data();
  torch::Tensor *other = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::bitwise_right_shift(*self_scalar, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_bitwise_right_shift_tensor_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[2].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::bitwise_right_shift_out(*out, *self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_bitwise_right_shift_tensor_scalar_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *other = info__[2].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::bitwise_right_shift_out(*out, *self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_bitwise_right_shift_scalar_tensor_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *self_scalar = info__[1].As<Napi::External<torch::Scalar>>().Data();
  torch::Tensor *other = info__[2].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::bitwise_right_shift_out(*out, *self_scalar, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_bitwise_right_shift_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = self->bitwise_right_shift_(*other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_bitwise_right_shift_tensor_scalar_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *other = info__[1].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = self->bitwise_right_shift_(*other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_tril_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t diagonal = info__[1].As<Napi::Number>().Int64Value();
  auto output__ = self->tril_(diagonal);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_triu_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t diagonal = info__[1].As<Napi::Number>().Int64Value();
  auto output__ = self->triu_(diagonal);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_digamma_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = self->digamma_();
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_lerp_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *end = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *weight = info__[2].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = self->lerp_(*end, *weight);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_lerp_tensor_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *end = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *weight = info__[2].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = self->lerp_(*end, *weight);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_addbmm_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *batch1 = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *batch2 = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *beta = info__[3].As<Napi::External<torch::Scalar>>().Data();
  torch::Scalar *alpha = info__[4].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = self->addbmm_(*batch1, *batch2, *beta, *alpha);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_addbmm(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *batch1 = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *batch2 = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *beta = info__[3].As<Napi::External<torch::Scalar>>().Data();
  torch::Scalar *alpha = info__[4].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::addbmm(*self, *batch1, *batch2, *beta, *alpha);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_addbmm_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *batch1 = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *batch2 = info__[3].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *beta = info__[4].As<Napi::External<torch::Scalar>>().Data();
  torch::Scalar *alpha = info__[5].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::addbmm_out(*out, *self, *batch1, *batch2, *beta, *alpha);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_random_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = self->random_();
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_random_to_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t to = info__[1].As<Napi::Number>().Int64Value();
  auto output__ = self->random_(to);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_random_from_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t from = info__[1].As<Napi::Number>().Int64Value();
  bool to_null = info__[2].IsUndefined();
  int64_t to_v = to_null ? 0 : info__[2].As<Napi::Number>().Int64Value();
  auto output__ = self->random_(from, to_null ? c10::nullopt : c10::optional<int64_t>(to_v));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_uniform_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  double from = info__[1].As<Napi::Number>().DoubleValue();
  double to = info__[2].As<Napi::Number>().DoubleValue();
  auto output__ = self->uniform_(from, to);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_cauchy_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  double median = info__[1].As<Napi::Number>().DoubleValue();
  double sigma = info__[2].As<Napi::Number>().DoubleValue();
  auto output__ = self->cauchy_(median, sigma);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_log_normal_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  double mean = info__[1].As<Napi::Number>().DoubleValue();
  double std = info__[2].As<Napi::Number>().DoubleValue();
  auto output__ = self->log_normal_(mean, std);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_exponential_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  double lambd = info__[1].As<Napi::Number>().DoubleValue();
  auto output__ = self->exponential_(lambd);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_geometric_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  double p = info__[1].As<Napi::Number>().DoubleValue();
  auto output__ = self->geometric_(p);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_diag(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t diagonal = info__[1].As<Napi::Number>().Int64Value();
  auto output__ = torch::diag(*self, diagonal);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_diag_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  int64_t diagonal = info__[2].As<Napi::Number>().Int64Value();
  auto output__ = torch::diag_out(*out, *self, diagonal);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_cross(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[1].As<Napi::External<torch::Tensor>>().Data();
  bool dim_null = info__[2].IsUndefined();
  int64_t dim_v = dim_null ? 0 : info__[2].As<Napi::Number>().Int64Value();
  auto output__ = torch::cross(*self, *other, dim_null ? c10::nullopt : c10::optional<int64_t>(dim_v));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_cross_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[2].As<Napi::External<torch::Tensor>>().Data();
  bool dim_null = info__[3].IsUndefined();
  int64_t dim_v = dim_null ? 0 : info__[3].As<Napi::Number>().Int64Value();
  auto output__ = torch::cross_out(*out, *self, *other, dim_null ? c10::nullopt : c10::optional<int64_t>(dim_v));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_triu(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t diagonal = info__[1].As<Napi::Number>().Int64Value();
  auto output__ = torch::triu(*self, diagonal);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_triu_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  int64_t diagonal = info__[2].As<Napi::Number>().Int64Value();
  auto output__ = torch::triu_out(*out, *self, diagonal);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_tril(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t diagonal = info__[1].As<Napi::Number>().Int64Value();
  auto output__ = torch::tril(*self, diagonal);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_tril_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  int64_t diagonal = info__[2].As<Napi::Number>().Int64Value();
  auto output__ = torch::tril_out(*out, *self, diagonal);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_tril_indices(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  int64_t row = info__[0].As<Napi::Number>().Int64Value();
  int64_t col = info__[1].As<Napi::Number>().Int64Value();
  int64_t offset = info__[2].As<Napi::Number>().Int64Value();
  Napi::Object options_obj__ = info__[3].As<Napi::Object>();
  int options_device = options_obj__.Get("device").ToNumber().Int32Value();
  int options_kind = options_obj__.Get("dtype").ToNumber().Int32Value();
  auto output__ = torch::tril_indices(row, col, offset, at::device(device_of_int(options_device)).dtype(at::ScalarType(options_kind)));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_tril_indices_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t row = info__[1].As<Napi::Number>().Int64Value();
  int64_t col = info__[2].As<Napi::Number>().Int64Value();
  int64_t offset = info__[3].As<Napi::Number>().Int64Value();
  auto output__ = torch::tril_indices_out(*out, row, col, offset);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_triu_indices(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  int64_t row = info__[0].As<Napi::Number>().Int64Value();
  int64_t col = info__[1].As<Napi::Number>().Int64Value();
  int64_t offset = info__[2].As<Napi::Number>().Int64Value();
  Napi::Object options_obj__ = info__[3].As<Napi::Object>();
  int options_device = options_obj__.Get("device").ToNumber().Int32Value();
  int options_kind = options_obj__.Get("dtype").ToNumber().Int32Value();
  auto output__ = torch::triu_indices(row, col, offset, at::device(device_of_int(options_device)).dtype(at::ScalarType(options_kind)));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_triu_indices_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t row = info__[1].As<Napi::Number>().Int64Value();
  int64_t col = info__[2].As<Napi::Number>().Int64Value();
  int64_t offset = info__[3].As<Napi::Number>().Int64Value();
  auto output__ = torch::triu_indices_out(*out, row, col, offset);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_trace(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::trace(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_trace_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::trace_out(*out, *self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_trace_backward(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *grad = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array sizes_array__ = info__[1].As<Napi::Array>();
  int sizes_len = sizes_array__.Length();
  int64_t *sizes_data = new int64_t[sizes_len];
  for (int i = 0; i < sizes_len; ++i)
    sizes_data[i] = sizes_array__.Get(i).ToNumber().Int64Value();
  auto output__ = torch::trace_backward(*grad, torch::IntArrayRef(sizes_data, sizes_len));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_ne(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *other = info__[1].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::ne(*self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_ne_tensor(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::ne(*self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_ne_scalar_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *other = info__[2].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::ne_out(*out, *self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_ne_tensor_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[2].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::ne_out(*out, *self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_ne_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *other = info__[1].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = self->ne_(*other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_ne_tensor_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = self->ne_(*other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_not_equal(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *other = info__[1].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::not_equal(*self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_not_equal_tensor(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::not_equal(*self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_not_equal_scalar_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *other = info__[2].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::not_equal_out(*out, *self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_not_equal_tensor_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[2].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::not_equal_out(*out, *self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_not_equal_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *other = info__[1].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = self->not_equal_(*other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_not_equal_tensor_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = self->not_equal_(*other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_eq(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *other = info__[1].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::eq(*self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_eq_tensor(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::eq(*self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_eq_scalar_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *other = info__[2].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::eq_out(*out, *self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_eq_tensor_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[2].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::eq_out(*out, *self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_ge(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *other = info__[1].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::ge(*self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_ge_tensor(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::ge(*self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_ge_scalar_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *other = info__[2].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::ge_out(*out, *self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_ge_tensor_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[2].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::ge_out(*out, *self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_ge_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *other = info__[1].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = self->ge_(*other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_ge_tensor_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = self->ge_(*other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_greater_equal(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *other = info__[1].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::greater_equal(*self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_greater_equal_tensor(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::greater_equal(*self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_greater_equal_scalar_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *other = info__[2].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::greater_equal_out(*out, *self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_greater_equal_tensor_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[2].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::greater_equal_out(*out, *self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_greater_equal_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *other = info__[1].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = self->greater_equal_(*other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_greater_equal_tensor_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = self->greater_equal_(*other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_le(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *other = info__[1].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::le(*self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_le_tensor(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::le(*self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_le_scalar_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *other = info__[2].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::le_out(*out, *self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_le_tensor_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[2].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::le_out(*out, *self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_le_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *other = info__[1].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = self->le_(*other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_le_tensor_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = self->le_(*other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_less_equal(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *other = info__[1].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::less_equal(*self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_less_equal_tensor(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::less_equal(*self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_less_equal_scalar_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *other = info__[2].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::less_equal_out(*out, *self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_less_equal_tensor_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[2].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::less_equal_out(*out, *self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_less_equal_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *other = info__[1].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = self->less_equal_(*other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_less_equal_tensor_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = self->less_equal_(*other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_gt(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *other = info__[1].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::gt(*self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_gt_tensor(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::gt(*self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_gt_scalar_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *other = info__[2].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::gt_out(*out, *self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_gt_tensor_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[2].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::gt_out(*out, *self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_gt_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *other = info__[1].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = self->gt_(*other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_gt_tensor_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = self->gt_(*other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_greater(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *other = info__[1].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::greater(*self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_greater_tensor(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::greater(*self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_greater_scalar_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *other = info__[2].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::greater_out(*out, *self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_greater_tensor_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[2].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::greater_out(*out, *self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_greater_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *other = info__[1].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = self->greater_(*other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_greater_tensor_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = self->greater_(*other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_lt(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *other = info__[1].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::lt(*self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_lt_tensor(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::lt(*self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_lt_scalar_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *other = info__[2].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::lt_out(*out, *self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_lt_tensor_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[2].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::lt_out(*out, *self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_lt_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *other = info__[1].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = self->lt_(*other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_lt_tensor_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = self->lt_(*other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_less(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *other = info__[1].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::less(*self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_less_tensor(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::less(*self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_less_scalar_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *other = info__[2].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::less_out(*out, *self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_less_tensor_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[2].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::less_out(*out, *self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_less_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *other = info__[1].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = self->less_(*other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_less_tensor_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = self->less_(*other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_take(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *index = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::take(*self, *index);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_take_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *index = info__[2].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::take_out(*out, *self, *index);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_take_along_dim(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *indices = info__[1].As<Napi::External<torch::Tensor>>().Data();
  bool dim_null = info__[2].IsUndefined();
  int64_t dim_v = dim_null ? 0 : info__[2].As<Napi::Number>().Int64Value();
  auto output__ = torch::take_along_dim(*self, *indices, dim_null ? c10::nullopt : c10::optional<int64_t>(dim_v));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_take_along_dim_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *indices = info__[2].As<Napi::External<torch::Tensor>>().Data();
  bool dim_null = info__[3].IsUndefined();
  int64_t dim_v = dim_null ? 0 : info__[3].As<Napi::Number>().Int64Value();
  auto output__ = torch::take_along_dim_out(*out, *self, *indices, dim_null ? c10::nullopt : c10::optional<int64_t>(dim_v));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_index_select(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t dim = info__[1].As<Napi::Number>().Int64Value();
  torch::Tensor *index = info__[2].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::index_select(*self, dim, *index);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_index_select_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  int64_t dim = info__[2].As<Napi::Number>().Int64Value();
  torch::Tensor *index = info__[3].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::index_select_out(*out, *self, dim, *index);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_index_select_backward(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *grad = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array self_sizes_array__ = info__[1].As<Napi::Array>();
  int self_sizes_len = self_sizes_array__.Length();
  int64_t *self_sizes_data = new int64_t[self_sizes_len];
  for (int i = 0; i < self_sizes_len; ++i)
    self_sizes_data[i] = self_sizes_array__.Get(i).ToNumber().Int64Value();
  int64_t dim = info__[2].As<Napi::Number>().Int64Value();
  torch::Tensor *index = info__[3].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::index_select_backward(*grad, torch::IntArrayRef(self_sizes_data, self_sizes_len), dim, *index);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_masked_select(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *mask = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::masked_select(*self, *mask);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_masked_select_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *mask = info__[2].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::masked_select_out(*out, *self, *mask);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_masked_select_backward(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *grad = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *input = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *mask = info__[2].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::masked_select_backward(*grad, *input, *mask);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_nonzero(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::nonzero(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_nonzero_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::nonzero_out(*out, *self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_argwhere(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::argwhere(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_gather(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t dim = info__[1].As<Napi::Number>().Int64Value();
  torch::Tensor *index = info__[2].As<Napi::External<torch::Tensor>>().Data();
  bool sparse_grad = info__[3].As<Napi::Boolean>().Value();
  auto output__ = torch::gather(*self, dim, *index, sparse_grad);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_gather_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  int64_t dim = info__[2].As<Napi::Number>().Int64Value();
  torch::Tensor *index = info__[3].As<Napi::External<torch::Tensor>>().Data();
  bool sparse_grad = info__[4].As<Napi::Boolean>().Value();
  auto output__ = torch::gather_out(*out, *self, dim, *index, sparse_grad);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_gather_backward(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *grad = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  int64_t dim = info__[2].As<Napi::Number>().Int64Value();
  torch::Tensor *index = info__[3].As<Napi::External<torch::Tensor>>().Data();
  bool sparse_grad = info__[4].As<Napi::Boolean>().Value();
  auto output__ = torch::gather_backward(*grad, *self, dim, *index, sparse_grad);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__gather_sparse_backward(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t dim = info__[1].As<Napi::Number>().Int64Value();
  torch::Tensor *index = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *grad = info__[3].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::_gather_sparse_backward(*self, dim, *index, *grad);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_addcmul(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *tensor1 = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *tensor2 = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *value = info__[3].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::addcmul(*self, *tensor1, *tensor2, *value);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_addcmul_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *tensor1 = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *tensor2 = info__[3].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *value = info__[4].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::addcmul_out(*out, *self, *tensor1, *tensor2, *value);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_addcmul_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *tensor1 = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *tensor2 = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *value = info__[3].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = self->addcmul_(*tensor1, *tensor2, *value);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_addcdiv(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *tensor1 = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *tensor2 = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *value = info__[3].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::addcdiv(*self, *tensor1, *tensor2, *value);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_addcdiv_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *tensor1 = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *tensor2 = info__[3].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *value = info__[4].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::addcdiv_out(*out, *self, *tensor1, *tensor2, *value);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_addcdiv_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *tensor1 = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *tensor2 = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *value = info__[3].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = self->addcdiv_(*tensor1, *tensor2, *value);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_cross_entropy_loss(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *target = info__[1].As<Napi::External<torch::Tensor>>().Data();
  bool weight_null = info__[2].IsUndefined();
  torch::Tensor *weight_v = weight_null ? nullptr : info__[2].As<Napi::External<torch::Tensor>>().Data();
  int64_t reduction = info__[3].As<Napi::Number>().Int64Value();
  int64_t ignore_index = info__[4].As<Napi::Number>().Int64Value();
  double label_smoothing = info__[5].As<Napi::Number>().DoubleValue();
  auto output__ = torch::cross_entropy_loss(*self, *target, (weight_null ? *weight_v : torch::Tensor()), reduction, ignore_index, label_smoothing);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::Array atg_triangular_solve(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *A = info__[1].As<Napi::External<torch::Tensor>>().Data();
  bool upper = info__[2].As<Napi::Boolean>().Value();
  bool transpose = info__[3].As<Napi::Boolean>().Value();
  bool unitriangular = info__[4].As<Napi::Boolean>().Value();
  auto output__ = torch::triangular_solve(*self, *A, upper, transpose, unitriangular);
  Napi::Array output__array__ = Napi::Array::New(env__, 2);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  return output__array__;
}

Napi::Array atg_triangular_solve_x(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *X = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *M = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *A = info__[3].As<Napi::External<torch::Tensor>>().Data();
  bool upper = info__[4].As<Napi::Boolean>().Value();
  bool transpose = info__[5].As<Napi::Boolean>().Value();
  bool unitriangular = info__[6].As<Napi::Boolean>().Value();
  auto output__ = torch::triangular_solve_out(*X, *M, *self, *A, upper, transpose, unitriangular);
  Napi::Array output__array__ = Napi::Array::New(env__, 2);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  return output__array__;
}

void atg__linalg_check_errors(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *info = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::String api_name_str__ = info__[1].As<Napi::String>();
  std::string api_name = api_name_str__.Utf8Value();
  bool is_matrix = info__[2].As<Napi::Boolean>().Value();
  torch::_linalg_check_errors(*info, api_name, is_matrix);
}

Napi::External<torch::Tensor> atg_linalg_solve_triangular(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *B = info__[1].As<Napi::External<torch::Tensor>>().Data();
  bool upper = info__[2].As<Napi::Boolean>().Value();
  bool left = info__[3].As<Napi::Boolean>().Value();
  bool unitriangular = info__[4].As<Napi::Boolean>().Value();
  auto output__ = torch::linalg_solve_triangular(*self, *B, upper, left, unitriangular);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_linalg_solve_triangular_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *B = info__[2].As<Napi::External<torch::Tensor>>().Data();
  bool upper = info__[3].As<Napi::Boolean>().Value();
  bool left = info__[4].As<Napi::Boolean>().Value();
  bool unitriangular = info__[5].As<Napi::Boolean>().Value();
  auto output__ = torch::linalg_solve_triangular_out(*out, *self, *B, upper, left, unitriangular);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_linalg_vander(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *x = info__[0].As<Napi::External<torch::Tensor>>().Data();
  bool N_null = info__[1].IsUndefined();
  int64_t N_v = N_null ? 0 : info__[1].As<Napi::Number>().Int64Value();
  auto output__ = torch::linalg_vander(*x, N_null ? c10::nullopt : c10::optional<int64_t>(N_v));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::Array atg_svd(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  bool some = info__[1].As<Napi::Boolean>().Value();
  bool compute_uv = info__[2].As<Napi::Boolean>().Value();
  auto output__ = torch::svd(*self, some, compute_uv);
  Napi::Array output__array__ = Napi::Array::New(env__, 3);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  output__array__[2u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<2>(output__)));
  return output__array__;
}

Napi::Array atg_svd_u(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *U = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *S = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *V = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[3].As<Napi::External<torch::Tensor>>().Data();
  bool some = info__[4].As<Napi::Boolean>().Value();
  bool compute_uv = info__[5].As<Napi::Boolean>().Value();
  auto output__ = torch::svd_out(*U, *S, *V, *self, some, compute_uv);
  Napi::Array output__array__ = Napi::Array::New(env__, 3);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  output__array__[2u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<2>(output__)));
  return output__array__;
}

Napi::External<torch::Tensor> atg_swapaxes(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t axis0 = info__[1].As<Napi::Number>().Int64Value();
  int64_t axis1 = info__[2].As<Napi::Number>().Int64Value();
  auto output__ = torch::swapaxes(*self, axis0, axis1);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_swapaxes_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t axis0 = info__[1].As<Napi::Number>().Int64Value();
  int64_t axis1 = info__[2].As<Napi::Number>().Int64Value();
  auto output__ = self->swapaxes_(axis0, axis1);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_swapdims(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t dim0 = info__[1].As<Napi::Number>().Int64Value();
  int64_t dim1 = info__[2].As<Napi::Number>().Int64Value();
  auto output__ = torch::swapdims(*self, dim0, dim1);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_swapdims_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t dim0 = info__[1].As<Napi::Number>().Int64Value();
  int64_t dim1 = info__[2].As<Napi::Number>().Int64Value();
  auto output__ = self->swapdims_(dim0, dim1);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_cholesky(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  bool upper = info__[1].As<Napi::Boolean>().Value();
  auto output__ = torch::cholesky(*self, upper);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_cholesky_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  bool upper = info__[2].As<Napi::Boolean>().Value();
  auto output__ = torch::cholesky_out(*out, *self, upper);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_cholesky_solve(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *input2 = info__[1].As<Napi::External<torch::Tensor>>().Data();
  bool upper = info__[2].As<Napi::Boolean>().Value();
  auto output__ = torch::cholesky_solve(*self, *input2, upper);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_cholesky_solve_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *input2 = info__[2].As<Napi::External<torch::Tensor>>().Data();
  bool upper = info__[3].As<Napi::Boolean>().Value();
  auto output__ = torch::cholesky_solve_out(*out, *self, *input2, upper);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__cholesky_solve_helper(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *A = info__[1].As<Napi::External<torch::Tensor>>().Data();
  bool upper = info__[2].As<Napi::Boolean>().Value();
  auto output__ = torch::_cholesky_solve_helper(*self, *A, upper);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__cholesky_solve_helper_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *A = info__[2].As<Napi::External<torch::Tensor>>().Data();
  bool upper = info__[3].As<Napi::Boolean>().Value();
  auto output__ = torch::_cholesky_solve_helper_out(*out, *self, *A, upper);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_cholesky_inverse(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  bool upper = info__[1].As<Napi::Boolean>().Value();
  auto output__ = torch::cholesky_inverse(*self, upper);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_cholesky_inverse_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  bool upper = info__[2].As<Napi::Boolean>().Value();
  auto output__ = torch::cholesky_inverse_out(*out, *self, upper);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::Array atg_qr(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  bool some = info__[1].As<Napi::Boolean>().Value();
  auto output__ = torch::qr(*self, some);
  Napi::Array output__array__ = Napi::Array::New(env__, 2);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  return output__array__;
}

Napi::Array atg_qr_q(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *Q = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *R = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[2].As<Napi::External<torch::Tensor>>().Data();
  bool some = info__[3].As<Napi::Boolean>().Value();
  auto output__ = torch::qr_out(*Q, *R, *self, some);
  Napi::Array output__array__ = Napi::Array::New(env__, 2);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  return output__array__;
}

Napi::Array atg_geqrf(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::geqrf(*self);
  Napi::Array output__array__ = Napi::Array::New(env__, 2);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  return output__array__;
}

Napi::Array atg_geqrf_a(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *a = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *tau = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[2].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::geqrf_out(*a, *tau, *self);
  Napi::Array output__array__ = Napi::Array::New(env__, 2);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  return output__array__;
}

Napi::External<torch::Tensor> atg_orgqr(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *input2 = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::orgqr(*self, *input2);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_orgqr_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *input2 = info__[2].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::orgqr_out(*out, *self, *input2);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_ormqr(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *input2 = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *input3 = info__[2].As<Napi::External<torch::Tensor>>().Data();
  bool left = info__[3].As<Napi::Boolean>().Value();
  bool transpose = info__[4].As<Napi::Boolean>().Value();
  auto output__ = torch::ormqr(*self, *input2, *input3, left, transpose);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_ormqr_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *input2 = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *input3 = info__[3].As<Napi::External<torch::Tensor>>().Data();
  bool left = info__[4].As<Napi::Boolean>().Value();
  bool transpose = info__[5].As<Napi::Boolean>().Value();
  auto output__ = torch::ormqr_out(*out, *self, *input2, *input3, left, transpose);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::Array atg__lu_with_info(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  bool pivot = info__[1].As<Napi::Boolean>().Value();
  bool check_errors = info__[2].As<Napi::Boolean>().Value();
  auto output__ = torch::_lu_with_info(*self, pivot, check_errors);
  Napi::Array output__array__ = Napi::Array::New(env__, 3);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  output__array__[2u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<2>(output__)));
  return output__array__;
}

Napi::External<torch::Tensor> atg_lu_solve(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *LU_data = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *LU_pivots = info__[2].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::lu_solve(*self, *LU_data, *LU_pivots);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_lu_solve_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *LU_data = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *LU_pivots = info__[3].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::lu_solve_out(*out, *self, *LU_data, *LU_pivots);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::Array atg_lu_unpack(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *LU_data = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *LU_pivots = info__[1].As<Napi::External<torch::Tensor>>().Data();
  bool unpack_data = info__[2].As<Napi::Boolean>().Value();
  bool unpack_pivots = info__[3].As<Napi::Boolean>().Value();
  auto output__ = torch::lu_unpack(*LU_data, *LU_pivots, unpack_data, unpack_pivots);
  Napi::Array output__array__ = Napi::Array::New(env__, 3);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  output__array__[2u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<2>(output__)));
  return output__array__;
}

Napi::Array atg_lu_unpack_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *P = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *L = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *U = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *LU_data = info__[3].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *LU_pivots = info__[4].As<Napi::External<torch::Tensor>>().Data();
  bool unpack_data = info__[5].As<Napi::Boolean>().Value();
  bool unpack_pivots = info__[6].As<Napi::Boolean>().Value();
  auto output__ = torch::lu_unpack_out(*P, *L, *U, *LU_data, *LU_pivots, unpack_data, unpack_pivots);
  Napi::Array output__array__ = Napi::Array::New(env__, 3);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  output__array__[2u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<2>(output__)));
  return output__array__;
}

Napi::External<torch::Tensor> atg_multinomial(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t num_samples = info__[1].As<Napi::Number>().Int64Value();
  bool replacement = info__[2].As<Napi::Boolean>().Value();
  auto output__ = torch::multinomial(*self, num_samples, replacement);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_multinomial_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  int64_t num_samples = info__[2].As<Napi::Number>().Int64Value();
  bool replacement = info__[3].As<Napi::Boolean>().Value();
  auto output__ = torch::multinomial_out(*out, *self, num_samples, replacement);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_lgamma(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::lgamma(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_lgamma_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::lgamma_out(*out, *self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_lgamma_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = self->lgamma_();
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_digamma(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::digamma(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_digamma_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::digamma_out(*out, *self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_polygamma(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  int64_t n = info__[0].As<Napi::Number>().Int64Value();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::polygamma(n, *self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_polygamma_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t n = info__[1].As<Napi::Number>().Int64Value();
  torch::Tensor *self = info__[2].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::polygamma_out(*out, n, *self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_polygamma_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t n = info__[1].As<Napi::Number>().Int64Value();
  auto output__ = self->polygamma_(n);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_erfinv(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::erfinv(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_erfinv_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::erfinv_out(*out, *self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_erfinv_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = self->erfinv_();
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_i0(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::i0(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_i0_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::i0_out(*out, *self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_i0_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::i0_(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_sign(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::sign(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_sign_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::sign_out(*out, *self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_sign_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = self->sign_();
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_signbit(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::signbit(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_signbit_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::signbit_out(*out, *self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_dist(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *p = info__[2].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::dist(*self, *other, *p);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_dist_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *p = info__[3].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::dist_out(*out, *self, *other, *p);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_atan2(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::atan2(*self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_atan2_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[2].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::atan2_out(*out, *self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_atan2_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = self->atan2_(*other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_arctan2(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::arctan2(*self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_arctan2_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[2].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::arctan2_out(*out, *self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_arctan2_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = self->arctan2_(*other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_lerp(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *end = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *weight = info__[2].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::lerp(*self, *end, *weight);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_lerp_tensor(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *end = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *weight = info__[2].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::lerp(*self, *end, *weight);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_lerp_scalar_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *end = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *weight = info__[3].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::lerp_out(*out, *self, *end, *weight);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_lerp_tensor_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *end = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *weight = info__[3].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::lerp_out(*out, *self, *end, *weight);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_histc(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t bins = info__[1].As<Napi::Number>().Int64Value();
  torch::Scalar *min = info__[2].As<Napi::External<torch::Scalar>>().Data();
  torch::Scalar *max = info__[3].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::histc(*self, bins, *min, *max);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_histc_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  int64_t bins = info__[2].As<Napi::Number>().Int64Value();
  torch::Scalar *min = info__[3].As<Napi::External<torch::Scalar>>().Data();
  torch::Scalar *max = info__[4].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::histc_out(*out, *self, bins, *min, *max);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::Array atg_histogram(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *bins = info__[1].As<Napi::External<torch::Tensor>>().Data();
  bool weight_null = info__[2].IsUndefined();
  torch::Tensor *weight_v = weight_null ? nullptr : info__[2].As<Napi::External<torch::Tensor>>().Data();
  bool density = info__[3].As<Napi::Boolean>().Value();
  auto output__ = torch::histogram(*self, *bins, (weight_null ? *weight_v : torch::Tensor()), density);
  Napi::Array output__array__ = Napi::Array::New(env__, 2);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  return output__array__;
}

Napi::Array atg_histogram_bin_ct(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t bins = info__[1].As<Napi::Number>().Int64Value();
  Napi::Array range_array__ = info__[2].As<Napi::Array>();
  int range_len = range_array__.Length();
  double *range_data = new double[range_len];
  for (int i = 0; i < range_len; ++i)
    range_data[i] = range_array__.Get(i).ToNumber().DoubleValue();
  bool weight_null = info__[3].IsUndefined();
  torch::Tensor *weight_v = weight_null ? nullptr : info__[3].As<Napi::External<torch::Tensor>>().Data();
  bool density = info__[4].As<Napi::Boolean>().Value();
  auto output__ = torch::histogram(*self, bins, at::ArrayRef<double>(range_data, range_len), (weight_null ? *weight_v : torch::Tensor()), density);
  Napi::Array output__array__ = Napi::Array::New(env__, 2);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  return output__array__;
}

Napi::Array atg_histogram_bins_tensor_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *hist = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *bin_edges = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *bins = info__[3].As<Napi::External<torch::Tensor>>().Data();
  bool weight_null = info__[4].IsUndefined();
  torch::Tensor *weight_v = weight_null ? nullptr : info__[4].As<Napi::External<torch::Tensor>>().Data();
  bool density = info__[5].As<Napi::Boolean>().Value();
  auto output__ = torch::histogram_out(*hist, *bin_edges, *self, *bins, (weight_null ? *weight_v : torch::Tensor()), density);
  Napi::Array output__array__ = Napi::Array::New(env__, 2);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  return output__array__;
}

Napi::Array atg_histogram_bin_ct_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *hist = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *bin_edges = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[2].As<Napi::External<torch::Tensor>>().Data();
  int64_t bins = info__[3].As<Napi::Number>().Int64Value();
  Napi::Array range_array__ = info__[4].As<Napi::Array>();
  int range_len = range_array__.Length();
  double *range_data = new double[range_len];
  for (int i = 0; i < range_len; ++i)
    range_data[i] = range_array__.Get(i).ToNumber().DoubleValue();
  bool weight_null = info__[5].IsUndefined();
  torch::Tensor *weight_v = weight_null ? nullptr : info__[5].As<Napi::External<torch::Tensor>>().Data();
  bool density = info__[6].As<Napi::Boolean>().Value();
  auto output__ = torch::histogram_out(*hist, *bin_edges, *self, bins, at::ArrayRef<double>(range_data, range_len), (weight_null ? *weight_v : torch::Tensor()), density);
  Napi::Array output__array__ = Napi::Array::New(env__, 2);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  return output__array__;
}

Napi::External<torch::Tensor> atg__histogramdd_from_bin_cts(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array bins_array__ = info__[1].As<Napi::Array>();
  int bins_len = bins_array__.Length();
  int64_t *bins_data = new int64_t[bins_len];
  for (int i = 0; i < bins_len; ++i)
    bins_data[i] = bins_array__.Get(i).ToNumber().Int64Value();
  Napi::Array range_array__ = info__[2].As<Napi::Array>();
  int range_len = range_array__.Length();
  double *range_data = new double[range_len];
  for (int i = 0; i < range_len; ++i)
    range_data[i] = range_array__.Get(i).ToNumber().DoubleValue();
  bool weight_null = info__[3].IsUndefined();
  torch::Tensor *weight_v = weight_null ? nullptr : info__[3].As<Napi::External<torch::Tensor>>().Data();
  bool density = info__[4].As<Napi::Boolean>().Value();
  auto output__ = torch::_histogramdd_from_bin_cts(*self, torch::IntArrayRef(bins_data, bins_len), at::ArrayRef<double>(range_data, range_len), (weight_null ? *weight_v : torch::Tensor()), density);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__histogramdd_from_bin_cts_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array bins_array__ = info__[2].As<Napi::Array>();
  int bins_len = bins_array__.Length();
  int64_t *bins_data = new int64_t[bins_len];
  for (int i = 0; i < bins_len; ++i)
    bins_data[i] = bins_array__.Get(i).ToNumber().Int64Value();
  Napi::Array range_array__ = info__[3].As<Napi::Array>();
  int range_len = range_array__.Length();
  double *range_data = new double[range_len];
  for (int i = 0; i < range_len; ++i)
    range_data[i] = range_array__.Get(i).ToNumber().DoubleValue();
  bool weight_null = info__[4].IsUndefined();
  torch::Tensor *weight_v = weight_null ? nullptr : info__[4].As<Napi::External<torch::Tensor>>().Data();
  bool density = info__[5].As<Napi::Boolean>().Value();
  auto output__ = torch::_histogramdd_from_bin_cts_out(*out, *self, torch::IntArrayRef(bins_data, bins_len), at::ArrayRef<double>(range_data, range_len), (weight_null ? *weight_v : torch::Tensor()), density);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__histogramdd_from_bin_tensors(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array bins_array__ = info__[1].As<Napi::Array>();
  int bins_len = bins_array__.Length();
  torch::Tensor **bins_data = new torch::Tensor *[bins_len];
  for (int i = 0; i < bins_len; ++i)
    bins_data[i] = bins_array__.Get(i).As<Napi::External<torch::Tensor>>().Data();
  bool weight_null = info__[2].IsUndefined();
  torch::Tensor *weight_v = weight_null ? nullptr : info__[2].As<Napi::External<torch::Tensor>>().Data();
  bool density = info__[3].As<Napi::Boolean>().Value();
  auto output__ = torch::_histogramdd_from_bin_tensors(*self, of_carray_tensor(bins_data, bins_len), (weight_null ? *weight_v : torch::Tensor()), density);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__histogramdd_from_bin_tensors_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array bins_array__ = info__[2].As<Napi::Array>();
  int bins_len = bins_array__.Length();
  torch::Tensor **bins_data = new torch::Tensor *[bins_len];
  for (int i = 0; i < bins_len; ++i)
    bins_data[i] = bins_array__.Get(i).As<Napi::External<torch::Tensor>>().Data();
  bool weight_null = info__[3].IsUndefined();
  torch::Tensor *weight_v = weight_null ? nullptr : info__[3].As<Napi::External<torch::Tensor>>().Data();
  bool density = info__[4].As<Napi::Boolean>().Value();
  auto output__ = torch::_histogramdd_from_bin_tensors_out(*out, *self, of_carray_tensor(bins_data, bins_len), (weight_null ? *weight_v : torch::Tensor()), density);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_fmod(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *other = info__[1].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::fmod(*self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_fmod_tensor(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::fmod(*self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_fmod_scalar_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *other = info__[2].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::fmod_out(*out, *self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_fmod_tensor_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[2].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::fmod_out(*out, *self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_fmod_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *other = info__[1].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = self->fmod_(*other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_fmod_tensor_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = self->fmod_(*other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_hypot(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::hypot(*self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_hypot_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[2].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::hypot_out(*out, *self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_hypot_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = self->hypot_(*other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_igamma(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::igamma(*self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_igamma_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[2].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::igamma_out(*out, *self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_igamma_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = self->igamma_(*other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_igammac(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::igammac(*self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_igammac_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[2].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::igammac_out(*out, *self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_igammac_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = self->igammac_(*other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_nextafter(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::nextafter(*self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_nextafter_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[2].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::nextafter_out(*out, *self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_nextafter_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = self->nextafter_(*other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_remainder(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *other = info__[1].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::remainder(*self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_remainder_tensor(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::remainder(*self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_remainder_scalar_tensor(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Scalar *self_scalar = info__[0].As<Napi::External<torch::Scalar>>().Data();
  torch::Tensor *other = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::remainder(*self_scalar, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_remainder_scalar_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *other = info__[2].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::remainder_out(*out, *self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_remainder_tensor_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[2].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::remainder_out(*out, *self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_remainder_scalar_tensor_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *self_scalar = info__[1].As<Napi::External<torch::Scalar>>().Data();
  torch::Tensor *other = info__[2].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::remainder_out(*out, *self_scalar, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_remainder_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *other = info__[1].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = self->remainder_(*other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_remainder_tensor_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = self->remainder_(*other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_fmin(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::fmin(*self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_fmin_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[2].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::fmin_out(*out, *self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_fmax(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::fmax(*self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_fmax_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[2].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::fmax_out(*out, *self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_maximum(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::maximum(*self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_maximum_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[2].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::maximum_out(*out, *self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_minimum(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::minimum(*self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_minimum_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[2].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::minimum_out(*out, *self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_quantile(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *q = info__[1].As<Napi::External<torch::Tensor>>().Data();
  bool dim_null = info__[2].IsUndefined();
  int64_t dim_v = dim_null ? 0 : info__[2].As<Napi::Number>().Int64Value();
  bool keepdim = info__[3].As<Napi::Boolean>().Value();
  Napi::String interpolation_str__ = info__[4].As<Napi::String>();
  std::string interpolation = interpolation_str__.Utf8Value();
  auto output__ = torch::quantile(*self, *q, dim_null ? c10::nullopt : c10::optional<int64_t>(dim_v), keepdim, interpolation);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_quantile_scalar(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  double q = info__[1].As<Napi::Number>().DoubleValue();
  bool dim_null = info__[2].IsUndefined();
  int64_t dim_v = dim_null ? 0 : info__[2].As<Napi::Number>().Int64Value();
  bool keepdim = info__[3].As<Napi::Boolean>().Value();
  Napi::String interpolation_str__ = info__[4].As<Napi::String>();
  std::string interpolation = interpolation_str__.Utf8Value();
  auto output__ = torch::quantile(*self, q, dim_null ? c10::nullopt : c10::optional<int64_t>(dim_v), keepdim, interpolation);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_quantile_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *q = info__[2].As<Napi::External<torch::Tensor>>().Data();
  bool dim_null = info__[3].IsUndefined();
  int64_t dim_v = dim_null ? 0 : info__[3].As<Napi::Number>().Int64Value();
  bool keepdim = info__[4].As<Napi::Boolean>().Value();
  Napi::String interpolation_str__ = info__[5].As<Napi::String>();
  std::string interpolation = interpolation_str__.Utf8Value();
  auto output__ = torch::quantile_out(*out, *self, *q, dim_null ? c10::nullopt : c10::optional<int64_t>(dim_v), keepdim, interpolation);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_quantile_scalar_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  double q = info__[2].As<Napi::Number>().DoubleValue();
  bool dim_null = info__[3].IsUndefined();
  int64_t dim_v = dim_null ? 0 : info__[3].As<Napi::Number>().Int64Value();
  bool keepdim = info__[4].As<Napi::Boolean>().Value();
  Napi::String interpolation_str__ = info__[5].As<Napi::String>();
  std::string interpolation = interpolation_str__.Utf8Value();
  auto output__ = torch::quantile_out(*out, *self, q, dim_null ? c10::nullopt : c10::optional<int64_t>(dim_v), keepdim, interpolation);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_nanquantile(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *q = info__[1].As<Napi::External<torch::Tensor>>().Data();
  bool dim_null = info__[2].IsUndefined();
  int64_t dim_v = dim_null ? 0 : info__[2].As<Napi::Number>().Int64Value();
  bool keepdim = info__[3].As<Napi::Boolean>().Value();
  Napi::String interpolation_str__ = info__[4].As<Napi::String>();
  std::string interpolation = interpolation_str__.Utf8Value();
  auto output__ = torch::nanquantile(*self, *q, dim_null ? c10::nullopt : c10::optional<int64_t>(dim_v), keepdim, interpolation);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_nanquantile_scalar(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  double q = info__[1].As<Napi::Number>().DoubleValue();
  bool dim_null = info__[2].IsUndefined();
  int64_t dim_v = dim_null ? 0 : info__[2].As<Napi::Number>().Int64Value();
  bool keepdim = info__[3].As<Napi::Boolean>().Value();
  Napi::String interpolation_str__ = info__[4].As<Napi::String>();
  std::string interpolation = interpolation_str__.Utf8Value();
  auto output__ = torch::nanquantile(*self, q, dim_null ? c10::nullopt : c10::optional<int64_t>(dim_v), keepdim, interpolation);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_nanquantile_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *q = info__[2].As<Napi::External<torch::Tensor>>().Data();
  bool dim_null = info__[3].IsUndefined();
  int64_t dim_v = dim_null ? 0 : info__[3].As<Napi::Number>().Int64Value();
  bool keepdim = info__[4].As<Napi::Boolean>().Value();
  Napi::String interpolation_str__ = info__[5].As<Napi::String>();
  std::string interpolation = interpolation_str__.Utf8Value();
  auto output__ = torch::nanquantile_out(*out, *self, *q, dim_null ? c10::nullopt : c10::optional<int64_t>(dim_v), keepdim, interpolation);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_nanquantile_scalar_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  double q = info__[2].As<Napi::Number>().DoubleValue();
  bool dim_null = info__[3].IsUndefined();
  int64_t dim_v = dim_null ? 0 : info__[3].As<Napi::Number>().Int64Value();
  bool keepdim = info__[4].As<Napi::Boolean>().Value();
  Napi::String interpolation_str__ = info__[5].As<Napi::String>();
  std::string interpolation = interpolation_str__.Utf8Value();
  auto output__ = torch::nanquantile_out(*out, *self, q, dim_null ? c10::nullopt : c10::optional<int64_t>(dim_v), keepdim, interpolation);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::Array atg_sort(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t dim = info__[1].As<Napi::Number>().Int64Value();
  bool descending = info__[2].As<Napi::Boolean>().Value();
  auto output__ = torch::sort(*self, dim, descending);
  Napi::Array output__array__ = Napi::Array::New(env__, 2);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  return output__array__;
}

Napi::Array atg_sort_stable(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  bool stable = info__[1].As<Napi::Boolean>().Value();
  int64_t dim = info__[2].As<Napi::Number>().Int64Value();
  bool descending = info__[3].As<Napi::Boolean>().Value();
  auto output__ = torch::sort(*self, stable, dim, descending);
  Napi::Array output__array__ = Napi::Array::New(env__, 2);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  return output__array__;
}

Napi::Array atg_sort_values(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *values = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *indices = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[2].As<Napi::External<torch::Tensor>>().Data();
  int64_t dim = info__[3].As<Napi::Number>().Int64Value();
  bool descending = info__[4].As<Napi::Boolean>().Value();
  auto output__ = torch::sort_out(*values, *indices, *self, dim, descending);
  Napi::Array output__array__ = Napi::Array::New(env__, 2);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  return output__array__;
}

Napi::Array atg_sort_values_stable(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *values = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *indices = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[2].As<Napi::External<torch::Tensor>>().Data();
  bool stable = info__[3].As<Napi::Boolean>().Value();
  int64_t dim = info__[4].As<Napi::Number>().Int64Value();
  bool descending = info__[5].As<Napi::Boolean>().Value();
  auto output__ = torch::sort_out(*values, *indices, *self, stable, dim, descending);
  Napi::Array output__array__ = Napi::Array::New(env__, 2);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  return output__array__;
}

Napi::External<torch::Tensor> atg_msort(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::msort(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_msort_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::msort_out(*out, *self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_argsort(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t dim = info__[1].As<Napi::Number>().Int64Value();
  bool descending = info__[2].As<Napi::Boolean>().Value();
  auto output__ = torch::argsort(*self, dim, descending);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_argsort_stable(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  bool stable = info__[1].As<Napi::Boolean>().Value();
  int64_t dim = info__[2].As<Napi::Number>().Int64Value();
  bool descending = info__[3].As<Napi::Boolean>().Value();
  auto output__ = torch::argsort(*self, stable, dim, descending);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_argsort_stable_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  bool stable = info__[2].As<Napi::Boolean>().Value();
  int64_t dim = info__[3].As<Napi::Number>().Int64Value();
  bool descending = info__[4].As<Napi::Boolean>().Value();
  auto output__ = torch::argsort_out(*out, *self, stable, dim, descending);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::Array atg_topk(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t k = info__[1].As<Napi::Number>().Int64Value();
  int64_t dim = info__[2].As<Napi::Number>().Int64Value();
  bool largest = info__[3].As<Napi::Boolean>().Value();
  bool sorted = info__[4].As<Napi::Boolean>().Value();
  auto output__ = torch::topk(*self, k, dim, largest, sorted);
  Napi::Array output__array__ = Napi::Array::New(env__, 2);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  return output__array__;
}

Napi::Array atg_topk_values(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *values = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *indices = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[2].As<Napi::External<torch::Tensor>>().Data();
  int64_t k = info__[3].As<Napi::Number>().Int64Value();
  int64_t dim = info__[4].As<Napi::Number>().Int64Value();
  bool largest = info__[5].As<Napi::Boolean>().Value();
  bool sorted = info__[6].As<Napi::Boolean>().Value();
  auto output__ = torch::topk_out(*values, *indices, *self, k, dim, largest, sorted);
  Napi::Array output__array__ = Napi::Array::New(env__, 2);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  return output__array__;
}

Napi::External<torch::Tensor> atg_renorm(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *p = info__[1].As<Napi::External<torch::Scalar>>().Data();
  int64_t dim = info__[2].As<Napi::Number>().Int64Value();
  torch::Scalar *maxnorm = info__[3].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::renorm(*self, *p, dim, *maxnorm);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_renorm_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *p = info__[2].As<Napi::External<torch::Scalar>>().Data();
  int64_t dim = info__[3].As<Napi::Number>().Int64Value();
  torch::Scalar *maxnorm = info__[4].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::renorm_out(*out, *self, *p, dim, *maxnorm);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_renorm_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *p = info__[1].As<Napi::External<torch::Scalar>>().Data();
  int64_t dim = info__[2].As<Napi::Number>().Int64Value();
  torch::Scalar *maxnorm = info__[3].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = self->renorm_(*p, dim, *maxnorm);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_unfold(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t dimension = info__[1].As<Napi::Number>().Int64Value();
  int64_t size = info__[2].As<Napi::Number>().Int64Value();
  int64_t step = info__[3].As<Napi::Number>().Int64Value();
  auto output__ = self->unfold(dimension, size, step);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_unfold_backward(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *grad_in = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array input_sizes_array__ = info__[1].As<Napi::Array>();
  int input_sizes_len = input_sizes_array__.Length();
  int64_t *input_sizes_data = new int64_t[input_sizes_len];
  for (int i = 0; i < input_sizes_len; ++i)
    input_sizes_data[i] = input_sizes_array__.Get(i).ToNumber().Int64Value();
  int64_t dim = info__[2].As<Napi::Number>().Int64Value();
  int64_t size = info__[3].As<Napi::Number>().Int64Value();
  int64_t step = info__[4].As<Napi::Number>().Int64Value();
  auto output__ = torch::unfold_backward(*grad_in, torch::IntArrayRef(input_sizes_data, input_sizes_len), dim, size, step);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_unfold_backward_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *grad_in = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array input_sizes_array__ = info__[2].As<Napi::Array>();
  int input_sizes_len = input_sizes_array__.Length();
  int64_t *input_sizes_data = new int64_t[input_sizes_len];
  for (int i = 0; i < input_sizes_len; ++i)
    input_sizes_data[i] = input_sizes_array__.Get(i).ToNumber().Int64Value();
  int64_t dim = info__[3].As<Napi::Number>().Int64Value();
  int64_t size = info__[4].As<Napi::Number>().Int64Value();
  int64_t step = info__[5].As<Napi::Number>().Int64Value();
  auto output__ = torch::unfold_backward_out(*out, *grad_in, torch::IntArrayRef(input_sizes_data, input_sizes_len), dim, size, step);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::Boolean atg_equal(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::equal(*self, *other);
  return Napi::Boolean::New(env__, output__);
}

Napi::External<torch::Tensor> atg_pow(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *exponent = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::pow(*self, *exponent);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_pow_scalar(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Scalar *self_scalar = info__[0].As<Napi::External<torch::Scalar>>().Data();
  torch::Tensor *exponent = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::pow(*self_scalar, *exponent);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_pow_tensor_scalar(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *exponent = info__[1].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::pow(*self, *exponent);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_pow_tensor_tensor_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *exponent = info__[2].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::pow_out(*out, *self, *exponent);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_pow_scalar_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *self_scalar = info__[1].As<Napi::External<torch::Scalar>>().Data();
  torch::Tensor *exponent = info__[2].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::pow_out(*out, *self_scalar, *exponent);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_pow_tensor_scalar_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *exponent = info__[2].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::pow_out(*out, *self, *exponent);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_pow_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *exponent = info__[1].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = self->pow_(*exponent);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_pow_tensor_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *exponent = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = self->pow_(*exponent);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_float_power(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *exponent = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::float_power(*self, *exponent);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_float_power_scalar(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Scalar *self_scalar = info__[0].As<Napi::External<torch::Scalar>>().Data();
  torch::Tensor *exponent = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::float_power(*self_scalar, *exponent);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_float_power_tensor_scalar(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *exponent = info__[1].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::float_power(*self, *exponent);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_float_power_tensor_tensor_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *exponent = info__[2].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::float_power_out(*out, *self, *exponent);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_float_power_scalar_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *self_scalar = info__[1].As<Napi::External<torch::Scalar>>().Data();
  torch::Tensor *exponent = info__[2].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::float_power_out(*out, *self_scalar, *exponent);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_float_power_tensor_scalar_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *exponent = info__[2].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::float_power_out(*out, *self, *exponent);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_float_power_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *exponent = info__[1].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = self->float_power_(*exponent);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_float_power_tensor_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *exponent = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = self->float_power_(*exponent);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_normal_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  double mean = info__[1].As<Napi::Number>().DoubleValue();
  double std = info__[2].As<Napi::Number>().DoubleValue();
  auto output__ = self->normal_(mean, std);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_normal_functional(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  double mean = info__[1].As<Napi::Number>().DoubleValue();
  double std = info__[2].As<Napi::Number>().DoubleValue();
  auto output__ = torch::normal_functional(*self, mean, std);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_alias(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::alias(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__amp_update_scale_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *growth_tracker = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *found_inf = info__[2].As<Napi::External<torch::Tensor>>().Data();
  double scale_growth_factor = info__[3].As<Napi::Number>().DoubleValue();
  double scale_backoff_factor = info__[4].As<Napi::Number>().DoubleValue();
  int64_t growth_interval = info__[5].As<Napi::Number>().Int64Value();
  auto output__ = torch::_amp_update_scale_(*self, *growth_tracker, *found_inf, scale_growth_factor, scale_backoff_factor, growth_interval);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_bucketize(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *boundaries = info__[1].As<Napi::External<torch::Tensor>>().Data();
  bool out_int32 = info__[2].As<Napi::Boolean>().Value();
  bool right = info__[3].As<Napi::Boolean>().Value();
  auto output__ = torch::bucketize(*self, *boundaries, out_int32, right);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_bucketize_scalar(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Scalar *self_scalar = info__[0].As<Napi::External<torch::Scalar>>().Data();
  torch::Tensor *boundaries = info__[1].As<Napi::External<torch::Tensor>>().Data();
  bool out_int32 = info__[2].As<Napi::Boolean>().Value();
  bool right = info__[3].As<Napi::Boolean>().Value();
  auto output__ = torch::bucketize(*self_scalar, *boundaries, out_int32, right);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_bucketize_tensor_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *boundaries = info__[2].As<Napi::External<torch::Tensor>>().Data();
  bool out_int32 = info__[3].As<Napi::Boolean>().Value();
  bool right = info__[4].As<Napi::Boolean>().Value();
  auto output__ = torch::bucketize_out(*out, *self, *boundaries, out_int32, right);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_bucketize_scalar_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *self_scalar = info__[1].As<Napi::External<torch::Scalar>>().Data();
  torch::Tensor *boundaries = info__[2].As<Napi::External<torch::Tensor>>().Data();
  bool out_int32 = info__[3].As<Napi::Boolean>().Value();
  bool right = info__[4].As<Napi::Boolean>().Value();
  auto output__ = torch::bucketize_out(*out, *self_scalar, *boundaries, out_int32, right);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_searchsorted(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *sorted_sequence = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  bool out_int32 = info__[2].As<Napi::Boolean>().Value();
  bool right = info__[3].As<Napi::Boolean>().Value();
  Napi::String side_str__ = info__[4].As<Napi::String>();
  std::string side = side_str__.Utf8Value();
  bool sorter_null = info__[5].IsUndefined();
  torch::Tensor *sorter_v = sorter_null ? nullptr : info__[5].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::searchsorted(*sorted_sequence, *self, out_int32, right, side, (sorter_null ? *sorter_v : torch::Tensor()));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_searchsorted_scalar(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *sorted_sequence = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *self_scalar = info__[1].As<Napi::External<torch::Scalar>>().Data();
  bool out_int32 = info__[2].As<Napi::Boolean>().Value();
  bool right = info__[3].As<Napi::Boolean>().Value();
  Napi::String side_str__ = info__[4].As<Napi::String>();
  std::string side = side_str__.Utf8Value();
  bool sorter_null = info__[5].IsUndefined();
  torch::Tensor *sorter_v = sorter_null ? nullptr : info__[5].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::searchsorted(*sorted_sequence, *self_scalar, out_int32, right, side, (sorter_null ? *sorter_v : torch::Tensor()));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_searchsorted_tensor_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *sorted_sequence = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[2].As<Napi::External<torch::Tensor>>().Data();
  bool out_int32 = info__[3].As<Napi::Boolean>().Value();
  bool right = info__[4].As<Napi::Boolean>().Value();
  Napi::String side_str__ = info__[5].As<Napi::String>();
  std::string side = side_str__.Utf8Value();
  bool sorter_null = info__[6].IsUndefined();
  torch::Tensor *sorter_v = sorter_null ? nullptr : info__[6].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::searchsorted_out(*out, *sorted_sequence, *self, out_int32, right, side, (sorter_null ? *sorter_v : torch::Tensor()));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_searchsorted_scalar_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *sorted_sequence = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *self_scalar = info__[2].As<Napi::External<torch::Scalar>>().Data();
  bool out_int32 = info__[3].As<Napi::Boolean>().Value();
  bool right = info__[4].As<Napi::Boolean>().Value();
  Napi::String side_str__ = info__[5].As<Napi::String>();
  std::string side = side_str__.Utf8Value();
  bool sorter_null = info__[6].IsUndefined();
  torch::Tensor *sorter_v = sorter_null ? nullptr : info__[6].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::searchsorted_out(*out, *sorted_sequence, *self_scalar, out_int32, right, side, (sorter_null ? *sorter_v : torch::Tensor()));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__convert_indices_from_coo_to_csr(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t size = info__[1].As<Napi::Number>().Int64Value();
  bool out_int32 = info__[2].As<Napi::Boolean>().Value();
  auto output__ = torch::_convert_indices_from_coo_to_csr(*self, size, out_int32);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__convert_indices_from_coo_to_csr_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  int64_t size = info__[2].As<Napi::Number>().Int64Value();
  bool out_int32 = info__[3].As<Napi::Boolean>().Value();
  auto output__ = torch::_convert_indices_from_coo_to_csr_out(*out, *self, size, out_int32);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__convert_indices_from_csr_to_coo(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *crow_indices = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *col_indices = info__[1].As<Napi::External<torch::Tensor>>().Data();
  bool out_int32 = info__[2].As<Napi::Boolean>().Value();
  bool transpose = info__[3].As<Napi::Boolean>().Value();
  auto output__ = torch::_convert_indices_from_csr_to_coo(*crow_indices, *col_indices, out_int32, transpose);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__convert_indices_from_csr_to_coo_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *crow_indices = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *col_indices = info__[2].As<Napi::External<torch::Tensor>>().Data();
  bool out_int32 = info__[3].As<Napi::Boolean>().Value();
  bool transpose = info__[4].As<Napi::Boolean>().Value();
  auto output__ = torch::_convert_indices_from_csr_to_coo_out(*out, *crow_indices, *col_indices, out_int32, transpose);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_mse_loss(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *target = info__[1].As<Napi::External<torch::Tensor>>().Data();
  int64_t reduction = info__[2].As<Napi::Number>().Int64Value();
  auto output__ = torch::mse_loss(*self, *target, reduction);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_mse_loss_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *target = info__[2].As<Napi::External<torch::Tensor>>().Data();
  int64_t reduction = info__[3].As<Napi::Number>().Int64Value();
  auto output__ = torch::mse_loss_out(*out, *self, *target, reduction);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_mse_loss_backward(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *grad_output = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *target = info__[2].As<Napi::External<torch::Tensor>>().Data();
  int64_t reduction = info__[3].As<Napi::Number>().Int64Value();
  auto output__ = torch::mse_loss_backward(*grad_output, *self, *target, reduction);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_mse_loss_backward_grad_input(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *grad_input = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *grad_output = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *target = info__[3].As<Napi::External<torch::Tensor>>().Data();
  int64_t reduction = info__[4].As<Napi::Number>().Int64Value();
  auto output__ = torch::mse_loss_backward_out(*grad_input, *grad_output, *self, *target, reduction);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_l1_loss(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *target = info__[1].As<Napi::External<torch::Tensor>>().Data();
  int64_t reduction = info__[2].As<Napi::Number>().Int64Value();
  auto output__ = torch::l1_loss(*self, *target, reduction);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_multi_margin_loss_backward(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *grad_output = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *target = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *p = info__[3].As<Napi::External<torch::Scalar>>().Data();
  torch::Scalar *margin = info__[4].As<Napi::External<torch::Scalar>>().Data();
  bool weight_null = info__[5].IsUndefined();
  torch::Tensor *weight_v = weight_null ? nullptr : info__[5].As<Napi::External<torch::Tensor>>().Data();
  int64_t reduction = info__[6].As<Napi::Number>().Int64Value();
  auto output__ = torch::multi_margin_loss_backward(*grad_output, *self, *target, *p, *margin, (weight_null ? *weight_v : torch::Tensor()), reduction);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_multi_margin_loss_backward_grad_input(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *grad_input = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *grad_output = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *target = info__[3].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *p = info__[4].As<Napi::External<torch::Scalar>>().Data();
  torch::Scalar *margin = info__[5].As<Napi::External<torch::Scalar>>().Data();
  bool weight_null = info__[6].IsUndefined();
  torch::Tensor *weight_v = weight_null ? nullptr : info__[6].As<Napi::External<torch::Tensor>>().Data();
  int64_t reduction = info__[7].As<Napi::Number>().Int64Value();
  auto output__ = torch::multi_margin_loss_backward_out(*grad_input, *grad_output, *self, *target, *p, *margin, (weight_null ? *weight_v : torch::Tensor()), reduction);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_multilabel_margin_loss(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *target = info__[1].As<Napi::External<torch::Tensor>>().Data();
  int64_t reduction = info__[2].As<Napi::Number>().Int64Value();
  auto output__ = torch::multilabel_margin_loss(*self, *target, reduction);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_multilabel_margin_loss_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *target = info__[2].As<Napi::External<torch::Tensor>>().Data();
  int64_t reduction = info__[3].As<Napi::Number>().Int64Value();
  auto output__ = torch::multilabel_margin_loss_out(*out, *self, *target, reduction);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_multilabel_margin_loss_backward(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *grad_output = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *target = info__[2].As<Napi::External<torch::Tensor>>().Data();
  int64_t reduction = info__[3].As<Napi::Number>().Int64Value();
  torch::Tensor *is_target = info__[4].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::multilabel_margin_loss_backward(*grad_output, *self, *target, reduction, *is_target);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_multilabel_margin_loss_backward_grad_input(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *grad_input = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *grad_output = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *target = info__[3].As<Napi::External<torch::Tensor>>().Data();
  int64_t reduction = info__[4].As<Napi::Number>().Int64Value();
  torch::Tensor *is_target = info__[5].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::multilabel_margin_loss_backward_out(*grad_input, *grad_output, *self, *target, reduction, *is_target);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_nll_loss(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *target = info__[1].As<Napi::External<torch::Tensor>>().Data();
  bool weight_null = info__[2].IsUndefined();
  torch::Tensor *weight_v = weight_null ? nullptr : info__[2].As<Napi::External<torch::Tensor>>().Data();
  int64_t reduction = info__[3].As<Napi::Number>().Int64Value();
  int64_t ignore_index = info__[4].As<Napi::Number>().Int64Value();
  auto output__ = torch::nll_loss(*self, *target, (weight_null ? *weight_v : torch::Tensor()), reduction, ignore_index);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_nll_loss_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *target = info__[2].As<Napi::External<torch::Tensor>>().Data();
  bool weight_null = info__[3].IsUndefined();
  torch::Tensor *weight_v = weight_null ? nullptr : info__[3].As<Napi::External<torch::Tensor>>().Data();
  int64_t reduction = info__[4].As<Napi::Number>().Int64Value();
  int64_t ignore_index = info__[5].As<Napi::Number>().Int64Value();
  auto output__ = torch::nll_loss_out(*out, *self, *target, (weight_null ? *weight_v : torch::Tensor()), reduction, ignore_index);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_nll_loss_nd(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *target = info__[1].As<Napi::External<torch::Tensor>>().Data();
  bool weight_null = info__[2].IsUndefined();
  torch::Tensor *weight_v = weight_null ? nullptr : info__[2].As<Napi::External<torch::Tensor>>().Data();
  int64_t reduction = info__[3].As<Napi::Number>().Int64Value();
  int64_t ignore_index = info__[4].As<Napi::Number>().Int64Value();
  auto output__ = torch::nll_loss_nd(*self, *target, (weight_null ? *weight_v : torch::Tensor()), reduction, ignore_index);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_nll_loss_backward(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *grad_output = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *target = info__[2].As<Napi::External<torch::Tensor>>().Data();
  bool weight_null = info__[3].IsUndefined();
  torch::Tensor *weight_v = weight_null ? nullptr : info__[3].As<Napi::External<torch::Tensor>>().Data();
  int64_t reduction = info__[4].As<Napi::Number>().Int64Value();
  int64_t ignore_index = info__[5].As<Napi::Number>().Int64Value();
  torch::Tensor *total_weight = info__[6].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::nll_loss_backward(*grad_output, *self, *target, (weight_null ? *weight_v : torch::Tensor()), reduction, ignore_index, *total_weight);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_nll_loss_backward_grad_input(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *grad_input = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *grad_output = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *target = info__[3].As<Napi::External<torch::Tensor>>().Data();
  bool weight_null = info__[4].IsUndefined();
  torch::Tensor *weight_v = weight_null ? nullptr : info__[4].As<Napi::External<torch::Tensor>>().Data();
  int64_t reduction = info__[5].As<Napi::Number>().Int64Value();
  int64_t ignore_index = info__[6].As<Napi::Number>().Int64Value();
  torch::Tensor *total_weight = info__[7].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::nll_loss_backward_out(*grad_input, *grad_output, *self, *target, (weight_null ? *weight_v : torch::Tensor()), reduction, ignore_index, *total_weight);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_nll_loss2d(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *target = info__[1].As<Napi::External<torch::Tensor>>().Data();
  bool weight_null = info__[2].IsUndefined();
  torch::Tensor *weight_v = weight_null ? nullptr : info__[2].As<Napi::External<torch::Tensor>>().Data();
  int64_t reduction = info__[3].As<Napi::Number>().Int64Value();
  int64_t ignore_index = info__[4].As<Napi::Number>().Int64Value();
  auto output__ = torch::nll_loss2d(*self, *target, (weight_null ? *weight_v : torch::Tensor()), reduction, ignore_index);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_nll_loss2d_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *target = info__[2].As<Napi::External<torch::Tensor>>().Data();
  bool weight_null = info__[3].IsUndefined();
  torch::Tensor *weight_v = weight_null ? nullptr : info__[3].As<Napi::External<torch::Tensor>>().Data();
  int64_t reduction = info__[4].As<Napi::Number>().Int64Value();
  int64_t ignore_index = info__[5].As<Napi::Number>().Int64Value();
  auto output__ = torch::nll_loss2d_out(*out, *self, *target, (weight_null ? *weight_v : torch::Tensor()), reduction, ignore_index);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_nll_loss2d_backward(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *grad_output = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *target = info__[2].As<Napi::External<torch::Tensor>>().Data();
  bool weight_null = info__[3].IsUndefined();
  torch::Tensor *weight_v = weight_null ? nullptr : info__[3].As<Napi::External<torch::Tensor>>().Data();
  int64_t reduction = info__[4].As<Napi::Number>().Int64Value();
  int64_t ignore_index = info__[5].As<Napi::Number>().Int64Value();
  torch::Tensor *total_weight = info__[6].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::nll_loss2d_backward(*grad_output, *self, *target, (weight_null ? *weight_v : torch::Tensor()), reduction, ignore_index, *total_weight);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_nll_loss2d_backward_grad_input(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *grad_input = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *grad_output = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *target = info__[3].As<Napi::External<torch::Tensor>>().Data();
  bool weight_null = info__[4].IsUndefined();
  torch::Tensor *weight_v = weight_null ? nullptr : info__[4].As<Napi::External<torch::Tensor>>().Data();
  int64_t reduction = info__[5].As<Napi::Number>().Int64Value();
  int64_t ignore_index = info__[6].As<Napi::Number>().Int64Value();
  torch::Tensor *total_weight = info__[7].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::nll_loss2d_backward_out(*grad_input, *grad_output, *self, *target, (weight_null ? *weight_v : torch::Tensor()), reduction, ignore_index, *total_weight);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_smooth_l1_loss(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *target = info__[1].As<Napi::External<torch::Tensor>>().Data();
  int64_t reduction = info__[2].As<Napi::Number>().Int64Value();
  double beta = info__[3].As<Napi::Number>().DoubleValue();
  auto output__ = torch::smooth_l1_loss(*self, *target, reduction, beta);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_smooth_l1_loss_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *target = info__[2].As<Napi::External<torch::Tensor>>().Data();
  int64_t reduction = info__[3].As<Napi::Number>().Int64Value();
  double beta = info__[4].As<Napi::Number>().DoubleValue();
  auto output__ = torch::smooth_l1_loss_out(*out, *self, *target, reduction, beta);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_smooth_l1_loss_backward(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *grad_output = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *target = info__[2].As<Napi::External<torch::Tensor>>().Data();
  int64_t reduction = info__[3].As<Napi::Number>().Int64Value();
  double beta = info__[4].As<Napi::Number>().DoubleValue();
  auto output__ = torch::smooth_l1_loss_backward(*grad_output, *self, *target, reduction, beta);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_smooth_l1_loss_backward_grad_input(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *grad_input = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *grad_output = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *target = info__[3].As<Napi::External<torch::Tensor>>().Data();
  int64_t reduction = info__[4].As<Napi::Number>().Int64Value();
  double beta = info__[5].As<Napi::Number>().DoubleValue();
  auto output__ = torch::smooth_l1_loss_backward_out(*grad_input, *grad_output, *self, *target, reduction, beta);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_huber_loss(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *target = info__[1].As<Napi::External<torch::Tensor>>().Data();
  int64_t reduction = info__[2].As<Napi::Number>().Int64Value();
  double delta = info__[3].As<Napi::Number>().DoubleValue();
  auto output__ = torch::huber_loss(*self, *target, reduction, delta);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_huber_loss_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *target = info__[2].As<Napi::External<torch::Tensor>>().Data();
  int64_t reduction = info__[3].As<Napi::Number>().Int64Value();
  double delta = info__[4].As<Napi::Number>().DoubleValue();
  auto output__ = torch::huber_loss_out(*out, *self, *target, reduction, delta);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_huber_loss_backward(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *grad_output = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *target = info__[2].As<Napi::External<torch::Tensor>>().Data();
  int64_t reduction = info__[3].As<Napi::Number>().Int64Value();
  double delta = info__[4].As<Napi::Number>().DoubleValue();
  auto output__ = torch::huber_loss_backward(*grad_output, *self, *target, reduction, delta);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_huber_loss_backward_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *grad_input = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *grad_output = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *target = info__[3].As<Napi::External<torch::Tensor>>().Data();
  int64_t reduction = info__[4].As<Napi::Number>().Int64Value();
  double delta = info__[5].As<Napi::Number>().DoubleValue();
  auto output__ = torch::huber_loss_backward_out(*grad_input, *grad_output, *self, *target, reduction, delta);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_soft_margin_loss(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *target = info__[1].As<Napi::External<torch::Tensor>>().Data();
  int64_t reduction = info__[2].As<Napi::Number>().Int64Value();
  auto output__ = torch::soft_margin_loss(*self, *target, reduction);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_soft_margin_loss_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *target = info__[2].As<Napi::External<torch::Tensor>>().Data();
  int64_t reduction = info__[3].As<Napi::Number>().Int64Value();
  auto output__ = torch::soft_margin_loss_out(*out, *self, *target, reduction);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_soft_margin_loss_backward(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *grad_output = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *target = info__[2].As<Napi::External<torch::Tensor>>().Data();
  int64_t reduction = info__[3].As<Napi::Number>().Int64Value();
  auto output__ = torch::soft_margin_loss_backward(*grad_output, *self, *target, reduction);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_soft_margin_loss_backward_grad_input(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *grad_input = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *grad_output = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *target = info__[3].As<Napi::External<torch::Tensor>>().Data();
  int64_t reduction = info__[4].As<Napi::Number>().Int64Value();
  auto output__ = torch::soft_margin_loss_backward_out(*grad_input, *grad_output, *self, *target, reduction);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_elu(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *alpha = info__[1].As<Napi::External<torch::Scalar>>().Data();
  torch::Scalar *scale = info__[2].As<Napi::External<torch::Scalar>>().Data();
  torch::Scalar *input_scale = info__[3].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::elu(*self, *alpha, *scale, *input_scale);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_elu_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *alpha = info__[2].As<Napi::External<torch::Scalar>>().Data();
  torch::Scalar *scale = info__[3].As<Napi::External<torch::Scalar>>().Data();
  torch::Scalar *input_scale = info__[4].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::elu_out(*out, *self, *alpha, *scale, *input_scale);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_elu_backward(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *grad_output = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *alpha = info__[1].As<Napi::External<torch::Scalar>>().Data();
  torch::Scalar *scale = info__[2].As<Napi::External<torch::Scalar>>().Data();
  torch::Scalar *input_scale = info__[3].As<Napi::External<torch::Scalar>>().Data();
  bool is_result = info__[4].As<Napi::Boolean>().Value();
  torch::Tensor *self_or_result = info__[5].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::elu_backward(*grad_output, *alpha, *scale, *input_scale, is_result, *self_or_result);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_elu_backward_grad_input(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *grad_input = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *grad_output = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *alpha = info__[2].As<Napi::External<torch::Scalar>>().Data();
  torch::Scalar *scale = info__[3].As<Napi::External<torch::Scalar>>().Data();
  torch::Scalar *input_scale = info__[4].As<Napi::External<torch::Scalar>>().Data();
  bool is_result = info__[5].As<Napi::Boolean>().Value();
  torch::Tensor *self_or_result = info__[6].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::elu_backward_out(*grad_input, *grad_output, *alpha, *scale, *input_scale, is_result, *self_or_result);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_elu_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *alpha = info__[1].As<Napi::External<torch::Scalar>>().Data();
  torch::Scalar *scale = info__[2].As<Napi::External<torch::Scalar>>().Data();
  torch::Scalar *input_scale = info__[3].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::elu_(*self, *alpha, *scale, *input_scale);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_glu(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t dim = info__[1].As<Napi::Number>().Int64Value();
  auto output__ = torch::glu(*self, dim);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_glu_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  int64_t dim = info__[2].As<Napi::Number>().Int64Value();
  auto output__ = torch::glu_out(*out, *self, dim);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_glu_backward(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *grad_output = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  int64_t dim = info__[2].As<Napi::Number>().Int64Value();
  auto output__ = torch::glu_backward(*grad_output, *self, dim);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_glu_backward_grad_input(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *grad_input = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *grad_output = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[2].As<Napi::External<torch::Tensor>>().Data();
  int64_t dim = info__[3].As<Napi::Number>().Int64Value();
  auto output__ = torch::glu_backward_out(*grad_input, *grad_output, *self, dim);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_glu_jvp(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *glu = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *x = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *dx = info__[2].As<Napi::External<torch::Tensor>>().Data();
  int64_t dim = info__[3].As<Napi::Number>().Int64Value();
  auto output__ = torch::glu_jvp(*glu, *x, *dx, dim);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_glu_jvp_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *glu = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *x = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *dx = info__[3].As<Napi::External<torch::Tensor>>().Data();
  int64_t dim = info__[4].As<Napi::Number>().Int64Value();
  auto output__ = torch::glu_jvp_out(*out, *glu, *x, *dx, dim);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_glu_backward_jvp(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *grad_x = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *grad_glu = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *x = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *dgrad_glu = info__[3].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *dx = info__[4].As<Napi::External<torch::Tensor>>().Data();
  int64_t dim = info__[5].As<Napi::Number>().Int64Value();
  auto output__ = torch::glu_backward_jvp(*grad_x, *grad_glu, *x, *dgrad_glu, *dx, dim);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_glu_backward_jvp_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *grad_x = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *grad_glu = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *x = info__[3].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *dgrad_glu = info__[4].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *dx = info__[5].As<Napi::External<torch::Tensor>>().Data();
  int64_t dim = info__[6].As<Napi::Number>().Int64Value();
  auto output__ = torch::glu_backward_jvp_out(*out, *grad_x, *grad_glu, *x, *dgrad_glu, *dx, dim);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_hardsigmoid(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::hardsigmoid(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_hardsigmoid_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::hardsigmoid_out(*out, *self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_hardsigmoid_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::hardsigmoid_(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_hardsigmoid_backward(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *grad_output = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::hardsigmoid_backward(*grad_output, *self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_hardsigmoid_backward_grad_input(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *grad_input = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *grad_output = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[2].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::hardsigmoid_backward_out(*grad_input, *grad_output, *self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_hardtanh(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *min_val = info__[1].As<Napi::External<torch::Scalar>>().Data();
  torch::Scalar *max_val = info__[2].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::hardtanh(*self, *min_val, *max_val);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_hardtanh_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *min_val = info__[2].As<Napi::External<torch::Scalar>>().Data();
  torch::Scalar *max_val = info__[3].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::hardtanh_out(*out, *self, *min_val, *max_val);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_hardtanh_backward(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *grad_output = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *min_val = info__[2].As<Napi::External<torch::Scalar>>().Data();
  torch::Scalar *max_val = info__[3].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::hardtanh_backward(*grad_output, *self, *min_val, *max_val);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_hardtanh_backward_grad_input(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *grad_input = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *grad_output = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *min_val = info__[3].As<Napi::External<torch::Scalar>>().Data();
  torch::Scalar *max_val = info__[4].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::hardtanh_backward_out(*grad_input, *grad_output, *self, *min_val, *max_val);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_hardtanh_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *min_val = info__[1].As<Napi::External<torch::Scalar>>().Data();
  torch::Scalar *max_val = info__[2].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::hardtanh_(*self, *min_val, *max_val);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_hardswish(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::hardswish(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_hardswish_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::hardswish_out(*out, *self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_hardswish_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::hardswish_(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_hardswish_backward(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *grad_output = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::hardswish_backward(*grad_output, *self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_hardswish_backward_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *grad_output = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[2].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::hardswish_backward_out(*out, *grad_output, *self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_leaky_relu(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *negative_slope = info__[1].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::leaky_relu(*self, *negative_slope);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_leaky_relu_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *negative_slope = info__[2].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::leaky_relu_out(*out, *self, *negative_slope);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_leaky_relu_backward(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *grad_output = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *negative_slope = info__[2].As<Napi::External<torch::Scalar>>().Data();
  bool self_is_result = info__[3].As<Napi::Boolean>().Value();
  auto output__ = torch::leaky_relu_backward(*grad_output, *self, *negative_slope, self_is_result);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_leaky_relu_backward_grad_input(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *grad_input = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *grad_output = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *negative_slope = info__[3].As<Napi::External<torch::Scalar>>().Data();
  bool self_is_result = info__[4].As<Napi::Boolean>().Value();
  auto output__ = torch::leaky_relu_backward_out(*grad_input, *grad_output, *self, *negative_slope, self_is_result);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_leaky_relu_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *negative_slope = info__[1].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::leaky_relu_(*self, *negative_slope);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_log_sigmoid(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::log_sigmoid(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_log_sigmoid_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::log_sigmoid_out(*out, *self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_log_sigmoid_backward(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *grad_output = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *buffer = info__[2].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::log_sigmoid_backward(*grad_output, *self, *buffer);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_log_sigmoid_backward_grad_input(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *grad_input = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *grad_output = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *buffer = info__[3].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::log_sigmoid_backward_out(*grad_input, *grad_output, *self, *buffer);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_rrelu_with_noise(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *noise = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *lower = info__[2].As<Napi::External<torch::Scalar>>().Data();
  torch::Scalar *upper = info__[3].As<Napi::External<torch::Scalar>>().Data();
  bool training = info__[4].As<Napi::Boolean>().Value();
  auto output__ = torch::rrelu_with_noise(*self, *noise, *lower, *upper, training);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_rrelu_with_noise_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *noise = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *lower = info__[3].As<Napi::External<torch::Scalar>>().Data();
  torch::Scalar *upper = info__[4].As<Napi::External<torch::Scalar>>().Data();
  bool training = info__[5].As<Napi::Boolean>().Value();
  auto output__ = torch::rrelu_with_noise_out(*out, *self, *noise, *lower, *upper, training);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_rrelu_with_noise_backward(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *grad_output = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *noise = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *lower = info__[3].As<Napi::External<torch::Scalar>>().Data();
  torch::Scalar *upper = info__[4].As<Napi::External<torch::Scalar>>().Data();
  bool training = info__[5].As<Napi::Boolean>().Value();
  bool self_is_result = info__[6].As<Napi::Boolean>().Value();
  auto output__ = torch::rrelu_with_noise_backward(*grad_output, *self, *noise, *lower, *upper, training, self_is_result);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_rrelu_with_noise_backward_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *grad_output = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *noise = info__[3].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *lower = info__[4].As<Napi::External<torch::Scalar>>().Data();
  torch::Scalar *upper = info__[5].As<Napi::External<torch::Scalar>>().Data();
  bool training = info__[6].As<Napi::Boolean>().Value();
  bool self_is_result = info__[7].As<Napi::Boolean>().Value();
  auto output__ = torch::rrelu_with_noise_backward_out(*out, *grad_output, *self, *noise, *lower, *upper, training, self_is_result);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_rrelu_with_noise_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *noise = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *lower = info__[2].As<Napi::External<torch::Scalar>>().Data();
  torch::Scalar *upper = info__[3].As<Napi::External<torch::Scalar>>().Data();
  bool training = info__[4].As<Napi::Boolean>().Value();
  auto output__ = torch::rrelu_with_noise_(*self, *noise, *lower, *upper, training);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_softplus(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *beta = info__[1].As<Napi::External<torch::Scalar>>().Data();
  torch::Scalar *threshold = info__[2].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::softplus(*self, *beta, *threshold);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_softplus_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *beta = info__[2].As<Napi::External<torch::Scalar>>().Data();
  torch::Scalar *threshold = info__[3].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::softplus_out(*out, *self, *beta, *threshold);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_softplus_backward(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *grad_output = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *beta = info__[2].As<Napi::External<torch::Scalar>>().Data();
  torch::Scalar *threshold = info__[3].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::softplus_backward(*grad_output, *self, *beta, *threshold);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_softplus_backward_grad_input(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *grad_input = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *grad_output = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *beta = info__[3].As<Napi::External<torch::Scalar>>().Data();
  torch::Scalar *threshold = info__[4].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::softplus_backward_out(*grad_input, *grad_output, *self, *beta, *threshold);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_softshrink(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *lambd = info__[1].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::softshrink(*self, *lambd);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_softshrink_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *lambd = info__[2].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::softshrink_out(*out, *self, *lambd);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_softshrink_backward(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *grad_output = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *lambd = info__[2].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::softshrink_backward(*grad_output, *self, *lambd);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_softshrink_backward_grad_input(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *grad_input = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *grad_output = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *lambd = info__[3].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::softshrink_backward_out(*grad_input, *grad_output, *self, *lambd);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_adaptive_avg_pool2d(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array output_size_array__ = info__[1].As<Napi::Array>();
  int output_size_len = output_size_array__.Length();
  int64_t *output_size_data = new int64_t[output_size_len];
  for (int i = 0; i < output_size_len; ++i)
    output_size_data[i] = output_size_array__.Get(i).ToNumber().Int64Value();
  auto output__ = torch::adaptive_avg_pool2d(*self, torch::IntArrayRef(output_size_data, output_size_len));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_adaptive_avg_pool2d_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array output_size_array__ = info__[2].As<Napi::Array>();
  int output_size_len = output_size_array__.Length();
  int64_t *output_size_data = new int64_t[output_size_len];
  for (int i = 0; i < output_size_len; ++i)
    output_size_data[i] = output_size_array__.Get(i).ToNumber().Int64Value();
  auto output__ = torch::adaptive_avg_pool2d_out(*out, *self, torch::IntArrayRef(output_size_data, output_size_len));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_mkldnn_adaptive_avg_pool2d(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array output_size_array__ = info__[1].As<Napi::Array>();
  int output_size_len = output_size_array__.Length();
  int64_t *output_size_data = new int64_t[output_size_len];
  for (int i = 0; i < output_size_len; ++i)
    output_size_data[i] = output_size_array__.Get(i).ToNumber().Int64Value();
  auto output__ = torch::mkldnn_adaptive_avg_pool2d(*self, torch::IntArrayRef(output_size_data, output_size_len));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_mkldnn_adaptive_avg_pool2d_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array output_size_array__ = info__[2].As<Napi::Array>();
  int output_size_len = output_size_array__.Length();
  int64_t *output_size_data = new int64_t[output_size_len];
  for (int i = 0; i < output_size_len; ++i)
    output_size_data[i] = output_size_array__.Get(i).ToNumber().Int64Value();
  auto output__ = torch::mkldnn_adaptive_avg_pool2d_out(*out, *self, torch::IntArrayRef(output_size_data, output_size_len));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_mkldnn_adaptive_avg_pool2d_backward(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *grad_output = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::mkldnn_adaptive_avg_pool2d_backward(*grad_output, *self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_mkldnn_adaptive_avg_pool2d_backward_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *grad_output = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[2].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::mkldnn_adaptive_avg_pool2d_backward_out(*out, *grad_output, *self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__adaptive_avg_pool2d(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array output_size_array__ = info__[1].As<Napi::Array>();
  int output_size_len = output_size_array__.Length();
  int64_t *output_size_data = new int64_t[output_size_len];
  for (int i = 0; i < output_size_len; ++i)
    output_size_data[i] = output_size_array__.Get(i).ToNumber().Int64Value();
  auto output__ = torch::_adaptive_avg_pool2d(*self, torch::IntArrayRef(output_size_data, output_size_len));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__adaptive_avg_pool2d_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array output_size_array__ = info__[2].As<Napi::Array>();
  int output_size_len = output_size_array__.Length();
  int64_t *output_size_data = new int64_t[output_size_len];
  for (int i = 0; i < output_size_len; ++i)
    output_size_data[i] = output_size_array__.Get(i).ToNumber().Int64Value();
  auto output__ = torch::_adaptive_avg_pool2d_out(*out, *self, torch::IntArrayRef(output_size_data, output_size_len));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__adaptive_avg_pool2d_backward(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *grad_output = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::_adaptive_avg_pool2d_backward(*grad_output, *self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__adaptive_avg_pool2d_backward_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *grad_output = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[2].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::_adaptive_avg_pool2d_backward_out(*out, *grad_output, *self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_adaptive_avg_pool3d(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array output_size_array__ = info__[1].As<Napi::Array>();
  int output_size_len = output_size_array__.Length();
  int64_t *output_size_data = new int64_t[output_size_len];
  for (int i = 0; i < output_size_len; ++i)
    output_size_data[i] = output_size_array__.Get(i).ToNumber().Int64Value();
  auto output__ = torch::adaptive_avg_pool3d(*self, torch::IntArrayRef(output_size_data, output_size_len));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_adaptive_avg_pool3d_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array output_size_array__ = info__[2].As<Napi::Array>();
  int output_size_len = output_size_array__.Length();
  int64_t *output_size_data = new int64_t[output_size_len];
  for (int i = 0; i < output_size_len; ++i)
    output_size_data[i] = output_size_array__.Get(i).ToNumber().Int64Value();
  auto output__ = torch::adaptive_avg_pool3d_out(*out, *self, torch::IntArrayRef(output_size_data, output_size_len));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__adaptive_avg_pool3d(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array output_size_array__ = info__[1].As<Napi::Array>();
  int output_size_len = output_size_array__.Length();
  int64_t *output_size_data = new int64_t[output_size_len];
  for (int i = 0; i < output_size_len; ++i)
    output_size_data[i] = output_size_array__.Get(i).ToNumber().Int64Value();
  auto output__ = torch::_adaptive_avg_pool3d(*self, torch::IntArrayRef(output_size_data, output_size_len));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__adaptive_avg_pool3d_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array output_size_array__ = info__[2].As<Napi::Array>();
  int output_size_len = output_size_array__.Length();
  int64_t *output_size_data = new int64_t[output_size_len];
  for (int i = 0; i < output_size_len; ++i)
    output_size_data[i] = output_size_array__.Get(i).ToNumber().Int64Value();
  auto output__ = torch::_adaptive_avg_pool3d_out(*out, *self, torch::IntArrayRef(output_size_data, output_size_len));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_adaptive_avg_pool3d_backward(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *grad_input = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *grad_output = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[2].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::adaptive_avg_pool3d_backward_out(*grad_input, *grad_output, *self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__adaptive_avg_pool3d_backward(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *grad_output = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::_adaptive_avg_pool3d_backward(*grad_output, *self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__adaptive_avg_pool3d_backward_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *grad_output = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[2].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::_adaptive_avg_pool3d_backward_out(*out, *grad_output, *self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::Array atg_adaptive_max_pool2d(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array output_size_array__ = info__[1].As<Napi::Array>();
  int output_size_len = output_size_array__.Length();
  int64_t *output_size_data = new int64_t[output_size_len];
  for (int i = 0; i < output_size_len; ++i)
    output_size_data[i] = output_size_array__.Get(i).ToNumber().Int64Value();
  auto output__ = torch::adaptive_max_pool2d(*self, torch::IntArrayRef(output_size_data, output_size_len));
  Napi::Array output__array__ = Napi::Array::New(env__, 2);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  return output__array__;
}

Napi::Array atg_adaptive_max_pool2d_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *indices = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[2].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array output_size_array__ = info__[3].As<Napi::Array>();
  int output_size_len = output_size_array__.Length();
  int64_t *output_size_data = new int64_t[output_size_len];
  for (int i = 0; i < output_size_len; ++i)
    output_size_data[i] = output_size_array__.Get(i).ToNumber().Int64Value();
  auto output__ = torch::adaptive_max_pool2d_out(*out, *indices, *self, torch::IntArrayRef(output_size_data, output_size_len));
  Napi::Array output__array__ = Napi::Array::New(env__, 2);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  return output__array__;
}

Napi::External<torch::Tensor> atg_adaptive_max_pool2d_backward(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *grad_output = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *indices = info__[2].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::adaptive_max_pool2d_backward(*grad_output, *self, *indices);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_adaptive_max_pool2d_backward_grad_input(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *grad_input = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *grad_output = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *indices = info__[3].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::adaptive_max_pool2d_backward_out(*grad_input, *grad_output, *self, *indices);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::Array atg_adaptive_max_pool3d(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array output_size_array__ = info__[1].As<Napi::Array>();
  int output_size_len = output_size_array__.Length();
  int64_t *output_size_data = new int64_t[output_size_len];
  for (int i = 0; i < output_size_len; ++i)
    output_size_data[i] = output_size_array__.Get(i).ToNumber().Int64Value();
  auto output__ = torch::adaptive_max_pool3d(*self, torch::IntArrayRef(output_size_data, output_size_len));
  Napi::Array output__array__ = Napi::Array::New(env__, 2);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  return output__array__;
}

Napi::Array atg_adaptive_max_pool3d_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *indices = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[2].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array output_size_array__ = info__[3].As<Napi::Array>();
  int output_size_len = output_size_array__.Length();
  int64_t *output_size_data = new int64_t[output_size_len];
  for (int i = 0; i < output_size_len; ++i)
    output_size_data[i] = output_size_array__.Get(i).ToNumber().Int64Value();
  auto output__ = torch::adaptive_max_pool3d_out(*out, *indices, *self, torch::IntArrayRef(output_size_data, output_size_len));
  Napi::Array output__array__ = Napi::Array::New(env__, 2);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  return output__array__;
}

Napi::External<torch::Tensor> atg_adaptive_max_pool3d_backward(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *grad_output = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *indices = info__[2].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::adaptive_max_pool3d_backward(*grad_output, *self, *indices);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_adaptive_max_pool3d_backward_grad_input(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *grad_input = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *grad_output = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *indices = info__[3].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::adaptive_max_pool3d_backward_out(*grad_input, *grad_output, *self, *indices);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_avg_pool2d(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array kernel_size_array__ = info__[1].As<Napi::Array>();
  int kernel_size_len = kernel_size_array__.Length();
  int64_t *kernel_size_data = new int64_t[kernel_size_len];
  for (int i = 0; i < kernel_size_len; ++i)
    kernel_size_data[i] = kernel_size_array__.Get(i).ToNumber().Int64Value();
  Napi::Array stride_array__ = info__[2].As<Napi::Array>();
  int stride_len = stride_array__.Length();
  int64_t *stride_data = new int64_t[stride_len];
  for (int i = 0; i < stride_len; ++i)
    stride_data[i] = stride_array__.Get(i).ToNumber().Int64Value();
  Napi::Array padding_array__ = info__[3].As<Napi::Array>();
  int padding_len = padding_array__.Length();
  int64_t *padding_data = new int64_t[padding_len];
  for (int i = 0; i < padding_len; ++i)
    padding_data[i] = padding_array__.Get(i).ToNumber().Int64Value();
  bool ceil_mode = info__[4].As<Napi::Boolean>().Value();
  bool count_include_pad = info__[5].As<Napi::Boolean>().Value();
  bool divisor_override_null = info__[6].IsUndefined();
  int64_t divisor_override_v = divisor_override_null ? 0 : info__[6].As<Napi::Number>().Int64Value();
  auto output__ = torch::avg_pool2d(*self, torch::IntArrayRef(kernel_size_data, kernel_size_len), torch::IntArrayRef(stride_data, stride_len), torch::IntArrayRef(padding_data, padding_len), ceil_mode, count_include_pad, divisor_override_null ? c10::nullopt : c10::optional<int64_t>(divisor_override_v));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_avg_pool2d_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array kernel_size_array__ = info__[2].As<Napi::Array>();
  int kernel_size_len = kernel_size_array__.Length();
  int64_t *kernel_size_data = new int64_t[kernel_size_len];
  for (int i = 0; i < kernel_size_len; ++i)
    kernel_size_data[i] = kernel_size_array__.Get(i).ToNumber().Int64Value();
  Napi::Array stride_array__ = info__[3].As<Napi::Array>();
  int stride_len = stride_array__.Length();
  int64_t *stride_data = new int64_t[stride_len];
  for (int i = 0; i < stride_len; ++i)
    stride_data[i] = stride_array__.Get(i).ToNumber().Int64Value();
  Napi::Array padding_array__ = info__[4].As<Napi::Array>();
  int padding_len = padding_array__.Length();
  int64_t *padding_data = new int64_t[padding_len];
  for (int i = 0; i < padding_len; ++i)
    padding_data[i] = padding_array__.Get(i).ToNumber().Int64Value();
  bool ceil_mode = info__[5].As<Napi::Boolean>().Value();
  bool count_include_pad = info__[6].As<Napi::Boolean>().Value();
  bool divisor_override_null = info__[7].IsUndefined();
  int64_t divisor_override_v = divisor_override_null ? 0 : info__[7].As<Napi::Number>().Int64Value();
  auto output__ = torch::avg_pool2d_out(*out, *self, torch::IntArrayRef(kernel_size_data, kernel_size_len), torch::IntArrayRef(stride_data, stride_len), torch::IntArrayRef(padding_data, padding_len), ceil_mode, count_include_pad, divisor_override_null ? c10::nullopt : c10::optional<int64_t>(divisor_override_v));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_avg_pool2d_backward(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *grad_output = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array kernel_size_array__ = info__[2].As<Napi::Array>();
  int kernel_size_len = kernel_size_array__.Length();
  int64_t *kernel_size_data = new int64_t[kernel_size_len];
  for (int i = 0; i < kernel_size_len; ++i)
    kernel_size_data[i] = kernel_size_array__.Get(i).ToNumber().Int64Value();
  Napi::Array stride_array__ = info__[3].As<Napi::Array>();
  int stride_len = stride_array__.Length();
  int64_t *stride_data = new int64_t[stride_len];
  for (int i = 0; i < stride_len; ++i)
    stride_data[i] = stride_array__.Get(i).ToNumber().Int64Value();
  Napi::Array padding_array__ = info__[4].As<Napi::Array>();
  int padding_len = padding_array__.Length();
  int64_t *padding_data = new int64_t[padding_len];
  for (int i = 0; i < padding_len; ++i)
    padding_data[i] = padding_array__.Get(i).ToNumber().Int64Value();
  bool ceil_mode = info__[5].As<Napi::Boolean>().Value();
  bool count_include_pad = info__[6].As<Napi::Boolean>().Value();
  bool divisor_override_null = info__[7].IsUndefined();
  int64_t divisor_override_v = divisor_override_null ? 0 : info__[7].As<Napi::Number>().Int64Value();
  auto output__ = torch::avg_pool2d_backward(*grad_output, *self, torch::IntArrayRef(kernel_size_data, kernel_size_len), torch::IntArrayRef(stride_data, stride_len), torch::IntArrayRef(padding_data, padding_len), ceil_mode, count_include_pad, divisor_override_null ? c10::nullopt : c10::optional<int64_t>(divisor_override_v));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_avg_pool2d_backward_grad_input(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *grad_input = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *grad_output = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[2].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array kernel_size_array__ = info__[3].As<Napi::Array>();
  int kernel_size_len = kernel_size_array__.Length();
  int64_t *kernel_size_data = new int64_t[kernel_size_len];
  for (int i = 0; i < kernel_size_len; ++i)
    kernel_size_data[i] = kernel_size_array__.Get(i).ToNumber().Int64Value();
  Napi::Array stride_array__ = info__[4].As<Napi::Array>();
  int stride_len = stride_array__.Length();
  int64_t *stride_data = new int64_t[stride_len];
  for (int i = 0; i < stride_len; ++i)
    stride_data[i] = stride_array__.Get(i).ToNumber().Int64Value();
  Napi::Array padding_array__ = info__[5].As<Napi::Array>();
  int padding_len = padding_array__.Length();
  int64_t *padding_data = new int64_t[padding_len];
  for (int i = 0; i < padding_len; ++i)
    padding_data[i] = padding_array__.Get(i).ToNumber().Int64Value();
  bool ceil_mode = info__[6].As<Napi::Boolean>().Value();
  bool count_include_pad = info__[7].As<Napi::Boolean>().Value();
  bool divisor_override_null = info__[8].IsUndefined();
  int64_t divisor_override_v = divisor_override_null ? 0 : info__[8].As<Napi::Number>().Int64Value();
  auto output__ = torch::avg_pool2d_backward_out(*grad_input, *grad_output, *self, torch::IntArrayRef(kernel_size_data, kernel_size_len), torch::IntArrayRef(stride_data, stride_len), torch::IntArrayRef(padding_data, padding_len), ceil_mode, count_include_pad, divisor_override_null ? c10::nullopt : c10::optional<int64_t>(divisor_override_v));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_avg_pool3d(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array kernel_size_array__ = info__[1].As<Napi::Array>();
  int kernel_size_len = kernel_size_array__.Length();
  int64_t *kernel_size_data = new int64_t[kernel_size_len];
  for (int i = 0; i < kernel_size_len; ++i)
    kernel_size_data[i] = kernel_size_array__.Get(i).ToNumber().Int64Value();
  Napi::Array stride_array__ = info__[2].As<Napi::Array>();
  int stride_len = stride_array__.Length();
  int64_t *stride_data = new int64_t[stride_len];
  for (int i = 0; i < stride_len; ++i)
    stride_data[i] = stride_array__.Get(i).ToNumber().Int64Value();
  Napi::Array padding_array__ = info__[3].As<Napi::Array>();
  int padding_len = padding_array__.Length();
  int64_t *padding_data = new int64_t[padding_len];
  for (int i = 0; i < padding_len; ++i)
    padding_data[i] = padding_array__.Get(i).ToNumber().Int64Value();
  bool ceil_mode = info__[4].As<Napi::Boolean>().Value();
  bool count_include_pad = info__[5].As<Napi::Boolean>().Value();
  bool divisor_override_null = info__[6].IsUndefined();
  int64_t divisor_override_v = divisor_override_null ? 0 : info__[6].As<Napi::Number>().Int64Value();
  auto output__ = torch::avg_pool3d(*self, torch::IntArrayRef(kernel_size_data, kernel_size_len), torch::IntArrayRef(stride_data, stride_len), torch::IntArrayRef(padding_data, padding_len), ceil_mode, count_include_pad, divisor_override_null ? c10::nullopt : c10::optional<int64_t>(divisor_override_v));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_avg_pool3d_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array kernel_size_array__ = info__[2].As<Napi::Array>();
  int kernel_size_len = kernel_size_array__.Length();
  int64_t *kernel_size_data = new int64_t[kernel_size_len];
  for (int i = 0; i < kernel_size_len; ++i)
    kernel_size_data[i] = kernel_size_array__.Get(i).ToNumber().Int64Value();
  Napi::Array stride_array__ = info__[3].As<Napi::Array>();
  int stride_len = stride_array__.Length();
  int64_t *stride_data = new int64_t[stride_len];
  for (int i = 0; i < stride_len; ++i)
    stride_data[i] = stride_array__.Get(i).ToNumber().Int64Value();
  Napi::Array padding_array__ = info__[4].As<Napi::Array>();
  int padding_len = padding_array__.Length();
  int64_t *padding_data = new int64_t[padding_len];
  for (int i = 0; i < padding_len; ++i)
    padding_data[i] = padding_array__.Get(i).ToNumber().Int64Value();
  bool ceil_mode = info__[5].As<Napi::Boolean>().Value();
  bool count_include_pad = info__[6].As<Napi::Boolean>().Value();
  bool divisor_override_null = info__[7].IsUndefined();
  int64_t divisor_override_v = divisor_override_null ? 0 : info__[7].As<Napi::Number>().Int64Value();
  auto output__ = torch::avg_pool3d_out(*out, *self, torch::IntArrayRef(kernel_size_data, kernel_size_len), torch::IntArrayRef(stride_data, stride_len), torch::IntArrayRef(padding_data, padding_len), ceil_mode, count_include_pad, divisor_override_null ? c10::nullopt : c10::optional<int64_t>(divisor_override_v));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_avg_pool3d_backward(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *grad_output = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array kernel_size_array__ = info__[2].As<Napi::Array>();
  int kernel_size_len = kernel_size_array__.Length();
  int64_t *kernel_size_data = new int64_t[kernel_size_len];
  for (int i = 0; i < kernel_size_len; ++i)
    kernel_size_data[i] = kernel_size_array__.Get(i).ToNumber().Int64Value();
  Napi::Array stride_array__ = info__[3].As<Napi::Array>();
  int stride_len = stride_array__.Length();
  int64_t *stride_data = new int64_t[stride_len];
  for (int i = 0; i < stride_len; ++i)
    stride_data[i] = stride_array__.Get(i).ToNumber().Int64Value();
  Napi::Array padding_array__ = info__[4].As<Napi::Array>();
  int padding_len = padding_array__.Length();
  int64_t *padding_data = new int64_t[padding_len];
  for (int i = 0; i < padding_len; ++i)
    padding_data[i] = padding_array__.Get(i).ToNumber().Int64Value();
  bool ceil_mode = info__[5].As<Napi::Boolean>().Value();
  bool count_include_pad = info__[6].As<Napi::Boolean>().Value();
  bool divisor_override_null = info__[7].IsUndefined();
  int64_t divisor_override_v = divisor_override_null ? 0 : info__[7].As<Napi::Number>().Int64Value();
  auto output__ = torch::avg_pool3d_backward(*grad_output, *self, torch::IntArrayRef(kernel_size_data, kernel_size_len), torch::IntArrayRef(stride_data, stride_len), torch::IntArrayRef(padding_data, padding_len), ceil_mode, count_include_pad, divisor_override_null ? c10::nullopt : c10::optional<int64_t>(divisor_override_v));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_avg_pool3d_backward_grad_input(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *grad_input = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *grad_output = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[2].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array kernel_size_array__ = info__[3].As<Napi::Array>();
  int kernel_size_len = kernel_size_array__.Length();
  int64_t *kernel_size_data = new int64_t[kernel_size_len];
  for (int i = 0; i < kernel_size_len; ++i)
    kernel_size_data[i] = kernel_size_array__.Get(i).ToNumber().Int64Value();
  Napi::Array stride_array__ = info__[4].As<Napi::Array>();
  int stride_len = stride_array__.Length();
  int64_t *stride_data = new int64_t[stride_len];
  for (int i = 0; i < stride_len; ++i)
    stride_data[i] = stride_array__.Get(i).ToNumber().Int64Value();
  Napi::Array padding_array__ = info__[5].As<Napi::Array>();
  int padding_len = padding_array__.Length();
  int64_t *padding_data = new int64_t[padding_len];
  for (int i = 0; i < padding_len; ++i)
    padding_data[i] = padding_array__.Get(i).ToNumber().Int64Value();
  bool ceil_mode = info__[6].As<Napi::Boolean>().Value();
  bool count_include_pad = info__[7].As<Napi::Boolean>().Value();
  bool divisor_override_null = info__[8].IsUndefined();
  int64_t divisor_override_v = divisor_override_null ? 0 : info__[8].As<Napi::Number>().Int64Value();
  auto output__ = torch::avg_pool3d_backward_out(*grad_input, *grad_output, *self, torch::IntArrayRef(kernel_size_data, kernel_size_len), torch::IntArrayRef(stride_data, stride_len), torch::IntArrayRef(padding_data, padding_len), ceil_mode, count_include_pad, divisor_override_null ? c10::nullopt : c10::optional<int64_t>(divisor_override_v));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::Array atg_fractional_max_pool2d(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array kernel_size_array__ = info__[1].As<Napi::Array>();
  int kernel_size_len = kernel_size_array__.Length();
  int64_t *kernel_size_data = new int64_t[kernel_size_len];
  for (int i = 0; i < kernel_size_len; ++i)
    kernel_size_data[i] = kernel_size_array__.Get(i).ToNumber().Int64Value();
  Napi::Array output_size_array__ = info__[2].As<Napi::Array>();
  int output_size_len = output_size_array__.Length();
  int64_t *output_size_data = new int64_t[output_size_len];
  for (int i = 0; i < output_size_len; ++i)
    output_size_data[i] = output_size_array__.Get(i).ToNumber().Int64Value();
  torch::Tensor *random_samples = info__[3].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::fractional_max_pool2d(*self, torch::IntArrayRef(kernel_size_data, kernel_size_len), torch::IntArrayRef(output_size_data, output_size_len), *random_samples);
  Napi::Array output__array__ = Napi::Array::New(env__, 2);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  return output__array__;
}

Napi::Array atg_fractional_max_pool2d_output(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *output = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *indices = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[2].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array kernel_size_array__ = info__[3].As<Napi::Array>();
  int kernel_size_len = kernel_size_array__.Length();
  int64_t *kernel_size_data = new int64_t[kernel_size_len];
  for (int i = 0; i < kernel_size_len; ++i)
    kernel_size_data[i] = kernel_size_array__.Get(i).ToNumber().Int64Value();
  Napi::Array output_size_array__ = info__[4].As<Napi::Array>();
  int output_size_len = output_size_array__.Length();
  int64_t *output_size_data = new int64_t[output_size_len];
  for (int i = 0; i < output_size_len; ++i)
    output_size_data[i] = output_size_array__.Get(i).ToNumber().Int64Value();
  torch::Tensor *random_samples = info__[5].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::fractional_max_pool2d_out(*output, *indices, *self, torch::IntArrayRef(kernel_size_data, kernel_size_len), torch::IntArrayRef(output_size_data, output_size_len), *random_samples);
  Napi::Array output__array__ = Napi::Array::New(env__, 2);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  return output__array__;
}

Napi::External<torch::Tensor> atg_fractional_max_pool2d_backward(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *grad_output = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array kernel_size_array__ = info__[2].As<Napi::Array>();
  int kernel_size_len = kernel_size_array__.Length();
  int64_t *kernel_size_data = new int64_t[kernel_size_len];
  for (int i = 0; i < kernel_size_len; ++i)
    kernel_size_data[i] = kernel_size_array__.Get(i).ToNumber().Int64Value();
  Napi::Array output_size_array__ = info__[3].As<Napi::Array>();
  int output_size_len = output_size_array__.Length();
  int64_t *output_size_data = new int64_t[output_size_len];
  for (int i = 0; i < output_size_len; ++i)
    output_size_data[i] = output_size_array__.Get(i).ToNumber().Int64Value();
  torch::Tensor *indices = info__[4].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::fractional_max_pool2d_backward(*grad_output, *self, torch::IntArrayRef(kernel_size_data, kernel_size_len), torch::IntArrayRef(output_size_data, output_size_len), *indices);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_fractional_max_pool2d_backward_grad_input(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *grad_input = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *grad_output = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[2].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array kernel_size_array__ = info__[3].As<Napi::Array>();
  int kernel_size_len = kernel_size_array__.Length();
  int64_t *kernel_size_data = new int64_t[kernel_size_len];
  for (int i = 0; i < kernel_size_len; ++i)
    kernel_size_data[i] = kernel_size_array__.Get(i).ToNumber().Int64Value();
  Napi::Array output_size_array__ = info__[4].As<Napi::Array>();
  int output_size_len = output_size_array__.Length();
  int64_t *output_size_data = new int64_t[output_size_len];
  for (int i = 0; i < output_size_len; ++i)
    output_size_data[i] = output_size_array__.Get(i).ToNumber().Int64Value();
  torch::Tensor *indices = info__[5].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::fractional_max_pool2d_backward_out(*grad_input, *grad_output, *self, torch::IntArrayRef(kernel_size_data, kernel_size_len), torch::IntArrayRef(output_size_data, output_size_len), *indices);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::Array atg_fractional_max_pool3d(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array kernel_size_array__ = info__[1].As<Napi::Array>();
  int kernel_size_len = kernel_size_array__.Length();
  int64_t *kernel_size_data = new int64_t[kernel_size_len];
  for (int i = 0; i < kernel_size_len; ++i)
    kernel_size_data[i] = kernel_size_array__.Get(i).ToNumber().Int64Value();
  Napi::Array output_size_array__ = info__[2].As<Napi::Array>();
  int output_size_len = output_size_array__.Length();
  int64_t *output_size_data = new int64_t[output_size_len];
  for (int i = 0; i < output_size_len; ++i)
    output_size_data[i] = output_size_array__.Get(i).ToNumber().Int64Value();
  torch::Tensor *random_samples = info__[3].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::fractional_max_pool3d(*self, torch::IntArrayRef(kernel_size_data, kernel_size_len), torch::IntArrayRef(output_size_data, output_size_len), *random_samples);
  Napi::Array output__array__ = Napi::Array::New(env__, 2);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  return output__array__;
}

Napi::Array atg_fractional_max_pool3d_output(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *output = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *indices = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[2].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array kernel_size_array__ = info__[3].As<Napi::Array>();
  int kernel_size_len = kernel_size_array__.Length();
  int64_t *kernel_size_data = new int64_t[kernel_size_len];
  for (int i = 0; i < kernel_size_len; ++i)
    kernel_size_data[i] = kernel_size_array__.Get(i).ToNumber().Int64Value();
  Napi::Array output_size_array__ = info__[4].As<Napi::Array>();
  int output_size_len = output_size_array__.Length();
  int64_t *output_size_data = new int64_t[output_size_len];
  for (int i = 0; i < output_size_len; ++i)
    output_size_data[i] = output_size_array__.Get(i).ToNumber().Int64Value();
  torch::Tensor *random_samples = info__[5].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::fractional_max_pool3d_out(*output, *indices, *self, torch::IntArrayRef(kernel_size_data, kernel_size_len), torch::IntArrayRef(output_size_data, output_size_len), *random_samples);
  Napi::Array output__array__ = Napi::Array::New(env__, 2);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  return output__array__;
}

Napi::External<torch::Tensor> atg_fractional_max_pool3d_backward(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *grad_output = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array kernel_size_array__ = info__[2].As<Napi::Array>();
  int kernel_size_len = kernel_size_array__.Length();
  int64_t *kernel_size_data = new int64_t[kernel_size_len];
  for (int i = 0; i < kernel_size_len; ++i)
    kernel_size_data[i] = kernel_size_array__.Get(i).ToNumber().Int64Value();
  Napi::Array output_size_array__ = info__[3].As<Napi::Array>();
  int output_size_len = output_size_array__.Length();
  int64_t *output_size_data = new int64_t[output_size_len];
  for (int i = 0; i < output_size_len; ++i)
    output_size_data[i] = output_size_array__.Get(i).ToNumber().Int64Value();
  torch::Tensor *indices = info__[4].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::fractional_max_pool3d_backward(*grad_output, *self, torch::IntArrayRef(kernel_size_data, kernel_size_len), torch::IntArrayRef(output_size_data, output_size_len), *indices);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_fractional_max_pool3d_backward_grad_input(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *grad_input = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *grad_output = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[2].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array kernel_size_array__ = info__[3].As<Napi::Array>();
  int kernel_size_len = kernel_size_array__.Length();
  int64_t *kernel_size_data = new int64_t[kernel_size_len];
  for (int i = 0; i < kernel_size_len; ++i)
    kernel_size_data[i] = kernel_size_array__.Get(i).ToNumber().Int64Value();
  Napi::Array output_size_array__ = info__[4].As<Napi::Array>();
  int output_size_len = output_size_array__.Length();
  int64_t *output_size_data = new int64_t[output_size_len];
  for (int i = 0; i < output_size_len; ++i)
    output_size_data[i] = output_size_array__.Get(i).ToNumber().Int64Value();
  torch::Tensor *indices = info__[5].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::fractional_max_pool3d_backward_out(*grad_input, *grad_output, *self, torch::IntArrayRef(kernel_size_data, kernel_size_len), torch::IntArrayRef(output_size_data, output_size_len), *indices);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::Array atg_max_pool2d_with_indices(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array kernel_size_array__ = info__[1].As<Napi::Array>();
  int kernel_size_len = kernel_size_array__.Length();
  int64_t *kernel_size_data = new int64_t[kernel_size_len];
  for (int i = 0; i < kernel_size_len; ++i)
    kernel_size_data[i] = kernel_size_array__.Get(i).ToNumber().Int64Value();
  Napi::Array stride_array__ = info__[2].As<Napi::Array>();
  int stride_len = stride_array__.Length();
  int64_t *stride_data = new int64_t[stride_len];
  for (int i = 0; i < stride_len; ++i)
    stride_data[i] = stride_array__.Get(i).ToNumber().Int64Value();
  Napi::Array padding_array__ = info__[3].As<Napi::Array>();
  int padding_len = padding_array__.Length();
  int64_t *padding_data = new int64_t[padding_len];
  for (int i = 0; i < padding_len; ++i)
    padding_data[i] = padding_array__.Get(i).ToNumber().Int64Value();
  Napi::Array dilation_array__ = info__[4].As<Napi::Array>();
  int dilation_len = dilation_array__.Length();
  int64_t *dilation_data = new int64_t[dilation_len];
  for (int i = 0; i < dilation_len; ++i)
    dilation_data[i] = dilation_array__.Get(i).ToNumber().Int64Value();
  bool ceil_mode = info__[5].As<Napi::Boolean>().Value();
  auto output__ = torch::max_pool2d_with_indices(*self, torch::IntArrayRef(kernel_size_data, kernel_size_len), torch::IntArrayRef(stride_data, stride_len), torch::IntArrayRef(padding_data, padding_len), torch::IntArrayRef(dilation_data, dilation_len), ceil_mode);
  Napi::Array output__array__ = Napi::Array::New(env__, 2);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  return output__array__;
}

Napi::Array atg_max_pool2d_with_indices_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *indices = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[2].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array kernel_size_array__ = info__[3].As<Napi::Array>();
  int kernel_size_len = kernel_size_array__.Length();
  int64_t *kernel_size_data = new int64_t[kernel_size_len];
  for (int i = 0; i < kernel_size_len; ++i)
    kernel_size_data[i] = kernel_size_array__.Get(i).ToNumber().Int64Value();
  Napi::Array stride_array__ = info__[4].As<Napi::Array>();
  int stride_len = stride_array__.Length();
  int64_t *stride_data = new int64_t[stride_len];
  for (int i = 0; i < stride_len; ++i)
    stride_data[i] = stride_array__.Get(i).ToNumber().Int64Value();
  Napi::Array padding_array__ = info__[5].As<Napi::Array>();
  int padding_len = padding_array__.Length();
  int64_t *padding_data = new int64_t[padding_len];
  for (int i = 0; i < padding_len; ++i)
    padding_data[i] = padding_array__.Get(i).ToNumber().Int64Value();
  Napi::Array dilation_array__ = info__[6].As<Napi::Array>();
  int dilation_len = dilation_array__.Length();
  int64_t *dilation_data = new int64_t[dilation_len];
  for (int i = 0; i < dilation_len; ++i)
    dilation_data[i] = dilation_array__.Get(i).ToNumber().Int64Value();
  bool ceil_mode = info__[7].As<Napi::Boolean>().Value();
  auto output__ = torch::max_pool2d_with_indices_out(*out, *indices, *self, torch::IntArrayRef(kernel_size_data, kernel_size_len), torch::IntArrayRef(stride_data, stride_len), torch::IntArrayRef(padding_data, padding_len), torch::IntArrayRef(dilation_data, dilation_len), ceil_mode);
  Napi::Array output__array__ = Napi::Array::New(env__, 2);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  return output__array__;
}

Napi::External<torch::Tensor> atg_max_pool2d_with_indices_backward(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *grad_output = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array kernel_size_array__ = info__[2].As<Napi::Array>();
  int kernel_size_len = kernel_size_array__.Length();
  int64_t *kernel_size_data = new int64_t[kernel_size_len];
  for (int i = 0; i < kernel_size_len; ++i)
    kernel_size_data[i] = kernel_size_array__.Get(i).ToNumber().Int64Value();
  Napi::Array stride_array__ = info__[3].As<Napi::Array>();
  int stride_len = stride_array__.Length();
  int64_t *stride_data = new int64_t[stride_len];
  for (int i = 0; i < stride_len; ++i)
    stride_data[i] = stride_array__.Get(i).ToNumber().Int64Value();
  Napi::Array padding_array__ = info__[4].As<Napi::Array>();
  int padding_len = padding_array__.Length();
  int64_t *padding_data = new int64_t[padding_len];
  for (int i = 0; i < padding_len; ++i)
    padding_data[i] = padding_array__.Get(i).ToNumber().Int64Value();
  Napi::Array dilation_array__ = info__[5].As<Napi::Array>();
  int dilation_len = dilation_array__.Length();
  int64_t *dilation_data = new int64_t[dilation_len];
  for (int i = 0; i < dilation_len; ++i)
    dilation_data[i] = dilation_array__.Get(i).ToNumber().Int64Value();
  bool ceil_mode = info__[6].As<Napi::Boolean>().Value();
  torch::Tensor *indices = info__[7].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::max_pool2d_with_indices_backward(*grad_output, *self, torch::IntArrayRef(kernel_size_data, kernel_size_len), torch::IntArrayRef(stride_data, stride_len), torch::IntArrayRef(padding_data, padding_len), torch::IntArrayRef(dilation_data, dilation_len), ceil_mode, *indices);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_max_pool2d_with_indices_backward_grad_input(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *grad_input = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *grad_output = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[2].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array kernel_size_array__ = info__[3].As<Napi::Array>();
  int kernel_size_len = kernel_size_array__.Length();
  int64_t *kernel_size_data = new int64_t[kernel_size_len];
  for (int i = 0; i < kernel_size_len; ++i)
    kernel_size_data[i] = kernel_size_array__.Get(i).ToNumber().Int64Value();
  Napi::Array stride_array__ = info__[4].As<Napi::Array>();
  int stride_len = stride_array__.Length();
  int64_t *stride_data = new int64_t[stride_len];
  for (int i = 0; i < stride_len; ++i)
    stride_data[i] = stride_array__.Get(i).ToNumber().Int64Value();
  Napi::Array padding_array__ = info__[5].As<Napi::Array>();
  int padding_len = padding_array__.Length();
  int64_t *padding_data = new int64_t[padding_len];
  for (int i = 0; i < padding_len; ++i)
    padding_data[i] = padding_array__.Get(i).ToNumber().Int64Value();
  Napi::Array dilation_array__ = info__[6].As<Napi::Array>();
  int dilation_len = dilation_array__.Length();
  int64_t *dilation_data = new int64_t[dilation_len];
  for (int i = 0; i < dilation_len; ++i)
    dilation_data[i] = dilation_array__.Get(i).ToNumber().Int64Value();
  bool ceil_mode = info__[7].As<Napi::Boolean>().Value();
  torch::Tensor *indices = info__[8].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::max_pool2d_with_indices_backward_out(*grad_input, *grad_output, *self, torch::IntArrayRef(kernel_size_data, kernel_size_len), torch::IntArrayRef(stride_data, stride_len), torch::IntArrayRef(padding_data, padding_len), torch::IntArrayRef(dilation_data, dilation_len), ceil_mode, *indices);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::Array atg_max_pool3d_with_indices(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array kernel_size_array__ = info__[1].As<Napi::Array>();
  int kernel_size_len = kernel_size_array__.Length();
  int64_t *kernel_size_data = new int64_t[kernel_size_len];
  for (int i = 0; i < kernel_size_len; ++i)
    kernel_size_data[i] = kernel_size_array__.Get(i).ToNumber().Int64Value();
  Napi::Array stride_array__ = info__[2].As<Napi::Array>();
  int stride_len = stride_array__.Length();
  int64_t *stride_data = new int64_t[stride_len];
  for (int i = 0; i < stride_len; ++i)
    stride_data[i] = stride_array__.Get(i).ToNumber().Int64Value();
  Napi::Array padding_array__ = info__[3].As<Napi::Array>();
  int padding_len = padding_array__.Length();
  int64_t *padding_data = new int64_t[padding_len];
  for (int i = 0; i < padding_len; ++i)
    padding_data[i] = padding_array__.Get(i).ToNumber().Int64Value();
  Napi::Array dilation_array__ = info__[4].As<Napi::Array>();
  int dilation_len = dilation_array__.Length();
  int64_t *dilation_data = new int64_t[dilation_len];
  for (int i = 0; i < dilation_len; ++i)
    dilation_data[i] = dilation_array__.Get(i).ToNumber().Int64Value();
  bool ceil_mode = info__[5].As<Napi::Boolean>().Value();
  auto output__ = torch::max_pool3d_with_indices(*self, torch::IntArrayRef(kernel_size_data, kernel_size_len), torch::IntArrayRef(stride_data, stride_len), torch::IntArrayRef(padding_data, padding_len), torch::IntArrayRef(dilation_data, dilation_len), ceil_mode);
  Napi::Array output__array__ = Napi::Array::New(env__, 2);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  return output__array__;
}

Napi::Array atg_max_pool3d_with_indices_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *indices = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[2].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array kernel_size_array__ = info__[3].As<Napi::Array>();
  int kernel_size_len = kernel_size_array__.Length();
  int64_t *kernel_size_data = new int64_t[kernel_size_len];
  for (int i = 0; i < kernel_size_len; ++i)
    kernel_size_data[i] = kernel_size_array__.Get(i).ToNumber().Int64Value();
  Napi::Array stride_array__ = info__[4].As<Napi::Array>();
  int stride_len = stride_array__.Length();
  int64_t *stride_data = new int64_t[stride_len];
  for (int i = 0; i < stride_len; ++i)
    stride_data[i] = stride_array__.Get(i).ToNumber().Int64Value();
  Napi::Array padding_array__ = info__[5].As<Napi::Array>();
  int padding_len = padding_array__.Length();
  int64_t *padding_data = new int64_t[padding_len];
  for (int i = 0; i < padding_len; ++i)
    padding_data[i] = padding_array__.Get(i).ToNumber().Int64Value();
  Napi::Array dilation_array__ = info__[6].As<Napi::Array>();
  int dilation_len = dilation_array__.Length();
  int64_t *dilation_data = new int64_t[dilation_len];
  for (int i = 0; i < dilation_len; ++i)
    dilation_data[i] = dilation_array__.Get(i).ToNumber().Int64Value();
  bool ceil_mode = info__[7].As<Napi::Boolean>().Value();
  auto output__ = torch::max_pool3d_with_indices_out(*out, *indices, *self, torch::IntArrayRef(kernel_size_data, kernel_size_len), torch::IntArrayRef(stride_data, stride_len), torch::IntArrayRef(padding_data, padding_len), torch::IntArrayRef(dilation_data, dilation_len), ceil_mode);
  Napi::Array output__array__ = Napi::Array::New(env__, 2);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  return output__array__;
}

Napi::External<torch::Tensor> atg_max_pool3d_with_indices_backward(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *grad_output = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array kernel_size_array__ = info__[2].As<Napi::Array>();
  int kernel_size_len = kernel_size_array__.Length();
  int64_t *kernel_size_data = new int64_t[kernel_size_len];
  for (int i = 0; i < kernel_size_len; ++i)
    kernel_size_data[i] = kernel_size_array__.Get(i).ToNumber().Int64Value();
  Napi::Array stride_array__ = info__[3].As<Napi::Array>();
  int stride_len = stride_array__.Length();
  int64_t *stride_data = new int64_t[stride_len];
  for (int i = 0; i < stride_len; ++i)
    stride_data[i] = stride_array__.Get(i).ToNumber().Int64Value();
  Napi::Array padding_array__ = info__[4].As<Napi::Array>();
  int padding_len = padding_array__.Length();
  int64_t *padding_data = new int64_t[padding_len];
  for (int i = 0; i < padding_len; ++i)
    padding_data[i] = padding_array__.Get(i).ToNumber().Int64Value();
  Napi::Array dilation_array__ = info__[5].As<Napi::Array>();
  int dilation_len = dilation_array__.Length();
  int64_t *dilation_data = new int64_t[dilation_len];
  for (int i = 0; i < dilation_len; ++i)
    dilation_data[i] = dilation_array__.Get(i).ToNumber().Int64Value();
  bool ceil_mode = info__[6].As<Napi::Boolean>().Value();
  torch::Tensor *indices = info__[7].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::max_pool3d_with_indices_backward(*grad_output, *self, torch::IntArrayRef(kernel_size_data, kernel_size_len), torch::IntArrayRef(stride_data, stride_len), torch::IntArrayRef(padding_data, padding_len), torch::IntArrayRef(dilation_data, dilation_len), ceil_mode, *indices);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_max_pool3d_with_indices_backward_grad_input(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *grad_input = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *grad_output = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[2].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array kernel_size_array__ = info__[3].As<Napi::Array>();
  int kernel_size_len = kernel_size_array__.Length();
  int64_t *kernel_size_data = new int64_t[kernel_size_len];
  for (int i = 0; i < kernel_size_len; ++i)
    kernel_size_data[i] = kernel_size_array__.Get(i).ToNumber().Int64Value();
  Napi::Array stride_array__ = info__[4].As<Napi::Array>();
  int stride_len = stride_array__.Length();
  int64_t *stride_data = new int64_t[stride_len];
  for (int i = 0; i < stride_len; ++i)
    stride_data[i] = stride_array__.Get(i).ToNumber().Int64Value();
  Napi::Array padding_array__ = info__[5].As<Napi::Array>();
  int padding_len = padding_array__.Length();
  int64_t *padding_data = new int64_t[padding_len];
  for (int i = 0; i < padding_len; ++i)
    padding_data[i] = padding_array__.Get(i).ToNumber().Int64Value();
  Napi::Array dilation_array__ = info__[6].As<Napi::Array>();
  int dilation_len = dilation_array__.Length();
  int64_t *dilation_data = new int64_t[dilation_len];
  for (int i = 0; i < dilation_len; ++i)
    dilation_data[i] = dilation_array__.Get(i).ToNumber().Int64Value();
  bool ceil_mode = info__[7].As<Napi::Boolean>().Value();
  torch::Tensor *indices = info__[8].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::max_pool3d_with_indices_backward_out(*grad_input, *grad_output, *self, torch::IntArrayRef(kernel_size_data, kernel_size_len), torch::IntArrayRef(stride_data, stride_len), torch::IntArrayRef(padding_data, padding_len), torch::IntArrayRef(dilation_data, dilation_len), ceil_mode, *indices);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_max_unpool2d(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *indices = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array output_size_array__ = info__[2].As<Napi::Array>();
  int output_size_len = output_size_array__.Length();
  int64_t *output_size_data = new int64_t[output_size_len];
  for (int i = 0; i < output_size_len; ++i)
    output_size_data[i] = output_size_array__.Get(i).ToNumber().Int64Value();
  auto output__ = torch::max_unpool2d(*self, *indices, torch::IntArrayRef(output_size_data, output_size_len));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_max_unpool2d_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *indices = info__[2].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array output_size_array__ = info__[3].As<Napi::Array>();
  int output_size_len = output_size_array__.Length();
  int64_t *output_size_data = new int64_t[output_size_len];
  for (int i = 0; i < output_size_len; ++i)
    output_size_data[i] = output_size_array__.Get(i).ToNumber().Int64Value();
  auto output__ = torch::max_unpool2d_out(*out, *self, *indices, torch::IntArrayRef(output_size_data, output_size_len));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_max_unpool3d(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *indices = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array output_size_array__ = info__[2].As<Napi::Array>();
  int output_size_len = output_size_array__.Length();
  int64_t *output_size_data = new int64_t[output_size_len];
  for (int i = 0; i < output_size_len; ++i)
    output_size_data[i] = output_size_array__.Get(i).ToNumber().Int64Value();
  Napi::Array stride_array__ = info__[3].As<Napi::Array>();
  int stride_len = stride_array__.Length();
  int64_t *stride_data = new int64_t[stride_len];
  for (int i = 0; i < stride_len; ++i)
    stride_data[i] = stride_array__.Get(i).ToNumber().Int64Value();
  Napi::Array padding_array__ = info__[4].As<Napi::Array>();
  int padding_len = padding_array__.Length();
  int64_t *padding_data = new int64_t[padding_len];
  for (int i = 0; i < padding_len; ++i)
    padding_data[i] = padding_array__.Get(i).ToNumber().Int64Value();
  auto output__ = torch::max_unpool3d(*self, *indices, torch::IntArrayRef(output_size_data, output_size_len), torch::IntArrayRef(stride_data, stride_len), torch::IntArrayRef(padding_data, padding_len));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_max_unpool3d_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *indices = info__[2].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array output_size_array__ = info__[3].As<Napi::Array>();
  int output_size_len = output_size_array__.Length();
  int64_t *output_size_data = new int64_t[output_size_len];
  for (int i = 0; i < output_size_len; ++i)
    output_size_data[i] = output_size_array__.Get(i).ToNumber().Int64Value();
  Napi::Array stride_array__ = info__[4].As<Napi::Array>();
  int stride_len = stride_array__.Length();
  int64_t *stride_data = new int64_t[stride_len];
  for (int i = 0; i < stride_len; ++i)
    stride_data[i] = stride_array__.Get(i).ToNumber().Int64Value();
  Napi::Array padding_array__ = info__[5].As<Napi::Array>();
  int padding_len = padding_array__.Length();
  int64_t *padding_data = new int64_t[padding_len];
  for (int i = 0; i < padding_len; ++i)
    padding_data[i] = padding_array__.Get(i).ToNumber().Int64Value();
  auto output__ = torch::max_unpool3d_out(*out, *self, *indices, torch::IntArrayRef(output_size_data, output_size_len), torch::IntArrayRef(stride_data, stride_len), torch::IntArrayRef(padding_data, padding_len));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_reflection_pad1d(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array padding_array__ = info__[1].As<Napi::Array>();
  int padding_len = padding_array__.Length();
  int64_t *padding_data = new int64_t[padding_len];
  for (int i = 0; i < padding_len; ++i)
    padding_data[i] = padding_array__.Get(i).ToNumber().Int64Value();
  auto output__ = torch::reflection_pad1d(*self, torch::IntArrayRef(padding_data, padding_len));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_reflection_pad1d_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array padding_array__ = info__[2].As<Napi::Array>();
  int padding_len = padding_array__.Length();
  int64_t *padding_data = new int64_t[padding_len];
  for (int i = 0; i < padding_len; ++i)
    padding_data[i] = padding_array__.Get(i).ToNumber().Int64Value();
  auto output__ = torch::reflection_pad1d_out(*out, *self, torch::IntArrayRef(padding_data, padding_len));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_reflection_pad1d_backward(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *grad_output = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array padding_array__ = info__[2].As<Napi::Array>();
  int padding_len = padding_array__.Length();
  int64_t *padding_data = new int64_t[padding_len];
  for (int i = 0; i < padding_len; ++i)
    padding_data[i] = padding_array__.Get(i).ToNumber().Int64Value();
  auto output__ = torch::reflection_pad1d_backward(*grad_output, *self, torch::IntArrayRef(padding_data, padding_len));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_reflection_pad1d_backward_grad_input(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *grad_input = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *grad_output = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[2].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array padding_array__ = info__[3].As<Napi::Array>();
  int padding_len = padding_array__.Length();
  int64_t *padding_data = new int64_t[padding_len];
  for (int i = 0; i < padding_len; ++i)
    padding_data[i] = padding_array__.Get(i).ToNumber().Int64Value();
  auto output__ = torch::reflection_pad1d_backward_out(*grad_input, *grad_output, *self, torch::IntArrayRef(padding_data, padding_len));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_reflection_pad2d(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array padding_array__ = info__[1].As<Napi::Array>();
  int padding_len = padding_array__.Length();
  int64_t *padding_data = new int64_t[padding_len];
  for (int i = 0; i < padding_len; ++i)
    padding_data[i] = padding_array__.Get(i).ToNumber().Int64Value();
  auto output__ = torch::reflection_pad2d(*self, torch::IntArrayRef(padding_data, padding_len));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_reflection_pad2d_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array padding_array__ = info__[2].As<Napi::Array>();
  int padding_len = padding_array__.Length();
  int64_t *padding_data = new int64_t[padding_len];
  for (int i = 0; i < padding_len; ++i)
    padding_data[i] = padding_array__.Get(i).ToNumber().Int64Value();
  auto output__ = torch::reflection_pad2d_out(*out, *self, torch::IntArrayRef(padding_data, padding_len));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_reflection_pad2d_backward(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *grad_output = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array padding_array__ = info__[2].As<Napi::Array>();
  int padding_len = padding_array__.Length();
  int64_t *padding_data = new int64_t[padding_len];
  for (int i = 0; i < padding_len; ++i)
    padding_data[i] = padding_array__.Get(i).ToNumber().Int64Value();
  auto output__ = torch::reflection_pad2d_backward(*grad_output, *self, torch::IntArrayRef(padding_data, padding_len));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_reflection_pad2d_backward_grad_input(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *grad_input = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *grad_output = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[2].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array padding_array__ = info__[3].As<Napi::Array>();
  int padding_len = padding_array__.Length();
  int64_t *padding_data = new int64_t[padding_len];
  for (int i = 0; i < padding_len; ++i)
    padding_data[i] = padding_array__.Get(i).ToNumber().Int64Value();
  auto output__ = torch::reflection_pad2d_backward_out(*grad_input, *grad_output, *self, torch::IntArrayRef(padding_data, padding_len));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_reflection_pad3d(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array padding_array__ = info__[1].As<Napi::Array>();
  int padding_len = padding_array__.Length();
  int64_t *padding_data = new int64_t[padding_len];
  for (int i = 0; i < padding_len; ++i)
    padding_data[i] = padding_array__.Get(i).ToNumber().Int64Value();
  auto output__ = torch::reflection_pad3d(*self, torch::IntArrayRef(padding_data, padding_len));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_reflection_pad3d_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array padding_array__ = info__[2].As<Napi::Array>();
  int padding_len = padding_array__.Length();
  int64_t *padding_data = new int64_t[padding_len];
  for (int i = 0; i < padding_len; ++i)
    padding_data[i] = padding_array__.Get(i).ToNumber().Int64Value();
  auto output__ = torch::reflection_pad3d_out(*out, *self, torch::IntArrayRef(padding_data, padding_len));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_reflection_pad3d_backward(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *grad_output = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array padding_array__ = info__[2].As<Napi::Array>();
  int padding_len = padding_array__.Length();
  int64_t *padding_data = new int64_t[padding_len];
  for (int i = 0; i < padding_len; ++i)
    padding_data[i] = padding_array__.Get(i).ToNumber().Int64Value();
  auto output__ = torch::reflection_pad3d_backward(*grad_output, *self, torch::IntArrayRef(padding_data, padding_len));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_reflection_pad3d_backward_grad_input(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *grad_input = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *grad_output = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[2].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array padding_array__ = info__[3].As<Napi::Array>();
  int padding_len = padding_array__.Length();
  int64_t *padding_data = new int64_t[padding_len];
  for (int i = 0; i < padding_len; ++i)
    padding_data[i] = padding_array__.Get(i).ToNumber().Int64Value();
  auto output__ = torch::reflection_pad3d_backward_out(*grad_input, *grad_output, *self, torch::IntArrayRef(padding_data, padding_len));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_replication_pad1d(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array padding_array__ = info__[1].As<Napi::Array>();
  int padding_len = padding_array__.Length();
  int64_t *padding_data = new int64_t[padding_len];
  for (int i = 0; i < padding_len; ++i)
    padding_data[i] = padding_array__.Get(i).ToNumber().Int64Value();
  auto output__ = torch::replication_pad1d(*self, torch::IntArrayRef(padding_data, padding_len));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_replication_pad1d_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array padding_array__ = info__[2].As<Napi::Array>();
  int padding_len = padding_array__.Length();
  int64_t *padding_data = new int64_t[padding_len];
  for (int i = 0; i < padding_len; ++i)
    padding_data[i] = padding_array__.Get(i).ToNumber().Int64Value();
  auto output__ = torch::replication_pad1d_out(*out, *self, torch::IntArrayRef(padding_data, padding_len));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_replication_pad1d_backward(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *grad_output = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array padding_array__ = info__[2].As<Napi::Array>();
  int padding_len = padding_array__.Length();
  int64_t *padding_data = new int64_t[padding_len];
  for (int i = 0; i < padding_len; ++i)
    padding_data[i] = padding_array__.Get(i).ToNumber().Int64Value();
  auto output__ = torch::replication_pad1d_backward(*grad_output, *self, torch::IntArrayRef(padding_data, padding_len));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_replication_pad1d_backward_grad_input(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *grad_input = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *grad_output = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[2].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array padding_array__ = info__[3].As<Napi::Array>();
  int padding_len = padding_array__.Length();
  int64_t *padding_data = new int64_t[padding_len];
  for (int i = 0; i < padding_len; ++i)
    padding_data[i] = padding_array__.Get(i).ToNumber().Int64Value();
  auto output__ = torch::replication_pad1d_backward_out(*grad_input, *grad_output, *self, torch::IntArrayRef(padding_data, padding_len));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_replication_pad2d(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array padding_array__ = info__[1].As<Napi::Array>();
  int padding_len = padding_array__.Length();
  int64_t *padding_data = new int64_t[padding_len];
  for (int i = 0; i < padding_len; ++i)
    padding_data[i] = padding_array__.Get(i).ToNumber().Int64Value();
  auto output__ = torch::replication_pad2d(*self, torch::IntArrayRef(padding_data, padding_len));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_replication_pad2d_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array padding_array__ = info__[2].As<Napi::Array>();
  int padding_len = padding_array__.Length();
  int64_t *padding_data = new int64_t[padding_len];
  for (int i = 0; i < padding_len; ++i)
    padding_data[i] = padding_array__.Get(i).ToNumber().Int64Value();
  auto output__ = torch::replication_pad2d_out(*out, *self, torch::IntArrayRef(padding_data, padding_len));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_replication_pad2d_backward(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *grad_output = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array padding_array__ = info__[2].As<Napi::Array>();
  int padding_len = padding_array__.Length();
  int64_t *padding_data = new int64_t[padding_len];
  for (int i = 0; i < padding_len; ++i)
    padding_data[i] = padding_array__.Get(i).ToNumber().Int64Value();
  auto output__ = torch::replication_pad2d_backward(*grad_output, *self, torch::IntArrayRef(padding_data, padding_len));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_replication_pad2d_backward_grad_input(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *grad_input = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *grad_output = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[2].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array padding_array__ = info__[3].As<Napi::Array>();
  int padding_len = padding_array__.Length();
  int64_t *padding_data = new int64_t[padding_len];
  for (int i = 0; i < padding_len; ++i)
    padding_data[i] = padding_array__.Get(i).ToNumber().Int64Value();
  auto output__ = torch::replication_pad2d_backward_out(*grad_input, *grad_output, *self, torch::IntArrayRef(padding_data, padding_len));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_replication_pad3d(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array padding_array__ = info__[1].As<Napi::Array>();
  int padding_len = padding_array__.Length();
  int64_t *padding_data = new int64_t[padding_len];
  for (int i = 0; i < padding_len; ++i)
    padding_data[i] = padding_array__.Get(i).ToNumber().Int64Value();
  auto output__ = torch::replication_pad3d(*self, torch::IntArrayRef(padding_data, padding_len));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_replication_pad3d_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array padding_array__ = info__[2].As<Napi::Array>();
  int padding_len = padding_array__.Length();
  int64_t *padding_data = new int64_t[padding_len];
  for (int i = 0; i < padding_len; ++i)
    padding_data[i] = padding_array__.Get(i).ToNumber().Int64Value();
  auto output__ = torch::replication_pad3d_out(*out, *self, torch::IntArrayRef(padding_data, padding_len));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_replication_pad3d_backward(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *grad_output = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array padding_array__ = info__[2].As<Napi::Array>();
  int padding_len = padding_array__.Length();
  int64_t *padding_data = new int64_t[padding_len];
  for (int i = 0; i < padding_len; ++i)
    padding_data[i] = padding_array__.Get(i).ToNumber().Int64Value();
  auto output__ = torch::replication_pad3d_backward(*grad_output, *self, torch::IntArrayRef(padding_data, padding_len));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_replication_pad3d_backward_grad_input(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *grad_input = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *grad_output = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[2].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array padding_array__ = info__[3].As<Napi::Array>();
  int padding_len = padding_array__.Length();
  int64_t *padding_data = new int64_t[padding_len];
  for (int i = 0; i < padding_len; ++i)
    padding_data[i] = padding_array__.Get(i).ToNumber().Int64Value();
  auto output__ = torch::replication_pad3d_backward_out(*grad_input, *grad_output, *self, torch::IntArrayRef(padding_data, padding_len));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__pad_circular(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array pad_array__ = info__[1].As<Napi::Array>();
  int pad_len = pad_array__.Length();
  int64_t *pad_data = new int64_t[pad_len];
  for (int i = 0; i < pad_len; ++i)
    pad_data[i] = pad_array__.Get(i).ToNumber().Int64Value();
  auto output__ = torch::_pad_circular(*self, torch::IntArrayRef(pad_data, pad_len));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__pad_enum(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array pad_array__ = info__[1].As<Napi::Array>();
  int pad_len = pad_array__.Length();
  int64_t *pad_data = new int64_t[pad_len];
  for (int i = 0; i < pad_len; ++i)
    pad_data[i] = pad_array__.Get(i).ToNumber().Int64Value();
  int64_t mode = info__[2].As<Napi::Number>().Int64Value();
  bool value_null = info__[3].IsUndefined();
  double value_v = value_null ? 0 : info__[3].As<Napi::Number>().DoubleValue();
  auto output__ = torch::_pad_enum(*self, torch::IntArrayRef(pad_data, pad_len), mode, value_null ? c10::nullopt : c10::optional<double>(value_v));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_pad(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array pad_array__ = info__[1].As<Napi::Array>();
  int pad_len = pad_array__.Length();
  int64_t *pad_data = new int64_t[pad_len];
  for (int i = 0; i < pad_len; ++i)
    pad_data[i] = pad_array__.Get(i).ToNumber().Int64Value();
  Napi::String mode_str__ = info__[2].As<Napi::String>();
  std::string mode = mode_str__.Utf8Value();
  bool value_null = info__[3].IsUndefined();
  double value_v = value_null ? 0 : info__[3].As<Napi::Number>().DoubleValue();
  auto output__ = torch::pad(*self, torch::IntArrayRef(pad_data, pad_len), mode, value_null ? c10::nullopt : c10::optional<double>(value_v));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_upsample_linear1d_vec(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *input = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array output_size_array__ = info__[1].As<Napi::Array>();
  int output_size_len = output_size_array__.Length();
  int64_t *output_size_data = new int64_t[output_size_len];
  for (int i = 0; i < output_size_len; ++i)
    output_size_data[i] = output_size_array__.Get(i).ToNumber().Int64Value();
  bool align_corners = info__[2].As<Napi::Boolean>().Value();
  Napi::Array scale_factors_array__ = info__[3].As<Napi::Array>();
  int scale_factors_len = scale_factors_array__.Length();
  double *scale_factors_data = new double[scale_factors_len];
  for (int i = 0; i < scale_factors_len; ++i)
    scale_factors_data[i] = scale_factors_array__.Get(i).ToNumber().DoubleValue();
  auto output__ = torch::upsample_linear1d(*input, output_size_data == nullptr ? c10::nullopt : c10::optional<torch::IntArrayRef>(torch::IntArrayRef(output_size_data, output_size_len)), align_corners, at::ArrayRef<double>(scale_factors_data, scale_factors_len));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_upsample_linear1d(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array output_size_array__ = info__[1].As<Napi::Array>();
  int output_size_len = output_size_array__.Length();
  int64_t *output_size_data = new int64_t[output_size_len];
  for (int i = 0; i < output_size_len; ++i)
    output_size_data[i] = output_size_array__.Get(i).ToNumber().Int64Value();
  bool align_corners = info__[2].As<Napi::Boolean>().Value();
  bool scales_null = info__[3].IsUndefined();
  double scales_v = scales_null ? 0 : info__[3].As<Napi::Number>().DoubleValue();
  auto output__ = torch::upsample_linear1d(*self, torch::IntArrayRef(output_size_data, output_size_len), align_corners, scales_null ? c10::nullopt : c10::optional<double>(scales_v));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_upsample_linear1d_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array output_size_array__ = info__[2].As<Napi::Array>();
  int output_size_len = output_size_array__.Length();
  int64_t *output_size_data = new int64_t[output_size_len];
  for (int i = 0; i < output_size_len; ++i)
    output_size_data[i] = output_size_array__.Get(i).ToNumber().Int64Value();
  bool align_corners = info__[3].As<Napi::Boolean>().Value();
  bool scales_null = info__[4].IsUndefined();
  double scales_v = scales_null ? 0 : info__[4].As<Napi::Number>().DoubleValue();
  auto output__ = torch::upsample_linear1d_out(*out, *self, torch::IntArrayRef(output_size_data, output_size_len), align_corners, scales_null ? c10::nullopt : c10::optional<double>(scales_v));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_upsample_bilinear2d_vec(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *input = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array output_size_array__ = info__[1].As<Napi::Array>();
  int output_size_len = output_size_array__.Length();
  int64_t *output_size_data = new int64_t[output_size_len];
  for (int i = 0; i < output_size_len; ++i)
    output_size_data[i] = output_size_array__.Get(i).ToNumber().Int64Value();
  bool align_corners = info__[2].As<Napi::Boolean>().Value();
  Napi::Array scale_factors_array__ = info__[3].As<Napi::Array>();
  int scale_factors_len = scale_factors_array__.Length();
  double *scale_factors_data = new double[scale_factors_len];
  for (int i = 0; i < scale_factors_len; ++i)
    scale_factors_data[i] = scale_factors_array__.Get(i).ToNumber().DoubleValue();
  auto output__ = torch::upsample_bilinear2d(*input, output_size_data == nullptr ? c10::nullopt : c10::optional<torch::IntArrayRef>(torch::IntArrayRef(output_size_data, output_size_len)), align_corners, at::ArrayRef<double>(scale_factors_data, scale_factors_len));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_upsample_bilinear2d(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array output_size_array__ = info__[1].As<Napi::Array>();
  int output_size_len = output_size_array__.Length();
  int64_t *output_size_data = new int64_t[output_size_len];
  for (int i = 0; i < output_size_len; ++i)
    output_size_data[i] = output_size_array__.Get(i).ToNumber().Int64Value();
  bool align_corners = info__[2].As<Napi::Boolean>().Value();
  bool scales_h_null = info__[3].IsUndefined();
  double scales_h_v = scales_h_null ? 0 : info__[3].As<Napi::Number>().DoubleValue();
  bool scales_w_null = info__[4].IsUndefined();
  double scales_w_v = scales_w_null ? 0 : info__[4].As<Napi::Number>().DoubleValue();
  auto output__ = torch::upsample_bilinear2d(*self, torch::IntArrayRef(output_size_data, output_size_len), align_corners, scales_h_null ? c10::nullopt : c10::optional<double>(scales_h_v), scales_w_null ? c10::nullopt : c10::optional<double>(scales_w_v));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_upsample_bilinear2d_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array output_size_array__ = info__[2].As<Napi::Array>();
  int output_size_len = output_size_array__.Length();
  int64_t *output_size_data = new int64_t[output_size_len];
  for (int i = 0; i < output_size_len; ++i)
    output_size_data[i] = output_size_array__.Get(i).ToNumber().Int64Value();
  bool align_corners = info__[3].As<Napi::Boolean>().Value();
  bool scales_h_null = info__[4].IsUndefined();
  double scales_h_v = scales_h_null ? 0 : info__[4].As<Napi::Number>().DoubleValue();
  bool scales_w_null = info__[5].IsUndefined();
  double scales_w_v = scales_w_null ? 0 : info__[5].As<Napi::Number>().DoubleValue();
  auto output__ = torch::upsample_bilinear2d_out(*out, *self, torch::IntArrayRef(output_size_data, output_size_len), align_corners, scales_h_null ? c10::nullopt : c10::optional<double>(scales_h_v), scales_w_null ? c10::nullopt : c10::optional<double>(scales_w_v));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__upsample_bilinear2d_aa_vec(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *input = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array output_size_array__ = info__[1].As<Napi::Array>();
  int output_size_len = output_size_array__.Length();
  int64_t *output_size_data = new int64_t[output_size_len];
  for (int i = 0; i < output_size_len; ++i)
    output_size_data[i] = output_size_array__.Get(i).ToNumber().Int64Value();
  bool align_corners = info__[2].As<Napi::Boolean>().Value();
  Napi::Array scale_factors_array__ = info__[3].As<Napi::Array>();
  int scale_factors_len = scale_factors_array__.Length();
  double *scale_factors_data = new double[scale_factors_len];
  for (int i = 0; i < scale_factors_len; ++i)
    scale_factors_data[i] = scale_factors_array__.Get(i).ToNumber().DoubleValue();
  auto output__ = torch::_upsample_bilinear2d_aa(*input, output_size_data == nullptr ? c10::nullopt : c10::optional<torch::IntArrayRef>(torch::IntArrayRef(output_size_data, output_size_len)), align_corners, at::ArrayRef<double>(scale_factors_data, scale_factors_len));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__upsample_bilinear2d_aa(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array output_size_array__ = info__[1].As<Napi::Array>();
  int output_size_len = output_size_array__.Length();
  int64_t *output_size_data = new int64_t[output_size_len];
  for (int i = 0; i < output_size_len; ++i)
    output_size_data[i] = output_size_array__.Get(i).ToNumber().Int64Value();
  bool align_corners = info__[2].As<Napi::Boolean>().Value();
  bool scales_h_null = info__[3].IsUndefined();
  double scales_h_v = scales_h_null ? 0 : info__[3].As<Napi::Number>().DoubleValue();
  bool scales_w_null = info__[4].IsUndefined();
  double scales_w_v = scales_w_null ? 0 : info__[4].As<Napi::Number>().DoubleValue();
  auto output__ = torch::_upsample_bilinear2d_aa(*self, torch::IntArrayRef(output_size_data, output_size_len), align_corners, scales_h_null ? c10::nullopt : c10::optional<double>(scales_h_v), scales_w_null ? c10::nullopt : c10::optional<double>(scales_w_v));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__upsample_bilinear2d_aa_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array output_size_array__ = info__[2].As<Napi::Array>();
  int output_size_len = output_size_array__.Length();
  int64_t *output_size_data = new int64_t[output_size_len];
  for (int i = 0; i < output_size_len; ++i)
    output_size_data[i] = output_size_array__.Get(i).ToNumber().Int64Value();
  bool align_corners = info__[3].As<Napi::Boolean>().Value();
  bool scales_h_null = info__[4].IsUndefined();
  double scales_h_v = scales_h_null ? 0 : info__[4].As<Napi::Number>().DoubleValue();
  bool scales_w_null = info__[5].IsUndefined();
  double scales_w_v = scales_w_null ? 0 : info__[5].As<Napi::Number>().DoubleValue();
  auto output__ = torch::_upsample_bilinear2d_aa_out(*out, *self, torch::IntArrayRef(output_size_data, output_size_len), align_corners, scales_h_null ? c10::nullopt : c10::optional<double>(scales_h_v), scales_w_null ? c10::nullopt : c10::optional<double>(scales_w_v));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_upsample_trilinear3d_vec(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *input = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array output_size_array__ = info__[1].As<Napi::Array>();
  int output_size_len = output_size_array__.Length();
  int64_t *output_size_data = new int64_t[output_size_len];
  for (int i = 0; i < output_size_len; ++i)
    output_size_data[i] = output_size_array__.Get(i).ToNumber().Int64Value();
  bool align_corners = info__[2].As<Napi::Boolean>().Value();
  Napi::Array scale_factors_array__ = info__[3].As<Napi::Array>();
  int scale_factors_len = scale_factors_array__.Length();
  double *scale_factors_data = new double[scale_factors_len];
  for (int i = 0; i < scale_factors_len; ++i)
    scale_factors_data[i] = scale_factors_array__.Get(i).ToNumber().DoubleValue();
  auto output__ = torch::upsample_trilinear3d(*input, output_size_data == nullptr ? c10::nullopt : c10::optional<torch::IntArrayRef>(torch::IntArrayRef(output_size_data, output_size_len)), align_corners, at::ArrayRef<double>(scale_factors_data, scale_factors_len));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_upsample_trilinear3d(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array output_size_array__ = info__[1].As<Napi::Array>();
  int output_size_len = output_size_array__.Length();
  int64_t *output_size_data = new int64_t[output_size_len];
  for (int i = 0; i < output_size_len; ++i)
    output_size_data[i] = output_size_array__.Get(i).ToNumber().Int64Value();
  bool align_corners = info__[2].As<Napi::Boolean>().Value();
  bool scales_d_null = info__[3].IsUndefined();
  double scales_d_v = scales_d_null ? 0 : info__[3].As<Napi::Number>().DoubleValue();
  bool scales_h_null = info__[4].IsUndefined();
  double scales_h_v = scales_h_null ? 0 : info__[4].As<Napi::Number>().DoubleValue();
  bool scales_w_null = info__[5].IsUndefined();
  double scales_w_v = scales_w_null ? 0 : info__[5].As<Napi::Number>().DoubleValue();
  auto output__ = torch::upsample_trilinear3d(*self, torch::IntArrayRef(output_size_data, output_size_len), align_corners, scales_d_null ? c10::nullopt : c10::optional<double>(scales_d_v), scales_h_null ? c10::nullopt : c10::optional<double>(scales_h_v), scales_w_null ? c10::nullopt : c10::optional<double>(scales_w_v));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_upsample_trilinear3d_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array output_size_array__ = info__[2].As<Napi::Array>();
  int output_size_len = output_size_array__.Length();
  int64_t *output_size_data = new int64_t[output_size_len];
  for (int i = 0; i < output_size_len; ++i)
    output_size_data[i] = output_size_array__.Get(i).ToNumber().Int64Value();
  bool align_corners = info__[3].As<Napi::Boolean>().Value();
  bool scales_d_null = info__[4].IsUndefined();
  double scales_d_v = scales_d_null ? 0 : info__[4].As<Napi::Number>().DoubleValue();
  bool scales_h_null = info__[5].IsUndefined();
  double scales_h_v = scales_h_null ? 0 : info__[5].As<Napi::Number>().DoubleValue();
  bool scales_w_null = info__[6].IsUndefined();
  double scales_w_v = scales_w_null ? 0 : info__[6].As<Napi::Number>().DoubleValue();
  auto output__ = torch::upsample_trilinear3d_out(*out, *self, torch::IntArrayRef(output_size_data, output_size_len), align_corners, scales_d_null ? c10::nullopt : c10::optional<double>(scales_d_v), scales_h_null ? c10::nullopt : c10::optional<double>(scales_h_v), scales_w_null ? c10::nullopt : c10::optional<double>(scales_w_v));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_upsample_bicubic2d_vec(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *input = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array output_size_array__ = info__[1].As<Napi::Array>();
  int output_size_len = output_size_array__.Length();
  int64_t *output_size_data = new int64_t[output_size_len];
  for (int i = 0; i < output_size_len; ++i)
    output_size_data[i] = output_size_array__.Get(i).ToNumber().Int64Value();
  bool align_corners = info__[2].As<Napi::Boolean>().Value();
  Napi::Array scale_factors_array__ = info__[3].As<Napi::Array>();
  int scale_factors_len = scale_factors_array__.Length();
  double *scale_factors_data = new double[scale_factors_len];
  for (int i = 0; i < scale_factors_len; ++i)
    scale_factors_data[i] = scale_factors_array__.Get(i).ToNumber().DoubleValue();
  auto output__ = torch::upsample_bicubic2d(*input, output_size_data == nullptr ? c10::nullopt : c10::optional<torch::IntArrayRef>(torch::IntArrayRef(output_size_data, output_size_len)), align_corners, at::ArrayRef<double>(scale_factors_data, scale_factors_len));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_upsample_bicubic2d(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array output_size_array__ = info__[1].As<Napi::Array>();
  int output_size_len = output_size_array__.Length();
  int64_t *output_size_data = new int64_t[output_size_len];
  for (int i = 0; i < output_size_len; ++i)
    output_size_data[i] = output_size_array__.Get(i).ToNumber().Int64Value();
  bool align_corners = info__[2].As<Napi::Boolean>().Value();
  bool scales_h_null = info__[3].IsUndefined();
  double scales_h_v = scales_h_null ? 0 : info__[3].As<Napi::Number>().DoubleValue();
  bool scales_w_null = info__[4].IsUndefined();
  double scales_w_v = scales_w_null ? 0 : info__[4].As<Napi::Number>().DoubleValue();
  auto output__ = torch::upsample_bicubic2d(*self, torch::IntArrayRef(output_size_data, output_size_len), align_corners, scales_h_null ? c10::nullopt : c10::optional<double>(scales_h_v), scales_w_null ? c10::nullopt : c10::optional<double>(scales_w_v));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_upsample_bicubic2d_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array output_size_array__ = info__[2].As<Napi::Array>();
  int output_size_len = output_size_array__.Length();
  int64_t *output_size_data = new int64_t[output_size_len];
  for (int i = 0; i < output_size_len; ++i)
    output_size_data[i] = output_size_array__.Get(i).ToNumber().Int64Value();
  bool align_corners = info__[3].As<Napi::Boolean>().Value();
  bool scales_h_null = info__[4].IsUndefined();
  double scales_h_v = scales_h_null ? 0 : info__[4].As<Napi::Number>().DoubleValue();
  bool scales_w_null = info__[5].IsUndefined();
  double scales_w_v = scales_w_null ? 0 : info__[5].As<Napi::Number>().DoubleValue();
  auto output__ = torch::upsample_bicubic2d_out(*out, *self, torch::IntArrayRef(output_size_data, output_size_len), align_corners, scales_h_null ? c10::nullopt : c10::optional<double>(scales_h_v), scales_w_null ? c10::nullopt : c10::optional<double>(scales_w_v));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__upsample_bicubic2d_aa_vec(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *input = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array output_size_array__ = info__[1].As<Napi::Array>();
  int output_size_len = output_size_array__.Length();
  int64_t *output_size_data = new int64_t[output_size_len];
  for (int i = 0; i < output_size_len; ++i)
    output_size_data[i] = output_size_array__.Get(i).ToNumber().Int64Value();
  bool align_corners = info__[2].As<Napi::Boolean>().Value();
  Napi::Array scale_factors_array__ = info__[3].As<Napi::Array>();
  int scale_factors_len = scale_factors_array__.Length();
  double *scale_factors_data = new double[scale_factors_len];
  for (int i = 0; i < scale_factors_len; ++i)
    scale_factors_data[i] = scale_factors_array__.Get(i).ToNumber().DoubleValue();
  auto output__ = torch::_upsample_bicubic2d_aa(*input, output_size_data == nullptr ? c10::nullopt : c10::optional<torch::IntArrayRef>(torch::IntArrayRef(output_size_data, output_size_len)), align_corners, at::ArrayRef<double>(scale_factors_data, scale_factors_len));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__upsample_bicubic2d_aa(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array output_size_array__ = info__[1].As<Napi::Array>();
  int output_size_len = output_size_array__.Length();
  int64_t *output_size_data = new int64_t[output_size_len];
  for (int i = 0; i < output_size_len; ++i)
    output_size_data[i] = output_size_array__.Get(i).ToNumber().Int64Value();
  bool align_corners = info__[2].As<Napi::Boolean>().Value();
  bool scales_h_null = info__[3].IsUndefined();
  double scales_h_v = scales_h_null ? 0 : info__[3].As<Napi::Number>().DoubleValue();
  bool scales_w_null = info__[4].IsUndefined();
  double scales_w_v = scales_w_null ? 0 : info__[4].As<Napi::Number>().DoubleValue();
  auto output__ = torch::_upsample_bicubic2d_aa(*self, torch::IntArrayRef(output_size_data, output_size_len), align_corners, scales_h_null ? c10::nullopt : c10::optional<double>(scales_h_v), scales_w_null ? c10::nullopt : c10::optional<double>(scales_w_v));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__upsample_bicubic2d_aa_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array output_size_array__ = info__[2].As<Napi::Array>();
  int output_size_len = output_size_array__.Length();
  int64_t *output_size_data = new int64_t[output_size_len];
  for (int i = 0; i < output_size_len; ++i)
    output_size_data[i] = output_size_array__.Get(i).ToNumber().Int64Value();
  bool align_corners = info__[3].As<Napi::Boolean>().Value();
  bool scales_h_null = info__[4].IsUndefined();
  double scales_h_v = scales_h_null ? 0 : info__[4].As<Napi::Number>().DoubleValue();
  bool scales_w_null = info__[5].IsUndefined();
  double scales_w_v = scales_w_null ? 0 : info__[5].As<Napi::Number>().DoubleValue();
  auto output__ = torch::_upsample_bicubic2d_aa_out(*out, *self, torch::IntArrayRef(output_size_data, output_size_len), align_corners, scales_h_null ? c10::nullopt : c10::optional<double>(scales_h_v), scales_w_null ? c10::nullopt : c10::optional<double>(scales_w_v));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_upsample_nearest1d_vec(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *input = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array output_size_array__ = info__[1].As<Napi::Array>();
  int output_size_len = output_size_array__.Length();
  int64_t *output_size_data = new int64_t[output_size_len];
  for (int i = 0; i < output_size_len; ++i)
    output_size_data[i] = output_size_array__.Get(i).ToNumber().Int64Value();
  Napi::Array scale_factors_array__ = info__[2].As<Napi::Array>();
  int scale_factors_len = scale_factors_array__.Length();
  double *scale_factors_data = new double[scale_factors_len];
  for (int i = 0; i < scale_factors_len; ++i)
    scale_factors_data[i] = scale_factors_array__.Get(i).ToNumber().DoubleValue();
  auto output__ = torch::upsample_nearest1d(*input, output_size_data == nullptr ? c10::nullopt : c10::optional<torch::IntArrayRef>(torch::IntArrayRef(output_size_data, output_size_len)), at::ArrayRef<double>(scale_factors_data, scale_factors_len));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_upsample_nearest1d(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array output_size_array__ = info__[1].As<Napi::Array>();
  int output_size_len = output_size_array__.Length();
  int64_t *output_size_data = new int64_t[output_size_len];
  for (int i = 0; i < output_size_len; ++i)
    output_size_data[i] = output_size_array__.Get(i).ToNumber().Int64Value();
  bool scales_null = info__[2].IsUndefined();
  double scales_v = scales_null ? 0 : info__[2].As<Napi::Number>().DoubleValue();
  auto output__ = torch::upsample_nearest1d(*self, torch::IntArrayRef(output_size_data, output_size_len), scales_null ? c10::nullopt : c10::optional<double>(scales_v));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_upsample_nearest1d_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array output_size_array__ = info__[2].As<Napi::Array>();
  int output_size_len = output_size_array__.Length();
  int64_t *output_size_data = new int64_t[output_size_len];
  for (int i = 0; i < output_size_len; ++i)
    output_size_data[i] = output_size_array__.Get(i).ToNumber().Int64Value();
  bool scales_null = info__[3].IsUndefined();
  double scales_v = scales_null ? 0 : info__[3].As<Napi::Number>().DoubleValue();
  auto output__ = torch::upsample_nearest1d_out(*out, *self, torch::IntArrayRef(output_size_data, output_size_len), scales_null ? c10::nullopt : c10::optional<double>(scales_v));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__upsample_nearest_exact1d_vec(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *input = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array output_size_array__ = info__[1].As<Napi::Array>();
  int output_size_len = output_size_array__.Length();
  int64_t *output_size_data = new int64_t[output_size_len];
  for (int i = 0; i < output_size_len; ++i)
    output_size_data[i] = output_size_array__.Get(i).ToNumber().Int64Value();
  Napi::Array scale_factors_array__ = info__[2].As<Napi::Array>();
  int scale_factors_len = scale_factors_array__.Length();
  double *scale_factors_data = new double[scale_factors_len];
  for (int i = 0; i < scale_factors_len; ++i)
    scale_factors_data[i] = scale_factors_array__.Get(i).ToNumber().DoubleValue();
  auto output__ = torch::_upsample_nearest_exact1d(*input, output_size_data == nullptr ? c10::nullopt : c10::optional<torch::IntArrayRef>(torch::IntArrayRef(output_size_data, output_size_len)), at::ArrayRef<double>(scale_factors_data, scale_factors_len));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__upsample_nearest_exact1d(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array output_size_array__ = info__[1].As<Napi::Array>();
  int output_size_len = output_size_array__.Length();
  int64_t *output_size_data = new int64_t[output_size_len];
  for (int i = 0; i < output_size_len; ++i)
    output_size_data[i] = output_size_array__.Get(i).ToNumber().Int64Value();
  bool scales_null = info__[2].IsUndefined();
  double scales_v = scales_null ? 0 : info__[2].As<Napi::Number>().DoubleValue();
  auto output__ = torch::_upsample_nearest_exact1d(*self, torch::IntArrayRef(output_size_data, output_size_len), scales_null ? c10::nullopt : c10::optional<double>(scales_v));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__upsample_nearest_exact1d_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array output_size_array__ = info__[2].As<Napi::Array>();
  int output_size_len = output_size_array__.Length();
  int64_t *output_size_data = new int64_t[output_size_len];
  for (int i = 0; i < output_size_len; ++i)
    output_size_data[i] = output_size_array__.Get(i).ToNumber().Int64Value();
  bool scales_null = info__[3].IsUndefined();
  double scales_v = scales_null ? 0 : info__[3].As<Napi::Number>().DoubleValue();
  auto output__ = torch::_upsample_nearest_exact1d_out(*out, *self, torch::IntArrayRef(output_size_data, output_size_len), scales_null ? c10::nullopt : c10::optional<double>(scales_v));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_upsample_nearest2d_vec(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *input = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array output_size_array__ = info__[1].As<Napi::Array>();
  int output_size_len = output_size_array__.Length();
  int64_t *output_size_data = new int64_t[output_size_len];
  for (int i = 0; i < output_size_len; ++i)
    output_size_data[i] = output_size_array__.Get(i).ToNumber().Int64Value();
  Napi::Array scale_factors_array__ = info__[2].As<Napi::Array>();
  int scale_factors_len = scale_factors_array__.Length();
  double *scale_factors_data = new double[scale_factors_len];
  for (int i = 0; i < scale_factors_len; ++i)
    scale_factors_data[i] = scale_factors_array__.Get(i).ToNumber().DoubleValue();
  auto output__ = torch::upsample_nearest2d(*input, output_size_data == nullptr ? c10::nullopt : c10::optional<torch::IntArrayRef>(torch::IntArrayRef(output_size_data, output_size_len)), at::ArrayRef<double>(scale_factors_data, scale_factors_len));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_upsample_nearest2d(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array output_size_array__ = info__[1].As<Napi::Array>();
  int output_size_len = output_size_array__.Length();
  int64_t *output_size_data = new int64_t[output_size_len];
  for (int i = 0; i < output_size_len; ++i)
    output_size_data[i] = output_size_array__.Get(i).ToNumber().Int64Value();
  bool scales_h_null = info__[2].IsUndefined();
  double scales_h_v = scales_h_null ? 0 : info__[2].As<Napi::Number>().DoubleValue();
  bool scales_w_null = info__[3].IsUndefined();
  double scales_w_v = scales_w_null ? 0 : info__[3].As<Napi::Number>().DoubleValue();
  auto output__ = torch::upsample_nearest2d(*self, torch::IntArrayRef(output_size_data, output_size_len), scales_h_null ? c10::nullopt : c10::optional<double>(scales_h_v), scales_w_null ? c10::nullopt : c10::optional<double>(scales_w_v));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_upsample_nearest2d_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array output_size_array__ = info__[2].As<Napi::Array>();
  int output_size_len = output_size_array__.Length();
  int64_t *output_size_data = new int64_t[output_size_len];
  for (int i = 0; i < output_size_len; ++i)
    output_size_data[i] = output_size_array__.Get(i).ToNumber().Int64Value();
  bool scales_h_null = info__[3].IsUndefined();
  double scales_h_v = scales_h_null ? 0 : info__[3].As<Napi::Number>().DoubleValue();
  bool scales_w_null = info__[4].IsUndefined();
  double scales_w_v = scales_w_null ? 0 : info__[4].As<Napi::Number>().DoubleValue();
  auto output__ = torch::upsample_nearest2d_out(*out, *self, torch::IntArrayRef(output_size_data, output_size_len), scales_h_null ? c10::nullopt : c10::optional<double>(scales_h_v), scales_w_null ? c10::nullopt : c10::optional<double>(scales_w_v));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__upsample_nearest_exact2d_vec(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *input = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array output_size_array__ = info__[1].As<Napi::Array>();
  int output_size_len = output_size_array__.Length();
  int64_t *output_size_data = new int64_t[output_size_len];
  for (int i = 0; i < output_size_len; ++i)
    output_size_data[i] = output_size_array__.Get(i).ToNumber().Int64Value();
  Napi::Array scale_factors_array__ = info__[2].As<Napi::Array>();
  int scale_factors_len = scale_factors_array__.Length();
  double *scale_factors_data = new double[scale_factors_len];
  for (int i = 0; i < scale_factors_len; ++i)
    scale_factors_data[i] = scale_factors_array__.Get(i).ToNumber().DoubleValue();
  auto output__ = torch::_upsample_nearest_exact2d(*input, output_size_data == nullptr ? c10::nullopt : c10::optional<torch::IntArrayRef>(torch::IntArrayRef(output_size_data, output_size_len)), at::ArrayRef<double>(scale_factors_data, scale_factors_len));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__upsample_nearest_exact2d(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array output_size_array__ = info__[1].As<Napi::Array>();
  int output_size_len = output_size_array__.Length();
  int64_t *output_size_data = new int64_t[output_size_len];
  for (int i = 0; i < output_size_len; ++i)
    output_size_data[i] = output_size_array__.Get(i).ToNumber().Int64Value();
  bool scales_h_null = info__[2].IsUndefined();
  double scales_h_v = scales_h_null ? 0 : info__[2].As<Napi::Number>().DoubleValue();
  bool scales_w_null = info__[3].IsUndefined();
  double scales_w_v = scales_w_null ? 0 : info__[3].As<Napi::Number>().DoubleValue();
  auto output__ = torch::_upsample_nearest_exact2d(*self, torch::IntArrayRef(output_size_data, output_size_len), scales_h_null ? c10::nullopt : c10::optional<double>(scales_h_v), scales_w_null ? c10::nullopt : c10::optional<double>(scales_w_v));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__upsample_nearest_exact2d_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array output_size_array__ = info__[2].As<Napi::Array>();
  int output_size_len = output_size_array__.Length();
  int64_t *output_size_data = new int64_t[output_size_len];
  for (int i = 0; i < output_size_len; ++i)
    output_size_data[i] = output_size_array__.Get(i).ToNumber().Int64Value();
  bool scales_h_null = info__[3].IsUndefined();
  double scales_h_v = scales_h_null ? 0 : info__[3].As<Napi::Number>().DoubleValue();
  bool scales_w_null = info__[4].IsUndefined();
  double scales_w_v = scales_w_null ? 0 : info__[4].As<Napi::Number>().DoubleValue();
  auto output__ = torch::_upsample_nearest_exact2d_out(*out, *self, torch::IntArrayRef(output_size_data, output_size_len), scales_h_null ? c10::nullopt : c10::optional<double>(scales_h_v), scales_w_null ? c10::nullopt : c10::optional<double>(scales_w_v));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_upsample_nearest3d_vec(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *input = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array output_size_array__ = info__[1].As<Napi::Array>();
  int output_size_len = output_size_array__.Length();
  int64_t *output_size_data = new int64_t[output_size_len];
  for (int i = 0; i < output_size_len; ++i)
    output_size_data[i] = output_size_array__.Get(i).ToNumber().Int64Value();
  Napi::Array scale_factors_array__ = info__[2].As<Napi::Array>();
  int scale_factors_len = scale_factors_array__.Length();
  double *scale_factors_data = new double[scale_factors_len];
  for (int i = 0; i < scale_factors_len; ++i)
    scale_factors_data[i] = scale_factors_array__.Get(i).ToNumber().DoubleValue();
  auto output__ = torch::upsample_nearest3d(*input, output_size_data == nullptr ? c10::nullopt : c10::optional<torch::IntArrayRef>(torch::IntArrayRef(output_size_data, output_size_len)), at::ArrayRef<double>(scale_factors_data, scale_factors_len));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_upsample_nearest3d(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array output_size_array__ = info__[1].As<Napi::Array>();
  int output_size_len = output_size_array__.Length();
  int64_t *output_size_data = new int64_t[output_size_len];
  for (int i = 0; i < output_size_len; ++i)
    output_size_data[i] = output_size_array__.Get(i).ToNumber().Int64Value();
  bool scales_d_null = info__[2].IsUndefined();
  double scales_d_v = scales_d_null ? 0 : info__[2].As<Napi::Number>().DoubleValue();
  bool scales_h_null = info__[3].IsUndefined();
  double scales_h_v = scales_h_null ? 0 : info__[3].As<Napi::Number>().DoubleValue();
  bool scales_w_null = info__[4].IsUndefined();
  double scales_w_v = scales_w_null ? 0 : info__[4].As<Napi::Number>().DoubleValue();
  auto output__ = torch::upsample_nearest3d(*self, torch::IntArrayRef(output_size_data, output_size_len), scales_d_null ? c10::nullopt : c10::optional<double>(scales_d_v), scales_h_null ? c10::nullopt : c10::optional<double>(scales_h_v), scales_w_null ? c10::nullopt : c10::optional<double>(scales_w_v));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_upsample_nearest3d_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array output_size_array__ = info__[2].As<Napi::Array>();
  int output_size_len = output_size_array__.Length();
  int64_t *output_size_data = new int64_t[output_size_len];
  for (int i = 0; i < output_size_len; ++i)
    output_size_data[i] = output_size_array__.Get(i).ToNumber().Int64Value();
  bool scales_d_null = info__[3].IsUndefined();
  double scales_d_v = scales_d_null ? 0 : info__[3].As<Napi::Number>().DoubleValue();
  bool scales_h_null = info__[4].IsUndefined();
  double scales_h_v = scales_h_null ? 0 : info__[4].As<Napi::Number>().DoubleValue();
  bool scales_w_null = info__[5].IsUndefined();
  double scales_w_v = scales_w_null ? 0 : info__[5].As<Napi::Number>().DoubleValue();
  auto output__ = torch::upsample_nearest3d_out(*out, *self, torch::IntArrayRef(output_size_data, output_size_len), scales_d_null ? c10::nullopt : c10::optional<double>(scales_d_v), scales_h_null ? c10::nullopt : c10::optional<double>(scales_h_v), scales_w_null ? c10::nullopt : c10::optional<double>(scales_w_v));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__upsample_nearest_exact3d_vec(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *input = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array output_size_array__ = info__[1].As<Napi::Array>();
  int output_size_len = output_size_array__.Length();
  int64_t *output_size_data = new int64_t[output_size_len];
  for (int i = 0; i < output_size_len; ++i)
    output_size_data[i] = output_size_array__.Get(i).ToNumber().Int64Value();
  Napi::Array scale_factors_array__ = info__[2].As<Napi::Array>();
  int scale_factors_len = scale_factors_array__.Length();
  double *scale_factors_data = new double[scale_factors_len];
  for (int i = 0; i < scale_factors_len; ++i)
    scale_factors_data[i] = scale_factors_array__.Get(i).ToNumber().DoubleValue();
  auto output__ = torch::_upsample_nearest_exact3d(*input, output_size_data == nullptr ? c10::nullopt : c10::optional<torch::IntArrayRef>(torch::IntArrayRef(output_size_data, output_size_len)), at::ArrayRef<double>(scale_factors_data, scale_factors_len));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__upsample_nearest_exact3d(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array output_size_array__ = info__[1].As<Napi::Array>();
  int output_size_len = output_size_array__.Length();
  int64_t *output_size_data = new int64_t[output_size_len];
  for (int i = 0; i < output_size_len; ++i)
    output_size_data[i] = output_size_array__.Get(i).ToNumber().Int64Value();
  bool scales_d_null = info__[2].IsUndefined();
  double scales_d_v = scales_d_null ? 0 : info__[2].As<Napi::Number>().DoubleValue();
  bool scales_h_null = info__[3].IsUndefined();
  double scales_h_v = scales_h_null ? 0 : info__[3].As<Napi::Number>().DoubleValue();
  bool scales_w_null = info__[4].IsUndefined();
  double scales_w_v = scales_w_null ? 0 : info__[4].As<Napi::Number>().DoubleValue();
  auto output__ = torch::_upsample_nearest_exact3d(*self, torch::IntArrayRef(output_size_data, output_size_len), scales_d_null ? c10::nullopt : c10::optional<double>(scales_d_v), scales_h_null ? c10::nullopt : c10::optional<double>(scales_h_v), scales_w_null ? c10::nullopt : c10::optional<double>(scales_w_v));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__upsample_nearest_exact3d_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array output_size_array__ = info__[2].As<Napi::Array>();
  int output_size_len = output_size_array__.Length();
  int64_t *output_size_data = new int64_t[output_size_len];
  for (int i = 0; i < output_size_len; ++i)
    output_size_data[i] = output_size_array__.Get(i).ToNumber().Int64Value();
  bool scales_d_null = info__[3].IsUndefined();
  double scales_d_v = scales_d_null ? 0 : info__[3].As<Napi::Number>().DoubleValue();
  bool scales_h_null = info__[4].IsUndefined();
  double scales_h_v = scales_h_null ? 0 : info__[4].As<Napi::Number>().DoubleValue();
  bool scales_w_null = info__[5].IsUndefined();
  double scales_w_v = scales_w_null ? 0 : info__[5].As<Napi::Number>().DoubleValue();
  auto output__ = torch::_upsample_nearest_exact3d_out(*out, *self, torch::IntArrayRef(output_size_data, output_size_len), scales_d_null ? c10::nullopt : c10::optional<double>(scales_d_v), scales_h_null ? c10::nullopt : c10::optional<double>(scales_h_v), scales_w_null ? c10::nullopt : c10::optional<double>(scales_w_v));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_upsample_linear1d_backward(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *grad_output = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array output_size_array__ = info__[1].As<Napi::Array>();
  int output_size_len = output_size_array__.Length();
  int64_t *output_size_data = new int64_t[output_size_len];
  for (int i = 0; i < output_size_len; ++i)
    output_size_data[i] = output_size_array__.Get(i).ToNumber().Int64Value();
  Napi::Array input_size_array__ = info__[2].As<Napi::Array>();
  int input_size_len = input_size_array__.Length();
  int64_t *input_size_data = new int64_t[input_size_len];
  for (int i = 0; i < input_size_len; ++i)
    input_size_data[i] = input_size_array__.Get(i).ToNumber().Int64Value();
  bool align_corners = info__[3].As<Napi::Boolean>().Value();
  bool scales_null = info__[4].IsUndefined();
  double scales_v = scales_null ? 0 : info__[4].As<Napi::Number>().DoubleValue();
  auto output__ = torch::upsample_linear1d_backward(*grad_output, torch::IntArrayRef(output_size_data, output_size_len), torch::IntArrayRef(input_size_data, input_size_len), align_corners, scales_null ? c10::nullopt : c10::optional<double>(scales_v));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_upsample_linear1d_backward_grad_input(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *grad_input = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *grad_output = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array output_size_array__ = info__[2].As<Napi::Array>();
  int output_size_len = output_size_array__.Length();
  int64_t *output_size_data = new int64_t[output_size_len];
  for (int i = 0; i < output_size_len; ++i)
    output_size_data[i] = output_size_array__.Get(i).ToNumber().Int64Value();
  Napi::Array input_size_array__ = info__[3].As<Napi::Array>();
  int input_size_len = input_size_array__.Length();
  int64_t *input_size_data = new int64_t[input_size_len];
  for (int i = 0; i < input_size_len; ++i)
    input_size_data[i] = input_size_array__.Get(i).ToNumber().Int64Value();
  bool align_corners = info__[4].As<Napi::Boolean>().Value();
  bool scales_null = info__[5].IsUndefined();
  double scales_v = scales_null ? 0 : info__[5].As<Napi::Number>().DoubleValue();
  auto output__ = torch::upsample_linear1d_backward_out(*grad_input, *grad_output, torch::IntArrayRef(output_size_data, output_size_len), torch::IntArrayRef(input_size_data, input_size_len), align_corners, scales_null ? c10::nullopt : c10::optional<double>(scales_v));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_upsample_bilinear2d_backward(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *grad_output = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array output_size_array__ = info__[1].As<Napi::Array>();
  int output_size_len = output_size_array__.Length();
  int64_t *output_size_data = new int64_t[output_size_len];
  for (int i = 0; i < output_size_len; ++i)
    output_size_data[i] = output_size_array__.Get(i).ToNumber().Int64Value();
  Napi::Array input_size_array__ = info__[2].As<Napi::Array>();
  int input_size_len = input_size_array__.Length();
  int64_t *input_size_data = new int64_t[input_size_len];
  for (int i = 0; i < input_size_len; ++i)
    input_size_data[i] = input_size_array__.Get(i).ToNumber().Int64Value();
  bool align_corners = info__[3].As<Napi::Boolean>().Value();
  bool scales_h_null = info__[4].IsUndefined();
  double scales_h_v = scales_h_null ? 0 : info__[4].As<Napi::Number>().DoubleValue();
  bool scales_w_null = info__[5].IsUndefined();
  double scales_w_v = scales_w_null ? 0 : info__[5].As<Napi::Number>().DoubleValue();
  auto output__ = torch::upsample_bilinear2d_backward(*grad_output, torch::IntArrayRef(output_size_data, output_size_len), torch::IntArrayRef(input_size_data, input_size_len), align_corners, scales_h_null ? c10::nullopt : c10::optional<double>(scales_h_v), scales_w_null ? c10::nullopt : c10::optional<double>(scales_w_v));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_upsample_bilinear2d_backward_grad_input(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *grad_input = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *grad_output = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array output_size_array__ = info__[2].As<Napi::Array>();
  int output_size_len = output_size_array__.Length();
  int64_t *output_size_data = new int64_t[output_size_len];
  for (int i = 0; i < output_size_len; ++i)
    output_size_data[i] = output_size_array__.Get(i).ToNumber().Int64Value();
  Napi::Array input_size_array__ = info__[3].As<Napi::Array>();
  int input_size_len = input_size_array__.Length();
  int64_t *input_size_data = new int64_t[input_size_len];
  for (int i = 0; i < input_size_len; ++i)
    input_size_data[i] = input_size_array__.Get(i).ToNumber().Int64Value();
  bool align_corners = info__[4].As<Napi::Boolean>().Value();
  bool scales_h_null = info__[5].IsUndefined();
  double scales_h_v = scales_h_null ? 0 : info__[5].As<Napi::Number>().DoubleValue();
  bool scales_w_null = info__[6].IsUndefined();
  double scales_w_v = scales_w_null ? 0 : info__[6].As<Napi::Number>().DoubleValue();
  auto output__ = torch::upsample_bilinear2d_backward_out(*grad_input, *grad_output, torch::IntArrayRef(output_size_data, output_size_len), torch::IntArrayRef(input_size_data, input_size_len), align_corners, scales_h_null ? c10::nullopt : c10::optional<double>(scales_h_v), scales_w_null ? c10::nullopt : c10::optional<double>(scales_w_v));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__upsample_bilinear2d_aa_backward(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *grad_output = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array output_size_array__ = info__[1].As<Napi::Array>();
  int output_size_len = output_size_array__.Length();
  int64_t *output_size_data = new int64_t[output_size_len];
  for (int i = 0; i < output_size_len; ++i)
    output_size_data[i] = output_size_array__.Get(i).ToNumber().Int64Value();
  Napi::Array input_size_array__ = info__[2].As<Napi::Array>();
  int input_size_len = input_size_array__.Length();
  int64_t *input_size_data = new int64_t[input_size_len];
  for (int i = 0; i < input_size_len; ++i)
    input_size_data[i] = input_size_array__.Get(i).ToNumber().Int64Value();
  bool align_corners = info__[3].As<Napi::Boolean>().Value();
  bool scales_h_null = info__[4].IsUndefined();
  double scales_h_v = scales_h_null ? 0 : info__[4].As<Napi::Number>().DoubleValue();
  bool scales_w_null = info__[5].IsUndefined();
  double scales_w_v = scales_w_null ? 0 : info__[5].As<Napi::Number>().DoubleValue();
  auto output__ = torch::_upsample_bilinear2d_aa_backward(*grad_output, torch::IntArrayRef(output_size_data, output_size_len), torch::IntArrayRef(input_size_data, input_size_len), align_corners, scales_h_null ? c10::nullopt : c10::optional<double>(scales_h_v), scales_w_null ? c10::nullopt : c10::optional<double>(scales_w_v));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__upsample_bilinear2d_aa_backward_grad_input(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *grad_input = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *grad_output = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array output_size_array__ = info__[2].As<Napi::Array>();
  int output_size_len = output_size_array__.Length();
  int64_t *output_size_data = new int64_t[output_size_len];
  for (int i = 0; i < output_size_len; ++i)
    output_size_data[i] = output_size_array__.Get(i).ToNumber().Int64Value();
  Napi::Array input_size_array__ = info__[3].As<Napi::Array>();
  int input_size_len = input_size_array__.Length();
  int64_t *input_size_data = new int64_t[input_size_len];
  for (int i = 0; i < input_size_len; ++i)
    input_size_data[i] = input_size_array__.Get(i).ToNumber().Int64Value();
  bool align_corners = info__[4].As<Napi::Boolean>().Value();
  bool scales_h_null = info__[5].IsUndefined();
  double scales_h_v = scales_h_null ? 0 : info__[5].As<Napi::Number>().DoubleValue();
  bool scales_w_null = info__[6].IsUndefined();
  double scales_w_v = scales_w_null ? 0 : info__[6].As<Napi::Number>().DoubleValue();
  auto output__ = torch::_upsample_bilinear2d_aa_backward_out(*grad_input, *grad_output, torch::IntArrayRef(output_size_data, output_size_len), torch::IntArrayRef(input_size_data, input_size_len), align_corners, scales_h_null ? c10::nullopt : c10::optional<double>(scales_h_v), scales_w_null ? c10::nullopt : c10::optional<double>(scales_w_v));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_upsample_bicubic2d_backward(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *grad_output = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array output_size_array__ = info__[1].As<Napi::Array>();
  int output_size_len = output_size_array__.Length();
  int64_t *output_size_data = new int64_t[output_size_len];
  for (int i = 0; i < output_size_len; ++i)
    output_size_data[i] = output_size_array__.Get(i).ToNumber().Int64Value();
  Napi::Array input_size_array__ = info__[2].As<Napi::Array>();
  int input_size_len = input_size_array__.Length();
  int64_t *input_size_data = new int64_t[input_size_len];
  for (int i = 0; i < input_size_len; ++i)
    input_size_data[i] = input_size_array__.Get(i).ToNumber().Int64Value();
  bool align_corners = info__[3].As<Napi::Boolean>().Value();
  bool scales_h_null = info__[4].IsUndefined();
  double scales_h_v = scales_h_null ? 0 : info__[4].As<Napi::Number>().DoubleValue();
  bool scales_w_null = info__[5].IsUndefined();
  double scales_w_v = scales_w_null ? 0 : info__[5].As<Napi::Number>().DoubleValue();
  auto output__ = torch::upsample_bicubic2d_backward(*grad_output, torch::IntArrayRef(output_size_data, output_size_len), torch::IntArrayRef(input_size_data, input_size_len), align_corners, scales_h_null ? c10::nullopt : c10::optional<double>(scales_h_v), scales_w_null ? c10::nullopt : c10::optional<double>(scales_w_v));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_upsample_bicubic2d_backward_grad_input(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *grad_input = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *grad_output = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array output_size_array__ = info__[2].As<Napi::Array>();
  int output_size_len = output_size_array__.Length();
  int64_t *output_size_data = new int64_t[output_size_len];
  for (int i = 0; i < output_size_len; ++i)
    output_size_data[i] = output_size_array__.Get(i).ToNumber().Int64Value();
  Napi::Array input_size_array__ = info__[3].As<Napi::Array>();
  int input_size_len = input_size_array__.Length();
  int64_t *input_size_data = new int64_t[input_size_len];
  for (int i = 0; i < input_size_len; ++i)
    input_size_data[i] = input_size_array__.Get(i).ToNumber().Int64Value();
  bool align_corners = info__[4].As<Napi::Boolean>().Value();
  bool scales_h_null = info__[5].IsUndefined();
  double scales_h_v = scales_h_null ? 0 : info__[5].As<Napi::Number>().DoubleValue();
  bool scales_w_null = info__[6].IsUndefined();
  double scales_w_v = scales_w_null ? 0 : info__[6].As<Napi::Number>().DoubleValue();
  auto output__ = torch::upsample_bicubic2d_backward_out(*grad_input, *grad_output, torch::IntArrayRef(output_size_data, output_size_len), torch::IntArrayRef(input_size_data, input_size_len), align_corners, scales_h_null ? c10::nullopt : c10::optional<double>(scales_h_v), scales_w_null ? c10::nullopt : c10::optional<double>(scales_w_v));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__upsample_bicubic2d_aa_backward(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *grad_output = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array output_size_array__ = info__[1].As<Napi::Array>();
  int output_size_len = output_size_array__.Length();
  int64_t *output_size_data = new int64_t[output_size_len];
  for (int i = 0; i < output_size_len; ++i)
    output_size_data[i] = output_size_array__.Get(i).ToNumber().Int64Value();
  Napi::Array input_size_array__ = info__[2].As<Napi::Array>();
  int input_size_len = input_size_array__.Length();
  int64_t *input_size_data = new int64_t[input_size_len];
  for (int i = 0; i < input_size_len; ++i)
    input_size_data[i] = input_size_array__.Get(i).ToNumber().Int64Value();
  bool align_corners = info__[3].As<Napi::Boolean>().Value();
  bool scales_h_null = info__[4].IsUndefined();
  double scales_h_v = scales_h_null ? 0 : info__[4].As<Napi::Number>().DoubleValue();
  bool scales_w_null = info__[5].IsUndefined();
  double scales_w_v = scales_w_null ? 0 : info__[5].As<Napi::Number>().DoubleValue();
  auto output__ = torch::_upsample_bicubic2d_aa_backward(*grad_output, torch::IntArrayRef(output_size_data, output_size_len), torch::IntArrayRef(input_size_data, input_size_len), align_corners, scales_h_null ? c10::nullopt : c10::optional<double>(scales_h_v), scales_w_null ? c10::nullopt : c10::optional<double>(scales_w_v));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__upsample_bicubic2d_aa_backward_grad_input(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *grad_input = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *grad_output = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array output_size_array__ = info__[2].As<Napi::Array>();
  int output_size_len = output_size_array__.Length();
  int64_t *output_size_data = new int64_t[output_size_len];
  for (int i = 0; i < output_size_len; ++i)
    output_size_data[i] = output_size_array__.Get(i).ToNumber().Int64Value();
  Napi::Array input_size_array__ = info__[3].As<Napi::Array>();
  int input_size_len = input_size_array__.Length();
  int64_t *input_size_data = new int64_t[input_size_len];
  for (int i = 0; i < input_size_len; ++i)
    input_size_data[i] = input_size_array__.Get(i).ToNumber().Int64Value();
  bool align_corners = info__[4].As<Napi::Boolean>().Value();
  bool scales_h_null = info__[5].IsUndefined();
  double scales_h_v = scales_h_null ? 0 : info__[5].As<Napi::Number>().DoubleValue();
  bool scales_w_null = info__[6].IsUndefined();
  double scales_w_v = scales_w_null ? 0 : info__[6].As<Napi::Number>().DoubleValue();
  auto output__ = torch::_upsample_bicubic2d_aa_backward_out(*grad_input, *grad_output, torch::IntArrayRef(output_size_data, output_size_len), torch::IntArrayRef(input_size_data, input_size_len), align_corners, scales_h_null ? c10::nullopt : c10::optional<double>(scales_h_v), scales_w_null ? c10::nullopt : c10::optional<double>(scales_w_v));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_upsample_trilinear3d_backward(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *grad_output = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array output_size_array__ = info__[1].As<Napi::Array>();
  int output_size_len = output_size_array__.Length();
  int64_t *output_size_data = new int64_t[output_size_len];
  for (int i = 0; i < output_size_len; ++i)
    output_size_data[i] = output_size_array__.Get(i).ToNumber().Int64Value();
  Napi::Array input_size_array__ = info__[2].As<Napi::Array>();
  int input_size_len = input_size_array__.Length();
  int64_t *input_size_data = new int64_t[input_size_len];
  for (int i = 0; i < input_size_len; ++i)
    input_size_data[i] = input_size_array__.Get(i).ToNumber().Int64Value();
  bool align_corners = info__[3].As<Napi::Boolean>().Value();
  bool scales_d_null = info__[4].IsUndefined();
  double scales_d_v = scales_d_null ? 0 : info__[4].As<Napi::Number>().DoubleValue();
  bool scales_h_null = info__[5].IsUndefined();
  double scales_h_v = scales_h_null ? 0 : info__[5].As<Napi::Number>().DoubleValue();
  bool scales_w_null = info__[6].IsUndefined();
  double scales_w_v = scales_w_null ? 0 : info__[6].As<Napi::Number>().DoubleValue();
  auto output__ = torch::upsample_trilinear3d_backward(*grad_output, torch::IntArrayRef(output_size_data, output_size_len), torch::IntArrayRef(input_size_data, input_size_len), align_corners, scales_d_null ? c10::nullopt : c10::optional<double>(scales_d_v), scales_h_null ? c10::nullopt : c10::optional<double>(scales_h_v), scales_w_null ? c10::nullopt : c10::optional<double>(scales_w_v));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_upsample_trilinear3d_backward_grad_input(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *grad_input = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *grad_output = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array output_size_array__ = info__[2].As<Napi::Array>();
  int output_size_len = output_size_array__.Length();
  int64_t *output_size_data = new int64_t[output_size_len];
  for (int i = 0; i < output_size_len; ++i)
    output_size_data[i] = output_size_array__.Get(i).ToNumber().Int64Value();
  Napi::Array input_size_array__ = info__[3].As<Napi::Array>();
  int input_size_len = input_size_array__.Length();
  int64_t *input_size_data = new int64_t[input_size_len];
  for (int i = 0; i < input_size_len; ++i)
    input_size_data[i] = input_size_array__.Get(i).ToNumber().Int64Value();
  bool align_corners = info__[4].As<Napi::Boolean>().Value();
  bool scales_d_null = info__[5].IsUndefined();
  double scales_d_v = scales_d_null ? 0 : info__[5].As<Napi::Number>().DoubleValue();
  bool scales_h_null = info__[6].IsUndefined();
  double scales_h_v = scales_h_null ? 0 : info__[6].As<Napi::Number>().DoubleValue();
  bool scales_w_null = info__[7].IsUndefined();
  double scales_w_v = scales_w_null ? 0 : info__[7].As<Napi::Number>().DoubleValue();
  auto output__ = torch::upsample_trilinear3d_backward_out(*grad_input, *grad_output, torch::IntArrayRef(output_size_data, output_size_len), torch::IntArrayRef(input_size_data, input_size_len), align_corners, scales_d_null ? c10::nullopt : c10::optional<double>(scales_d_v), scales_h_null ? c10::nullopt : c10::optional<double>(scales_h_v), scales_w_null ? c10::nullopt : c10::optional<double>(scales_w_v));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_upsample_nearest1d_backward(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *grad_output = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array output_size_array__ = info__[1].As<Napi::Array>();
  int output_size_len = output_size_array__.Length();
  int64_t *output_size_data = new int64_t[output_size_len];
  for (int i = 0; i < output_size_len; ++i)
    output_size_data[i] = output_size_array__.Get(i).ToNumber().Int64Value();
  Napi::Array input_size_array__ = info__[2].As<Napi::Array>();
  int input_size_len = input_size_array__.Length();
  int64_t *input_size_data = new int64_t[input_size_len];
  for (int i = 0; i < input_size_len; ++i)
    input_size_data[i] = input_size_array__.Get(i).ToNumber().Int64Value();
  bool scales_null = info__[3].IsUndefined();
  double scales_v = scales_null ? 0 : info__[3].As<Napi::Number>().DoubleValue();
  auto output__ = torch::upsample_nearest1d_backward(*grad_output, torch::IntArrayRef(output_size_data, output_size_len), torch::IntArrayRef(input_size_data, input_size_len), scales_null ? c10::nullopt : c10::optional<double>(scales_v));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_upsample_nearest1d_backward_grad_input(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *grad_input = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *grad_output = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array output_size_array__ = info__[2].As<Napi::Array>();
  int output_size_len = output_size_array__.Length();
  int64_t *output_size_data = new int64_t[output_size_len];
  for (int i = 0; i < output_size_len; ++i)
    output_size_data[i] = output_size_array__.Get(i).ToNumber().Int64Value();
  Napi::Array input_size_array__ = info__[3].As<Napi::Array>();
  int input_size_len = input_size_array__.Length();
  int64_t *input_size_data = new int64_t[input_size_len];
  for (int i = 0; i < input_size_len; ++i)
    input_size_data[i] = input_size_array__.Get(i).ToNumber().Int64Value();
  bool scales_null = info__[4].IsUndefined();
  double scales_v = scales_null ? 0 : info__[4].As<Napi::Number>().DoubleValue();
  auto output__ = torch::upsample_nearest1d_backward_out(*grad_input, *grad_output, torch::IntArrayRef(output_size_data, output_size_len), torch::IntArrayRef(input_size_data, input_size_len), scales_null ? c10::nullopt : c10::optional<double>(scales_v));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__upsample_nearest_exact1d_backward(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *grad_output = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array output_size_array__ = info__[1].As<Napi::Array>();
  int output_size_len = output_size_array__.Length();
  int64_t *output_size_data = new int64_t[output_size_len];
  for (int i = 0; i < output_size_len; ++i)
    output_size_data[i] = output_size_array__.Get(i).ToNumber().Int64Value();
  Napi::Array input_size_array__ = info__[2].As<Napi::Array>();
  int input_size_len = input_size_array__.Length();
  int64_t *input_size_data = new int64_t[input_size_len];
  for (int i = 0; i < input_size_len; ++i)
    input_size_data[i] = input_size_array__.Get(i).ToNumber().Int64Value();
  bool scales_null = info__[3].IsUndefined();
  double scales_v = scales_null ? 0 : info__[3].As<Napi::Number>().DoubleValue();
  auto output__ = torch::_upsample_nearest_exact1d_backward(*grad_output, torch::IntArrayRef(output_size_data, output_size_len), torch::IntArrayRef(input_size_data, input_size_len), scales_null ? c10::nullopt : c10::optional<double>(scales_v));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__upsample_nearest_exact1d_backward_grad_input(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *grad_input = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *grad_output = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array output_size_array__ = info__[2].As<Napi::Array>();
  int output_size_len = output_size_array__.Length();
  int64_t *output_size_data = new int64_t[output_size_len];
  for (int i = 0; i < output_size_len; ++i)
    output_size_data[i] = output_size_array__.Get(i).ToNumber().Int64Value();
  Napi::Array input_size_array__ = info__[3].As<Napi::Array>();
  int input_size_len = input_size_array__.Length();
  int64_t *input_size_data = new int64_t[input_size_len];
  for (int i = 0; i < input_size_len; ++i)
    input_size_data[i] = input_size_array__.Get(i).ToNumber().Int64Value();
  bool scales_null = info__[4].IsUndefined();
  double scales_v = scales_null ? 0 : info__[4].As<Napi::Number>().DoubleValue();
  auto output__ = torch::_upsample_nearest_exact1d_backward_out(*grad_input, *grad_output, torch::IntArrayRef(output_size_data, output_size_len), torch::IntArrayRef(input_size_data, input_size_len), scales_null ? c10::nullopt : c10::optional<double>(scales_v));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_upsample_nearest2d_backward(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *grad_output = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array output_size_array__ = info__[1].As<Napi::Array>();
  int output_size_len = output_size_array__.Length();
  int64_t *output_size_data = new int64_t[output_size_len];
  for (int i = 0; i < output_size_len; ++i)
    output_size_data[i] = output_size_array__.Get(i).ToNumber().Int64Value();
  Napi::Array input_size_array__ = info__[2].As<Napi::Array>();
  int input_size_len = input_size_array__.Length();
  int64_t *input_size_data = new int64_t[input_size_len];
  for (int i = 0; i < input_size_len; ++i)
    input_size_data[i] = input_size_array__.Get(i).ToNumber().Int64Value();
  bool scales_h_null = info__[3].IsUndefined();
  double scales_h_v = scales_h_null ? 0 : info__[3].As<Napi::Number>().DoubleValue();
  bool scales_w_null = info__[4].IsUndefined();
  double scales_w_v = scales_w_null ? 0 : info__[4].As<Napi::Number>().DoubleValue();
  auto output__ = torch::upsample_nearest2d_backward(*grad_output, torch::IntArrayRef(output_size_data, output_size_len), torch::IntArrayRef(input_size_data, input_size_len), scales_h_null ? c10::nullopt : c10::optional<double>(scales_h_v), scales_w_null ? c10::nullopt : c10::optional<double>(scales_w_v));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_upsample_nearest2d_backward_grad_input(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *grad_input = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *grad_output = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array output_size_array__ = info__[2].As<Napi::Array>();
  int output_size_len = output_size_array__.Length();
  int64_t *output_size_data = new int64_t[output_size_len];
  for (int i = 0; i < output_size_len; ++i)
    output_size_data[i] = output_size_array__.Get(i).ToNumber().Int64Value();
  Napi::Array input_size_array__ = info__[3].As<Napi::Array>();
  int input_size_len = input_size_array__.Length();
  int64_t *input_size_data = new int64_t[input_size_len];
  for (int i = 0; i < input_size_len; ++i)
    input_size_data[i] = input_size_array__.Get(i).ToNumber().Int64Value();
  bool scales_h_null = info__[4].IsUndefined();
  double scales_h_v = scales_h_null ? 0 : info__[4].As<Napi::Number>().DoubleValue();
  bool scales_w_null = info__[5].IsUndefined();
  double scales_w_v = scales_w_null ? 0 : info__[5].As<Napi::Number>().DoubleValue();
  auto output__ = torch::upsample_nearest2d_backward_out(*grad_input, *grad_output, torch::IntArrayRef(output_size_data, output_size_len), torch::IntArrayRef(input_size_data, input_size_len), scales_h_null ? c10::nullopt : c10::optional<double>(scales_h_v), scales_w_null ? c10::nullopt : c10::optional<double>(scales_w_v));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__upsample_nearest_exact2d_backward(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *grad_output = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array output_size_array__ = info__[1].As<Napi::Array>();
  int output_size_len = output_size_array__.Length();
  int64_t *output_size_data = new int64_t[output_size_len];
  for (int i = 0; i < output_size_len; ++i)
    output_size_data[i] = output_size_array__.Get(i).ToNumber().Int64Value();
  Napi::Array input_size_array__ = info__[2].As<Napi::Array>();
  int input_size_len = input_size_array__.Length();
  int64_t *input_size_data = new int64_t[input_size_len];
  for (int i = 0; i < input_size_len; ++i)
    input_size_data[i] = input_size_array__.Get(i).ToNumber().Int64Value();
  bool scales_h_null = info__[3].IsUndefined();
  double scales_h_v = scales_h_null ? 0 : info__[3].As<Napi::Number>().DoubleValue();
  bool scales_w_null = info__[4].IsUndefined();
  double scales_w_v = scales_w_null ? 0 : info__[4].As<Napi::Number>().DoubleValue();
  auto output__ = torch::_upsample_nearest_exact2d_backward(*grad_output, torch::IntArrayRef(output_size_data, output_size_len), torch::IntArrayRef(input_size_data, input_size_len), scales_h_null ? c10::nullopt : c10::optional<double>(scales_h_v), scales_w_null ? c10::nullopt : c10::optional<double>(scales_w_v));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__upsample_nearest_exact2d_backward_grad_input(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *grad_input = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *grad_output = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array output_size_array__ = info__[2].As<Napi::Array>();
  int output_size_len = output_size_array__.Length();
  int64_t *output_size_data = new int64_t[output_size_len];
  for (int i = 0; i < output_size_len; ++i)
    output_size_data[i] = output_size_array__.Get(i).ToNumber().Int64Value();
  Napi::Array input_size_array__ = info__[3].As<Napi::Array>();
  int input_size_len = input_size_array__.Length();
  int64_t *input_size_data = new int64_t[input_size_len];
  for (int i = 0; i < input_size_len; ++i)
    input_size_data[i] = input_size_array__.Get(i).ToNumber().Int64Value();
  bool scales_h_null = info__[4].IsUndefined();
  double scales_h_v = scales_h_null ? 0 : info__[4].As<Napi::Number>().DoubleValue();
  bool scales_w_null = info__[5].IsUndefined();
  double scales_w_v = scales_w_null ? 0 : info__[5].As<Napi::Number>().DoubleValue();
  auto output__ = torch::_upsample_nearest_exact2d_backward_out(*grad_input, *grad_output, torch::IntArrayRef(output_size_data, output_size_len), torch::IntArrayRef(input_size_data, input_size_len), scales_h_null ? c10::nullopt : c10::optional<double>(scales_h_v), scales_w_null ? c10::nullopt : c10::optional<double>(scales_w_v));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_upsample_nearest3d_backward(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *grad_output = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array output_size_array__ = info__[1].As<Napi::Array>();
  int output_size_len = output_size_array__.Length();
  int64_t *output_size_data = new int64_t[output_size_len];
  for (int i = 0; i < output_size_len; ++i)
    output_size_data[i] = output_size_array__.Get(i).ToNumber().Int64Value();
  Napi::Array input_size_array__ = info__[2].As<Napi::Array>();
  int input_size_len = input_size_array__.Length();
  int64_t *input_size_data = new int64_t[input_size_len];
  for (int i = 0; i < input_size_len; ++i)
    input_size_data[i] = input_size_array__.Get(i).ToNumber().Int64Value();
  bool scales_d_null = info__[3].IsUndefined();
  double scales_d_v = scales_d_null ? 0 : info__[3].As<Napi::Number>().DoubleValue();
  bool scales_h_null = info__[4].IsUndefined();
  double scales_h_v = scales_h_null ? 0 : info__[4].As<Napi::Number>().DoubleValue();
  bool scales_w_null = info__[5].IsUndefined();
  double scales_w_v = scales_w_null ? 0 : info__[5].As<Napi::Number>().DoubleValue();
  auto output__ = torch::upsample_nearest3d_backward(*grad_output, torch::IntArrayRef(output_size_data, output_size_len), torch::IntArrayRef(input_size_data, input_size_len), scales_d_null ? c10::nullopt : c10::optional<double>(scales_d_v), scales_h_null ? c10::nullopt : c10::optional<double>(scales_h_v), scales_w_null ? c10::nullopt : c10::optional<double>(scales_w_v));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_upsample_nearest3d_backward_grad_input(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *grad_input = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *grad_output = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array output_size_array__ = info__[2].As<Napi::Array>();
  int output_size_len = output_size_array__.Length();
  int64_t *output_size_data = new int64_t[output_size_len];
  for (int i = 0; i < output_size_len; ++i)
    output_size_data[i] = output_size_array__.Get(i).ToNumber().Int64Value();
  Napi::Array input_size_array__ = info__[3].As<Napi::Array>();
  int input_size_len = input_size_array__.Length();
  int64_t *input_size_data = new int64_t[input_size_len];
  for (int i = 0; i < input_size_len; ++i)
    input_size_data[i] = input_size_array__.Get(i).ToNumber().Int64Value();
  bool scales_d_null = info__[4].IsUndefined();
  double scales_d_v = scales_d_null ? 0 : info__[4].As<Napi::Number>().DoubleValue();
  bool scales_h_null = info__[5].IsUndefined();
  double scales_h_v = scales_h_null ? 0 : info__[5].As<Napi::Number>().DoubleValue();
  bool scales_w_null = info__[6].IsUndefined();
  double scales_w_v = scales_w_null ? 0 : info__[6].As<Napi::Number>().DoubleValue();
  auto output__ = torch::upsample_nearest3d_backward_out(*grad_input, *grad_output, torch::IntArrayRef(output_size_data, output_size_len), torch::IntArrayRef(input_size_data, input_size_len), scales_d_null ? c10::nullopt : c10::optional<double>(scales_d_v), scales_h_null ? c10::nullopt : c10::optional<double>(scales_h_v), scales_w_null ? c10::nullopt : c10::optional<double>(scales_w_v));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__upsample_nearest_exact3d_backward(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *grad_output = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array output_size_array__ = info__[1].As<Napi::Array>();
  int output_size_len = output_size_array__.Length();
  int64_t *output_size_data = new int64_t[output_size_len];
  for (int i = 0; i < output_size_len; ++i)
    output_size_data[i] = output_size_array__.Get(i).ToNumber().Int64Value();
  Napi::Array input_size_array__ = info__[2].As<Napi::Array>();
  int input_size_len = input_size_array__.Length();
  int64_t *input_size_data = new int64_t[input_size_len];
  for (int i = 0; i < input_size_len; ++i)
    input_size_data[i] = input_size_array__.Get(i).ToNumber().Int64Value();
  bool scales_d_null = info__[3].IsUndefined();
  double scales_d_v = scales_d_null ? 0 : info__[3].As<Napi::Number>().DoubleValue();
  bool scales_h_null = info__[4].IsUndefined();
  double scales_h_v = scales_h_null ? 0 : info__[4].As<Napi::Number>().DoubleValue();
  bool scales_w_null = info__[5].IsUndefined();
  double scales_w_v = scales_w_null ? 0 : info__[5].As<Napi::Number>().DoubleValue();
  auto output__ = torch::_upsample_nearest_exact3d_backward(*grad_output, torch::IntArrayRef(output_size_data, output_size_len), torch::IntArrayRef(input_size_data, input_size_len), scales_d_null ? c10::nullopt : c10::optional<double>(scales_d_v), scales_h_null ? c10::nullopt : c10::optional<double>(scales_h_v), scales_w_null ? c10::nullopt : c10::optional<double>(scales_w_v));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__upsample_nearest_exact3d_backward_grad_input(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *grad_input = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *grad_output = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array output_size_array__ = info__[2].As<Napi::Array>();
  int output_size_len = output_size_array__.Length();
  int64_t *output_size_data = new int64_t[output_size_len];
  for (int i = 0; i < output_size_len; ++i)
    output_size_data[i] = output_size_array__.Get(i).ToNumber().Int64Value();
  Napi::Array input_size_array__ = info__[3].As<Napi::Array>();
  int input_size_len = input_size_array__.Length();
  int64_t *input_size_data = new int64_t[input_size_len];
  for (int i = 0; i < input_size_len; ++i)
    input_size_data[i] = input_size_array__.Get(i).ToNumber().Int64Value();
  bool scales_d_null = info__[4].IsUndefined();
  double scales_d_v = scales_d_null ? 0 : info__[4].As<Napi::Number>().DoubleValue();
  bool scales_h_null = info__[5].IsUndefined();
  double scales_h_v = scales_h_null ? 0 : info__[5].As<Napi::Number>().DoubleValue();
  bool scales_w_null = info__[6].IsUndefined();
  double scales_w_v = scales_w_null ? 0 : info__[6].As<Napi::Number>().DoubleValue();
  auto output__ = torch::_upsample_nearest_exact3d_backward_out(*grad_input, *grad_output, torch::IntArrayRef(output_size_data, output_size_len), torch::IntArrayRef(input_size_data, input_size_len), scales_d_null ? c10::nullopt : c10::optional<double>(scales_d_v), scales_h_null ? c10::nullopt : c10::optional<double>(scales_h_v), scales_w_null ? c10::nullopt : c10::optional<double>(scales_w_v));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_sigmoid_backward(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *grad_output = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *output = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::sigmoid_backward(*grad_output, *output);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_sigmoid_backward_grad_input(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *grad_input = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *grad_output = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *output = info__[2].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::sigmoid_backward_out(*grad_input, *grad_output, *output);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_logit_backward(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *grad_output = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  bool eps_null = info__[2].IsUndefined();
  double eps_v = eps_null ? 0 : info__[2].As<Napi::Number>().DoubleValue();
  auto output__ = torch::logit_backward(*grad_output, *self, eps_null ? c10::nullopt : c10::optional<double>(eps_v));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_logit_backward_grad_input(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *grad_input = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *grad_output = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[2].As<Napi::External<torch::Tensor>>().Data();
  bool eps_null = info__[3].IsUndefined();
  double eps_v = eps_null ? 0 : info__[3].As<Napi::Number>().DoubleValue();
  auto output__ = torch::logit_backward_out(*grad_input, *grad_output, *self, eps_null ? c10::nullopt : c10::optional<double>(eps_v));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_tanh_backward(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *grad_output = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *output = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::tanh_backward(*grad_output, *output);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_tanh_backward_grad_input(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *grad_input = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *grad_output = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *output = info__[2].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::tanh_backward_out(*grad_input, *grad_output, *output);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_slow_conv_transpose2d(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *weight = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array kernel_size_array__ = info__[2].As<Napi::Array>();
  int kernel_size_len = kernel_size_array__.Length();
  int64_t *kernel_size_data = new int64_t[kernel_size_len];
  for (int i = 0; i < kernel_size_len; ++i)
    kernel_size_data[i] = kernel_size_array__.Get(i).ToNumber().Int64Value();
  bool bias_null = info__[3].IsUndefined();
  torch::Tensor *bias_v = bias_null ? nullptr : info__[3].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array stride_array__ = info__[4].As<Napi::Array>();
  int stride_len = stride_array__.Length();
  int64_t *stride_data = new int64_t[stride_len];
  for (int i = 0; i < stride_len; ++i)
    stride_data[i] = stride_array__.Get(i).ToNumber().Int64Value();
  Napi::Array padding_array__ = info__[5].As<Napi::Array>();
  int padding_len = padding_array__.Length();
  int64_t *padding_data = new int64_t[padding_len];
  for (int i = 0; i < padding_len; ++i)
    padding_data[i] = padding_array__.Get(i).ToNumber().Int64Value();
  Napi::Array output_padding_array__ = info__[6].As<Napi::Array>();
  int output_padding_len = output_padding_array__.Length();
  int64_t *output_padding_data = new int64_t[output_padding_len];
  for (int i = 0; i < output_padding_len; ++i)
    output_padding_data[i] = output_padding_array__.Get(i).ToNumber().Int64Value();
  Napi::Array dilation_array__ = info__[7].As<Napi::Array>();
  int dilation_len = dilation_array__.Length();
  int64_t *dilation_data = new int64_t[dilation_len];
  for (int i = 0; i < dilation_len; ++i)
    dilation_data[i] = dilation_array__.Get(i).ToNumber().Int64Value();
  auto output__ = torch::slow_conv_transpose2d(*self, *weight, torch::IntArrayRef(kernel_size_data, kernel_size_len), (bias_null ? *bias_v : torch::Tensor()), torch::IntArrayRef(stride_data, stride_len), torch::IntArrayRef(padding_data, padding_len), torch::IntArrayRef(output_padding_data, output_padding_len), torch::IntArrayRef(dilation_data, dilation_len));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_slow_conv_transpose2d_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *weight = info__[2].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array kernel_size_array__ = info__[3].As<Napi::Array>();
  int kernel_size_len = kernel_size_array__.Length();
  int64_t *kernel_size_data = new int64_t[kernel_size_len];
  for (int i = 0; i < kernel_size_len; ++i)
    kernel_size_data[i] = kernel_size_array__.Get(i).ToNumber().Int64Value();
  bool bias_null = info__[4].IsUndefined();
  torch::Tensor *bias_v = bias_null ? nullptr : info__[4].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array stride_array__ = info__[5].As<Napi::Array>();
  int stride_len = stride_array__.Length();
  int64_t *stride_data = new int64_t[stride_len];
  for (int i = 0; i < stride_len; ++i)
    stride_data[i] = stride_array__.Get(i).ToNumber().Int64Value();
  Napi::Array padding_array__ = info__[6].As<Napi::Array>();
  int padding_len = padding_array__.Length();
  int64_t *padding_data = new int64_t[padding_len];
  for (int i = 0; i < padding_len; ++i)
    padding_data[i] = padding_array__.Get(i).ToNumber().Int64Value();
  Napi::Array output_padding_array__ = info__[7].As<Napi::Array>();
  int output_padding_len = output_padding_array__.Length();
  int64_t *output_padding_data = new int64_t[output_padding_len];
  for (int i = 0; i < output_padding_len; ++i)
    output_padding_data[i] = output_padding_array__.Get(i).ToNumber().Int64Value();
  Napi::Array dilation_array__ = info__[8].As<Napi::Array>();
  int dilation_len = dilation_array__.Length();
  int64_t *dilation_data = new int64_t[dilation_len];
  for (int i = 0; i < dilation_len; ++i)
    dilation_data[i] = dilation_array__.Get(i).ToNumber().Int64Value();
  auto output__ = torch::slow_conv_transpose2d_out(*out, *self, *weight, torch::IntArrayRef(kernel_size_data, kernel_size_len), (bias_null ? *bias_v : torch::Tensor()), torch::IntArrayRef(stride_data, stride_len), torch::IntArrayRef(padding_data, padding_len), torch::IntArrayRef(output_padding_data, output_padding_len), torch::IntArrayRef(dilation_data, dilation_len));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_slow_conv_transpose3d(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *weight = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array kernel_size_array__ = info__[2].As<Napi::Array>();
  int kernel_size_len = kernel_size_array__.Length();
  int64_t *kernel_size_data = new int64_t[kernel_size_len];
  for (int i = 0; i < kernel_size_len; ++i)
    kernel_size_data[i] = kernel_size_array__.Get(i).ToNumber().Int64Value();
  bool bias_null = info__[3].IsUndefined();
  torch::Tensor *bias_v = bias_null ? nullptr : info__[3].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array stride_array__ = info__[4].As<Napi::Array>();
  int stride_len = stride_array__.Length();
  int64_t *stride_data = new int64_t[stride_len];
  for (int i = 0; i < stride_len; ++i)
    stride_data[i] = stride_array__.Get(i).ToNumber().Int64Value();
  Napi::Array padding_array__ = info__[5].As<Napi::Array>();
  int padding_len = padding_array__.Length();
  int64_t *padding_data = new int64_t[padding_len];
  for (int i = 0; i < padding_len; ++i)
    padding_data[i] = padding_array__.Get(i).ToNumber().Int64Value();
  Napi::Array output_padding_array__ = info__[6].As<Napi::Array>();
  int output_padding_len = output_padding_array__.Length();
  int64_t *output_padding_data = new int64_t[output_padding_len];
  for (int i = 0; i < output_padding_len; ++i)
    output_padding_data[i] = output_padding_array__.Get(i).ToNumber().Int64Value();
  Napi::Array dilation_array__ = info__[7].As<Napi::Array>();
  int dilation_len = dilation_array__.Length();
  int64_t *dilation_data = new int64_t[dilation_len];
  for (int i = 0; i < dilation_len; ++i)
    dilation_data[i] = dilation_array__.Get(i).ToNumber().Int64Value();
  auto output__ = torch::slow_conv_transpose3d(*self, *weight, torch::IntArrayRef(kernel_size_data, kernel_size_len), (bias_null ? *bias_v : torch::Tensor()), torch::IntArrayRef(stride_data, stride_len), torch::IntArrayRef(padding_data, padding_len), torch::IntArrayRef(output_padding_data, output_padding_len), torch::IntArrayRef(dilation_data, dilation_len));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_slow_conv_transpose3d_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *weight = info__[2].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array kernel_size_array__ = info__[3].As<Napi::Array>();
  int kernel_size_len = kernel_size_array__.Length();
  int64_t *kernel_size_data = new int64_t[kernel_size_len];
  for (int i = 0; i < kernel_size_len; ++i)
    kernel_size_data[i] = kernel_size_array__.Get(i).ToNumber().Int64Value();
  bool bias_null = info__[4].IsUndefined();
  torch::Tensor *bias_v = bias_null ? nullptr : info__[4].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array stride_array__ = info__[5].As<Napi::Array>();
  int stride_len = stride_array__.Length();
  int64_t *stride_data = new int64_t[stride_len];
  for (int i = 0; i < stride_len; ++i)
    stride_data[i] = stride_array__.Get(i).ToNumber().Int64Value();
  Napi::Array padding_array__ = info__[6].As<Napi::Array>();
  int padding_len = padding_array__.Length();
  int64_t *padding_data = new int64_t[padding_len];
  for (int i = 0; i < padding_len; ++i)
    padding_data[i] = padding_array__.Get(i).ToNumber().Int64Value();
  Napi::Array output_padding_array__ = info__[7].As<Napi::Array>();
  int output_padding_len = output_padding_array__.Length();
  int64_t *output_padding_data = new int64_t[output_padding_len];
  for (int i = 0; i < output_padding_len; ++i)
    output_padding_data[i] = output_padding_array__.Get(i).ToNumber().Int64Value();
  Napi::Array dilation_array__ = info__[8].As<Napi::Array>();
  int dilation_len = dilation_array__.Length();
  int64_t *dilation_data = new int64_t[dilation_len];
  for (int i = 0; i < dilation_len; ++i)
    dilation_data[i] = dilation_array__.Get(i).ToNumber().Int64Value();
  auto output__ = torch::slow_conv_transpose3d_out(*out, *self, *weight, torch::IntArrayRef(kernel_size_data, kernel_size_len), (bias_null ? *bias_v : torch::Tensor()), torch::IntArrayRef(stride_data, stride_len), torch::IntArrayRef(padding_data, padding_len), torch::IntArrayRef(output_padding_data, output_padding_len), torch::IntArrayRef(dilation_data, dilation_len));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::Array atg__slow_conv2d_backward(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *grad_input = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *grad_weight = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *grad_bias = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *grad_output = info__[3].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[4].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *weight = info__[5].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array kernel_size_array__ = info__[6].As<Napi::Array>();
  int kernel_size_len = kernel_size_array__.Length();
  int64_t *kernel_size_data = new int64_t[kernel_size_len];
  for (int i = 0; i < kernel_size_len; ++i)
    kernel_size_data[i] = kernel_size_array__.Get(i).ToNumber().Int64Value();
  Napi::Array stride_array__ = info__[7].As<Napi::Array>();
  int stride_len = stride_array__.Length();
  int64_t *stride_data = new int64_t[stride_len];
  for (int i = 0; i < stride_len; ++i)
    stride_data[i] = stride_array__.Get(i).ToNumber().Int64Value();
  Napi::Array padding_array__ = info__[8].As<Napi::Array>();
  int padding_len = padding_array__.Length();
  int64_t *padding_data = new int64_t[padding_len];
  for (int i = 0; i < padding_len; ++i)
    padding_data[i] = padding_array__.Get(i).ToNumber().Int64Value();
  auto output__ = torch::_slow_conv2d_backward_out(*grad_input, *grad_weight, *grad_bias, *grad_output, *self, *weight, torch::IntArrayRef(kernel_size_data, kernel_size_len), torch::IntArrayRef(stride_data, stride_len), torch::IntArrayRef(padding_data, padding_len));
  Napi::Array output__array__ = Napi::Array::New(env__, 3);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  output__array__[2u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<2>(output__)));
  return output__array__;
}

Napi::External<torch::Tensor> atg__conv_depthwise2d(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *weight = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array kernel_size_array__ = info__[2].As<Napi::Array>();
  int kernel_size_len = kernel_size_array__.Length();
  int64_t *kernel_size_data = new int64_t[kernel_size_len];
  for (int i = 0; i < kernel_size_len; ++i)
    kernel_size_data[i] = kernel_size_array__.Get(i).ToNumber().Int64Value();
  bool bias_null = info__[3].IsUndefined();
  torch::Tensor *bias_v = bias_null ? nullptr : info__[3].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array stride_array__ = info__[4].As<Napi::Array>();
  int stride_len = stride_array__.Length();
  int64_t *stride_data = new int64_t[stride_len];
  for (int i = 0; i < stride_len; ++i)
    stride_data[i] = stride_array__.Get(i).ToNumber().Int64Value();
  Napi::Array padding_array__ = info__[5].As<Napi::Array>();
  int padding_len = padding_array__.Length();
  int64_t *padding_data = new int64_t[padding_len];
  for (int i = 0; i < padding_len; ++i)
    padding_data[i] = padding_array__.Get(i).ToNumber().Int64Value();
  Napi::Array dilation_array__ = info__[6].As<Napi::Array>();
  int dilation_len = dilation_array__.Length();
  int64_t *dilation_data = new int64_t[dilation_len];
  for (int i = 0; i < dilation_len; ++i)
    dilation_data[i] = dilation_array__.Get(i).ToNumber().Int64Value();
  auto output__ = torch::_conv_depthwise2d(*self, *weight, torch::IntArrayRef(kernel_size_data, kernel_size_len), (bias_null ? *bias_v : torch::Tensor()), torch::IntArrayRef(stride_data, stride_len), torch::IntArrayRef(padding_data, padding_len), torch::IntArrayRef(dilation_data, dilation_len));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__conv_depthwise2d_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *weight = info__[2].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array kernel_size_array__ = info__[3].As<Napi::Array>();
  int kernel_size_len = kernel_size_array__.Length();
  int64_t *kernel_size_data = new int64_t[kernel_size_len];
  for (int i = 0; i < kernel_size_len; ++i)
    kernel_size_data[i] = kernel_size_array__.Get(i).ToNumber().Int64Value();
  bool bias_null = info__[4].IsUndefined();
  torch::Tensor *bias_v = bias_null ? nullptr : info__[4].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array stride_array__ = info__[5].As<Napi::Array>();
  int stride_len = stride_array__.Length();
  int64_t *stride_data = new int64_t[stride_len];
  for (int i = 0; i < stride_len; ++i)
    stride_data[i] = stride_array__.Get(i).ToNumber().Int64Value();
  Napi::Array padding_array__ = info__[6].As<Napi::Array>();
  int padding_len = padding_array__.Length();
  int64_t *padding_data = new int64_t[padding_len];
  for (int i = 0; i < padding_len; ++i)
    padding_data[i] = padding_array__.Get(i).ToNumber().Int64Value();
  Napi::Array dilation_array__ = info__[7].As<Napi::Array>();
  int dilation_len = dilation_array__.Length();
  int64_t *dilation_data = new int64_t[dilation_len];
  for (int i = 0; i < dilation_len; ++i)
    dilation_data[i] = dilation_array__.Get(i).ToNumber().Int64Value();
  auto output__ = torch::_conv_depthwise2d_out(*out, *self, *weight, torch::IntArrayRef(kernel_size_data, kernel_size_len), (bias_null ? *bias_v : torch::Tensor()), torch::IntArrayRef(stride_data, stride_len), torch::IntArrayRef(padding_data, padding_len), torch::IntArrayRef(dilation_data, dilation_len));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_conv_depthwise3d(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *weight = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array kernel_size_array__ = info__[2].As<Napi::Array>();
  int kernel_size_len = kernel_size_array__.Length();
  int64_t *kernel_size_data = new int64_t[kernel_size_len];
  for (int i = 0; i < kernel_size_len; ++i)
    kernel_size_data[i] = kernel_size_array__.Get(i).ToNumber().Int64Value();
  bool bias_null = info__[3].IsUndefined();
  torch::Tensor *bias_v = bias_null ? nullptr : info__[3].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array stride_array__ = info__[4].As<Napi::Array>();
  int stride_len = stride_array__.Length();
  int64_t *stride_data = new int64_t[stride_len];
  for (int i = 0; i < stride_len; ++i)
    stride_data[i] = stride_array__.Get(i).ToNumber().Int64Value();
  Napi::Array padding_array__ = info__[5].As<Napi::Array>();
  int padding_len = padding_array__.Length();
  int64_t *padding_data = new int64_t[padding_len];
  for (int i = 0; i < padding_len; ++i)
    padding_data[i] = padding_array__.Get(i).ToNumber().Int64Value();
  Napi::Array dilation_array__ = info__[6].As<Napi::Array>();
  int dilation_len = dilation_array__.Length();
  int64_t *dilation_data = new int64_t[dilation_len];
  for (int i = 0; i < dilation_len; ++i)
    dilation_data[i] = dilation_array__.Get(i).ToNumber().Int64Value();
  auto output__ = torch::conv_depthwise3d(*self, *weight, torch::IntArrayRef(kernel_size_data, kernel_size_len), (bias_null ? *bias_v : torch::Tensor()), torch::IntArrayRef(stride_data, stride_len), torch::IntArrayRef(padding_data, padding_len), torch::IntArrayRef(dilation_data, dilation_len));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_conv_depthwise3d_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *weight = info__[2].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array kernel_size_array__ = info__[3].As<Napi::Array>();
  int kernel_size_len = kernel_size_array__.Length();
  int64_t *kernel_size_data = new int64_t[kernel_size_len];
  for (int i = 0; i < kernel_size_len; ++i)
    kernel_size_data[i] = kernel_size_array__.Get(i).ToNumber().Int64Value();
  bool bias_null = info__[4].IsUndefined();
  torch::Tensor *bias_v = bias_null ? nullptr : info__[4].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array stride_array__ = info__[5].As<Napi::Array>();
  int stride_len = stride_array__.Length();
  int64_t *stride_data = new int64_t[stride_len];
  for (int i = 0; i < stride_len; ++i)
    stride_data[i] = stride_array__.Get(i).ToNumber().Int64Value();
  Napi::Array padding_array__ = info__[6].As<Napi::Array>();
  int padding_len = padding_array__.Length();
  int64_t *padding_data = new int64_t[padding_len];
  for (int i = 0; i < padding_len; ++i)
    padding_data[i] = padding_array__.Get(i).ToNumber().Int64Value();
  Napi::Array dilation_array__ = info__[7].As<Napi::Array>();
  int dilation_len = dilation_array__.Length();
  int64_t *dilation_data = new int64_t[dilation_len];
  for (int i = 0; i < dilation_len; ++i)
    dilation_data[i] = dilation_array__.Get(i).ToNumber().Int64Value();
  auto output__ = torch::conv_depthwise3d_out(*out, *self, *weight, torch::IntArrayRef(kernel_size_data, kernel_size_len), (bias_null ? *bias_v : torch::Tensor()), torch::IntArrayRef(stride_data, stride_len), torch::IntArrayRef(padding_data, padding_len), torch::IntArrayRef(dilation_data, dilation_len));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_slow_conv3d(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *weight = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array kernel_size_array__ = info__[2].As<Napi::Array>();
  int kernel_size_len = kernel_size_array__.Length();
  int64_t *kernel_size_data = new int64_t[kernel_size_len];
  for (int i = 0; i < kernel_size_len; ++i)
    kernel_size_data[i] = kernel_size_array__.Get(i).ToNumber().Int64Value();
  bool bias_null = info__[3].IsUndefined();
  torch::Tensor *bias_v = bias_null ? nullptr : info__[3].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array stride_array__ = info__[4].As<Napi::Array>();
  int stride_len = stride_array__.Length();
  int64_t *stride_data = new int64_t[stride_len];
  for (int i = 0; i < stride_len; ++i)
    stride_data[i] = stride_array__.Get(i).ToNumber().Int64Value();
  Napi::Array padding_array__ = info__[5].As<Napi::Array>();
  int padding_len = padding_array__.Length();
  int64_t *padding_data = new int64_t[padding_len];
  for (int i = 0; i < padding_len; ++i)
    padding_data[i] = padding_array__.Get(i).ToNumber().Int64Value();
  auto output__ = torch::slow_conv3d(*self, *weight, torch::IntArrayRef(kernel_size_data, kernel_size_len), (bias_null ? *bias_v : torch::Tensor()), torch::IntArrayRef(stride_data, stride_len), torch::IntArrayRef(padding_data, padding_len));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_slow_conv3d_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *weight = info__[2].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array kernel_size_array__ = info__[3].As<Napi::Array>();
  int kernel_size_len = kernel_size_array__.Length();
  int64_t *kernel_size_data = new int64_t[kernel_size_len];
  for (int i = 0; i < kernel_size_len; ++i)
    kernel_size_data[i] = kernel_size_array__.Get(i).ToNumber().Int64Value();
  bool bias_null = info__[4].IsUndefined();
  torch::Tensor *bias_v = bias_null ? nullptr : info__[4].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array stride_array__ = info__[5].As<Napi::Array>();
  int stride_len = stride_array__.Length();
  int64_t *stride_data = new int64_t[stride_len];
  for (int i = 0; i < stride_len; ++i)
    stride_data[i] = stride_array__.Get(i).ToNumber().Int64Value();
  Napi::Array padding_array__ = info__[6].As<Napi::Array>();
  int padding_len = padding_array__.Length();
  int64_t *padding_data = new int64_t[padding_len];
  for (int i = 0; i < padding_len; ++i)
    padding_data[i] = padding_array__.Get(i).ToNumber().Int64Value();
  auto output__ = torch::slow_conv3d_out(*out, *self, *weight, torch::IntArrayRef(kernel_size_data, kernel_size_len), (bias_null ? *bias_v : torch::Tensor()), torch::IntArrayRef(stride_data, stride_len), torch::IntArrayRef(padding_data, padding_len));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_slow_conv_dilated2d(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *weight = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array kernel_size_array__ = info__[2].As<Napi::Array>();
  int kernel_size_len = kernel_size_array__.Length();
  int64_t *kernel_size_data = new int64_t[kernel_size_len];
  for (int i = 0; i < kernel_size_len; ++i)
    kernel_size_data[i] = kernel_size_array__.Get(i).ToNumber().Int64Value();
  bool bias_null = info__[3].IsUndefined();
  torch::Tensor *bias_v = bias_null ? nullptr : info__[3].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array stride_array__ = info__[4].As<Napi::Array>();
  int stride_len = stride_array__.Length();
  int64_t *stride_data = new int64_t[stride_len];
  for (int i = 0; i < stride_len; ++i)
    stride_data[i] = stride_array__.Get(i).ToNumber().Int64Value();
  Napi::Array padding_array__ = info__[5].As<Napi::Array>();
  int padding_len = padding_array__.Length();
  int64_t *padding_data = new int64_t[padding_len];
  for (int i = 0; i < padding_len; ++i)
    padding_data[i] = padding_array__.Get(i).ToNumber().Int64Value();
  Napi::Array dilation_array__ = info__[6].As<Napi::Array>();
  int dilation_len = dilation_array__.Length();
  int64_t *dilation_data = new int64_t[dilation_len];
  for (int i = 0; i < dilation_len; ++i)
    dilation_data[i] = dilation_array__.Get(i).ToNumber().Int64Value();
  auto output__ = torch::slow_conv_dilated2d(*self, *weight, torch::IntArrayRef(kernel_size_data, kernel_size_len), (bias_null ? *bias_v : torch::Tensor()), torch::IntArrayRef(stride_data, stride_len), torch::IntArrayRef(padding_data, padding_len), torch::IntArrayRef(dilation_data, dilation_len));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_slow_conv_dilated2d_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *weight = info__[2].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array kernel_size_array__ = info__[3].As<Napi::Array>();
  int kernel_size_len = kernel_size_array__.Length();
  int64_t *kernel_size_data = new int64_t[kernel_size_len];
  for (int i = 0; i < kernel_size_len; ++i)
    kernel_size_data[i] = kernel_size_array__.Get(i).ToNumber().Int64Value();
  bool bias_null = info__[4].IsUndefined();
  torch::Tensor *bias_v = bias_null ? nullptr : info__[4].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array stride_array__ = info__[5].As<Napi::Array>();
  int stride_len = stride_array__.Length();
  int64_t *stride_data = new int64_t[stride_len];
  for (int i = 0; i < stride_len; ++i)
    stride_data[i] = stride_array__.Get(i).ToNumber().Int64Value();
  Napi::Array padding_array__ = info__[6].As<Napi::Array>();
  int padding_len = padding_array__.Length();
  int64_t *padding_data = new int64_t[padding_len];
  for (int i = 0; i < padding_len; ++i)
    padding_data[i] = padding_array__.Get(i).ToNumber().Int64Value();
  Napi::Array dilation_array__ = info__[7].As<Napi::Array>();
  int dilation_len = dilation_array__.Length();
  int64_t *dilation_data = new int64_t[dilation_len];
  for (int i = 0; i < dilation_len; ++i)
    dilation_data[i] = dilation_array__.Get(i).ToNumber().Int64Value();
  auto output__ = torch::slow_conv_dilated2d_out(*out, *self, *weight, torch::IntArrayRef(kernel_size_data, kernel_size_len), (bias_null ? *bias_v : torch::Tensor()), torch::IntArrayRef(stride_data, stride_len), torch::IntArrayRef(padding_data, padding_len), torch::IntArrayRef(dilation_data, dilation_len));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_slow_conv_dilated3d(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *weight = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array kernel_size_array__ = info__[2].As<Napi::Array>();
  int kernel_size_len = kernel_size_array__.Length();
  int64_t *kernel_size_data = new int64_t[kernel_size_len];
  for (int i = 0; i < kernel_size_len; ++i)
    kernel_size_data[i] = kernel_size_array__.Get(i).ToNumber().Int64Value();
  bool bias_null = info__[3].IsUndefined();
  torch::Tensor *bias_v = bias_null ? nullptr : info__[3].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array stride_array__ = info__[4].As<Napi::Array>();
  int stride_len = stride_array__.Length();
  int64_t *stride_data = new int64_t[stride_len];
  for (int i = 0; i < stride_len; ++i)
    stride_data[i] = stride_array__.Get(i).ToNumber().Int64Value();
  Napi::Array padding_array__ = info__[5].As<Napi::Array>();
  int padding_len = padding_array__.Length();
  int64_t *padding_data = new int64_t[padding_len];
  for (int i = 0; i < padding_len; ++i)
    padding_data[i] = padding_array__.Get(i).ToNumber().Int64Value();
  Napi::Array dilation_array__ = info__[6].As<Napi::Array>();
  int dilation_len = dilation_array__.Length();
  int64_t *dilation_data = new int64_t[dilation_len];
  for (int i = 0; i < dilation_len; ++i)
    dilation_data[i] = dilation_array__.Get(i).ToNumber().Int64Value();
  auto output__ = torch::slow_conv_dilated3d(*self, *weight, torch::IntArrayRef(kernel_size_data, kernel_size_len), (bias_null ? *bias_v : torch::Tensor()), torch::IntArrayRef(stride_data, stride_len), torch::IntArrayRef(padding_data, padding_len), torch::IntArrayRef(dilation_data, dilation_len));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_slow_conv_dilated3d_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *weight = info__[2].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array kernel_size_array__ = info__[3].As<Napi::Array>();
  int kernel_size_len = kernel_size_array__.Length();
  int64_t *kernel_size_data = new int64_t[kernel_size_len];
  for (int i = 0; i < kernel_size_len; ++i)
    kernel_size_data[i] = kernel_size_array__.Get(i).ToNumber().Int64Value();
  bool bias_null = info__[4].IsUndefined();
  torch::Tensor *bias_v = bias_null ? nullptr : info__[4].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array stride_array__ = info__[5].As<Napi::Array>();
  int stride_len = stride_array__.Length();
  int64_t *stride_data = new int64_t[stride_len];
  for (int i = 0; i < stride_len; ++i)
    stride_data[i] = stride_array__.Get(i).ToNumber().Int64Value();
  Napi::Array padding_array__ = info__[6].As<Napi::Array>();
  int padding_len = padding_array__.Length();
  int64_t *padding_data = new int64_t[padding_len];
  for (int i = 0; i < padding_len; ++i)
    padding_data[i] = padding_array__.Get(i).ToNumber().Int64Value();
  Napi::Array dilation_array__ = info__[7].As<Napi::Array>();
  int dilation_len = dilation_array__.Length();
  int64_t *dilation_data = new int64_t[dilation_len];
  for (int i = 0; i < dilation_len; ++i)
    dilation_data[i] = dilation_array__.Get(i).ToNumber().Int64Value();
  auto output__ = torch::slow_conv_dilated3d_out(*out, *self, *weight, torch::IntArrayRef(kernel_size_data, kernel_size_len), (bias_null ? *bias_v : torch::Tensor()), torch::IntArrayRef(stride_data, stride_len), torch::IntArrayRef(padding_data, padding_len), torch::IntArrayRef(dilation_data, dilation_len));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_col2im(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array output_size_array__ = info__[1].As<Napi::Array>();
  int output_size_len = output_size_array__.Length();
  int64_t *output_size_data = new int64_t[output_size_len];
  for (int i = 0; i < output_size_len; ++i)
    output_size_data[i] = output_size_array__.Get(i).ToNumber().Int64Value();
  Napi::Array kernel_size_array__ = info__[2].As<Napi::Array>();
  int kernel_size_len = kernel_size_array__.Length();
  int64_t *kernel_size_data = new int64_t[kernel_size_len];
  for (int i = 0; i < kernel_size_len; ++i)
    kernel_size_data[i] = kernel_size_array__.Get(i).ToNumber().Int64Value();
  Napi::Array dilation_array__ = info__[3].As<Napi::Array>();
  int dilation_len = dilation_array__.Length();
  int64_t *dilation_data = new int64_t[dilation_len];
  for (int i = 0; i < dilation_len; ++i)
    dilation_data[i] = dilation_array__.Get(i).ToNumber().Int64Value();
  Napi::Array padding_array__ = info__[4].As<Napi::Array>();
  int padding_len = padding_array__.Length();
  int64_t *padding_data = new int64_t[padding_len];
  for (int i = 0; i < padding_len; ++i)
    padding_data[i] = padding_array__.Get(i).ToNumber().Int64Value();
  Napi::Array stride_array__ = info__[5].As<Napi::Array>();
  int stride_len = stride_array__.Length();
  int64_t *stride_data = new int64_t[stride_len];
  for (int i = 0; i < stride_len; ++i)
    stride_data[i] = stride_array__.Get(i).ToNumber().Int64Value();
  auto output__ = torch::col2im(*self, torch::IntArrayRef(output_size_data, output_size_len), torch::IntArrayRef(kernel_size_data, kernel_size_len), torch::IntArrayRef(dilation_data, dilation_len), torch::IntArrayRef(padding_data, padding_len), torch::IntArrayRef(stride_data, stride_len));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_col2im_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array output_size_array__ = info__[2].As<Napi::Array>();
  int output_size_len = output_size_array__.Length();
  int64_t *output_size_data = new int64_t[output_size_len];
  for (int i = 0; i < output_size_len; ++i)
    output_size_data[i] = output_size_array__.Get(i).ToNumber().Int64Value();
  Napi::Array kernel_size_array__ = info__[3].As<Napi::Array>();
  int kernel_size_len = kernel_size_array__.Length();
  int64_t *kernel_size_data = new int64_t[kernel_size_len];
  for (int i = 0; i < kernel_size_len; ++i)
    kernel_size_data[i] = kernel_size_array__.Get(i).ToNumber().Int64Value();
  Napi::Array dilation_array__ = info__[4].As<Napi::Array>();
  int dilation_len = dilation_array__.Length();
  int64_t *dilation_data = new int64_t[dilation_len];
  for (int i = 0; i < dilation_len; ++i)
    dilation_data[i] = dilation_array__.Get(i).ToNumber().Int64Value();
  Napi::Array padding_array__ = info__[5].As<Napi::Array>();
  int padding_len = padding_array__.Length();
  int64_t *padding_data = new int64_t[padding_len];
  for (int i = 0; i < padding_len; ++i)
    padding_data[i] = padding_array__.Get(i).ToNumber().Int64Value();
  Napi::Array stride_array__ = info__[6].As<Napi::Array>();
  int stride_len = stride_array__.Length();
  int64_t *stride_data = new int64_t[stride_len];
  for (int i = 0; i < stride_len; ++i)
    stride_data[i] = stride_array__.Get(i).ToNumber().Int64Value();
  auto output__ = torch::col2im_out(*out, *self, torch::IntArrayRef(output_size_data, output_size_len), torch::IntArrayRef(kernel_size_data, kernel_size_len), torch::IntArrayRef(dilation_data, dilation_len), torch::IntArrayRef(padding_data, padding_len), torch::IntArrayRef(stride_data, stride_len));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_column_stack(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  Napi::Array tensors_array__ = info__[0].As<Napi::Array>();
  int tensors_len = tensors_array__.Length();
  torch::Tensor **tensors_data = new torch::Tensor *[tensors_len];
  for (int i = 0; i < tensors_len; ++i)
    tensors_data[i] = tensors_array__.Get(i).As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::column_stack(of_carray_tensor(tensors_data, tensors_len));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_column_stack_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array tensors_array__ = info__[1].As<Napi::Array>();
  int tensors_len = tensors_array__.Length();
  torch::Tensor **tensors_data = new torch::Tensor *[tensors_len];
  for (int i = 0; i < tensors_len; ++i)
    tensors_data[i] = tensors_array__.Get(i).As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::column_stack_out(*out, of_carray_tensor(tensors_data, tensors_len));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_im2col(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array kernel_size_array__ = info__[1].As<Napi::Array>();
  int kernel_size_len = kernel_size_array__.Length();
  int64_t *kernel_size_data = new int64_t[kernel_size_len];
  for (int i = 0; i < kernel_size_len; ++i)
    kernel_size_data[i] = kernel_size_array__.Get(i).ToNumber().Int64Value();
  Napi::Array dilation_array__ = info__[2].As<Napi::Array>();
  int dilation_len = dilation_array__.Length();
  int64_t *dilation_data = new int64_t[dilation_len];
  for (int i = 0; i < dilation_len; ++i)
    dilation_data[i] = dilation_array__.Get(i).ToNumber().Int64Value();
  Napi::Array padding_array__ = info__[3].As<Napi::Array>();
  int padding_len = padding_array__.Length();
  int64_t *padding_data = new int64_t[padding_len];
  for (int i = 0; i < padding_len; ++i)
    padding_data[i] = padding_array__.Get(i).ToNumber().Int64Value();
  Napi::Array stride_array__ = info__[4].As<Napi::Array>();
  int stride_len = stride_array__.Length();
  int64_t *stride_data = new int64_t[stride_len];
  for (int i = 0; i < stride_len; ++i)
    stride_data[i] = stride_array__.Get(i).ToNumber().Int64Value();
  auto output__ = torch::im2col(*self, torch::IntArrayRef(kernel_size_data, kernel_size_len), torch::IntArrayRef(dilation_data, dilation_len), torch::IntArrayRef(padding_data, padding_len), torch::IntArrayRef(stride_data, stride_len));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_im2col_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array kernel_size_array__ = info__[2].As<Napi::Array>();
  int kernel_size_len = kernel_size_array__.Length();
  int64_t *kernel_size_data = new int64_t[kernel_size_len];
  for (int i = 0; i < kernel_size_len; ++i)
    kernel_size_data[i] = kernel_size_array__.Get(i).ToNumber().Int64Value();
  Napi::Array dilation_array__ = info__[3].As<Napi::Array>();
  int dilation_len = dilation_array__.Length();
  int64_t *dilation_data = new int64_t[dilation_len];
  for (int i = 0; i < dilation_len; ++i)
    dilation_data[i] = dilation_array__.Get(i).ToNumber().Int64Value();
  Napi::Array padding_array__ = info__[4].As<Napi::Array>();
  int padding_len = padding_array__.Length();
  int64_t *padding_data = new int64_t[padding_len];
  for (int i = 0; i < padding_len; ++i)
    padding_data[i] = padding_array__.Get(i).ToNumber().Int64Value();
  Napi::Array stride_array__ = info__[5].As<Napi::Array>();
  int stride_len = stride_array__.Length();
  int64_t *stride_data = new int64_t[stride_len];
  for (int i = 0; i < stride_len; ++i)
    stride_data[i] = stride_array__.Get(i).ToNumber().Int64Value();
  auto output__ = torch::im2col_out(*out, *self, torch::IntArrayRef(kernel_size_data, kernel_size_len), torch::IntArrayRef(dilation_data, dilation_len), torch::IntArrayRef(padding_data, padding_len), torch::IntArrayRef(stride_data, stride_len));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_isfinite(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::isfinite(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_isinf(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::isinf(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_isinf_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::isinf_out(*out, *self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_isposinf(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::isposinf(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_isposinf_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::isposinf_out(*out, *self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_isneginf(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::isneginf(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_isneginf_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::isneginf_out(*out, *self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__add_batch_dim(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t batch_dim = info__[1].As<Napi::Number>().Int64Value();
  int64_t level = info__[2].As<Napi::Number>().Int64Value();
  auto output__ = torch::_add_batch_dim(*self, batch_dim, level);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__remove_batch_dim(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t level = info__[1].As<Napi::Number>().Int64Value();
  int64_t batch_size = info__[2].As<Napi::Number>().Int64Value();
  int64_t out_dim = info__[3].As<Napi::Number>().Int64Value();
  auto output__ = torch::_remove_batch_dim(*self, level, batch_size, out_dim);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_special_entr(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::special_entr(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_special_entr_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::special_entr_out(*out, *self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_special_ndtri(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::special_ndtri(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_special_ndtri_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::special_ndtri_out(*out, *self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_special_log_ndtr(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::special_log_ndtr(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_special_log_ndtr_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::special_log_ndtr_out(*out, *self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_special_expm1(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::special_expm1(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_special_expm1_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::special_expm1_out(*out, *self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_special_exp2(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::special_exp2(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_special_exp2_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::special_exp2_out(*out, *self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_special_psi(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::special_psi(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_special_psi_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::special_psi_out(*out, *self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_special_digamma(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::special_digamma(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_special_digamma_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::special_digamma_out(*out, *self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_special_gammaln(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::special_gammaln(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_special_gammaln_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::special_gammaln_out(*out, *self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_special_erf(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::special_erf(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_special_erf_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::special_erf_out(*out, *self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_special_erfc(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::special_erfc(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_special_erfc_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::special_erfc_out(*out, *self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_special_erfcx(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::special_erfcx(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_special_erfcx_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::special_erfcx_out(*out, *self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_special_erfinv(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::special_erfinv(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_special_erfinv_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::special_erfinv_out(*out, *self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_special_ndtr(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::special_ndtr(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_special_ndtr_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::special_ndtr_out(*out, *self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_special_xlog1py(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::special_xlog1py(*self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_special_xlog1py_self_scalar(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Scalar *self_scalar = info__[0].As<Napi::External<torch::Scalar>>().Data();
  torch::Tensor *other = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::special_xlog1py(*self_scalar, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_special_xlog1py_other_scalar(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *other = info__[1].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::special_xlog1py(*self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_special_xlog1py_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[2].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::special_xlog1py_out(*out, *self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_special_xlog1py_self_scalar_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *self_scalar = info__[1].As<Napi::External<torch::Scalar>>().Data();
  torch::Tensor *other = info__[2].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::special_xlog1py_out(*out, *self_scalar, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_special_xlog1py_other_scalar_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *other = info__[2].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::special_xlog1py_out(*out, *self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_special_xlogy(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::special_xlogy(*self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_special_xlogy_self_scalar(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Scalar *self_scalar = info__[0].As<Napi::External<torch::Scalar>>().Data();
  torch::Tensor *other = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::special_xlogy(*self_scalar, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_special_xlogy_other_scalar(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *other = info__[1].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::special_xlogy(*self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_special_xlogy_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[2].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::special_xlogy_out(*out, *self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_special_xlogy_self_scalar_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *self_scalar = info__[1].As<Napi::External<torch::Scalar>>().Data();
  torch::Tensor *other = info__[2].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::special_xlogy_out(*out, *self_scalar, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_special_xlogy_other_scalar_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *other = info__[2].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::special_xlogy_out(*out, *self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_special_zeta(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::special_zeta(*self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_special_zeta_self_scalar(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Scalar *self_scalar = info__[0].As<Napi::External<torch::Scalar>>().Data();
  torch::Tensor *other = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::special_zeta(*self_scalar, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_special_zeta_other_scalar(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *other = info__[1].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::special_zeta(*self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_special_zeta_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[2].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::special_zeta_out(*out, *self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_special_zeta_self_scalar_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *self_scalar = info__[1].As<Napi::External<torch::Scalar>>().Data();
  torch::Tensor *other = info__[2].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::special_zeta_out(*out, *self_scalar, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_special_zeta_other_scalar_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *other = info__[2].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::special_zeta_out(*out, *self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_special_i0(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::special_i0(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_special_i0_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::special_i0_out(*out, *self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_special_i0e(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::special_i0e(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_special_i0e_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::special_i0e_out(*out, *self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_special_i1(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::special_i1(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_special_i1_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::special_i1_out(*out, *self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_special_i1e(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::special_i1e(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_special_i1e_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::special_i1e_out(*out, *self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_special_logit(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  bool eps_null = info__[1].IsUndefined();
  double eps_v = eps_null ? 0 : info__[1].As<Napi::Number>().DoubleValue();
  auto output__ = torch::special_logit(*self, eps_null ? c10::nullopt : c10::optional<double>(eps_v));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_special_logit_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  bool eps_null = info__[2].IsUndefined();
  double eps_v = eps_null ? 0 : info__[2].As<Napi::Number>().DoubleValue();
  auto output__ = torch::special_logit_out(*out, *self, eps_null ? c10::nullopt : c10::optional<double>(eps_v));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_special_polygamma(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  int64_t n = info__[0].As<Napi::Number>().Int64Value();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::special_polygamma(n, *self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_special_polygamma_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t n = info__[1].As<Napi::Number>().Int64Value();
  torch::Tensor *self = info__[2].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::special_polygamma_out(*out, n, *self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_special_logsumexp(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array dim_array__ = info__[1].As<Napi::Array>();
  int dim_len = dim_array__.Length();
  int64_t *dim_data = new int64_t[dim_len];
  for (int i = 0; i < dim_len; ++i)
    dim_data[i] = dim_array__.Get(i).ToNumber().Int64Value();
  bool keepdim = info__[2].As<Napi::Boolean>().Value();
  auto output__ = torch::special_logsumexp(*self, torch::IntArrayRef(dim_data, dim_len), keepdim);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_special_logsumexp_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array dim_array__ = info__[2].As<Napi::Array>();
  int dim_len = dim_array__.Length();
  int64_t *dim_data = new int64_t[dim_len];
  for (int i = 0; i < dim_len; ++i)
    dim_data[i] = dim_array__.Get(i).ToNumber().Int64Value();
  bool keepdim = info__[3].As<Napi::Boolean>().Value();
  auto output__ = torch::special_logsumexp_out(*out, *self, torch::IntArrayRef(dim_data, dim_len), keepdim);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_special_expit(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::special_expit(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_special_expit_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::special_expit_out(*out, *self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_special_sinc(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::special_sinc(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_special_sinc_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::special_sinc_out(*out, *self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_special_round(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t decimals = info__[1].As<Napi::Number>().Int64Value();
  auto output__ = torch::special_round(*self, decimals);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_special_round_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  int64_t decimals = info__[2].As<Napi::Number>().Int64Value();
  auto output__ = torch::special_round_out(*out, *self, decimals);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_special_log1p(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::special_log1p(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_special_log1p_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::special_log1p_out(*out, *self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_special_log_softmax(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t dim = info__[1].As<Napi::Number>().Int64Value();
  int dtype = info__[2].As<Napi::Number>().Int32Value();
  auto output__ = torch::special_log_softmax(*self, dim, at::ScalarType(dtype));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_special_gammainc(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::special_gammainc(*self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_special_gammainc_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[2].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::special_gammainc_out(*out, *self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_special_gammaincc(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::special_gammaincc(*self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_special_gammaincc_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[2].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::special_gammaincc_out(*out, *self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_special_multigammaln(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t p = info__[1].As<Napi::Number>().Int64Value();
  auto output__ = torch::special_multigammaln(*self, p);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_special_multigammaln_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  int64_t p = info__[2].As<Napi::Number>().Int64Value();
  auto output__ = torch::special_multigammaln_out(*out, *self, p);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_special_softmax(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t dim = info__[1].As<Napi::Number>().Int64Value();
  int dtype = info__[2].As<Napi::Number>().Int32Value();
  auto output__ = torch::special_softmax(*self, dim, at::ScalarType(dtype));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_fft_fft(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  bool n_null = info__[1].IsUndefined();
  int64_t n_v = n_null ? 0 : info__[1].As<Napi::Number>().Int64Value();
  int64_t dim = info__[2].As<Napi::Number>().Int64Value();
  Napi::String norm_str__ = info__[3].As<Napi::String>();
  std::string norm = norm_str__.Utf8Value();
  auto output__ = torch::fft_fft(*self, n_null ? c10::nullopt : c10::optional<int64_t>(n_v), dim, norm);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_fft_fft_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  bool n_null = info__[2].IsUndefined();
  int64_t n_v = n_null ? 0 : info__[2].As<Napi::Number>().Int64Value();
  int64_t dim = info__[3].As<Napi::Number>().Int64Value();
  Napi::String norm_str__ = info__[4].As<Napi::String>();
  std::string norm = norm_str__.Utf8Value();
  auto output__ = torch::fft_fft_out(*out, *self, n_null ? c10::nullopt : c10::optional<int64_t>(n_v), dim, norm);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_fft_ifft(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  bool n_null = info__[1].IsUndefined();
  int64_t n_v = n_null ? 0 : info__[1].As<Napi::Number>().Int64Value();
  int64_t dim = info__[2].As<Napi::Number>().Int64Value();
  Napi::String norm_str__ = info__[3].As<Napi::String>();
  std::string norm = norm_str__.Utf8Value();
  auto output__ = torch::fft_ifft(*self, n_null ? c10::nullopt : c10::optional<int64_t>(n_v), dim, norm);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_fft_ifft_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  bool n_null = info__[2].IsUndefined();
  int64_t n_v = n_null ? 0 : info__[2].As<Napi::Number>().Int64Value();
  int64_t dim = info__[3].As<Napi::Number>().Int64Value();
  Napi::String norm_str__ = info__[4].As<Napi::String>();
  std::string norm = norm_str__.Utf8Value();
  auto output__ = torch::fft_ifft_out(*out, *self, n_null ? c10::nullopt : c10::optional<int64_t>(n_v), dim, norm);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_fft_rfft(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  bool n_null = info__[1].IsUndefined();
  int64_t n_v = n_null ? 0 : info__[1].As<Napi::Number>().Int64Value();
  int64_t dim = info__[2].As<Napi::Number>().Int64Value();
  Napi::String norm_str__ = info__[3].As<Napi::String>();
  std::string norm = norm_str__.Utf8Value();
  auto output__ = torch::fft_rfft(*self, n_null ? c10::nullopt : c10::optional<int64_t>(n_v), dim, norm);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_fft_rfft_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  bool n_null = info__[2].IsUndefined();
  int64_t n_v = n_null ? 0 : info__[2].As<Napi::Number>().Int64Value();
  int64_t dim = info__[3].As<Napi::Number>().Int64Value();
  Napi::String norm_str__ = info__[4].As<Napi::String>();
  std::string norm = norm_str__.Utf8Value();
  auto output__ = torch::fft_rfft_out(*out, *self, n_null ? c10::nullopt : c10::optional<int64_t>(n_v), dim, norm);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_fft_irfft(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  bool n_null = info__[1].IsUndefined();
  int64_t n_v = n_null ? 0 : info__[1].As<Napi::Number>().Int64Value();
  int64_t dim = info__[2].As<Napi::Number>().Int64Value();
  Napi::String norm_str__ = info__[3].As<Napi::String>();
  std::string norm = norm_str__.Utf8Value();
  auto output__ = torch::fft_irfft(*self, n_null ? c10::nullopt : c10::optional<int64_t>(n_v), dim, norm);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_fft_irfft_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  bool n_null = info__[2].IsUndefined();
  int64_t n_v = n_null ? 0 : info__[2].As<Napi::Number>().Int64Value();
  int64_t dim = info__[3].As<Napi::Number>().Int64Value();
  Napi::String norm_str__ = info__[4].As<Napi::String>();
  std::string norm = norm_str__.Utf8Value();
  auto output__ = torch::fft_irfft_out(*out, *self, n_null ? c10::nullopt : c10::optional<int64_t>(n_v), dim, norm);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_fft_hfft(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  bool n_null = info__[1].IsUndefined();
  int64_t n_v = n_null ? 0 : info__[1].As<Napi::Number>().Int64Value();
  int64_t dim = info__[2].As<Napi::Number>().Int64Value();
  Napi::String norm_str__ = info__[3].As<Napi::String>();
  std::string norm = norm_str__.Utf8Value();
  auto output__ = torch::fft_hfft(*self, n_null ? c10::nullopt : c10::optional<int64_t>(n_v), dim, norm);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_fft_hfft_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  bool n_null = info__[2].IsUndefined();
  int64_t n_v = n_null ? 0 : info__[2].As<Napi::Number>().Int64Value();
  int64_t dim = info__[3].As<Napi::Number>().Int64Value();
  Napi::String norm_str__ = info__[4].As<Napi::String>();
  std::string norm = norm_str__.Utf8Value();
  auto output__ = torch::fft_hfft_out(*out, *self, n_null ? c10::nullopt : c10::optional<int64_t>(n_v), dim, norm);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_fft_ihfft(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  bool n_null = info__[1].IsUndefined();
  int64_t n_v = n_null ? 0 : info__[1].As<Napi::Number>().Int64Value();
  int64_t dim = info__[2].As<Napi::Number>().Int64Value();
  Napi::String norm_str__ = info__[3].As<Napi::String>();
  std::string norm = norm_str__.Utf8Value();
  auto output__ = torch::fft_ihfft(*self, n_null ? c10::nullopt : c10::optional<int64_t>(n_v), dim, norm);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_fft_ihfft_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  bool n_null = info__[2].IsUndefined();
  int64_t n_v = n_null ? 0 : info__[2].As<Napi::Number>().Int64Value();
  int64_t dim = info__[3].As<Napi::Number>().Int64Value();
  Napi::String norm_str__ = info__[4].As<Napi::String>();
  std::string norm = norm_str__.Utf8Value();
  auto output__ = torch::fft_ihfft_out(*out, *self, n_null ? c10::nullopt : c10::optional<int64_t>(n_v), dim, norm);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_fft_fft2(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array s_array__ = info__[1].As<Napi::Array>();
  int s_len = s_array__.Length();
  int64_t *s_data = new int64_t[s_len];
  for (int i = 0; i < s_len; ++i)
    s_data[i] = s_array__.Get(i).ToNumber().Int64Value();
  Napi::Array dim_array__ = info__[2].As<Napi::Array>();
  int dim_len = dim_array__.Length();
  int64_t *dim_data = new int64_t[dim_len];
  for (int i = 0; i < dim_len; ++i)
    dim_data[i] = dim_array__.Get(i).ToNumber().Int64Value();
  Napi::String norm_str__ = info__[3].As<Napi::String>();
  std::string norm = norm_str__.Utf8Value();
  auto output__ = torch::fft_fft2(*self, s_data == nullptr ? c10::nullopt : c10::optional<torch::IntArrayRef>(torch::IntArrayRef(s_data, s_len)), torch::IntArrayRef(dim_data, dim_len), norm);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_fft_fft2_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array s_array__ = info__[2].As<Napi::Array>();
  int s_len = s_array__.Length();
  int64_t *s_data = new int64_t[s_len];
  for (int i = 0; i < s_len; ++i)
    s_data[i] = s_array__.Get(i).ToNumber().Int64Value();
  Napi::Array dim_array__ = info__[3].As<Napi::Array>();
  int dim_len = dim_array__.Length();
  int64_t *dim_data = new int64_t[dim_len];
  for (int i = 0; i < dim_len; ++i)
    dim_data[i] = dim_array__.Get(i).ToNumber().Int64Value();
  Napi::String norm_str__ = info__[4].As<Napi::String>();
  std::string norm = norm_str__.Utf8Value();
  auto output__ = torch::fft_fft2_out(*out, *self, s_data == nullptr ? c10::nullopt : c10::optional<torch::IntArrayRef>(torch::IntArrayRef(s_data, s_len)), torch::IntArrayRef(dim_data, dim_len), norm);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_fft_ifft2(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array s_array__ = info__[1].As<Napi::Array>();
  int s_len = s_array__.Length();
  int64_t *s_data = new int64_t[s_len];
  for (int i = 0; i < s_len; ++i)
    s_data[i] = s_array__.Get(i).ToNumber().Int64Value();
  Napi::Array dim_array__ = info__[2].As<Napi::Array>();
  int dim_len = dim_array__.Length();
  int64_t *dim_data = new int64_t[dim_len];
  for (int i = 0; i < dim_len; ++i)
    dim_data[i] = dim_array__.Get(i).ToNumber().Int64Value();
  Napi::String norm_str__ = info__[3].As<Napi::String>();
  std::string norm = norm_str__.Utf8Value();
  auto output__ = torch::fft_ifft2(*self, s_data == nullptr ? c10::nullopt : c10::optional<torch::IntArrayRef>(torch::IntArrayRef(s_data, s_len)), torch::IntArrayRef(dim_data, dim_len), norm);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_fft_ifft2_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array s_array__ = info__[2].As<Napi::Array>();
  int s_len = s_array__.Length();
  int64_t *s_data = new int64_t[s_len];
  for (int i = 0; i < s_len; ++i)
    s_data[i] = s_array__.Get(i).ToNumber().Int64Value();
  Napi::Array dim_array__ = info__[3].As<Napi::Array>();
  int dim_len = dim_array__.Length();
  int64_t *dim_data = new int64_t[dim_len];
  for (int i = 0; i < dim_len; ++i)
    dim_data[i] = dim_array__.Get(i).ToNumber().Int64Value();
  Napi::String norm_str__ = info__[4].As<Napi::String>();
  std::string norm = norm_str__.Utf8Value();
  auto output__ = torch::fft_ifft2_out(*out, *self, s_data == nullptr ? c10::nullopt : c10::optional<torch::IntArrayRef>(torch::IntArrayRef(s_data, s_len)), torch::IntArrayRef(dim_data, dim_len), norm);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_fft_rfft2(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array s_array__ = info__[1].As<Napi::Array>();
  int s_len = s_array__.Length();
  int64_t *s_data = new int64_t[s_len];
  for (int i = 0; i < s_len; ++i)
    s_data[i] = s_array__.Get(i).ToNumber().Int64Value();
  Napi::Array dim_array__ = info__[2].As<Napi::Array>();
  int dim_len = dim_array__.Length();
  int64_t *dim_data = new int64_t[dim_len];
  for (int i = 0; i < dim_len; ++i)
    dim_data[i] = dim_array__.Get(i).ToNumber().Int64Value();
  Napi::String norm_str__ = info__[3].As<Napi::String>();
  std::string norm = norm_str__.Utf8Value();
  auto output__ = torch::fft_rfft2(*self, s_data == nullptr ? c10::nullopt : c10::optional<torch::IntArrayRef>(torch::IntArrayRef(s_data, s_len)), torch::IntArrayRef(dim_data, dim_len), norm);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_fft_rfft2_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array s_array__ = info__[2].As<Napi::Array>();
  int s_len = s_array__.Length();
  int64_t *s_data = new int64_t[s_len];
  for (int i = 0; i < s_len; ++i)
    s_data[i] = s_array__.Get(i).ToNumber().Int64Value();
  Napi::Array dim_array__ = info__[3].As<Napi::Array>();
  int dim_len = dim_array__.Length();
  int64_t *dim_data = new int64_t[dim_len];
  for (int i = 0; i < dim_len; ++i)
    dim_data[i] = dim_array__.Get(i).ToNumber().Int64Value();
  Napi::String norm_str__ = info__[4].As<Napi::String>();
  std::string norm = norm_str__.Utf8Value();
  auto output__ = torch::fft_rfft2_out(*out, *self, s_data == nullptr ? c10::nullopt : c10::optional<torch::IntArrayRef>(torch::IntArrayRef(s_data, s_len)), torch::IntArrayRef(dim_data, dim_len), norm);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_fft_irfft2(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array s_array__ = info__[1].As<Napi::Array>();
  int s_len = s_array__.Length();
  int64_t *s_data = new int64_t[s_len];
  for (int i = 0; i < s_len; ++i)
    s_data[i] = s_array__.Get(i).ToNumber().Int64Value();
  Napi::Array dim_array__ = info__[2].As<Napi::Array>();
  int dim_len = dim_array__.Length();
  int64_t *dim_data = new int64_t[dim_len];
  for (int i = 0; i < dim_len; ++i)
    dim_data[i] = dim_array__.Get(i).ToNumber().Int64Value();
  Napi::String norm_str__ = info__[3].As<Napi::String>();
  std::string norm = norm_str__.Utf8Value();
  auto output__ = torch::fft_irfft2(*self, s_data == nullptr ? c10::nullopt : c10::optional<torch::IntArrayRef>(torch::IntArrayRef(s_data, s_len)), torch::IntArrayRef(dim_data, dim_len), norm);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_fft_irfft2_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array s_array__ = info__[2].As<Napi::Array>();
  int s_len = s_array__.Length();
  int64_t *s_data = new int64_t[s_len];
  for (int i = 0; i < s_len; ++i)
    s_data[i] = s_array__.Get(i).ToNumber().Int64Value();
  Napi::Array dim_array__ = info__[3].As<Napi::Array>();
  int dim_len = dim_array__.Length();
  int64_t *dim_data = new int64_t[dim_len];
  for (int i = 0; i < dim_len; ++i)
    dim_data[i] = dim_array__.Get(i).ToNumber().Int64Value();
  Napi::String norm_str__ = info__[4].As<Napi::String>();
  std::string norm = norm_str__.Utf8Value();
  auto output__ = torch::fft_irfft2_out(*out, *self, s_data == nullptr ? c10::nullopt : c10::optional<torch::IntArrayRef>(torch::IntArrayRef(s_data, s_len)), torch::IntArrayRef(dim_data, dim_len), norm);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_fft_hfft2(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array s_array__ = info__[1].As<Napi::Array>();
  int s_len = s_array__.Length();
  int64_t *s_data = new int64_t[s_len];
  for (int i = 0; i < s_len; ++i)
    s_data[i] = s_array__.Get(i).ToNumber().Int64Value();
  Napi::Array dim_array__ = info__[2].As<Napi::Array>();
  int dim_len = dim_array__.Length();
  int64_t *dim_data = new int64_t[dim_len];
  for (int i = 0; i < dim_len; ++i)
    dim_data[i] = dim_array__.Get(i).ToNumber().Int64Value();
  Napi::String norm_str__ = info__[3].As<Napi::String>();
  std::string norm = norm_str__.Utf8Value();
  auto output__ = torch::fft_hfft2(*self, s_data == nullptr ? c10::nullopt : c10::optional<torch::IntArrayRef>(torch::IntArrayRef(s_data, s_len)), torch::IntArrayRef(dim_data, dim_len), norm);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_fft_hfft2_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array s_array__ = info__[2].As<Napi::Array>();
  int s_len = s_array__.Length();
  int64_t *s_data = new int64_t[s_len];
  for (int i = 0; i < s_len; ++i)
    s_data[i] = s_array__.Get(i).ToNumber().Int64Value();
  Napi::Array dim_array__ = info__[3].As<Napi::Array>();
  int dim_len = dim_array__.Length();
  int64_t *dim_data = new int64_t[dim_len];
  for (int i = 0; i < dim_len; ++i)
    dim_data[i] = dim_array__.Get(i).ToNumber().Int64Value();
  Napi::String norm_str__ = info__[4].As<Napi::String>();
  std::string norm = norm_str__.Utf8Value();
  auto output__ = torch::fft_hfft2_out(*out, *self, s_data == nullptr ? c10::nullopt : c10::optional<torch::IntArrayRef>(torch::IntArrayRef(s_data, s_len)), torch::IntArrayRef(dim_data, dim_len), norm);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_fft_ihfft2(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array s_array__ = info__[1].As<Napi::Array>();
  int s_len = s_array__.Length();
  int64_t *s_data = new int64_t[s_len];
  for (int i = 0; i < s_len; ++i)
    s_data[i] = s_array__.Get(i).ToNumber().Int64Value();
  Napi::Array dim_array__ = info__[2].As<Napi::Array>();
  int dim_len = dim_array__.Length();
  int64_t *dim_data = new int64_t[dim_len];
  for (int i = 0; i < dim_len; ++i)
    dim_data[i] = dim_array__.Get(i).ToNumber().Int64Value();
  Napi::String norm_str__ = info__[3].As<Napi::String>();
  std::string norm = norm_str__.Utf8Value();
  auto output__ = torch::fft_ihfft2(*self, s_data == nullptr ? c10::nullopt : c10::optional<torch::IntArrayRef>(torch::IntArrayRef(s_data, s_len)), torch::IntArrayRef(dim_data, dim_len), norm);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_fft_ihfft2_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array s_array__ = info__[2].As<Napi::Array>();
  int s_len = s_array__.Length();
  int64_t *s_data = new int64_t[s_len];
  for (int i = 0; i < s_len; ++i)
    s_data[i] = s_array__.Get(i).ToNumber().Int64Value();
  Napi::Array dim_array__ = info__[3].As<Napi::Array>();
  int dim_len = dim_array__.Length();
  int64_t *dim_data = new int64_t[dim_len];
  for (int i = 0; i < dim_len; ++i)
    dim_data[i] = dim_array__.Get(i).ToNumber().Int64Value();
  Napi::String norm_str__ = info__[4].As<Napi::String>();
  std::string norm = norm_str__.Utf8Value();
  auto output__ = torch::fft_ihfft2_out(*out, *self, s_data == nullptr ? c10::nullopt : c10::optional<torch::IntArrayRef>(torch::IntArrayRef(s_data, s_len)), torch::IntArrayRef(dim_data, dim_len), norm);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_fft_fftn(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array s_array__ = info__[1].As<Napi::Array>();
  int s_len = s_array__.Length();
  int64_t *s_data = new int64_t[s_len];
  for (int i = 0; i < s_len; ++i)
    s_data[i] = s_array__.Get(i).ToNumber().Int64Value();
  Napi::Array dim_array__ = info__[2].As<Napi::Array>();
  int dim_len = dim_array__.Length();
  int64_t *dim_data = new int64_t[dim_len];
  for (int i = 0; i < dim_len; ++i)
    dim_data[i] = dim_array__.Get(i).ToNumber().Int64Value();
  Napi::String norm_str__ = info__[3].As<Napi::String>();
  std::string norm = norm_str__.Utf8Value();
  auto output__ = torch::fft_fftn(*self, s_data == nullptr ? c10::nullopt : c10::optional<torch::IntArrayRef>(torch::IntArrayRef(s_data, s_len)), dim_data == nullptr ? c10::nullopt : c10::optional<torch::IntArrayRef>(torch::IntArrayRef(dim_data, dim_len)), norm);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_fft_fftn_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array s_array__ = info__[2].As<Napi::Array>();
  int s_len = s_array__.Length();
  int64_t *s_data = new int64_t[s_len];
  for (int i = 0; i < s_len; ++i)
    s_data[i] = s_array__.Get(i).ToNumber().Int64Value();
  Napi::Array dim_array__ = info__[3].As<Napi::Array>();
  int dim_len = dim_array__.Length();
  int64_t *dim_data = new int64_t[dim_len];
  for (int i = 0; i < dim_len; ++i)
    dim_data[i] = dim_array__.Get(i).ToNumber().Int64Value();
  Napi::String norm_str__ = info__[4].As<Napi::String>();
  std::string norm = norm_str__.Utf8Value();
  auto output__ = torch::fft_fftn_out(*out, *self, s_data == nullptr ? c10::nullopt : c10::optional<torch::IntArrayRef>(torch::IntArrayRef(s_data, s_len)), dim_data == nullptr ? c10::nullopt : c10::optional<torch::IntArrayRef>(torch::IntArrayRef(dim_data, dim_len)), norm);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_fft_ifftn(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array s_array__ = info__[1].As<Napi::Array>();
  int s_len = s_array__.Length();
  int64_t *s_data = new int64_t[s_len];
  for (int i = 0; i < s_len; ++i)
    s_data[i] = s_array__.Get(i).ToNumber().Int64Value();
  Napi::Array dim_array__ = info__[2].As<Napi::Array>();
  int dim_len = dim_array__.Length();
  int64_t *dim_data = new int64_t[dim_len];
  for (int i = 0; i < dim_len; ++i)
    dim_data[i] = dim_array__.Get(i).ToNumber().Int64Value();
  Napi::String norm_str__ = info__[3].As<Napi::String>();
  std::string norm = norm_str__.Utf8Value();
  auto output__ = torch::fft_ifftn(*self, s_data == nullptr ? c10::nullopt : c10::optional<torch::IntArrayRef>(torch::IntArrayRef(s_data, s_len)), dim_data == nullptr ? c10::nullopt : c10::optional<torch::IntArrayRef>(torch::IntArrayRef(dim_data, dim_len)), norm);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_fft_ifftn_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array s_array__ = info__[2].As<Napi::Array>();
  int s_len = s_array__.Length();
  int64_t *s_data = new int64_t[s_len];
  for (int i = 0; i < s_len; ++i)
    s_data[i] = s_array__.Get(i).ToNumber().Int64Value();
  Napi::Array dim_array__ = info__[3].As<Napi::Array>();
  int dim_len = dim_array__.Length();
  int64_t *dim_data = new int64_t[dim_len];
  for (int i = 0; i < dim_len; ++i)
    dim_data[i] = dim_array__.Get(i).ToNumber().Int64Value();
  Napi::String norm_str__ = info__[4].As<Napi::String>();
  std::string norm = norm_str__.Utf8Value();
  auto output__ = torch::fft_ifftn_out(*out, *self, s_data == nullptr ? c10::nullopt : c10::optional<torch::IntArrayRef>(torch::IntArrayRef(s_data, s_len)), dim_data == nullptr ? c10::nullopt : c10::optional<torch::IntArrayRef>(torch::IntArrayRef(dim_data, dim_len)), norm);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_fft_rfftn(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array s_array__ = info__[1].As<Napi::Array>();
  int s_len = s_array__.Length();
  int64_t *s_data = new int64_t[s_len];
  for (int i = 0; i < s_len; ++i)
    s_data[i] = s_array__.Get(i).ToNumber().Int64Value();
  Napi::Array dim_array__ = info__[2].As<Napi::Array>();
  int dim_len = dim_array__.Length();
  int64_t *dim_data = new int64_t[dim_len];
  for (int i = 0; i < dim_len; ++i)
    dim_data[i] = dim_array__.Get(i).ToNumber().Int64Value();
  Napi::String norm_str__ = info__[3].As<Napi::String>();
  std::string norm = norm_str__.Utf8Value();
  auto output__ = torch::fft_rfftn(*self, s_data == nullptr ? c10::nullopt : c10::optional<torch::IntArrayRef>(torch::IntArrayRef(s_data, s_len)), dim_data == nullptr ? c10::nullopt : c10::optional<torch::IntArrayRef>(torch::IntArrayRef(dim_data, dim_len)), norm);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_fft_rfftn_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array s_array__ = info__[2].As<Napi::Array>();
  int s_len = s_array__.Length();
  int64_t *s_data = new int64_t[s_len];
  for (int i = 0; i < s_len; ++i)
    s_data[i] = s_array__.Get(i).ToNumber().Int64Value();
  Napi::Array dim_array__ = info__[3].As<Napi::Array>();
  int dim_len = dim_array__.Length();
  int64_t *dim_data = new int64_t[dim_len];
  for (int i = 0; i < dim_len; ++i)
    dim_data[i] = dim_array__.Get(i).ToNumber().Int64Value();
  Napi::String norm_str__ = info__[4].As<Napi::String>();
  std::string norm = norm_str__.Utf8Value();
  auto output__ = torch::fft_rfftn_out(*out, *self, s_data == nullptr ? c10::nullopt : c10::optional<torch::IntArrayRef>(torch::IntArrayRef(s_data, s_len)), dim_data == nullptr ? c10::nullopt : c10::optional<torch::IntArrayRef>(torch::IntArrayRef(dim_data, dim_len)), norm);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_fft_irfftn(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array s_array__ = info__[1].As<Napi::Array>();
  int s_len = s_array__.Length();
  int64_t *s_data = new int64_t[s_len];
  for (int i = 0; i < s_len; ++i)
    s_data[i] = s_array__.Get(i).ToNumber().Int64Value();
  Napi::Array dim_array__ = info__[2].As<Napi::Array>();
  int dim_len = dim_array__.Length();
  int64_t *dim_data = new int64_t[dim_len];
  for (int i = 0; i < dim_len; ++i)
    dim_data[i] = dim_array__.Get(i).ToNumber().Int64Value();
  Napi::String norm_str__ = info__[3].As<Napi::String>();
  std::string norm = norm_str__.Utf8Value();
  auto output__ = torch::fft_irfftn(*self, s_data == nullptr ? c10::nullopt : c10::optional<torch::IntArrayRef>(torch::IntArrayRef(s_data, s_len)), dim_data == nullptr ? c10::nullopt : c10::optional<torch::IntArrayRef>(torch::IntArrayRef(dim_data, dim_len)), norm);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_fft_irfftn_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array s_array__ = info__[2].As<Napi::Array>();
  int s_len = s_array__.Length();
  int64_t *s_data = new int64_t[s_len];
  for (int i = 0; i < s_len; ++i)
    s_data[i] = s_array__.Get(i).ToNumber().Int64Value();
  Napi::Array dim_array__ = info__[3].As<Napi::Array>();
  int dim_len = dim_array__.Length();
  int64_t *dim_data = new int64_t[dim_len];
  for (int i = 0; i < dim_len; ++i)
    dim_data[i] = dim_array__.Get(i).ToNumber().Int64Value();
  Napi::String norm_str__ = info__[4].As<Napi::String>();
  std::string norm = norm_str__.Utf8Value();
  auto output__ = torch::fft_irfftn_out(*out, *self, s_data == nullptr ? c10::nullopt : c10::optional<torch::IntArrayRef>(torch::IntArrayRef(s_data, s_len)), dim_data == nullptr ? c10::nullopt : c10::optional<torch::IntArrayRef>(torch::IntArrayRef(dim_data, dim_len)), norm);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_fft_hfftn(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array s_array__ = info__[1].As<Napi::Array>();
  int s_len = s_array__.Length();
  int64_t *s_data = new int64_t[s_len];
  for (int i = 0; i < s_len; ++i)
    s_data[i] = s_array__.Get(i).ToNumber().Int64Value();
  Napi::Array dim_array__ = info__[2].As<Napi::Array>();
  int dim_len = dim_array__.Length();
  int64_t *dim_data = new int64_t[dim_len];
  for (int i = 0; i < dim_len; ++i)
    dim_data[i] = dim_array__.Get(i).ToNumber().Int64Value();
  Napi::String norm_str__ = info__[3].As<Napi::String>();
  std::string norm = norm_str__.Utf8Value();
  auto output__ = torch::fft_hfftn(*self, s_data == nullptr ? c10::nullopt : c10::optional<torch::IntArrayRef>(torch::IntArrayRef(s_data, s_len)), dim_data == nullptr ? c10::nullopt : c10::optional<torch::IntArrayRef>(torch::IntArrayRef(dim_data, dim_len)), norm);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_fft_hfftn_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array s_array__ = info__[2].As<Napi::Array>();
  int s_len = s_array__.Length();
  int64_t *s_data = new int64_t[s_len];
  for (int i = 0; i < s_len; ++i)
    s_data[i] = s_array__.Get(i).ToNumber().Int64Value();
  Napi::Array dim_array__ = info__[3].As<Napi::Array>();
  int dim_len = dim_array__.Length();
  int64_t *dim_data = new int64_t[dim_len];
  for (int i = 0; i < dim_len; ++i)
    dim_data[i] = dim_array__.Get(i).ToNumber().Int64Value();
  Napi::String norm_str__ = info__[4].As<Napi::String>();
  std::string norm = norm_str__.Utf8Value();
  auto output__ = torch::fft_hfftn_out(*out, *self, s_data == nullptr ? c10::nullopt : c10::optional<torch::IntArrayRef>(torch::IntArrayRef(s_data, s_len)), dim_data == nullptr ? c10::nullopt : c10::optional<torch::IntArrayRef>(torch::IntArrayRef(dim_data, dim_len)), norm);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_fft_ihfftn(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array s_array__ = info__[1].As<Napi::Array>();
  int s_len = s_array__.Length();
  int64_t *s_data = new int64_t[s_len];
  for (int i = 0; i < s_len; ++i)
    s_data[i] = s_array__.Get(i).ToNumber().Int64Value();
  Napi::Array dim_array__ = info__[2].As<Napi::Array>();
  int dim_len = dim_array__.Length();
  int64_t *dim_data = new int64_t[dim_len];
  for (int i = 0; i < dim_len; ++i)
    dim_data[i] = dim_array__.Get(i).ToNumber().Int64Value();
  Napi::String norm_str__ = info__[3].As<Napi::String>();
  std::string norm = norm_str__.Utf8Value();
  auto output__ = torch::fft_ihfftn(*self, s_data == nullptr ? c10::nullopt : c10::optional<torch::IntArrayRef>(torch::IntArrayRef(s_data, s_len)), dim_data == nullptr ? c10::nullopt : c10::optional<torch::IntArrayRef>(torch::IntArrayRef(dim_data, dim_len)), norm);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_fft_ihfftn_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array s_array__ = info__[2].As<Napi::Array>();
  int s_len = s_array__.Length();
  int64_t *s_data = new int64_t[s_len];
  for (int i = 0; i < s_len; ++i)
    s_data[i] = s_array__.Get(i).ToNumber().Int64Value();
  Napi::Array dim_array__ = info__[3].As<Napi::Array>();
  int dim_len = dim_array__.Length();
  int64_t *dim_data = new int64_t[dim_len];
  for (int i = 0; i < dim_len; ++i)
    dim_data[i] = dim_array__.Get(i).ToNumber().Int64Value();
  Napi::String norm_str__ = info__[4].As<Napi::String>();
  std::string norm = norm_str__.Utf8Value();
  auto output__ = torch::fft_ihfftn_out(*out, *self, s_data == nullptr ? c10::nullopt : c10::optional<torch::IntArrayRef>(torch::IntArrayRef(s_data, s_len)), dim_data == nullptr ? c10::nullopt : c10::optional<torch::IntArrayRef>(torch::IntArrayRef(dim_data, dim_len)), norm);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_fft_fftfreq(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  int64_t n = info__[0].As<Napi::Number>().Int64Value();
  double d = info__[1].As<Napi::Number>().DoubleValue();
  Napi::Object options_obj__ = info__[2].As<Napi::Object>();
  int options_device = options_obj__.Get("device").ToNumber().Int32Value();
  int options_kind = options_obj__.Get("dtype").ToNumber().Int32Value();
  auto output__ = torch::fft_fftfreq(n, d, at::device(device_of_int(options_device)).dtype(at::ScalarType(options_kind)));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_fft_fftfreq_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t n = info__[1].As<Napi::Number>().Int64Value();
  double d = info__[2].As<Napi::Number>().DoubleValue();
  auto output__ = torch::fft_fftfreq_out(*out, n, d);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_fft_rfftfreq(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  int64_t n = info__[0].As<Napi::Number>().Int64Value();
  double d = info__[1].As<Napi::Number>().DoubleValue();
  Napi::Object options_obj__ = info__[2].As<Napi::Object>();
  int options_device = options_obj__.Get("device").ToNumber().Int32Value();
  int options_kind = options_obj__.Get("dtype").ToNumber().Int32Value();
  auto output__ = torch::fft_rfftfreq(n, d, at::device(device_of_int(options_device)).dtype(at::ScalarType(options_kind)));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_fft_rfftfreq_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t n = info__[1].As<Napi::Number>().Int64Value();
  double d = info__[2].As<Napi::Number>().DoubleValue();
  auto output__ = torch::fft_rfftfreq_out(*out, n, d);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_fft_fftshift(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array dim_array__ = info__[1].As<Napi::Array>();
  int dim_len = dim_array__.Length();
  int64_t *dim_data = new int64_t[dim_len];
  for (int i = 0; i < dim_len; ++i)
    dim_data[i] = dim_array__.Get(i).ToNumber().Int64Value();
  auto output__ = torch::fft_fftshift(*self, dim_data == nullptr ? c10::nullopt : c10::optional<torch::IntArrayRef>(torch::IntArrayRef(dim_data, dim_len)));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_fft_ifftshift(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array dim_array__ = info__[1].As<Napi::Array>();
  int dim_len = dim_array__.Length();
  int64_t *dim_data = new int64_t[dim_len];
  for (int i = 0; i < dim_len; ++i)
    dim_data[i] = dim_array__.Get(i).ToNumber().Int64Value();
  auto output__ = torch::fft_ifftshift(*self, dim_data == nullptr ? c10::nullopt : c10::optional<torch::IntArrayRef>(torch::IntArrayRef(dim_data, dim_len)));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::Array atg_linalg_cholesky_ex(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  bool upper = info__[1].As<Napi::Boolean>().Value();
  bool check_errors = info__[2].As<Napi::Boolean>().Value();
  auto output__ = torch::linalg_cholesky_ex(*self, upper, check_errors);
  Napi::Array output__array__ = Napi::Array::New(env__, 2);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  return output__array__;
}

Napi::Array atg_linalg_cholesky_ex_l(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *L = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *info = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[2].As<Napi::External<torch::Tensor>>().Data();
  bool upper = info__[3].As<Napi::Boolean>().Value();
  bool check_errors = info__[4].As<Napi::Boolean>().Value();
  auto output__ = torch::linalg_cholesky_ex_out(*L, *info, *self, upper, check_errors);
  Napi::Array output__array__ = Napi::Array::New(env__, 2);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  return output__array__;
}

Napi::External<torch::Tensor> atg_linalg_cholesky(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  bool upper = info__[1].As<Napi::Boolean>().Value();
  auto output__ = torch::linalg_cholesky(*self, upper);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_linalg_cholesky_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  bool upper = info__[2].As<Napi::Boolean>().Value();
  auto output__ = torch::linalg_cholesky_out(*out, *self, upper);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_linalg_cross(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[1].As<Napi::External<torch::Tensor>>().Data();
  int64_t dim = info__[2].As<Napi::Number>().Int64Value();
  auto output__ = torch::linalg_cross(*self, *other, dim);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_linalg_cross_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[2].As<Napi::External<torch::Tensor>>().Data();
  int64_t dim = info__[3].As<Napi::Number>().Int64Value();
  auto output__ = torch::linalg_cross_out(*out, *self, *other, dim);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::Array atg_linalg_lu_factor(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *A = info__[0].As<Napi::External<torch::Tensor>>().Data();
  bool pivot = info__[1].As<Napi::Boolean>().Value();
  auto output__ = torch::linalg_lu_factor(*A, pivot);
  Napi::Array output__array__ = Napi::Array::New(env__, 2);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  return output__array__;
}

Napi::Array atg_linalg_lu_factor_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *LU = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *pivots = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *A = info__[2].As<Napi::External<torch::Tensor>>().Data();
  bool pivot = info__[3].As<Napi::Boolean>().Value();
  auto output__ = torch::linalg_lu_factor_out(*LU, *pivots, *A, pivot);
  Napi::Array output__array__ = Napi::Array::New(env__, 2);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  return output__array__;
}

Napi::Array atg_linalg_lu_factor_ex(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *A = info__[0].As<Napi::External<torch::Tensor>>().Data();
  bool pivot = info__[1].As<Napi::Boolean>().Value();
  bool check_errors = info__[2].As<Napi::Boolean>().Value();
  auto output__ = torch::linalg_lu_factor_ex(*A, pivot, check_errors);
  Napi::Array output__array__ = Napi::Array::New(env__, 3);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  output__array__[2u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<2>(output__)));
  return output__array__;
}

Napi::Array atg_linalg_lu_factor_ex_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *LU = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *pivots = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *info = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *A = info__[3].As<Napi::External<torch::Tensor>>().Data();
  bool pivot = info__[4].As<Napi::Boolean>().Value();
  bool check_errors = info__[5].As<Napi::Boolean>().Value();
  auto output__ = torch::linalg_lu_factor_ex_out(*LU, *pivots, *info, *A, pivot, check_errors);
  Napi::Array output__array__ = Napi::Array::New(env__, 3);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  output__array__[2u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<2>(output__)));
  return output__array__;
}

Napi::Array atg_linalg_lu(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *A = info__[0].As<Napi::External<torch::Tensor>>().Data();
  bool pivot = info__[1].As<Napi::Boolean>().Value();
  auto output__ = torch::linalg_lu(*A, pivot);
  Napi::Array output__array__ = Napi::Array::New(env__, 3);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  output__array__[2u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<2>(output__)));
  return output__array__;
}

Napi::Array atg_linalg_lu_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *P = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *L = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *U = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *A = info__[3].As<Napi::External<torch::Tensor>>().Data();
  bool pivot = info__[4].As<Napi::Boolean>().Value();
  auto output__ = torch::linalg_lu_out(*P, *L, *U, *A, pivot);
  Napi::Array output__array__ = Napi::Array::New(env__, 3);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  output__array__[2u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<2>(output__)));
  return output__array__;
}

Napi::External<torch::Tensor> atg_linalg_lu_solve(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *LU = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *pivots = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *B = info__[2].As<Napi::External<torch::Tensor>>().Data();
  bool left = info__[3].As<Napi::Boolean>().Value();
  bool adjoint = info__[4].As<Napi::Boolean>().Value();
  auto output__ = torch::linalg_lu_solve(*LU, *pivots, *B, left, adjoint);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_linalg_lu_solve_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *LU = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *pivots = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *B = info__[3].As<Napi::External<torch::Tensor>>().Data();
  bool left = info__[4].As<Napi::Boolean>().Value();
  bool adjoint = info__[5].As<Napi::Boolean>().Value();
  auto output__ = torch::linalg_lu_solve_out(*out, *LU, *pivots, *B, left, adjoint);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::Array atg__linalg_det(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *A = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::_linalg_det(*A);
  Napi::Array output__array__ = Napi::Array::New(env__, 3);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  output__array__[2u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<2>(output__)));
  return output__array__;
}

Napi::Array atg__linalg_det_result(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *result = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *LU = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *pivots = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *A = info__[3].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::_linalg_det_out(*result, *LU, *pivots, *A);
  Napi::Array output__array__ = Napi::Array::New(env__, 3);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  output__array__[2u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<2>(output__)));
  return output__array__;
}

Napi::External<torch::Tensor> atg_linalg_det(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *A = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::linalg_det(*A);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_linalg_det_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *A = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::linalg_det_out(*out, *A);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_det(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::det(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::Array atg_linalg_ldl_factor_ex(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  bool hermitian = info__[1].As<Napi::Boolean>().Value();
  bool check_errors = info__[2].As<Napi::Boolean>().Value();
  auto output__ = torch::linalg_ldl_factor_ex(*self, hermitian, check_errors);
  Napi::Array output__array__ = Napi::Array::New(env__, 3);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  output__array__[2u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<2>(output__)));
  return output__array__;
}

Napi::Array atg_linalg_ldl_factor_ex_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *LD = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *pivots = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *info = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[3].As<Napi::External<torch::Tensor>>().Data();
  bool hermitian = info__[4].As<Napi::Boolean>().Value();
  bool check_errors = info__[5].As<Napi::Boolean>().Value();
  auto output__ = torch::linalg_ldl_factor_ex_out(*LD, *pivots, *info, *self, hermitian, check_errors);
  Napi::Array output__array__ = Napi::Array::New(env__, 3);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  output__array__[2u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<2>(output__)));
  return output__array__;
}

Napi::Array atg_linalg_ldl_factor(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  bool hermitian = info__[1].As<Napi::Boolean>().Value();
  auto output__ = torch::linalg_ldl_factor(*self, hermitian);
  Napi::Array output__array__ = Napi::Array::New(env__, 2);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  return output__array__;
}

Napi::Array atg_linalg_ldl_factor_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *LD = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *pivots = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[2].As<Napi::External<torch::Tensor>>().Data();
  bool hermitian = info__[3].As<Napi::Boolean>().Value();
  auto output__ = torch::linalg_ldl_factor_out(*LD, *pivots, *self, hermitian);
  Napi::Array output__array__ = Napi::Array::New(env__, 2);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  return output__array__;
}

Napi::External<torch::Tensor> atg_linalg_ldl_solve(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *LD = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *pivots = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *B = info__[2].As<Napi::External<torch::Tensor>>().Data();
  bool hermitian = info__[3].As<Napi::Boolean>().Value();
  auto output__ = torch::linalg_ldl_solve(*LD, *pivots, *B, hermitian);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_linalg_ldl_solve_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *LD = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *pivots = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *B = info__[3].As<Napi::External<torch::Tensor>>().Data();
  bool hermitian = info__[4].As<Napi::Boolean>().Value();
  auto output__ = torch::linalg_ldl_solve_out(*out, *LD, *pivots, *B, hermitian);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::Array atg_linalg_lstsq(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *b = info__[1].As<Napi::External<torch::Tensor>>().Data();
  bool rcond_null = info__[2].IsUndefined();
  double rcond_v = rcond_null ? 0 : info__[2].As<Napi::Number>().DoubleValue();
  Napi::String driver_str__ = info__[3].As<Napi::String>();
  std::string driver = driver_str__.Utf8Value();
  auto output__ = torch::linalg_lstsq(*self, *b, rcond_null ? c10::nullopt : c10::optional<double>(rcond_v), driver);
  Napi::Array output__array__ = Napi::Array::New(env__, 4);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  output__array__[2u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<2>(output__)));
  output__array__[3u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<3>(output__)));
  return output__array__;
}

Napi::Array atg_linalg_lstsq_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *solution = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *residuals = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *rank = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *singular_values = info__[3].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[4].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *b = info__[5].As<Napi::External<torch::Tensor>>().Data();
  bool rcond_null = info__[6].IsUndefined();
  double rcond_v = rcond_null ? 0 : info__[6].As<Napi::Number>().DoubleValue();
  Napi::String driver_str__ = info__[7].As<Napi::String>();
  std::string driver = driver_str__.Utf8Value();
  auto output__ = torch::linalg_lstsq_out(*solution, *residuals, *rank, *singular_values, *self, *b, rcond_null ? c10::nullopt : c10::optional<double>(rcond_v), driver);
  Napi::Array output__array__ = Napi::Array::New(env__, 4);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  output__array__[2u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<2>(output__)));
  output__array__[3u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<3>(output__)));
  return output__array__;
}

Napi::External<torch::Tensor> atg_linalg_matmul(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::linalg_matmul(*self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_linalg_matmul_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[2].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::linalg_matmul_out(*out, *self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_linalg_vecdot(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *x = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *y = info__[1].As<Napi::External<torch::Tensor>>().Data();
  int64_t dim = info__[2].As<Napi::Number>().Int64Value();
  auto output__ = torch::linalg_vecdot(*x, *y, dim);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_linalg_vecdot_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *x = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *y = info__[2].As<Napi::External<torch::Tensor>>().Data();
  int64_t dim = info__[3].As<Napi::Number>().Int64Value();
  auto output__ = torch::linalg_vecdot_out(*out, *x, *y, dim);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_linalg_matrix_exp(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::linalg_matrix_exp(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_linalg_matrix_exp_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::linalg_matrix_exp_out(*out, *self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::Array atg__linalg_slogdet(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *A = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::_linalg_slogdet(*A);
  Napi::Array output__array__ = Napi::Array::New(env__, 4);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  output__array__[2u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<2>(output__)));
  output__array__[3u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<3>(output__)));
  return output__array__;
}

Napi::Array atg__linalg_slogdet_sign(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *sign = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *logabsdet = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *LU = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *pivots = info__[3].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *A = info__[4].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::_linalg_slogdet_out(*sign, *logabsdet, *LU, *pivots, *A);
  Napi::Array output__array__ = Napi::Array::New(env__, 4);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  output__array__[2u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<2>(output__)));
  output__array__[3u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<3>(output__)));
  return output__array__;
}

Napi::Array atg_linalg_slogdet(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *A = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::linalg_slogdet(*A);
  Napi::Array output__array__ = Napi::Array::New(env__, 2);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  return output__array__;
}

Napi::Array atg_linalg_slogdet_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *sign = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *logabsdet = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *A = info__[2].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::linalg_slogdet_out(*sign, *logabsdet, *A);
  Napi::Array output__array__ = Napi::Array::New(env__, 2);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  return output__array__;
}

Napi::Array atg_slogdet(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::slogdet(*self);
  Napi::Array output__array__ = Napi::Array::New(env__, 2);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  return output__array__;
}

Napi::Array atg_slogdet_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *sign = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *logabsdet = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[2].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::slogdet_out(*sign, *logabsdet, *self);
  Napi::Array output__array__ = Napi::Array::New(env__, 2);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  return output__array__;
}

Napi::External<torch::Tensor> atg_logdet(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::logdet(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::Array atg_linalg_eig(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::linalg_eig(*self);
  Napi::Array output__array__ = Napi::Array::New(env__, 2);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  return output__array__;
}

Napi::Array atg_linalg_eig_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *eigenvalues = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *eigenvectors = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[2].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::linalg_eig_out(*eigenvalues, *eigenvectors, *self);
  Napi::Array output__array__ = Napi::Array::New(env__, 2);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  return output__array__;
}

Napi::External<torch::Tensor> atg_linalg_eigvals(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::linalg_eigvals(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_linalg_eigvals_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::linalg_eigvals_out(*out, *self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::Array atg__linalg_eigh(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *A = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::String UPLO_str__ = info__[1].As<Napi::String>();
  std::string UPLO = UPLO_str__.Utf8Value();
  bool compute_v = info__[2].As<Napi::Boolean>().Value();
  auto output__ = torch::_linalg_eigh(*A, UPLO, compute_v);
  Napi::Array output__array__ = Napi::Array::New(env__, 2);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  return output__array__;
}

Napi::Array atg__linalg_eigh_eigenvalues(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *eigenvalues = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *eigenvectors = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *A = info__[2].As<Napi::External<torch::Tensor>>().Data();
  Napi::String UPLO_str__ = info__[3].As<Napi::String>();
  std::string UPLO = UPLO_str__.Utf8Value();
  bool compute_v = info__[4].As<Napi::Boolean>().Value();
  auto output__ = torch::_linalg_eigh_out(*eigenvalues, *eigenvectors, *A, UPLO, compute_v);
  Napi::Array output__array__ = Napi::Array::New(env__, 2);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  return output__array__;
}

Napi::Array atg_linalg_eigh(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::String UPLO_str__ = info__[1].As<Napi::String>();
  std::string UPLO = UPLO_str__.Utf8Value();
  auto output__ = torch::linalg_eigh(*self, UPLO);
  Napi::Array output__array__ = Napi::Array::New(env__, 2);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  return output__array__;
}

Napi::Array atg_linalg_eigh_eigvals(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *eigvals = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *eigvecs = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[2].As<Napi::External<torch::Tensor>>().Data();
  Napi::String UPLO_str__ = info__[3].As<Napi::String>();
  std::string UPLO = UPLO_str__.Utf8Value();
  auto output__ = torch::linalg_eigh_out(*eigvals, *eigvecs, *self, UPLO);
  Napi::Array output__array__ = Napi::Array::New(env__, 2);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  return output__array__;
}

Napi::External<torch::Tensor> atg_linalg_eigvalsh(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::String UPLO_str__ = info__[1].As<Napi::String>();
  std::string UPLO = UPLO_str__.Utf8Value();
  auto output__ = torch::linalg_eigvalsh(*self, UPLO);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_linalg_eigvalsh_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::String UPLO_str__ = info__[2].As<Napi::String>();
  std::string UPLO = UPLO_str__.Utf8Value();
  auto output__ = torch::linalg_eigvalsh_out(*out, *self, UPLO);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_linalg_householder_product(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *input = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *tau = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::linalg_householder_product(*input, *tau);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_linalg_householder_product_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *input = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *tau = info__[2].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::linalg_householder_product_out(*out, *input, *tau);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::Array atg_linalg_inv_ex(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *A = info__[0].As<Napi::External<torch::Tensor>>().Data();
  bool check_errors = info__[1].As<Napi::Boolean>().Value();
  auto output__ = torch::linalg_inv_ex(*A, check_errors);
  Napi::Array output__array__ = Napi::Array::New(env__, 2);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  return output__array__;
}

Napi::Array atg_linalg_inv_ex_inverse(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *inverse = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *info = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *A = info__[2].As<Napi::External<torch::Tensor>>().Data();
  bool check_errors = info__[3].As<Napi::Boolean>().Value();
  auto output__ = torch::linalg_inv_ex_out(*inverse, *info, *A, check_errors);
  Napi::Array output__array__ = Napi::Array::New(env__, 2);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  return output__array__;
}

Napi::External<torch::Tensor> atg_linalg_inv(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *A = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::linalg_inv(*A);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_linalg_inv_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *A = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::linalg_inv_out(*out, *A);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_inverse(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::inverse(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_inverse_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::inverse_out(*out, *self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_inner(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::inner(*self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_inner_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[2].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::inner_out(*out, *self, *other);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_outer(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *vec2 = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::outer(*self, *vec2);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_outer_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *vec2 = info__[2].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::outer_out(*out, *self, *vec2);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_ger(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *vec2 = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::ger(*self, *vec2);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_ger_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *vec2 = info__[2].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::ger_out(*out, *self, *vec2);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_linalg_norm(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *ord = info__[1].As<Napi::External<torch::Scalar>>().Data();
  Napi::Array dim_array__ = info__[2].As<Napi::Array>();
  int dim_len = dim_array__.Length();
  int64_t *dim_data = new int64_t[dim_len];
  for (int i = 0; i < dim_len; ++i)
    dim_data[i] = dim_array__.Get(i).ToNumber().Int64Value();
  bool keepdim = info__[3].As<Napi::Boolean>().Value();
  int dtype = info__[4].As<Napi::Number>().Int32Value();
  auto output__ = torch::linalg_norm(*self, *ord, dim_data == nullptr ? c10::nullopt : c10::optional<torch::IntArrayRef>(torch::IntArrayRef(dim_data, dim_len)), keepdim, at::ScalarType(dtype));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_linalg_norm_ord_str(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::String ord_str__ = info__[1].As<Napi::String>();
  std::string ord = ord_str__.Utf8Value();
  Napi::Array dim_array__ = info__[2].As<Napi::Array>();
  int dim_len = dim_array__.Length();
  int64_t *dim_data = new int64_t[dim_len];
  for (int i = 0; i < dim_len; ++i)
    dim_data[i] = dim_array__.Get(i).ToNumber().Int64Value();
  bool keepdim = info__[3].As<Napi::Boolean>().Value();
  int dtype = info__[4].As<Napi::Number>().Int32Value();
  auto output__ = torch::linalg_norm(*self, ord, dim_data == nullptr ? c10::nullopt : c10::optional<torch::IntArrayRef>(torch::IntArrayRef(dim_data, dim_len)), keepdim, at::ScalarType(dtype));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_linalg_norm_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *ord = info__[2].As<Napi::External<torch::Scalar>>().Data();
  Napi::Array dim_array__ = info__[3].As<Napi::Array>();
  int dim_len = dim_array__.Length();
  int64_t *dim_data = new int64_t[dim_len];
  for (int i = 0; i < dim_len; ++i)
    dim_data[i] = dim_array__.Get(i).ToNumber().Int64Value();
  bool keepdim = info__[4].As<Napi::Boolean>().Value();
  int dtype = info__[5].As<Napi::Number>().Int32Value();
  auto output__ = torch::linalg_norm_out(*out, *self, *ord, dim_data == nullptr ? c10::nullopt : c10::optional<torch::IntArrayRef>(torch::IntArrayRef(dim_data, dim_len)), keepdim, at::ScalarType(dtype));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_linalg_norm_ord_str_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::String ord_str__ = info__[2].As<Napi::String>();
  std::string ord = ord_str__.Utf8Value();
  Napi::Array dim_array__ = info__[3].As<Napi::Array>();
  int dim_len = dim_array__.Length();
  int64_t *dim_data = new int64_t[dim_len];
  for (int i = 0; i < dim_len; ++i)
    dim_data[i] = dim_array__.Get(i).ToNumber().Int64Value();
  bool keepdim = info__[4].As<Napi::Boolean>().Value();
  int dtype = info__[5].As<Napi::Number>().Int32Value();
  auto output__ = torch::linalg_norm_out(*out, *self, ord, dim_data == nullptr ? c10::nullopt : c10::optional<torch::IntArrayRef>(torch::IntArrayRef(dim_data, dim_len)), keepdim, at::ScalarType(dtype));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::Array atg__linalg_svd(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *A = info__[0].As<Napi::External<torch::Tensor>>().Data();
  bool full_matrices = info__[1].As<Napi::Boolean>().Value();
  bool compute_uv = info__[2].As<Napi::Boolean>().Value();
  Napi::String driver_str__ = info__[3].As<Napi::String>();
  std::string driver = driver_str__.Utf8Value();
  auto output__ = torch::_linalg_svd(*A, full_matrices, compute_uv, driver);
  Napi::Array output__array__ = Napi::Array::New(env__, 3);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  output__array__[2u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<2>(output__)));
  return output__array__;
}

Napi::Array atg__linalg_svd_u(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *U = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *S = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *Vh = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *A = info__[3].As<Napi::External<torch::Tensor>>().Data();
  bool full_matrices = info__[4].As<Napi::Boolean>().Value();
  bool compute_uv = info__[5].As<Napi::Boolean>().Value();
  Napi::String driver_str__ = info__[6].As<Napi::String>();
  std::string driver = driver_str__.Utf8Value();
  auto output__ = torch::_linalg_svd_out(*U, *S, *Vh, *A, full_matrices, compute_uv, driver);
  Napi::Array output__array__ = Napi::Array::New(env__, 3);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  output__array__[2u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<2>(output__)));
  return output__array__;
}

Napi::Array atg_linalg_svd(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *A = info__[0].As<Napi::External<torch::Tensor>>().Data();
  bool full_matrices = info__[1].As<Napi::Boolean>().Value();
  Napi::String driver_str__ = info__[2].As<Napi::String>();
  std::string driver = driver_str__.Utf8Value();
  auto output__ = torch::linalg_svd(*A, full_matrices, driver);
  Napi::Array output__array__ = Napi::Array::New(env__, 3);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  output__array__[2u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<2>(output__)));
  return output__array__;
}

Napi::Array atg_linalg_svd_u(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *U = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *S = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *Vh = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *A = info__[3].As<Napi::External<torch::Tensor>>().Data();
  bool full_matrices = info__[4].As<Napi::Boolean>().Value();
  Napi::String driver_str__ = info__[5].As<Napi::String>();
  std::string driver = driver_str__.Utf8Value();
  auto output__ = torch::linalg_svd_out(*U, *S, *Vh, *A, full_matrices, driver);
  Napi::Array output__array__ = Napi::Array::New(env__, 3);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  output__array__[2u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<2>(output__)));
  return output__array__;
}

Napi::External<torch::Tensor> atg_linalg_svdvals(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *A = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::String driver_str__ = info__[1].As<Napi::String>();
  std::string driver = driver_str__.Utf8Value();
  auto output__ = torch::linalg_svdvals(*A, driver);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_linalg_svdvals_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *A = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::String driver_str__ = info__[2].As<Napi::String>();
  std::string driver = driver_str__.Utf8Value();
  auto output__ = torch::linalg_svdvals_out(*out, *A, driver);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_linalg_cond(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *p = info__[1].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::linalg_cond(*self, *p);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_linalg_cond_p_str(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::String p_str__ = info__[1].As<Napi::String>();
  std::string p = p_str__.Utf8Value();
  auto output__ = torch::linalg_cond(*self, p);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_linalg_cond_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *p = info__[2].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::linalg_cond_out(*out, *self, *p);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_linalg_cond_p_str_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::String p_str__ = info__[2].As<Napi::String>();
  std::string p = p_str__.Utf8Value();
  auto output__ = torch::linalg_cond_out(*out, *self, p);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_linalg_pinv(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  double rcond = info__[1].As<Napi::Number>().DoubleValue();
  bool hermitian = info__[2].As<Napi::Boolean>().Value();
  auto output__ = torch::linalg_pinv(*self, rcond, hermitian);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_linalg_pinv_rcond_tensor(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *rcond = info__[1].As<Napi::External<torch::Tensor>>().Data();
  bool hermitian = info__[2].As<Napi::Boolean>().Value();
  auto output__ = torch::linalg_pinv(*self, *rcond, hermitian);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_linalg_pinv_atol_rtol_tensor(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  bool atol_null = info__[1].IsUndefined();
  torch::Tensor *atol_v = atol_null ? nullptr : info__[1].As<Napi::External<torch::Tensor>>().Data();
  bool rtol_null = info__[2].IsUndefined();
  torch::Tensor *rtol_v = rtol_null ? nullptr : info__[2].As<Napi::External<torch::Tensor>>().Data();
  bool hermitian = info__[3].As<Napi::Boolean>().Value();
  auto output__ = torch::linalg_pinv(*self, (atol_null ? *atol_v : torch::Tensor()), (rtol_null ? *rtol_v : torch::Tensor()), hermitian);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_linalg_pinv_atol_rtol_float(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  bool atol_null = info__[1].IsUndefined();
  double atol_v = atol_null ? 0 : info__[1].As<Napi::Number>().DoubleValue();
  bool rtol_null = info__[2].IsUndefined();
  double rtol_v = rtol_null ? 0 : info__[2].As<Napi::Number>().DoubleValue();
  bool hermitian = info__[3].As<Napi::Boolean>().Value();
  auto output__ = torch::linalg_pinv(*self, atol_null ? c10::nullopt : c10::optional<double>(atol_v), rtol_null ? c10::nullopt : c10::optional<double>(rtol_v), hermitian);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_linalg_pinv_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  double rcond = info__[2].As<Napi::Number>().DoubleValue();
  bool hermitian = info__[3].As<Napi::Boolean>().Value();
  auto output__ = torch::linalg_pinv_out(*out, *self, rcond, hermitian);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_linalg_pinv_out_rcond_tensor(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *rcond = info__[2].As<Napi::External<torch::Tensor>>().Data();
  bool hermitian = info__[3].As<Napi::Boolean>().Value();
  auto output__ = torch::linalg_pinv_out(*out, *self, *rcond, hermitian);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_linalg_pinv_atol_rtol_tensor_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  bool atol_null = info__[2].IsUndefined();
  torch::Tensor *atol_v = atol_null ? nullptr : info__[2].As<Napi::External<torch::Tensor>>().Data();
  bool rtol_null = info__[3].IsUndefined();
  torch::Tensor *rtol_v = rtol_null ? nullptr : info__[3].As<Napi::External<torch::Tensor>>().Data();
  bool hermitian = info__[4].As<Napi::Boolean>().Value();
  auto output__ = torch::linalg_pinv_out(*out, *self, (atol_null ? *atol_v : torch::Tensor()), (rtol_null ? *rtol_v : torch::Tensor()), hermitian);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_linalg_pinv_atol_rtol_float_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  bool atol_null = info__[2].IsUndefined();
  double atol_v = atol_null ? 0 : info__[2].As<Napi::Number>().DoubleValue();
  bool rtol_null = info__[3].IsUndefined();
  double rtol_v = rtol_null ? 0 : info__[3].As<Napi::Number>().DoubleValue();
  bool hermitian = info__[4].As<Napi::Boolean>().Value();
  auto output__ = torch::linalg_pinv_out(*out, *self, atol_null ? c10::nullopt : c10::optional<double>(atol_v), rtol_null ? c10::nullopt : c10::optional<double>(rtol_v), hermitian);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::Array atg__linalg_solve_ex(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *A = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *B = info__[1].As<Napi::External<torch::Tensor>>().Data();
  bool left = info__[2].As<Napi::Boolean>().Value();
  bool check_errors = info__[3].As<Napi::Boolean>().Value();
  auto output__ = torch::_linalg_solve_ex(*A, *B, left, check_errors);
  Napi::Array output__array__ = Napi::Array::New(env__, 4);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  output__array__[2u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<2>(output__)));
  output__array__[3u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<3>(output__)));
  return output__array__;
}

Napi::Array atg__linalg_solve_ex_result(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *result = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *LU = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *pivots = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *info = info__[3].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *A = info__[4].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *B = info__[5].As<Napi::External<torch::Tensor>>().Data();
  bool left = info__[6].As<Napi::Boolean>().Value();
  bool check_errors = info__[7].As<Napi::Boolean>().Value();
  auto output__ = torch::_linalg_solve_ex_out(*result, *LU, *pivots, *info, *A, *B, left, check_errors);
  Napi::Array output__array__ = Napi::Array::New(env__, 4);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  output__array__[2u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<2>(output__)));
  output__array__[3u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<3>(output__)));
  return output__array__;
}

Napi::Array atg_linalg_solve_ex(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *A = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *B = info__[1].As<Napi::External<torch::Tensor>>().Data();
  bool left = info__[2].As<Napi::Boolean>().Value();
  bool check_errors = info__[3].As<Napi::Boolean>().Value();
  auto output__ = torch::linalg_solve_ex(*A, *B, left, check_errors);
  Napi::Array output__array__ = Napi::Array::New(env__, 2);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  return output__array__;
}

Napi::Array atg_linalg_solve_ex_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *result = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *info = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *A = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *B = info__[3].As<Napi::External<torch::Tensor>>().Data();
  bool left = info__[4].As<Napi::Boolean>().Value();
  bool check_errors = info__[5].As<Napi::Boolean>().Value();
  auto output__ = torch::linalg_solve_ex_out(*result, *info, *A, *B, left, check_errors);
  Napi::Array output__array__ = Napi::Array::New(env__, 2);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  return output__array__;
}

Napi::External<torch::Tensor> atg_linalg_solve(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *A = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *B = info__[1].As<Napi::External<torch::Tensor>>().Data();
  bool left = info__[2].As<Napi::Boolean>().Value();
  auto output__ = torch::linalg_solve(*A, *B, left);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_linalg_solve_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *A = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *B = info__[2].As<Napi::External<torch::Tensor>>().Data();
  bool left = info__[3].As<Napi::Boolean>().Value();
  auto output__ = torch::linalg_solve_out(*out, *A, *B, left);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_linalg_tensorinv(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t ind = info__[1].As<Napi::Number>().Int64Value();
  auto output__ = torch::linalg_tensorinv(*self, ind);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_linalg_tensorinv_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  int64_t ind = info__[2].As<Napi::Number>().Int64Value();
  auto output__ = torch::linalg_tensorinv_out(*out, *self, ind);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_linalg_tensorsolve(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array dims_array__ = info__[2].As<Napi::Array>();
  int dims_len = dims_array__.Length();
  int64_t *dims_data = new int64_t[dims_len];
  for (int i = 0; i < dims_len; ++i)
    dims_data[i] = dims_array__.Get(i).ToNumber().Int64Value();
  auto output__ = torch::linalg_tensorsolve(*self, *other, dims_data == nullptr ? c10::nullopt : c10::optional<torch::IntArrayRef>(torch::IntArrayRef(dims_data, dims_len)));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_linalg_tensorsolve_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[2].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array dims_array__ = info__[3].As<Napi::Array>();
  int dims_len = dims_array__.Length();
  int64_t *dims_data = new int64_t[dims_len];
  for (int i = 0; i < dims_len; ++i)
    dims_data[i] = dims_array__.Get(i).ToNumber().Int64Value();
  auto output__ = torch::linalg_tensorsolve_out(*out, *self, *other, dims_data == nullptr ? c10::nullopt : c10::optional<torch::IntArrayRef>(torch::IntArrayRef(dims_data, dims_len)));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::Array atg_linalg_qr(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *A = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::String mode_str__ = info__[1].As<Napi::String>();
  std::string mode = mode_str__.Utf8Value();
  auto output__ = torch::linalg_qr(*A, mode);
  Napi::Array output__array__ = Napi::Array::New(env__, 2);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  return output__array__;
}

Napi::Array atg_linalg_qr_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *Q = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *R = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *A = info__[2].As<Napi::External<torch::Tensor>>().Data();
  Napi::String mode_str__ = info__[3].As<Napi::String>();
  std::string mode = mode_str__.Utf8Value();
  auto output__ = torch::linalg_qr_out(*Q, *R, *A, mode);
  Napi::Array output__array__ = Napi::Array::New(env__, 2);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  return output__array__;
}

Napi::External<torch::Tensor> atg_linalg_matrix_power(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t n = info__[1].As<Napi::Number>().Int64Value();
  auto output__ = torch::linalg_matrix_power(*self, n);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_linalg_matrix_power_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  int64_t n = info__[2].As<Napi::Number>().Int64Value();
  auto output__ = torch::linalg_matrix_power_out(*out, *self, n);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_linalg_matrix_rank(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  double tol = info__[1].As<Napi::Number>().DoubleValue();
  bool hermitian = info__[2].As<Napi::Boolean>().Value();
  auto output__ = torch::linalg_matrix_rank(*self, tol, hermitian);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_linalg_matrix_rank_tol_tensor(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *input = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *tol = info__[1].As<Napi::External<torch::Tensor>>().Data();
  bool hermitian = info__[2].As<Napi::Boolean>().Value();
  auto output__ = torch::linalg_matrix_rank(*input, *tol, hermitian);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_linalg_matrix_rank_atol_rtol_tensor(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *input = info__[0].As<Napi::External<torch::Tensor>>().Data();
  bool atol_null = info__[1].IsUndefined();
  torch::Tensor *atol_v = atol_null ? nullptr : info__[1].As<Napi::External<torch::Tensor>>().Data();
  bool rtol_null = info__[2].IsUndefined();
  torch::Tensor *rtol_v = rtol_null ? nullptr : info__[2].As<Napi::External<torch::Tensor>>().Data();
  bool hermitian = info__[3].As<Napi::Boolean>().Value();
  auto output__ = torch::linalg_matrix_rank(*input, (atol_null ? *atol_v : torch::Tensor()), (rtol_null ? *rtol_v : torch::Tensor()), hermitian);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_linalg_matrix_rank_atol_rtol_float(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  bool atol_null = info__[1].IsUndefined();
  double atol_v = atol_null ? 0 : info__[1].As<Napi::Number>().DoubleValue();
  bool rtol_null = info__[2].IsUndefined();
  double rtol_v = rtol_null ? 0 : info__[2].As<Napi::Number>().DoubleValue();
  bool hermitian = info__[3].As<Napi::Boolean>().Value();
  auto output__ = torch::linalg_matrix_rank(*self, atol_null ? c10::nullopt : c10::optional<double>(atol_v), rtol_null ? c10::nullopt : c10::optional<double>(rtol_v), hermitian);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_linalg_matrix_rank_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  double tol = info__[2].As<Napi::Number>().DoubleValue();
  bool hermitian = info__[3].As<Napi::Boolean>().Value();
  auto output__ = torch::linalg_matrix_rank_out(*out, *self, tol, hermitian);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_linalg_matrix_rank_out_tol_tensor(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *input = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *tol = info__[2].As<Napi::External<torch::Tensor>>().Data();
  bool hermitian = info__[3].As<Napi::Boolean>().Value();
  auto output__ = torch::linalg_matrix_rank_out(*out, *input, *tol, hermitian);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_linalg_matrix_rank_atol_rtol_tensor_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *input = info__[1].As<Napi::External<torch::Tensor>>().Data();
  bool atol_null = info__[2].IsUndefined();
  torch::Tensor *atol_v = atol_null ? nullptr : info__[2].As<Napi::External<torch::Tensor>>().Data();
  bool rtol_null = info__[3].IsUndefined();
  torch::Tensor *rtol_v = rtol_null ? nullptr : info__[3].As<Napi::External<torch::Tensor>>().Data();
  bool hermitian = info__[4].As<Napi::Boolean>().Value();
  auto output__ = torch::linalg_matrix_rank_out(*out, *input, (atol_null ? *atol_v : torch::Tensor()), (rtol_null ? *rtol_v : torch::Tensor()), hermitian);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_linalg_matrix_rank_atol_rtol_float_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  bool atol_null = info__[2].IsUndefined();
  double atol_v = atol_null ? 0 : info__[2].As<Napi::Number>().DoubleValue();
  bool rtol_null = info__[3].IsUndefined();
  double rtol_v = rtol_null ? 0 : info__[3].As<Napi::Number>().DoubleValue();
  bool hermitian = info__[4].As<Napi::Boolean>().Value();
  auto output__ = torch::linalg_matrix_rank_out(*out, *self, atol_null ? c10::nullopt : c10::optional<double>(atol_v), rtol_null ? c10::nullopt : c10::optional<double>(rtol_v), hermitian);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_linalg_multi_dot(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  Napi::Array tensors_array__ = info__[0].As<Napi::Array>();
  int tensors_len = tensors_array__.Length();
  torch::Tensor **tensors_data = new torch::Tensor *[tensors_len];
  for (int i = 0; i < tensors_len; ++i)
    tensors_data[i] = tensors_array__.Get(i).As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::linalg_multi_dot(of_carray_tensor(tensors_data, tensors_len));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_linalg_multi_dot_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array tensors_array__ = info__[1].As<Napi::Array>();
  int tensors_len = tensors_array__.Length();
  torch::Tensor **tensors_data = new torch::Tensor *[tensors_len];
  for (int i = 0; i < tensors_len; ++i)
    tensors_data[i] = tensors_array__.Get(i).As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::linalg_multi_dot_out(*out, of_carray_tensor(tensors_data, tensors_len));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_nested_to_padded_tensor(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  double padding = info__[1].As<Napi::Number>().DoubleValue();
  Napi::Array output_size_array__ = info__[2].As<Napi::Array>();
  int output_size_len = output_size_array__.Length();
  int64_t *output_size_data = new int64_t[output_size_len];
  for (int i = 0; i < output_size_len; ++i)
    output_size_data[i] = output_size_array__.Get(i).ToNumber().Int64Value();
  auto output__ = torch::nested_to_padded_tensor(*self, padding, output_size_data == nullptr ? c10::nullopt : c10::optional<torch::IntArrayRef>(torch::IntArrayRef(output_size_data, output_size_len)));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__test_serialization_subcmul(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *other = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *alpha = info__[2].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::_test_serialization_subcmul(*self, *other, *alpha);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__test_optional_intlist(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *values = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array addends_array__ = info__[1].As<Napi::Array>();
  int addends_len = addends_array__.Length();
  int64_t *addends_data = new int64_t[addends_len];
  for (int i = 0; i < addends_len; ++i)
    addends_data[i] = addends_array__.Get(i).ToNumber().Int64Value();
  auto output__ = torch::_test_optional_intlist(*values, addends_data == nullptr ? c10::nullopt : c10::optional<torch::IntArrayRef>(torch::IntArrayRef(addends_data, addends_len)));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__test_optional_intlist_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *values = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array addends_array__ = info__[2].As<Napi::Array>();
  int addends_len = addends_array__.Length();
  int64_t *addends_data = new int64_t[addends_len];
  for (int i = 0; i < addends_len; ++i)
    addends_data[i] = addends_array__.Get(i).ToNumber().Int64Value();
  auto output__ = torch::_test_optional_intlist_out(*out, *values, addends_data == nullptr ? c10::nullopt : c10::optional<torch::IntArrayRef>(torch::IntArrayRef(addends_data, addends_len)));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__test_optional_filled_intlist(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *values = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array addends_array__ = info__[1].As<Napi::Array>();
  int addends_len = addends_array__.Length();
  int64_t *addends_data = new int64_t[addends_len];
  for (int i = 0; i < addends_len; ++i)
    addends_data[i] = addends_array__.Get(i).ToNumber().Int64Value();
  auto output__ = torch::_test_optional_filled_intlist(*values, addends_data == nullptr ? c10::nullopt : c10::optional<torch::IntArrayRef>(torch::IntArrayRef(addends_data, addends_len)));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__test_optional_filled_intlist_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *values = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array addends_array__ = info__[2].As<Napi::Array>();
  int addends_len = addends_array__.Length();
  int64_t *addends_data = new int64_t[addends_len];
  for (int i = 0; i < addends_len; ++i)
    addends_data[i] = addends_array__.Get(i).ToNumber().Int64Value();
  auto output__ = torch::_test_optional_filled_intlist_out(*out, *values, addends_data == nullptr ? c10::nullopt : c10::optional<torch::IntArrayRef>(torch::IntArrayRef(addends_data, addends_len)));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__test_optional_floatlist(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *values = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array addends_array__ = info__[1].As<Napi::Array>();
  int addends_len = addends_array__.Length();
  double *addends_data = new double[addends_len];
  for (int i = 0; i < addends_len; ++i)
    addends_data[i] = addends_array__.Get(i).ToNumber().DoubleValue();
  auto output__ = torch::_test_optional_floatlist(*values, at::ArrayRef<double>(addends_data, addends_len));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__test_optional_floatlist_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *values = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array addends_array__ = info__[2].As<Napi::Array>();
  int addends_len = addends_array__.Length();
  double *addends_data = new double[addends_len];
  for (int i = 0; i < addends_len; ++i)
    addends_data[i] = addends_array__.Get(i).ToNumber().DoubleValue();
  auto output__ = torch::_test_optional_floatlist_out(*out, *values, at::ArrayRef<double>(addends_data, addends_len));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__test_string_default(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *dummy = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::String a_str__ = info__[1].As<Napi::String>();
  std::string a = a_str__.Utf8Value();
  Napi::String b_str__ = info__[2].As<Napi::String>();
  std::string b = b_str__.Utf8Value();
  auto output__ = torch::_test_string_default(*dummy, a, b);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__test_ambiguous_defaults(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *dummy = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t a = info__[1].As<Napi::Number>().Int64Value();
  int64_t b = info__[2].As<Napi::Number>().Int64Value();
  auto output__ = torch::_test_ambiguous_defaults(*dummy, a, b);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__test_ambiguous_defaults_b(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *dummy = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t a = info__[1].As<Napi::Number>().Int64Value();
  Napi::String b_str__ = info__[2].As<Napi::String>();
  std::string b = b_str__.Utf8Value();
  auto output__ = torch::_test_ambiguous_defaults(*dummy, a, b);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__test_warn_in_autograd(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::_test_warn_in_autograd(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__test_warn_in_autograd_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::_test_warn_in_autograd_out(*out, *self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__test_autograd_multiple_dispatch(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::_test_autograd_multiple_dispatch(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__test_autograd_multiple_dispatch_ntonly(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  bool b = info__[1].As<Napi::Boolean>().Value();
  auto output__ = torch::_test_autograd_multiple_dispatch(*self, b);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__test_autograd_multiple_dispatch_fullcoverage_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::_test_autograd_multiple_dispatch_out(*out, *self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__test_autograd_multiple_dispatch_view(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::_test_autograd_multiple_dispatch_view(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__test_autograd_multiple_dispatch_view_copy(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::_test_autograd_multiple_dispatch_view_copy(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__test_autograd_multiple_dispatch_view_copy_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::_test_autograd_multiple_dispatch_view_copy_out(*out, *self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_segment_reduce(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *data = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::String reduce_str__ = info__[1].As<Napi::String>();
  std::string reduce = reduce_str__.Utf8Value();
  bool lengths_null = info__[2].IsUndefined();
  torch::Tensor *lengths_v = lengths_null ? nullptr : info__[2].As<Napi::External<torch::Tensor>>().Data();
  bool indices_null = info__[3].IsUndefined();
  torch::Tensor *indices_v = indices_null ? nullptr : info__[3].As<Napi::External<torch::Tensor>>().Data();
  bool offsets_null = info__[4].IsUndefined();
  torch::Tensor *offsets_v = offsets_null ? nullptr : info__[4].As<Napi::External<torch::Tensor>>().Data();
  int64_t axis = info__[5].As<Napi::Number>().Int64Value();
  bool unsafe = info__[6].As<Napi::Boolean>().Value();
  torch::Scalar *initial = info__[7].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::segment_reduce(*data, reduce, (lengths_null ? *lengths_v : torch::Tensor()), (indices_null ? *indices_v : torch::Tensor()), (offsets_null ? *offsets_v : torch::Tensor()), axis, unsafe, *initial);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_segment_reduce_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *data = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::String reduce_str__ = info__[2].As<Napi::String>();
  std::string reduce = reduce_str__.Utf8Value();
  bool lengths_null = info__[3].IsUndefined();
  torch::Tensor *lengths_v = lengths_null ? nullptr : info__[3].As<Napi::External<torch::Tensor>>().Data();
  bool indices_null = info__[4].IsUndefined();
  torch::Tensor *indices_v = indices_null ? nullptr : info__[4].As<Napi::External<torch::Tensor>>().Data();
  bool offsets_null = info__[5].IsUndefined();
  torch::Tensor *offsets_v = offsets_null ? nullptr : info__[5].As<Napi::External<torch::Tensor>>().Data();
  int64_t axis = info__[6].As<Napi::Number>().Int64Value();
  bool unsafe = info__[7].As<Napi::Boolean>().Value();
  torch::Scalar *initial = info__[8].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::segment_reduce_out(*out, *data, reduce, (lengths_null ? *lengths_v : torch::Tensor()), (indices_null ? *indices_v : torch::Tensor()), (offsets_null ? *offsets_v : torch::Tensor()), axis, unsafe, *initial);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__segment_reduce_backward(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *grad = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *output = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *data = info__[2].As<Napi::External<torch::Tensor>>().Data();
  Napi::String reduce_str__ = info__[3].As<Napi::String>();
  std::string reduce = reduce_str__.Utf8Value();
  bool lengths_null = info__[4].IsUndefined();
  torch::Tensor *lengths_v = lengths_null ? nullptr : info__[4].As<Napi::External<torch::Tensor>>().Data();
  bool offsets_null = info__[5].IsUndefined();
  torch::Tensor *offsets_v = offsets_null ? nullptr : info__[5].As<Napi::External<torch::Tensor>>().Data();
  int64_t axis = info__[6].As<Napi::Number>().Int64Value();
  torch::Scalar *initial = info__[7].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::_segment_reduce_backward(*grad, *output, *data, reduce, (lengths_null ? *lengths_v : torch::Tensor()), (offsets_null ? *offsets_v : torch::Tensor()), axis, *initial);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__segment_reduce_backward_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *grad = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *output = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *data = info__[3].As<Napi::External<torch::Tensor>>().Data();
  Napi::String reduce_str__ = info__[4].As<Napi::String>();
  std::string reduce = reduce_str__.Utf8Value();
  bool lengths_null = info__[5].IsUndefined();
  torch::Tensor *lengths_v = lengths_null ? nullptr : info__[5].As<Napi::External<torch::Tensor>>().Data();
  bool offsets_null = info__[6].IsUndefined();
  torch::Tensor *offsets_v = offsets_null ? nullptr : info__[6].As<Napi::External<torch::Tensor>>().Data();
  int64_t axis = info__[7].As<Napi::Number>().Int64Value();
  torch::Scalar *initial = info__[8].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::_segment_reduce_backward_out(*out, *grad, *output, *data, reduce, (lengths_null ? *lengths_v : torch::Tensor()), (offsets_null ? *offsets_v : torch::Tensor()), axis, *initial);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_pad_sequence(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  Napi::Array sequences_array__ = info__[0].As<Napi::Array>();
  int sequences_len = sequences_array__.Length();
  torch::Tensor **sequences_data = new torch::Tensor *[sequences_len];
  for (int i = 0; i < sequences_len; ++i)
    sequences_data[i] = sequences_array__.Get(i).As<Napi::External<torch::Tensor>>().Data();
  bool batch_first = info__[1].As<Napi::Boolean>().Value();
  double padding_value = info__[2].As<Napi::Number>().DoubleValue();
  auto output__ = torch::pad_sequence(of_carray_tensor(sequences_data, sequences_len), batch_first, padding_value);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_flatten_dense_tensors(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  Napi::Array tensors_array__ = info__[0].As<Napi::Array>();
  int tensors_len = tensors_array__.Length();
  torch::Tensor **tensors_data = new torch::Tensor *[tensors_len];
  for (int i = 0; i < tensors_len; ++i)
    tensors_data[i] = tensors_array__.Get(i).As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::flatten_dense_tensors(of_carray_tensor(tensors_data, tensors_len));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__fw_primal_copy(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t level = info__[1].As<Napi::Number>().Int64Value();
  auto output__ = torch::_fw_primal_copy(*self, level);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__fw_primal_copy_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  int64_t level = info__[2].As<Napi::Number>().Int64Value();
  auto output__ = torch::_fw_primal_copy_out(*out, *self, level);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__make_dual_copy(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *primal = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *tangent = info__[1].As<Napi::External<torch::Tensor>>().Data();
  int64_t level = info__[2].As<Napi::Number>().Int64Value();
  auto output__ = torch::_make_dual_copy(*primal, *tangent, level);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__make_dual_copy_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *primal = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *tangent = info__[2].As<Napi::External<torch::Tensor>>().Data();
  int64_t level = info__[3].As<Napi::Number>().Int64Value();
  auto output__ = torch::_make_dual_copy_out(*out, *primal, *tangent, level);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_view_as_real_copy(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::view_as_real_copy(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_view_as_real_copy_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::view_as_real_copy_out(*out, *self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_view_as_complex_copy(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::view_as_complex_copy(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_view_as_complex_copy_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::view_as_complex_copy_out(*out, *self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__conj_copy(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::_conj_copy(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__conj_copy_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::_conj_copy_out(*out, *self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__neg_view_copy(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::_neg_view_copy(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__neg_view_copy_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::_neg_view_copy_out(*out, *self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_as_strided_copy(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array size_array__ = info__[1].As<Napi::Array>();
  int size_len = size_array__.Length();
  int64_t *size_data = new int64_t[size_len];
  for (int i = 0; i < size_len; ++i)
    size_data[i] = size_array__.Get(i).ToNumber().Int64Value();
  Napi::Array stride_array__ = info__[2].As<Napi::Array>();
  int stride_len = stride_array__.Length();
  int64_t *stride_data = new int64_t[stride_len];
  for (int i = 0; i < stride_len; ++i)
    stride_data[i] = stride_array__.Get(i).ToNumber().Int64Value();
  bool storage_offset_null = info__[3].IsUndefined();
  int64_t storage_offset_v = storage_offset_null ? 0 : info__[3].As<Napi::Number>().Int64Value();
  auto output__ = torch::as_strided_copy(*self, torch::IntArrayRef(size_data, size_len), torch::IntArrayRef(stride_data, stride_len), storage_offset_null ? c10::nullopt : c10::optional<int64_t>(storage_offset_v));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_as_strided_copy_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array size_array__ = info__[2].As<Napi::Array>();
  int size_len = size_array__.Length();
  int64_t *size_data = new int64_t[size_len];
  for (int i = 0; i < size_len; ++i)
    size_data[i] = size_array__.Get(i).ToNumber().Int64Value();
  Napi::Array stride_array__ = info__[3].As<Napi::Array>();
  int stride_len = stride_array__.Length();
  int64_t *stride_data = new int64_t[stride_len];
  for (int i = 0; i < stride_len; ++i)
    stride_data[i] = stride_array__.Get(i).ToNumber().Int64Value();
  bool storage_offset_null = info__[4].IsUndefined();
  int64_t storage_offset_v = storage_offset_null ? 0 : info__[4].As<Napi::Number>().Int64Value();
  auto output__ = torch::as_strided_copy_out(*out, *self, torch::IntArrayRef(size_data, size_len), torch::IntArrayRef(stride_data, stride_len), storage_offset_null ? c10::nullopt : c10::optional<int64_t>(storage_offset_v));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__sparse_broadcast_to_copy(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array size_array__ = info__[1].As<Napi::Array>();
  int size_len = size_array__.Length();
  int64_t *size_data = new int64_t[size_len];
  for (int i = 0; i < size_len; ++i)
    size_data[i] = size_array__.Get(i).ToNumber().Int64Value();
  auto output__ = torch::_sparse_broadcast_to_copy(*self, torch::IntArrayRef(size_data, size_len));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__sparse_broadcast_to_copy_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array size_array__ = info__[2].As<Napi::Array>();
  int size_len = size_array__.Length();
  int64_t *size_data = new int64_t[size_len];
  for (int i = 0; i < size_len; ++i)
    size_data[i] = size_array__.Get(i).ToNumber().Int64Value();
  auto output__ = torch::_sparse_broadcast_to_copy_out(*out, *self, torch::IntArrayRef(size_data, size_len));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_diagonal_copy(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t offset = info__[1].As<Napi::Number>().Int64Value();
  int64_t dim1 = info__[2].As<Napi::Number>().Int64Value();
  int64_t dim2 = info__[3].As<Napi::Number>().Int64Value();
  auto output__ = torch::diagonal_copy(*self, offset, dim1, dim2);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_diagonal_copy_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  int64_t offset = info__[2].As<Napi::Number>().Int64Value();
  int64_t dim1 = info__[3].As<Napi::Number>().Int64Value();
  int64_t dim2 = info__[4].As<Napi::Number>().Int64Value();
  auto output__ = torch::diagonal_copy_out(*out, *self, offset, dim1, dim2);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_expand_copy(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array size_array__ = info__[1].As<Napi::Array>();
  int size_len = size_array__.Length();
  int64_t *size_data = new int64_t[size_len];
  for (int i = 0; i < size_len; ++i)
    size_data[i] = size_array__.Get(i).ToNumber().Int64Value();
  bool implicit = info__[2].As<Napi::Boolean>().Value();
  auto output__ = torch::expand_copy(*self, torch::IntArrayRef(size_data, size_len), implicit);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_expand_copy_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array size_array__ = info__[2].As<Napi::Array>();
  int size_len = size_array__.Length();
  int64_t *size_data = new int64_t[size_len];
  for (int i = 0; i < size_len; ++i)
    size_data[i] = size_array__.Get(i).ToNumber().Int64Value();
  bool implicit = info__[3].As<Napi::Boolean>().Value();
  auto output__ = torch::expand_copy_out(*out, *self, torch::IntArrayRef(size_data, size_len), implicit);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_permute_copy(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array dims_array__ = info__[1].As<Napi::Array>();
  int dims_len = dims_array__.Length();
  int64_t *dims_data = new int64_t[dims_len];
  for (int i = 0; i < dims_len; ++i)
    dims_data[i] = dims_array__.Get(i).ToNumber().Int64Value();
  auto output__ = torch::permute_copy(*self, torch::IntArrayRef(dims_data, dims_len));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_permute_copy_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array dims_array__ = info__[2].As<Napi::Array>();
  int dims_len = dims_array__.Length();
  int64_t *dims_data = new int64_t[dims_len];
  for (int i = 0; i < dims_len; ++i)
    dims_data[i] = dims_array__.Get(i).ToNumber().Int64Value();
  auto output__ = torch::permute_copy_out(*out, *self, torch::IntArrayRef(dims_data, dims_len));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__reshape_alias_copy(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array size_array__ = info__[1].As<Napi::Array>();
  int size_len = size_array__.Length();
  int64_t *size_data = new int64_t[size_len];
  for (int i = 0; i < size_len; ++i)
    size_data[i] = size_array__.Get(i).ToNumber().Int64Value();
  Napi::Array stride_array__ = info__[2].As<Napi::Array>();
  int stride_len = stride_array__.Length();
  int64_t *stride_data = new int64_t[stride_len];
  for (int i = 0; i < stride_len; ++i)
    stride_data[i] = stride_array__.Get(i).ToNumber().Int64Value();
  auto output__ = torch::_reshape_alias_copy(*self, torch::IntArrayRef(size_data, size_len), torch::IntArrayRef(stride_data, stride_len));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__reshape_alias_copy_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array size_array__ = info__[2].As<Napi::Array>();
  int size_len = size_array__.Length();
  int64_t *size_data = new int64_t[size_len];
  for (int i = 0; i < size_len; ++i)
    size_data[i] = size_array__.Get(i).ToNumber().Int64Value();
  Napi::Array stride_array__ = info__[3].As<Napi::Array>();
  int stride_len = stride_array__.Length();
  int64_t *stride_data = new int64_t[stride_len];
  for (int i = 0; i < stride_len; ++i)
    stride_data[i] = stride_array__.Get(i).ToNumber().Int64Value();
  auto output__ = torch::_reshape_alias_copy_out(*out, *self, torch::IntArrayRef(size_data, size_len), torch::IntArrayRef(stride_data, stride_len));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_select_copy(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t dim = info__[1].As<Napi::Number>().Int64Value();
  int64_t index = info__[2].As<Napi::Number>().Int64Value();
  auto output__ = torch::select_copy(*self, dim, index);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_select_copy_int_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  int64_t dim = info__[2].As<Napi::Number>().Int64Value();
  int64_t index = info__[3].As<Napi::Number>().Int64Value();
  auto output__ = torch::select_copy_out(*out, *self, dim, index);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_detach_copy(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::detach_copy(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_detach_copy_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::detach_copy_out(*out, *self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_slice_copy(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t dim = info__[1].As<Napi::Number>().Int64Value();
  bool start_null = info__[2].IsUndefined();
  int64_t start_v = start_null ? 0 : info__[2].As<Napi::Number>().Int64Value();
  bool end_null = info__[3].IsUndefined();
  int64_t end_v = end_null ? 0 : info__[3].As<Napi::Number>().Int64Value();
  int64_t step = info__[4].As<Napi::Number>().Int64Value();
  auto output__ = torch::slice_copy(*self, dim, start_null ? c10::nullopt : c10::optional<int64_t>(start_v), end_null ? c10::nullopt : c10::optional<int64_t>(end_v), step);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_slice_copy_tensor_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  int64_t dim = info__[2].As<Napi::Number>().Int64Value();
  bool start_null = info__[3].IsUndefined();
  int64_t start_v = start_null ? 0 : info__[3].As<Napi::Number>().Int64Value();
  bool end_null = info__[4].IsUndefined();
  int64_t end_v = end_null ? 0 : info__[4].As<Napi::Number>().Int64Value();
  int64_t step = info__[5].As<Napi::Number>().Int64Value();
  auto output__ = torch::slice_copy_out(*out, *self, dim, start_null ? c10::nullopt : c10::optional<int64_t>(start_v), end_null ? c10::nullopt : c10::optional<int64_t>(end_v), step);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_squeeze_copy(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::squeeze_copy(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_squeeze_copy_dim(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t dim = info__[1].As<Napi::Number>().Int64Value();
  auto output__ = torch::squeeze_copy(*self, dim);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_squeeze_copy_dims(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array dim_array__ = info__[1].As<Napi::Array>();
  int dim_len = dim_array__.Length();
  int64_t *dim_data = new int64_t[dim_len];
  for (int i = 0; i < dim_len; ++i)
    dim_data[i] = dim_array__.Get(i).ToNumber().Int64Value();
  auto output__ = torch::squeeze_copy(*self, torch::IntArrayRef(dim_data, dim_len));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_squeeze_copy_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::squeeze_copy_out(*out, *self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_squeeze_copy_dim_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  int64_t dim = info__[2].As<Napi::Number>().Int64Value();
  auto output__ = torch::squeeze_copy_out(*out, *self, dim);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_squeeze_copy_dims_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array dim_array__ = info__[2].As<Napi::Array>();
  int dim_len = dim_array__.Length();
  int64_t *dim_data = new int64_t[dim_len];
  for (int i = 0; i < dim_len; ++i)
    dim_data[i] = dim_array__.Get(i).ToNumber().Int64Value();
  auto output__ = torch::squeeze_copy_out(*out, *self, torch::IntArrayRef(dim_data, dim_len));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_t_copy(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::t_copy(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_t_copy_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::t_copy_out(*out, *self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_transpose_copy(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t dim0 = info__[1].As<Napi::Number>().Int64Value();
  int64_t dim1 = info__[2].As<Napi::Number>().Int64Value();
  auto output__ = torch::transpose_copy(*self, dim0, dim1);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_transpose_copy_int_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  int64_t dim0 = info__[2].As<Napi::Number>().Int64Value();
  int64_t dim1 = info__[3].As<Napi::Number>().Int64Value();
  auto output__ = torch::transpose_copy_out(*out, *self, dim0, dim1);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_unsqueeze_copy(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t dim = info__[1].As<Napi::Number>().Int64Value();
  auto output__ = torch::unsqueeze_copy(*self, dim);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_unsqueeze_copy_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  int64_t dim = info__[2].As<Napi::Number>().Int64Value();
  auto output__ = torch::unsqueeze_copy_out(*out, *self, dim);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__indices_copy(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::_indices_copy(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__indices_copy_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::_indices_copy_out(*out, *self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__values_copy(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::_values_copy(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__values_copy_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::_values_copy_out(*out, *self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_indices_copy(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::indices_copy(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_indices_copy_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::indices_copy_out(*out, *self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_values_copy(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::values_copy(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_values_copy_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::values_copy_out(*out, *self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_crow_indices_copy(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::crow_indices_copy(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_crow_indices_copy_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::crow_indices_copy_out(*out, *self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_col_indices_copy(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::col_indices_copy(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_col_indices_copy_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::col_indices_copy_out(*out, *self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_ccol_indices_copy(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::ccol_indices_copy(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_ccol_indices_copy_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::ccol_indices_copy_out(*out, *self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_row_indices_copy(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::row_indices_copy(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_row_indices_copy_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::row_indices_copy_out(*out, *self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

void atg_unbind_copy(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  Napi::Array out_array__ = info__[0].As<Napi::Array>();
  int out_len = out_array__.Length();
  torch::Tensor **out_data = new torch::Tensor *[out_len];
  for (int i = 0; i < out_len; ++i)
    out_data[i] = out_array__.Get(i).As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  int64_t dim = info__[2].As<Napi::Number>().Int64Value();
  torch::unbind_copy_out(of_carray_tensor(out_data, out_len), *self, dim);
}

void atg_split_copy(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  Napi::Array out_array__ = info__[0].As<Napi::Array>();
  int out_len = out_array__.Length();
  torch::Tensor **out_data = new torch::Tensor *[out_len];
  for (int i = 0; i < out_len; ++i)
    out_data[i] = out_array__.Get(i).As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  int64_t split_size = info__[2].As<Napi::Number>().Int64Value();
  int64_t dim = info__[3].As<Napi::Number>().Int64Value();
  torch::split_copy_out(of_carray_tensor(out_data, out_len), *self, split_size, dim);
}

void atg_split_with_sizes_copy(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  Napi::Array out_array__ = info__[0].As<Napi::Array>();
  int out_len = out_array__.Length();
  torch::Tensor **out_data = new torch::Tensor *[out_len];
  for (int i = 0; i < out_len; ++i)
    out_data[i] = out_array__.Get(i).As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array split_sizes_array__ = info__[2].As<Napi::Array>();
  int split_sizes_len = split_sizes_array__.Length();
  int64_t *split_sizes_data = new int64_t[split_sizes_len];
  for (int i = 0; i < split_sizes_len; ++i)
    split_sizes_data[i] = split_sizes_array__.Get(i).ToNumber().Int64Value();
  int64_t dim = info__[3].As<Napi::Number>().Int64Value();
  torch::split_with_sizes_copy_out(of_carray_tensor(out_data, out_len), *self, torch::IntArrayRef(split_sizes_data, split_sizes_len), dim);
}

Napi::External<torch::Tensor> atg_view_copy(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array size_array__ = info__[1].As<Napi::Array>();
  int size_len = size_array__.Length();
  int64_t *size_data = new int64_t[size_len];
  for (int i = 0; i < size_len; ++i)
    size_data[i] = size_array__.Get(i).ToNumber().Int64Value();
  auto output__ = torch::view_copy(*self, torch::IntArrayRef(size_data, size_len));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_view_copy_dtype(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int dtype = info__[1].As<Napi::Number>().Int32Value();
  auto output__ = torch::view_copy(*self, at::ScalarType(dtype));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_view_copy_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array size_array__ = info__[2].As<Napi::Array>();
  int size_len = size_array__.Length();
  int64_t *size_data = new int64_t[size_len];
  for (int i = 0; i < size_len; ++i)
    size_data[i] = size_array__.Get(i).ToNumber().Int64Value();
  auto output__ = torch::view_copy_out(*out, *self, torch::IntArrayRef(size_data, size_len));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_view_copy_dtype_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  int dtype = info__[2].As<Napi::Number>().Int32Value();
  auto output__ = torch::view_copy_out(*out, *self, at::ScalarType(dtype));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_unfold_copy(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t dimension = info__[1].As<Napi::Number>().Int64Value();
  int64_t size = info__[2].As<Napi::Number>().Int64Value();
  int64_t step = info__[3].As<Napi::Number>().Int64Value();
  auto output__ = torch::unfold_copy(*self, dimension, size, step);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_unfold_copy_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  int64_t dimension = info__[2].As<Napi::Number>().Int64Value();
  int64_t size = info__[3].As<Napi::Number>().Int64Value();
  int64_t step = info__[4].As<Napi::Number>().Int64Value();
  auto output__ = torch::unfold_copy_out(*out, *self, dimension, size, step);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_alias_copy(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::alias_copy(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_alias_copy_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::alias_copy_out(*out, *self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_to_padded_tensor(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  double padding = info__[1].As<Napi::Number>().DoubleValue();
  Napi::Array output_size_array__ = info__[2].As<Napi::Array>();
  int output_size_len = output_size_array__.Length();
  int64_t *output_size_data = new int64_t[output_size_len];
  for (int i = 0; i < output_size_len; ++i)
    output_size_data[i] = output_size_array__.Get(i).ToNumber().Int64Value();
  auto output__ = self->to_padded_tensor(padding, output_size_data == nullptr ? c10::nullopt : c10::optional<torch::IntArrayRef>(torch::IntArrayRef(output_size_data, output_size_len)));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_to_padded_tensor_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  double padding = info__[2].As<Napi::Number>().DoubleValue();
  Napi::Array output_size_array__ = info__[3].As<Napi::Array>();
  int output_size_len = output_size_array__.Length();
  int64_t *output_size_data = new int64_t[output_size_len];
  for (int i = 0; i < output_size_len; ++i)
    output_size_data[i] = output_size_array__.Get(i).ToNumber().Int64Value();
  auto output__ = torch::to_padded_tensor_out(*out, *self, padding, output_size_data == nullptr ? c10::nullopt : c10::optional<torch::IntArrayRef>(torch::IntArrayRef(output_size_data, output_size_len)));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__nested_tensor_softmax_with_shape(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *query = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::_nested_tensor_softmax_with_shape(*self, *query);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__transformer_encoder_layer_fwd(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *src = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t embed_dim = info__[1].As<Napi::Number>().Int64Value();
  int64_t num_heads = info__[2].As<Napi::Number>().Int64Value();
  torch::Tensor *qkv_weight = info__[3].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *qkv_bias = info__[4].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *proj_weight = info__[5].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *proj_bias = info__[6].As<Napi::External<torch::Tensor>>().Data();
  bool use_gelu = info__[7].As<Napi::Boolean>().Value();
  bool norm_first = info__[8].As<Napi::Boolean>().Value();
  double eps = info__[9].As<Napi::Number>().DoubleValue();
  torch::Tensor *norm_weight_1 = info__[10].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *norm_bias_1 = info__[11].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *norm_weight_2 = info__[12].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *norm_bias_2 = info__[13].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *ffn_weight_1 = info__[14].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *ffn_bias_1 = info__[15].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *ffn_weight_2 = info__[16].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *ffn_bias_2 = info__[17].As<Napi::External<torch::Tensor>>().Data();
  bool mask_null = info__[18].IsUndefined();
  torch::Tensor *mask_v = mask_null ? nullptr : info__[18].As<Napi::External<torch::Tensor>>().Data();
  bool mask_type_null = info__[19].IsUndefined();
  int64_t mask_type_v = mask_type_null ? 0 : info__[19].As<Napi::Number>().Int64Value();
  auto output__ = torch::_transformer_encoder_layer_fwd(*src, embed_dim, num_heads, *qkv_weight, *qkv_bias, *proj_weight, *proj_bias, use_gelu, norm_first, eps, *norm_weight_1, *norm_bias_1, *norm_weight_2, *norm_bias_2, *ffn_weight_1, *ffn_bias_1, *ffn_weight_2, *ffn_bias_2, (mask_null ? *mask_v : torch::Tensor()), mask_type_null ? c10::nullopt : c10::optional<int64_t>(mask_type_v));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__transformer_encoder_layer_fwd_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *src = info__[1].As<Napi::External<torch::Tensor>>().Data();
  int64_t embed_dim = info__[2].As<Napi::Number>().Int64Value();
  int64_t num_heads = info__[3].As<Napi::Number>().Int64Value();
  torch::Tensor *qkv_weight = info__[4].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *qkv_bias = info__[5].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *proj_weight = info__[6].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *proj_bias = info__[7].As<Napi::External<torch::Tensor>>().Data();
  bool use_gelu = info__[8].As<Napi::Boolean>().Value();
  bool norm_first = info__[9].As<Napi::Boolean>().Value();
  double eps = info__[10].As<Napi::Number>().DoubleValue();
  torch::Tensor *norm_weight_1 = info__[11].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *norm_bias_1 = info__[12].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *norm_weight_2 = info__[13].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *norm_bias_2 = info__[14].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *ffn_weight_1 = info__[15].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *ffn_bias_1 = info__[16].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *ffn_weight_2 = info__[17].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *ffn_bias_2 = info__[18].As<Napi::External<torch::Tensor>>().Data();
  bool mask_null = info__[19].IsUndefined();
  torch::Tensor *mask_v = mask_null ? nullptr : info__[19].As<Napi::External<torch::Tensor>>().Data();
  bool mask_type_null = info__[20].IsUndefined();
  int64_t mask_type_v = mask_type_null ? 0 : info__[20].As<Napi::Number>().Int64Value();
  auto output__ = torch::_transformer_encoder_layer_fwd_out(*out, *src, embed_dim, num_heads, *qkv_weight, *qkv_bias, *proj_weight, *proj_bias, use_gelu, norm_first, eps, *norm_weight_1, *norm_bias_1, *norm_weight_2, *norm_bias_2, *ffn_weight_1, *ffn_bias_1, *ffn_weight_2, *ffn_bias_2, (mask_null ? *mask_v : torch::Tensor()), mask_type_null ? c10::nullopt : c10::optional<int64_t>(mask_type_v));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::Array atg__native_multi_head_attention(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *query = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *key = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *value = info__[2].As<Napi::External<torch::Tensor>>().Data();
  int64_t embed_dim = info__[3].As<Napi::Number>().Int64Value();
  int64_t num_head = info__[4].As<Napi::Number>().Int64Value();
  torch::Tensor *qkv_weight = info__[5].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *qkv_bias = info__[6].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *proj_weight = info__[7].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *proj_bias = info__[8].As<Napi::External<torch::Tensor>>().Data();
  bool mask_null = info__[9].IsUndefined();
  torch::Tensor *mask_v = mask_null ? nullptr : info__[9].As<Napi::External<torch::Tensor>>().Data();
  bool need_weights = info__[10].As<Napi::Boolean>().Value();
  bool average_attn_weights = info__[11].As<Napi::Boolean>().Value();
  bool mask_type_null = info__[12].IsUndefined();
  int64_t mask_type_v = mask_type_null ? 0 : info__[12].As<Napi::Number>().Int64Value();
  auto output__ = torch::_native_multi_head_attention(*query, *key, *value, embed_dim, num_head, *qkv_weight, *qkv_bias, *proj_weight, *proj_bias, (mask_null ? *mask_v : torch::Tensor()), need_weights, average_attn_weights, mask_type_null ? c10::nullopt : c10::optional<int64_t>(mask_type_v));
  Napi::Array output__array__ = Napi::Array::New(env__, 2);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  return output__array__;
}

Napi::Array atg__native_multi_head_attention_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out0 = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *out1 = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *query = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *key = info__[3].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *value = info__[4].As<Napi::External<torch::Tensor>>().Data();
  int64_t embed_dim = info__[5].As<Napi::Number>().Int64Value();
  int64_t num_head = info__[6].As<Napi::Number>().Int64Value();
  torch::Tensor *qkv_weight = info__[7].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *qkv_bias = info__[8].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *proj_weight = info__[9].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *proj_bias = info__[10].As<Napi::External<torch::Tensor>>().Data();
  bool mask_null = info__[11].IsUndefined();
  torch::Tensor *mask_v = mask_null ? nullptr : info__[11].As<Napi::External<torch::Tensor>>().Data();
  bool need_weights = info__[12].As<Napi::Boolean>().Value();
  bool average_attn_weights = info__[13].As<Napi::Boolean>().Value();
  bool mask_type_null = info__[14].IsUndefined();
  int64_t mask_type_v = mask_type_null ? 0 : info__[14].As<Napi::Number>().Int64Value();
  auto output__ = torch::_native_multi_head_attention_out(*out0, *out1, *query, *key, *value, embed_dim, num_head, *qkv_weight, *qkv_bias, *proj_weight, *proj_bias, (mask_null ? *mask_v : torch::Tensor()), need_weights, average_attn_weights, mask_type_null ? c10::nullopt : c10::optional<int64_t>(mask_type_v));
  Napi::Array output__array__ = Napi::Array::New(env__, 2);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  return output__array__;
}

Napi::External<torch::Tensor> atg_scaled_dot_product_attention(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *query = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *key = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *value = info__[2].As<Napi::External<torch::Tensor>>().Data();
  bool attn_mask_null = info__[3].IsUndefined();
  torch::Tensor *attn_mask_v = attn_mask_null ? nullptr : info__[3].As<Napi::External<torch::Tensor>>().Data();
  double dropout_p = info__[4].As<Napi::Number>().DoubleValue();
  bool is_causal = info__[5].As<Napi::Boolean>().Value();
  auto output__ = torch::scaled_dot_product_attention(*query, *key, *value, (attn_mask_null ? *attn_mask_v : torch::Tensor()), dropout_p, is_causal);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::Array atg__scaled_dot_product_attention(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *query = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *key = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *value = info__[2].As<Napi::External<torch::Tensor>>().Data();
  bool attn_mask_null = info__[3].IsUndefined();
  torch::Tensor *attn_mask_v = attn_mask_null ? nullptr : info__[3].As<Napi::External<torch::Tensor>>().Data();
  double dropout_p = info__[4].As<Napi::Number>().DoubleValue();
  bool need_attn_weights = info__[5].As<Napi::Boolean>().Value();
  bool is_causal = info__[6].As<Napi::Boolean>().Value();
  auto output__ = torch::_scaled_dot_product_attention(*query, *key, *value, (attn_mask_null ? *attn_mask_v : torch::Tensor()), dropout_p, need_attn_weights, is_causal);
  Napi::Array output__array__ = Napi::Array::New(env__, 2);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  return output__array__;
}

Napi::Number atg__fused_sdp_choice(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *query = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *key = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *value = info__[2].As<Napi::External<torch::Tensor>>().Data();
  bool attn_mask_null = info__[3].IsUndefined();
  torch::Tensor *attn_mask_v = attn_mask_null ? nullptr : info__[3].As<Napi::External<torch::Tensor>>().Data();
  double dropout_p = info__[4].As<Napi::Number>().DoubleValue();
  bool is_causal = info__[5].As<Napi::Boolean>().Value();
  auto output__ = torch::_fused_sdp_choice(*query, *key, *value, (attn_mask_null ? *attn_mask_v : torch::Tensor()), dropout_p, is_causal);
  return Napi::Number::New(env__, output__);
}

Napi::Array atg__scaled_dot_product_attention_math(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *query = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *key = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *value = info__[2].As<Napi::External<torch::Tensor>>().Data();
  bool attn_mask_null = info__[3].IsUndefined();
  torch::Tensor *attn_mask_v = attn_mask_null ? nullptr : info__[3].As<Napi::External<torch::Tensor>>().Data();
  double dropout_p = info__[4].As<Napi::Number>().DoubleValue();
  bool is_causal = info__[5].As<Napi::Boolean>().Value();
  bool dropout_mask_null = info__[6].IsUndefined();
  torch::Tensor *dropout_mask_v = dropout_mask_null ? nullptr : info__[6].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::_scaled_dot_product_attention_math(*query, *key, *value, (attn_mask_null ? *attn_mask_v : torch::Tensor()), dropout_p, is_causal, (dropout_mask_null ? *dropout_mask_v : torch::Tensor()));
  Napi::Array output__array__ = Napi::Array::New(env__, 2);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  return output__array__;
}

Napi::Array atg__scaled_dot_product_flash_attention_backward(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *grad_out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *query = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *key = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *value = info__[3].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *out = info__[4].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *logsumexp = info__[5].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *cum_seq_q = info__[6].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *cum_seq_k = info__[7].As<Napi::External<torch::Tensor>>().Data();
  int64_t max_q = info__[8].As<Napi::Number>().Int64Value();
  int64_t max_k = info__[9].As<Napi::Number>().Int64Value();
  double dropout_p = info__[10].As<Napi::Number>().DoubleValue();
  bool is_causal = info__[11].As<Napi::Boolean>().Value();
  int64_t philox_seed = info__[12].As<Napi::Number>().Int64Value();
  int64_t philox_offset = info__[13].As<Napi::Number>().Int64Value();
  auto output__ = torch::_scaled_dot_product_flash_attention_backward(*grad_out, *query, *key, *value, *out, *logsumexp, *cum_seq_q, *cum_seq_k, max_q, max_k, dropout_p, is_causal, philox_seed, philox_offset);
  Napi::Array output__array__ = Napi::Array::New(env__, 3);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  output__array__[2u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<2>(output__)));
  return output__array__;
}

Napi::Array atg__scaled_dot_product_efficient_attention(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *query = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *key = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *value = info__[2].As<Napi::External<torch::Tensor>>().Data();
  bool compute_log_sumexp = info__[3].As<Napi::Boolean>().Value();
  bool is_causal = info__[4].As<Napi::Boolean>().Value();
  auto output__ = torch::_scaled_dot_product_efficient_attention(*query, *key, *value, compute_log_sumexp, is_causal);
  Napi::Array output__array__ = Napi::Array::New(env__, 2);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  return output__array__;
}

Napi::Array atg__scaled_dot_product_efficient_attention_backward(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *grad_out_ = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *query = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *key = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *value = info__[3].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *out = info__[4].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *logsumexp = info__[5].As<Napi::External<torch::Tensor>>().Data();
  bool is_causal = info__[6].As<Napi::Boolean>().Value();
  bool chunk_grad_outputs = info__[7].As<Napi::Boolean>().Value();
  auto output__ = torch::_scaled_dot_product_efficient_attention_backward(*grad_out_, *query, *key, *value, *out, *logsumexp, is_causal, chunk_grad_outputs);
  Napi::Array output__array__ = Napi::Array::New(env__, 3);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  output__array__[2u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<2>(output__)));
  return output__array__;
}

Napi::Boolean atg__chunk_grad_outputs_efficient_attention(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *query = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *key = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *value = info__[2].As<Napi::External<torch::Tensor>>().Data();
  bool is_causal = info__[3].As<Napi::Boolean>().Value();
  auto output__ = torch::_chunk_grad_outputs_efficient_attention(*query, *key, *value, is_causal);
  return Napi::Boolean::New(env__, output__);
}

Napi::Array atg__flash_attention_backward(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *grad_out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *query = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *key = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *value = info__[3].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *out = info__[4].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *logsumexp = info__[5].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *cum_seq_q = info__[6].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *cum_seq_k = info__[7].As<Napi::External<torch::Tensor>>().Data();
  int64_t max_q = info__[8].As<Napi::Number>().Int64Value();
  int64_t max_k = info__[9].As<Napi::Number>().Int64Value();
  double dropout_p = info__[10].As<Napi::Number>().DoubleValue();
  bool is_causal = info__[11].As<Napi::Boolean>().Value();
  int64_t philox_seed = info__[12].As<Napi::Number>().Int64Value();
  int64_t philox_offset = info__[13].As<Napi::Number>().Int64Value();
  auto output__ = torch::_flash_attention_backward(*grad_out, *query, *key, *value, *out, *logsumexp, *cum_seq_q, *cum_seq_k, max_q, max_k, dropout_p, is_causal, philox_seed, philox_offset);
  Napi::Array output__array__ = Napi::Array::New(env__, 3);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  output__array__[2u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<2>(output__)));
  return output__array__;
}

Napi::Array atg__efficient_attention_backward(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *grad_out_ = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *query = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *key = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *value = info__[3].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *out = info__[4].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *logsumexp = info__[5].As<Napi::External<torch::Tensor>>().Data();
  bool is_causal = info__[6].As<Napi::Boolean>().Value();
  bool chunk_grad_outputs = info__[7].As<Napi::Boolean>().Value();
  auto output__ = torch::_efficient_attention_backward(*grad_out_, *query, *key, *value, *out, *logsumexp, is_causal, chunk_grad_outputs);
  Napi::Array output__array__ = Napi::Array::New(env__, 3);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  output__array__[2u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<2>(output__)));
  return output__array__;
}

Napi::External<torch::Tensor> atg__triton_scaled_dot_attention(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *q = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *k = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *v = info__[2].As<Napi::External<torch::Tensor>>().Data();
  double dropout_p = info__[3].As<Napi::Number>().DoubleValue();
  auto output__ = torch::_triton_scaled_dot_attention(*q, *k, *v, dropout_p);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__triton_scaled_dot_attention_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *q = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *k = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *v = info__[3].As<Napi::External<torch::Tensor>>().Data();
  double dropout_p = info__[4].As<Napi::Number>().DoubleValue();
  auto output__ = torch::_triton_scaled_dot_attention_out(*out, *q, *k, *v, dropout_p);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__triton_multi_head_attention(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *query = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *key = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *value = info__[2].As<Napi::External<torch::Tensor>>().Data();
  int64_t embed_dim = info__[3].As<Napi::Number>().Int64Value();
  int64_t num_head = info__[4].As<Napi::Number>().Int64Value();
  torch::Tensor *qkv_weight = info__[5].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *qkv_bias = info__[6].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *proj_weight = info__[7].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *proj_bias = info__[8].As<Napi::External<torch::Tensor>>().Data();
  bool mask_null = info__[9].IsUndefined();
  torch::Tensor *mask_v = mask_null ? nullptr : info__[9].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::_triton_multi_head_attention(*query, *key, *value, embed_dim, num_head, *qkv_weight, *qkv_bias, *proj_weight, *proj_bias, (mask_null ? *mask_v : torch::Tensor()));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__triton_multi_head_attention_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *query = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *key = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *value = info__[3].As<Napi::External<torch::Tensor>>().Data();
  int64_t embed_dim = info__[4].As<Napi::Number>().Int64Value();
  int64_t num_head = info__[5].As<Napi::Number>().Int64Value();
  torch::Tensor *qkv_weight = info__[6].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *qkv_bias = info__[7].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *proj_weight = info__[8].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *proj_bias = info__[9].As<Napi::External<torch::Tensor>>().Data();
  bool mask_null = info__[10].IsUndefined();
  torch::Tensor *mask_v = mask_null ? nullptr : info__[10].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::_triton_multi_head_attention_out(*out, *query, *key, *value, embed_dim, num_head, *qkv_weight, *qkv_bias, *proj_weight, *proj_bias, (mask_null ? *mask_v : torch::Tensor()));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_special_airy_ai(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *x = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::special_airy_ai(*x);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_special_airy_ai_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *x = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::special_airy_ai_out(*out, *x);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::Array atg__transformer_decoder_only_layer_fwd(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *src = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t embed_dim = info__[1].As<Napi::Number>().Int64Value();
  int64_t num_heads = info__[2].As<Napi::Number>().Int64Value();
  torch::Tensor *qkv_weight = info__[3].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *qkv_bias = info__[4].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *proj_weight = info__[5].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *proj_bias = info__[6].As<Napi::External<torch::Tensor>>().Data();
  bool use_gelu = info__[7].As<Napi::Boolean>().Value();
  bool norm_first = info__[8].As<Napi::Boolean>().Value();
  double eps = info__[9].As<Napi::Number>().DoubleValue();
  torch::Tensor *norm_weight_1 = info__[10].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *norm_bias_1 = info__[11].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *norm_weight_2 = info__[12].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *norm_bias_2 = info__[13].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *ffn_weight_1 = info__[14].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *ffn_bias_1 = info__[15].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *ffn_weight_2 = info__[16].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *ffn_bias_2 = info__[17].As<Napi::External<torch::Tensor>>().Data();
  bool mask_null = info__[18].IsUndefined();
  torch::Tensor *mask_v = mask_null ? nullptr : info__[18].As<Napi::External<torch::Tensor>>().Data();
  bool incr_key_null = info__[19].IsUndefined();
  torch::Tensor *incr_key_v = incr_key_null ? nullptr : info__[19].As<Napi::External<torch::Tensor>>().Data();
  bool incr_value_null = info__[20].IsUndefined();
  torch::Tensor *incr_value_v = incr_value_null ? nullptr : info__[20].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::_transformer_decoder_only_layer_fwd(*src, embed_dim, num_heads, *qkv_weight, *qkv_bias, *proj_weight, *proj_bias, use_gelu, norm_first, eps, *norm_weight_1, *norm_bias_1, *norm_weight_2, *norm_bias_2, *ffn_weight_1, *ffn_bias_1, *ffn_weight_2, *ffn_bias_2, (mask_null ? *mask_v : torch::Tensor()), (incr_key_null ? *incr_key_v : torch::Tensor()), (incr_value_null ? *incr_value_v : torch::Tensor()));
  Napi::Array output__array__ = Napi::Array::New(env__, 3);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  output__array__[2u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<2>(output__)));
  return output__array__;
}

Napi::Array atg__transformer_decoder_only_layer_fwd_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out0 = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *out1 = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *out2 = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *src = info__[3].As<Napi::External<torch::Tensor>>().Data();
  int64_t embed_dim = info__[4].As<Napi::Number>().Int64Value();
  int64_t num_heads = info__[5].As<Napi::Number>().Int64Value();
  torch::Tensor *qkv_weight = info__[6].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *qkv_bias = info__[7].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *proj_weight = info__[8].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *proj_bias = info__[9].As<Napi::External<torch::Tensor>>().Data();
  bool use_gelu = info__[10].As<Napi::Boolean>().Value();
  bool norm_first = info__[11].As<Napi::Boolean>().Value();
  double eps = info__[12].As<Napi::Number>().DoubleValue();
  torch::Tensor *norm_weight_1 = info__[13].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *norm_bias_1 = info__[14].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *norm_weight_2 = info__[15].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *norm_bias_2 = info__[16].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *ffn_weight_1 = info__[17].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *ffn_bias_1 = info__[18].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *ffn_weight_2 = info__[19].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *ffn_bias_2 = info__[20].As<Napi::External<torch::Tensor>>().Data();
  bool mask_null = info__[21].IsUndefined();
  torch::Tensor *mask_v = mask_null ? nullptr : info__[21].As<Napi::External<torch::Tensor>>().Data();
  bool incr_key_null = info__[22].IsUndefined();
  torch::Tensor *incr_key_v = incr_key_null ? nullptr : info__[22].As<Napi::External<torch::Tensor>>().Data();
  bool incr_value_null = info__[23].IsUndefined();
  torch::Tensor *incr_value_v = incr_value_null ? nullptr : info__[23].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::_transformer_decoder_only_layer_fwd_out(*out0, *out1, *out2, *src, embed_dim, num_heads, *qkv_weight, *qkv_bias, *proj_weight, *proj_bias, use_gelu, norm_first, eps, *norm_weight_1, *norm_bias_1, *norm_weight_2, *norm_bias_2, *ffn_weight_1, *ffn_bias_1, *ffn_weight_2, *ffn_bias_2, (mask_null ? *mask_v : torch::Tensor()), (incr_key_null ? *incr_key_v : torch::Tensor()), (incr_value_null ? *incr_value_v : torch::Tensor()));
  Napi::Array output__array__ = Napi::Array::New(env__, 3);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  output__array__[2u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<2>(output__)));
  return output__array__;
}

Napi::Array atg__native_decoder_only_multi_head_attention(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *query = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *key = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *value = info__[2].As<Napi::External<torch::Tensor>>().Data();
  int64_t embed_dim = info__[3].As<Napi::Number>().Int64Value();
  int64_t num_head = info__[4].As<Napi::Number>().Int64Value();
  torch::Tensor *qkv_weight = info__[5].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *qkv_bias = info__[6].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *proj_weight = info__[7].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *proj_bias = info__[8].As<Napi::External<torch::Tensor>>().Data();
  bool mask_null = info__[9].IsUndefined();
  torch::Tensor *mask_v = mask_null ? nullptr : info__[9].As<Napi::External<torch::Tensor>>().Data();
  bool incr_key_null = info__[10].IsUndefined();
  torch::Tensor *incr_key_v = incr_key_null ? nullptr : info__[10].As<Napi::External<torch::Tensor>>().Data();
  bool incr_value_null = info__[11].IsUndefined();
  torch::Tensor *incr_value_v = incr_value_null ? nullptr : info__[11].As<Napi::External<torch::Tensor>>().Data();
  bool need_weights = info__[12].As<Napi::Boolean>().Value();
  bool average_attn_weights = info__[13].As<Napi::Boolean>().Value();
  auto output__ = torch::_native_decoder_only_multi_head_attention(*query, *key, *value, embed_dim, num_head, *qkv_weight, *qkv_bias, *proj_weight, *proj_bias, (mask_null ? *mask_v : torch::Tensor()), (incr_key_null ? *incr_key_v : torch::Tensor()), (incr_value_null ? *incr_value_v : torch::Tensor()), need_weights, average_attn_weights);
  Napi::Array output__array__ = Napi::Array::New(env__, 4);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  output__array__[2u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<2>(output__)));
  output__array__[3u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<3>(output__)));
  return output__array__;
}

Napi::Array atg__native_decoder_only_multi_head_attention_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out0 = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *out1 = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *out2 = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *out3 = info__[3].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *query = info__[4].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *key = info__[5].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *value = info__[6].As<Napi::External<torch::Tensor>>().Data();
  int64_t embed_dim = info__[7].As<Napi::Number>().Int64Value();
  int64_t num_head = info__[8].As<Napi::Number>().Int64Value();
  torch::Tensor *qkv_weight = info__[9].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *qkv_bias = info__[10].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *proj_weight = info__[11].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *proj_bias = info__[12].As<Napi::External<torch::Tensor>>().Data();
  bool mask_null = info__[13].IsUndefined();
  torch::Tensor *mask_v = mask_null ? nullptr : info__[13].As<Napi::External<torch::Tensor>>().Data();
  bool incr_key_null = info__[14].IsUndefined();
  torch::Tensor *incr_key_v = incr_key_null ? nullptr : info__[14].As<Napi::External<torch::Tensor>>().Data();
  bool incr_value_null = info__[15].IsUndefined();
  torch::Tensor *incr_value_v = incr_value_null ? nullptr : info__[15].As<Napi::External<torch::Tensor>>().Data();
  bool need_weights = info__[16].As<Napi::Boolean>().Value();
  bool average_attn_weights = info__[17].As<Napi::Boolean>().Value();
  auto output__ = torch::_native_decoder_only_multi_head_attention_out(*out0, *out1, *out2, *out3, *query, *key, *value, embed_dim, num_head, *qkv_weight, *qkv_bias, *proj_weight, *proj_bias, (mask_null ? *mask_v : torch::Tensor()), (incr_key_null ? *incr_key_v : torch::Tensor()), (incr_value_null ? *incr_value_v : torch::Tensor()), need_weights, average_attn_weights);
  Napi::Array output__array__ = Napi::Array::New(env__, 4);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  output__array__[2u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<2>(output__)));
  output__array__[3u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<3>(output__)));
  return output__array__;
}

Napi::External<torch::Tensor> atg_special_bessel_j0(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::special_bessel_j0(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_special_bessel_j0_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::special_bessel_j0_out(*out, *self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_special_bessel_j1(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::special_bessel_j1(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_special_bessel_j1_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::special_bessel_j1_out(*out, *self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_special_bessel_y0(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::special_bessel_y0(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_special_bessel_y0_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::special_bessel_y0_out(*out, *self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_special_bessel_y1(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::special_bessel_y1(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_special_bessel_y1_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::special_bessel_y1_out(*out, *self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_special_chebyshev_polynomial_t(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *x = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *n = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::special_chebyshev_polynomial_t(*x, *n);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_special_chebyshev_polynomial_t_x_scalar(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Scalar *x = info__[0].As<Napi::External<torch::Scalar>>().Data();
  torch::Tensor *n = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::special_chebyshev_polynomial_t(*x, *n);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_special_chebyshev_polynomial_t_n_scalar(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *x = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *n = info__[1].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::special_chebyshev_polynomial_t(*x, *n);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_special_chebyshev_polynomial_t_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *x = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *n = info__[2].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::special_chebyshev_polynomial_t_out(*out, *x, *n);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_special_chebyshev_polynomial_t_x_scalar_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *x = info__[1].As<Napi::External<torch::Scalar>>().Data();
  torch::Tensor *n = info__[2].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::special_chebyshev_polynomial_t_out(*out, *x, *n);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_special_chebyshev_polynomial_t_n_scalar_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *x = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *n = info__[2].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::special_chebyshev_polynomial_t_out(*out, *x, *n);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_special_chebyshev_polynomial_u(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *x = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *n = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::special_chebyshev_polynomial_u(*x, *n);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_special_chebyshev_polynomial_u_x_scalar(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Scalar *x = info__[0].As<Napi::External<torch::Scalar>>().Data();
  torch::Tensor *n = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::special_chebyshev_polynomial_u(*x, *n);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_special_chebyshev_polynomial_u_n_scalar(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *x = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *n = info__[1].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::special_chebyshev_polynomial_u(*x, *n);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_special_chebyshev_polynomial_u_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *x = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *n = info__[2].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::special_chebyshev_polynomial_u_out(*out, *x, *n);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_special_chebyshev_polynomial_u_x_scalar_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *x = info__[1].As<Napi::External<torch::Scalar>>().Data();
  torch::Tensor *n = info__[2].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::special_chebyshev_polynomial_u_out(*out, *x, *n);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_special_chebyshev_polynomial_u_n_scalar_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *x = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *n = info__[2].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::special_chebyshev_polynomial_u_out(*out, *x, *n);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_special_chebyshev_polynomial_v(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *x = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *n = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::special_chebyshev_polynomial_v(*x, *n);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_special_chebyshev_polynomial_v_x_scalar(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Scalar *x = info__[0].As<Napi::External<torch::Scalar>>().Data();
  torch::Tensor *n = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::special_chebyshev_polynomial_v(*x, *n);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_special_chebyshev_polynomial_v_n_scalar(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *x = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *n = info__[1].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::special_chebyshev_polynomial_v(*x, *n);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_special_chebyshev_polynomial_v_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *x = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *n = info__[2].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::special_chebyshev_polynomial_v_out(*out, *x, *n);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_special_chebyshev_polynomial_v_x_scalar_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *x = info__[1].As<Napi::External<torch::Scalar>>().Data();
  torch::Tensor *n = info__[2].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::special_chebyshev_polynomial_v_out(*out, *x, *n);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_special_chebyshev_polynomial_v_n_scalar_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *x = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *n = info__[2].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::special_chebyshev_polynomial_v_out(*out, *x, *n);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_special_chebyshev_polynomial_w(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *x = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *n = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::special_chebyshev_polynomial_w(*x, *n);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_special_chebyshev_polynomial_w_x_scalar(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Scalar *x = info__[0].As<Napi::External<torch::Scalar>>().Data();
  torch::Tensor *n = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::special_chebyshev_polynomial_w(*x, *n);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_special_chebyshev_polynomial_w_n_scalar(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *x = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *n = info__[1].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::special_chebyshev_polynomial_w(*x, *n);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_special_chebyshev_polynomial_w_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *x = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *n = info__[2].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::special_chebyshev_polynomial_w_out(*out, *x, *n);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_special_chebyshev_polynomial_w_x_scalar_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *x = info__[1].As<Napi::External<torch::Scalar>>().Data();
  torch::Tensor *n = info__[2].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::special_chebyshev_polynomial_w_out(*out, *x, *n);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_special_chebyshev_polynomial_w_n_scalar_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *x = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *n = info__[2].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::special_chebyshev_polynomial_w_out(*out, *x, *n);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_special_hermite_polynomial_h(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *x = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *n = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::special_hermite_polynomial_h(*x, *n);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_special_hermite_polynomial_h_x_scalar(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Scalar *x = info__[0].As<Napi::External<torch::Scalar>>().Data();
  torch::Tensor *n = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::special_hermite_polynomial_h(*x, *n);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_special_hermite_polynomial_h_n_scalar(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *x = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *n = info__[1].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::special_hermite_polynomial_h(*x, *n);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_special_hermite_polynomial_h_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *x = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *n = info__[2].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::special_hermite_polynomial_h_out(*out, *x, *n);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_special_hermite_polynomial_h_x_scalar_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *x = info__[1].As<Napi::External<torch::Scalar>>().Data();
  torch::Tensor *n = info__[2].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::special_hermite_polynomial_h_out(*out, *x, *n);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_special_hermite_polynomial_h_n_scalar_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *x = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *n = info__[2].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::special_hermite_polynomial_h_out(*out, *x, *n);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_special_hermite_polynomial_he(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *x = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *n = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::special_hermite_polynomial_he(*x, *n);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_special_hermite_polynomial_he_x_scalar(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Scalar *x = info__[0].As<Napi::External<torch::Scalar>>().Data();
  torch::Tensor *n = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::special_hermite_polynomial_he(*x, *n);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_special_hermite_polynomial_he_n_scalar(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *x = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *n = info__[1].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::special_hermite_polynomial_he(*x, *n);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_special_hermite_polynomial_he_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *x = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *n = info__[2].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::special_hermite_polynomial_he_out(*out, *x, *n);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_special_hermite_polynomial_he_x_scalar_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *x = info__[1].As<Napi::External<torch::Scalar>>().Data();
  torch::Tensor *n = info__[2].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::special_hermite_polynomial_he_out(*out, *x, *n);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_special_hermite_polynomial_he_n_scalar_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *x = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *n = info__[2].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::special_hermite_polynomial_he_out(*out, *x, *n);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_special_laguerre_polynomial_l(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *x = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *n = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::special_laguerre_polynomial_l(*x, *n);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_special_laguerre_polynomial_l_x_scalar(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Scalar *x = info__[0].As<Napi::External<torch::Scalar>>().Data();
  torch::Tensor *n = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::special_laguerre_polynomial_l(*x, *n);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_special_laguerre_polynomial_l_n_scalar(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *x = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *n = info__[1].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::special_laguerre_polynomial_l(*x, *n);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_special_laguerre_polynomial_l_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *x = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *n = info__[2].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::special_laguerre_polynomial_l_out(*out, *x, *n);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_special_laguerre_polynomial_l_x_scalar_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *x = info__[1].As<Napi::External<torch::Scalar>>().Data();
  torch::Tensor *n = info__[2].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::special_laguerre_polynomial_l_out(*out, *x, *n);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_special_laguerre_polynomial_l_n_scalar_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *x = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *n = info__[2].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::special_laguerre_polynomial_l_out(*out, *x, *n);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_special_legendre_polynomial_p(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *x = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *n = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::special_legendre_polynomial_p(*x, *n);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_special_legendre_polynomial_p_x_scalar(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Scalar *x = info__[0].As<Napi::External<torch::Scalar>>().Data();
  torch::Tensor *n = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::special_legendre_polynomial_p(*x, *n);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_special_legendre_polynomial_p_n_scalar(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *x = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *n = info__[1].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::special_legendre_polynomial_p(*x, *n);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_special_legendre_polynomial_p_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *x = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *n = info__[2].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::special_legendre_polynomial_p_out(*out, *x, *n);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_special_legendre_polynomial_p_x_scalar_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *x = info__[1].As<Napi::External<torch::Scalar>>().Data();
  torch::Tensor *n = info__[2].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::special_legendre_polynomial_p_out(*out, *x, *n);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_special_legendre_polynomial_p_n_scalar_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *x = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *n = info__[2].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::special_legendre_polynomial_p_out(*out, *x, *n);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_special_modified_bessel_i0(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::special_modified_bessel_i0(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_special_modified_bessel_i0_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::special_modified_bessel_i0_out(*out, *self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_special_modified_bessel_i1(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::special_modified_bessel_i1(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_special_modified_bessel_i1_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::special_modified_bessel_i1_out(*out, *self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_special_modified_bessel_k0(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::special_modified_bessel_k0(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_special_modified_bessel_k0_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::special_modified_bessel_k0_out(*out, *self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_special_modified_bessel_k1(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::special_modified_bessel_k1(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_special_modified_bessel_k1_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::special_modified_bessel_k1_out(*out, *self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_special_scaled_modified_bessel_k0(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *x = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::special_scaled_modified_bessel_k0(*x);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_special_scaled_modified_bessel_k0_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *x = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::special_scaled_modified_bessel_k0_out(*out, *x);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_special_scaled_modified_bessel_k1(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *x = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::special_scaled_modified_bessel_k1(*x);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_special_scaled_modified_bessel_k1_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *x = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::special_scaled_modified_bessel_k1_out(*out, *x);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_special_shifted_chebyshev_polynomial_t(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *x = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *n = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::special_shifted_chebyshev_polynomial_t(*x, *n);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_special_shifted_chebyshev_polynomial_t_x_scalar(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Scalar *x = info__[0].As<Napi::External<torch::Scalar>>().Data();
  torch::Tensor *n = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::special_shifted_chebyshev_polynomial_t(*x, *n);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_special_shifted_chebyshev_polynomial_t_n_scalar(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *x = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *n = info__[1].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::special_shifted_chebyshev_polynomial_t(*x, *n);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_special_shifted_chebyshev_polynomial_t_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *x = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *n = info__[2].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::special_shifted_chebyshev_polynomial_t_out(*out, *x, *n);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_special_shifted_chebyshev_polynomial_t_x_scalar_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *x = info__[1].As<Napi::External<torch::Scalar>>().Data();
  torch::Tensor *n = info__[2].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::special_shifted_chebyshev_polynomial_t_out(*out, *x, *n);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_special_shifted_chebyshev_polynomial_t_n_scalar_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *x = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *n = info__[2].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::special_shifted_chebyshev_polynomial_t_out(*out, *x, *n);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_special_shifted_chebyshev_polynomial_u(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *x = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *n = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::special_shifted_chebyshev_polynomial_u(*x, *n);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_special_shifted_chebyshev_polynomial_u_x_scalar(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Scalar *x = info__[0].As<Napi::External<torch::Scalar>>().Data();
  torch::Tensor *n = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::special_shifted_chebyshev_polynomial_u(*x, *n);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_special_shifted_chebyshev_polynomial_u_n_scalar(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *x = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *n = info__[1].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::special_shifted_chebyshev_polynomial_u(*x, *n);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_special_shifted_chebyshev_polynomial_u_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *x = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *n = info__[2].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::special_shifted_chebyshev_polynomial_u_out(*out, *x, *n);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_special_shifted_chebyshev_polynomial_u_x_scalar_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *x = info__[1].As<Napi::External<torch::Scalar>>().Data();
  torch::Tensor *n = info__[2].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::special_shifted_chebyshev_polynomial_u_out(*out, *x, *n);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_special_shifted_chebyshev_polynomial_u_n_scalar_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *x = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *n = info__[2].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::special_shifted_chebyshev_polynomial_u_out(*out, *x, *n);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_special_shifted_chebyshev_polynomial_v(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *x = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *n = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::special_shifted_chebyshev_polynomial_v(*x, *n);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_special_shifted_chebyshev_polynomial_v_x_scalar(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Scalar *x = info__[0].As<Napi::External<torch::Scalar>>().Data();
  torch::Tensor *n = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::special_shifted_chebyshev_polynomial_v(*x, *n);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_special_shifted_chebyshev_polynomial_v_n_scalar(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *x = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *n = info__[1].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::special_shifted_chebyshev_polynomial_v(*x, *n);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_special_shifted_chebyshev_polynomial_v_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *x = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *n = info__[2].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::special_shifted_chebyshev_polynomial_v_out(*out, *x, *n);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_special_shifted_chebyshev_polynomial_v_x_scalar_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *x = info__[1].As<Napi::External<torch::Scalar>>().Data();
  torch::Tensor *n = info__[2].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::special_shifted_chebyshev_polynomial_v_out(*out, *x, *n);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_special_shifted_chebyshev_polynomial_v_n_scalar_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *x = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *n = info__[2].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::special_shifted_chebyshev_polynomial_v_out(*out, *x, *n);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_special_shifted_chebyshev_polynomial_w(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *x = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *n = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::special_shifted_chebyshev_polynomial_w(*x, *n);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_special_shifted_chebyshev_polynomial_w_x_scalar(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Scalar *x = info__[0].As<Napi::External<torch::Scalar>>().Data();
  torch::Tensor *n = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::special_shifted_chebyshev_polynomial_w(*x, *n);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_special_shifted_chebyshev_polynomial_w_n_scalar(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *x = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *n = info__[1].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::special_shifted_chebyshev_polynomial_w(*x, *n);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_special_shifted_chebyshev_polynomial_w_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *x = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *n = info__[2].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::special_shifted_chebyshev_polynomial_w_out(*out, *x, *n);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_special_shifted_chebyshev_polynomial_w_x_scalar_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *x = info__[1].As<Napi::External<torch::Scalar>>().Data();
  torch::Tensor *n = info__[2].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::special_shifted_chebyshev_polynomial_w_out(*out, *x, *n);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_special_shifted_chebyshev_polynomial_w_n_scalar_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *x = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Scalar *n = info__[2].As<Napi::External<torch::Scalar>>().Data();
  auto output__ = torch::special_shifted_chebyshev_polynomial_w_out(*out, *x, *n);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_special_spherical_bessel_j0(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *x = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::special_spherical_bessel_j0(*x);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_special_spherical_bessel_j0_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *x = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::special_spherical_bessel_j0_out(*out, *x);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__foobar(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  bool arg1 = info__[1].As<Napi::Boolean>().Value();
  bool arg2 = info__[2].As<Napi::Boolean>().Value();
  bool arg3 = info__[3].As<Napi::Boolean>().Value();
  auto output__ = torch::_foobar(*self, arg1, arg2, arg3);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__foobar_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  bool arg1 = info__[2].As<Napi::Boolean>().Value();
  bool arg2 = info__[3].As<Napi::Boolean>().Value();
  bool arg3 = info__[4].As<Napi::Boolean>().Value();
  auto output__ = torch::_foobar_out(*out, *self, arg1, arg2, arg3);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

void atg__fused_adam_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  Napi::Array self_array__ = info__[0].As<Napi::Array>();
  int self_len = self_array__.Length();
  torch::Tensor **self_data = new torch::Tensor *[self_len];
  for (int i = 0; i < self_len; ++i)
    self_data[i] = self_array__.Get(i).As<Napi::External<torch::Tensor>>().Data();
  Napi::Array grads_array__ = info__[1].As<Napi::Array>();
  int grads_len = grads_array__.Length();
  torch::Tensor **grads_data = new torch::Tensor *[grads_len];
  for (int i = 0; i < grads_len; ++i)
    grads_data[i] = grads_array__.Get(i).As<Napi::External<torch::Tensor>>().Data();
  Napi::Array exp_avgs_array__ = info__[2].As<Napi::Array>();
  int exp_avgs_len = exp_avgs_array__.Length();
  torch::Tensor **exp_avgs_data = new torch::Tensor *[exp_avgs_len];
  for (int i = 0; i < exp_avgs_len; ++i)
    exp_avgs_data[i] = exp_avgs_array__.Get(i).As<Napi::External<torch::Tensor>>().Data();
  Napi::Array exp_avg_sqs_array__ = info__[3].As<Napi::Array>();
  int exp_avg_sqs_len = exp_avg_sqs_array__.Length();
  torch::Tensor **exp_avg_sqs_data = new torch::Tensor *[exp_avg_sqs_len];
  for (int i = 0; i < exp_avg_sqs_len; ++i)
    exp_avg_sqs_data[i] = exp_avg_sqs_array__.Get(i).As<Napi::External<torch::Tensor>>().Data();
  Napi::Array max_exp_avg_sqs_array__ = info__[4].As<Napi::Array>();
  int max_exp_avg_sqs_len = max_exp_avg_sqs_array__.Length();
  torch::Tensor **max_exp_avg_sqs_data = new torch::Tensor *[max_exp_avg_sqs_len];
  for (int i = 0; i < max_exp_avg_sqs_len; ++i)
    max_exp_avg_sqs_data[i] = max_exp_avg_sqs_array__.Get(i).As<Napi::External<torch::Tensor>>().Data();
  Napi::Array state_steps_array__ = info__[5].As<Napi::Array>();
  int state_steps_len = state_steps_array__.Length();
  torch::Tensor **state_steps_data = new torch::Tensor *[state_steps_len];
  for (int i = 0; i < state_steps_len; ++i)
    state_steps_data[i] = state_steps_array__.Get(i).As<Napi::External<torch::Tensor>>().Data();
  double lr = info__[6].As<Napi::Number>().DoubleValue();
  double beta1 = info__[7].As<Napi::Number>().DoubleValue();
  double beta2 = info__[8].As<Napi::Number>().DoubleValue();
  double weight_decay = info__[9].As<Napi::Number>().DoubleValue();
  double eps = info__[10].As<Napi::Number>().DoubleValue();
  bool amsgrad = info__[11].As<Napi::Boolean>().Value();
  bool maximize = info__[12].As<Napi::Boolean>().Value();
  bool grad_scale_null = info__[13].IsUndefined();
  torch::Tensor *grad_scale_v = grad_scale_null ? nullptr : info__[13].As<Napi::External<torch::Tensor>>().Data();
  bool found_inf_null = info__[14].IsUndefined();
  torch::Tensor *found_inf_v = found_inf_null ? nullptr : info__[14].As<Napi::External<torch::Tensor>>().Data();
  torch::_fused_adam_(of_carray_tensor(self_data, self_len), of_carray_tensor(grads_data, grads_len), of_carray_tensor(exp_avgs_data, exp_avgs_len), of_carray_tensor(exp_avg_sqs_data, exp_avg_sqs_len), of_carray_tensor(max_exp_avg_sqs_data, max_exp_avg_sqs_len), of_carray_tensor(state_steps_data, state_steps_len), lr, beta1, beta2, weight_decay, eps, amsgrad, maximize, (grad_scale_null ? *grad_scale_v : torch::Tensor()), (found_inf_null ? *found_inf_v : torch::Tensor()));
}

void atg__fused_adamw_(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  Napi::Array self_array__ = info__[0].As<Napi::Array>();
  int self_len = self_array__.Length();
  torch::Tensor **self_data = new torch::Tensor *[self_len];
  for (int i = 0; i < self_len; ++i)
    self_data[i] = self_array__.Get(i).As<Napi::External<torch::Tensor>>().Data();
  Napi::Array grads_array__ = info__[1].As<Napi::Array>();
  int grads_len = grads_array__.Length();
  torch::Tensor **grads_data = new torch::Tensor *[grads_len];
  for (int i = 0; i < grads_len; ++i)
    grads_data[i] = grads_array__.Get(i).As<Napi::External<torch::Tensor>>().Data();
  Napi::Array exp_avgs_array__ = info__[2].As<Napi::Array>();
  int exp_avgs_len = exp_avgs_array__.Length();
  torch::Tensor **exp_avgs_data = new torch::Tensor *[exp_avgs_len];
  for (int i = 0; i < exp_avgs_len; ++i)
    exp_avgs_data[i] = exp_avgs_array__.Get(i).As<Napi::External<torch::Tensor>>().Data();
  Napi::Array exp_avg_sqs_array__ = info__[3].As<Napi::Array>();
  int exp_avg_sqs_len = exp_avg_sqs_array__.Length();
  torch::Tensor **exp_avg_sqs_data = new torch::Tensor *[exp_avg_sqs_len];
  for (int i = 0; i < exp_avg_sqs_len; ++i)
    exp_avg_sqs_data[i] = exp_avg_sqs_array__.Get(i).As<Napi::External<torch::Tensor>>().Data();
  Napi::Array max_exp_avg_sqs_array__ = info__[4].As<Napi::Array>();
  int max_exp_avg_sqs_len = max_exp_avg_sqs_array__.Length();
  torch::Tensor **max_exp_avg_sqs_data = new torch::Tensor *[max_exp_avg_sqs_len];
  for (int i = 0; i < max_exp_avg_sqs_len; ++i)
    max_exp_avg_sqs_data[i] = max_exp_avg_sqs_array__.Get(i).As<Napi::External<torch::Tensor>>().Data();
  Napi::Array state_steps_array__ = info__[5].As<Napi::Array>();
  int state_steps_len = state_steps_array__.Length();
  torch::Tensor **state_steps_data = new torch::Tensor *[state_steps_len];
  for (int i = 0; i < state_steps_len; ++i)
    state_steps_data[i] = state_steps_array__.Get(i).As<Napi::External<torch::Tensor>>().Data();
  double lr = info__[6].As<Napi::Number>().DoubleValue();
  double beta1 = info__[7].As<Napi::Number>().DoubleValue();
  double beta2 = info__[8].As<Napi::Number>().DoubleValue();
  double weight_decay = info__[9].As<Napi::Number>().DoubleValue();
  double eps = info__[10].As<Napi::Number>().DoubleValue();
  bool amsgrad = info__[11].As<Napi::Boolean>().Value();
  bool maximize = info__[12].As<Napi::Boolean>().Value();
  bool grad_scale_null = info__[13].IsUndefined();
  torch::Tensor *grad_scale_v = grad_scale_null ? nullptr : info__[13].As<Napi::External<torch::Tensor>>().Data();
  bool found_inf_null = info__[14].IsUndefined();
  torch::Tensor *found_inf_v = found_inf_null ? nullptr : info__[14].As<Napi::External<torch::Tensor>>().Data();
  torch::_fused_adamw_(of_carray_tensor(self_data, self_len), of_carray_tensor(grads_data, grads_len), of_carray_tensor(exp_avgs_data, exp_avgs_len), of_carray_tensor(exp_avg_sqs_data, exp_avg_sqs_len), of_carray_tensor(max_exp_avg_sqs_data, max_exp_avg_sqs_len), of_carray_tensor(state_steps_data, state_steps_len), lr, beta1, beta2, weight_decay, eps, amsgrad, maximize, (grad_scale_null ? *grad_scale_v : torch::Tensor()), (found_inf_null ? *found_inf_v : torch::Tensor()));
}

Napi::External<torch::Tensor> atg_embedding_renorm(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *indices = info__[1].As<Napi::External<torch::Tensor>>().Data();
  double max_norm = info__[2].As<Napi::Number>().DoubleValue();
  double norm_type = info__[3].As<Napi::Number>().DoubleValue();
  auto output__ = torch::embedding_renorm(*self, *indices, max_norm, norm_type);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_embedding_renorm_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *indices = info__[2].As<Napi::External<torch::Tensor>>().Data();
  double max_norm = info__[3].As<Napi::Number>().DoubleValue();
  double norm_type = info__[4].As<Napi::Number>().DoubleValue();
  auto output__ = torch::embedding_renorm_out(*out, *self, *indices, max_norm, norm_type);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_resize(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array size_array__ = info__[1].As<Napi::Array>();
  int size_len = size_array__.Length();
  int64_t *size_data = new int64_t[size_len];
  for (int i = 0; i < size_len; ++i)
    size_data[i] = size_array__.Get(i).ToNumber().Int64Value();
  int memory_format = info__[2].As<Napi::Number>().Int32Value();
  auto output__ = torch::resize(*self, torch::IntArrayRef(size_data, size_len), (at::MemoryFormat)memory_format);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_resize_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array size_array__ = info__[2].As<Napi::Array>();
  int size_len = size_array__.Length();
  int64_t *size_data = new int64_t[size_len];
  for (int i = 0; i < size_len; ++i)
    size_data[i] = size_array__.Get(i).ToNumber().Int64Value();
  int memory_format = info__[3].As<Napi::Number>().Int32Value();
  auto output__ = torch::resize_out(*out, *self, torch::IntArrayRef(size_data, size_len), (at::MemoryFormat)memory_format);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__resize_output(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array size_array__ = info__[1].As<Napi::Array>();
  int size_len = size_array__.Length();
  int64_t *size_data = new int64_t[size_len];
  for (int i = 0; i < size_len; ++i)
    size_data[i] = size_array__.Get(i).ToNumber().Int64Value();
  int device = info__[2].As<Napi::Number>().Int32Value();
  auto output__ = torch::_resize_output(*self, torch::IntArrayRef(size_data, size_len), device_of_int(device));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__resize_output_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array size_array__ = info__[2].As<Napi::Array>();
  int size_len = size_array__.Length();
  int64_t *size_data = new int64_t[size_len];
  for (int i = 0; i < size_len; ++i)
    size_data[i] = size_array__.Get(i).ToNumber().Int64Value();
  int device = info__[3].As<Napi::Number>().Int32Value();
  auto output__ = torch::_resize_output_out(*out, *self, torch::IntArrayRef(size_data, size_len), device_of_int(device));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__index_put_impl(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array indices_array__ = info__[1].As<Napi::Array>();
  int indices_len = indices_array__.Length();
  torch::Tensor **indices_data = new torch::Tensor *[indices_len];
  for (int i = 0; i < indices_len; ++i)
    indices_data[i] = indices_array__.Get(i).As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *values = info__[2].As<Napi::External<torch::Tensor>>().Data();
  bool accumulate = info__[3].As<Napi::Boolean>().Value();
  bool unsafe = info__[4].As<Napi::Boolean>().Value();
  auto output__ = torch::_index_put_impl(*self, of_carray_tensor_opt(indices_data, indices_len), *values, accumulate, unsafe);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__index_put_impl_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array indices_array__ = info__[2].As<Napi::Array>();
  int indices_len = indices_array__.Length();
  torch::Tensor **indices_data = new torch::Tensor *[indices_len];
  for (int i = 0; i < indices_len; ++i)
    indices_data[i] = indices_array__.Get(i).As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *values = info__[3].As<Napi::External<torch::Tensor>>().Data();
  bool accumulate = info__[4].As<Napi::Boolean>().Value();
  bool unsafe = info__[5].As<Napi::Boolean>().Value();
  auto output__ = torch::_index_put_impl_out(*out, *self, of_carray_tensor_opt(indices_data, indices_len), *values, accumulate, unsafe);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::Array atg__native_batch_norm_legit_functional(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *input = info__[0].As<Napi::External<torch::Tensor>>().Data();
  bool weight_null = info__[1].IsUndefined();
  torch::Tensor *weight_v = weight_null ? nullptr : info__[1].As<Napi::External<torch::Tensor>>().Data();
  bool bias_null = info__[2].IsUndefined();
  torch::Tensor *bias_v = bias_null ? nullptr : info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *running_mean = info__[3].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *running_var = info__[4].As<Napi::External<torch::Tensor>>().Data();
  bool training = info__[5].As<Napi::Boolean>().Value();
  double momentum = info__[6].As<Napi::Number>().DoubleValue();
  double eps = info__[7].As<Napi::Number>().DoubleValue();
  auto output__ = torch::_native_batch_norm_legit_functional(*input, (weight_null ? *weight_v : torch::Tensor()), (bias_null ? *bias_v : torch::Tensor()), *running_mean, *running_var, training, momentum, eps);
  Napi::Array output__array__ = Napi::Array::New(env__, 5);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  output__array__[2u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<2>(output__)));
  output__array__[3u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<3>(output__)));
  output__array__[4u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<4>(output__)));
  return output__array__;
}

void atg_unsafe_split(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  Napi::Array out_array__ = info__[0].As<Napi::Array>();
  int out_len = out_array__.Length();
  torch::Tensor **out_data = new torch::Tensor *[out_len];
  for (int i = 0; i < out_len; ++i)
    out_data[i] = out_array__.Get(i).As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  int64_t split_size = info__[2].As<Napi::Number>().Int64Value();
  int64_t dim = info__[3].As<Napi::Number>().Int64Value();
  torch::unsafe_split_out(of_carray_tensor(out_data, out_len), *self, split_size, dim);
}

void atg_unsafe_split_with_sizes(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  Napi::Array out_array__ = info__[0].As<Napi::Array>();
  int out_len = out_array__.Length();
  torch::Tensor **out_data = new torch::Tensor *[out_len];
  for (int i = 0; i < out_len; ++i)
    out_data[i] = out_array__.Get(i).As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array split_sizes_array__ = info__[2].As<Napi::Array>();
  int split_sizes_len = split_sizes_array__.Length();
  int64_t *split_sizes_data = new int64_t[split_sizes_len];
  for (int i = 0; i < split_sizes_len; ++i)
    split_sizes_data[i] = split_sizes_array__.Get(i).ToNumber().Int64Value();
  int64_t dim = info__[3].As<Napi::Number>().Int64Value();
  torch::unsafe_split_with_sizes_out(of_carray_tensor(out_data, out_len), *self, torch::IntArrayRef(split_sizes_data, split_sizes_len), dim);
}

Napi::External<torch::Tensor> atg_clone(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  int memory_format = info__[2].As<Napi::Number>().Int32Value();
  auto output__ = torch::clone_out(*out, *self, (at::MemoryFormat)memory_format);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_resize_as(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *the_template = info__[1].As<Napi::External<torch::Tensor>>().Data();
  int memory_format = info__[2].As<Napi::Number>().Int32Value();
  auto output__ = torch::resize_as(*self, *the_template, (at::MemoryFormat)memory_format);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_resize_as_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *the_template = info__[2].As<Napi::External<torch::Tensor>>().Data();
  int memory_format = info__[3].As<Napi::Number>().Int32Value();
  auto output__ = torch::resize_as_out(*out, *self, *the_template, (at::MemoryFormat)memory_format);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_resize_as_sparse(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *the_template = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::resize_as_sparse(*self, *the_template);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_resize_as_sparse_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *the_template = info__[2].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::resize_as_sparse_out(*out, *self, *the_template);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_zero(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::zero(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_zero_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::zero_out(*out, *self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_sparse_resize(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array size_array__ = info__[1].As<Napi::Array>();
  int size_len = size_array__.Length();
  int64_t *size_data = new int64_t[size_len];
  for (int i = 0; i < size_len; ++i)
    size_data[i] = size_array__.Get(i).ToNumber().Int64Value();
  int64_t sparse_dim = info__[2].As<Napi::Number>().Int64Value();
  int64_t dense_dim = info__[3].As<Napi::Number>().Int64Value();
  auto output__ = torch::sparse_resize(*self, torch::IntArrayRef(size_data, size_len), sparse_dim, dense_dim);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_sparse_resize_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array size_array__ = info__[2].As<Napi::Array>();
  int size_len = size_array__.Length();
  int64_t *size_data = new int64_t[size_len];
  for (int i = 0; i < size_len; ++i)
    size_data[i] = size_array__.Get(i).ToNumber().Int64Value();
  int64_t sparse_dim = info__[3].As<Napi::Number>().Int64Value();
  int64_t dense_dim = info__[4].As<Napi::Number>().Int64Value();
  auto output__ = torch::sparse_resize_out(*out, *self, torch::IntArrayRef(size_data, size_len), sparse_dim, dense_dim);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_sparse_resize_and_clear(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array size_array__ = info__[1].As<Napi::Array>();
  int size_len = size_array__.Length();
  int64_t *size_data = new int64_t[size_len];
  for (int i = 0; i < size_len; ++i)
    size_data[i] = size_array__.Get(i).ToNumber().Int64Value();
  int64_t sparse_dim = info__[2].As<Napi::Number>().Int64Value();
  int64_t dense_dim = info__[3].As<Napi::Number>().Int64Value();
  auto output__ = torch::sparse_resize_and_clear(*self, torch::IntArrayRef(size_data, size_len), sparse_dim, dense_dim);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_sparse_resize_and_clear_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array size_array__ = info__[2].As<Napi::Array>();
  int size_len = size_array__.Length();
  int64_t *size_data = new int64_t[size_len];
  for (int i = 0; i < size_len; ++i)
    size_data[i] = size_array__.Get(i).ToNumber().Int64Value();
  int64_t sparse_dim = info__[3].As<Napi::Number>().Int64Value();
  int64_t dense_dim = info__[4].As<Napi::Number>().Int64Value();
  auto output__ = torch::sparse_resize_and_clear_out(*out, *self, torch::IntArrayRef(size_data, size_len), sparse_dim, dense_dim);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__coalesced(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  bool coalesced = info__[1].As<Napi::Boolean>().Value();
  auto output__ = torch::_coalesced(*self, coalesced);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg__coalesced_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  bool coalesced = info__[2].As<Napi::Boolean>().Value();
  auto output__ = torch::_coalesced_out(*out, *self, coalesced);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_copy_sparse_to_sparse(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *src = info__[1].As<Napi::External<torch::Tensor>>().Data();
  bool non_blocking = info__[2].As<Napi::Boolean>().Value();
  auto output__ = torch::copy_sparse_to_sparse(*self, *src, non_blocking);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_copy_sparse_to_sparse_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *src = info__[2].As<Napi::External<torch::Tensor>>().Data();
  bool non_blocking = info__[3].As<Napi::Boolean>().Value();
  auto output__ = torch::copy_sparse_to_sparse_out(*out, *self, *src, non_blocking);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::Array atg__fused_moving_avg_obs_fq_helper_functional(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *observer_on = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *fake_quant_on = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *running_min = info__[3].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *running_max = info__[4].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *scale = info__[5].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *zero_point = info__[6].As<Napi::External<torch::Tensor>>().Data();
  double averaging_const = info__[7].As<Napi::Number>().DoubleValue();
  int64_t quant_min = info__[8].As<Napi::Number>().Int64Value();
  int64_t quant_max = info__[9].As<Napi::Number>().Int64Value();
  int64_t ch_axis = info__[10].As<Napi::Number>().Int64Value();
  bool per_row_fake_quant = info__[11].As<Napi::Boolean>().Value();
  bool symmetric_quant = info__[12].As<Napi::Boolean>().Value();
  auto output__ = torch::_fused_moving_avg_obs_fq_helper_functional(*self, *observer_on, *fake_quant_on, *running_min, *running_max, *scale, *zero_point, averaging_const, quant_min, quant_max, ch_axis, per_row_fake_quant, symmetric_quant);
  Napi::Array output__array__ = Napi::Array::New(env__, 6);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  output__array__[2u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<2>(output__)));
  output__array__[3u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<3>(output__)));
  output__array__[4u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<4>(output__)));
  output__array__[5u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<5>(output__)));
  return output__array__;
}

void atg_lstm_mps_backward(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out0 = info__[0].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array out1_array__ = info__[1].As<Napi::Array>();
  int out1_len = out1_array__.Length();
  torch::Tensor **out1_data = new torch::Tensor *[out1_len];
  for (int i = 0; i < out1_len; ++i)
    out1_data[i] = out1_array__.Get(i).As<Napi::External<torch::Tensor>>().Data();
  Napi::Array out2_array__ = info__[2].As<Napi::Array>();
  int out2_len = out2_array__.Length();
  torch::Tensor **out2_data = new torch::Tensor *[out2_len];
  for (int i = 0; i < out2_len; ++i)
    out2_data[i] = out2_array__.Get(i).As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *grad_y = info__[3].As<Napi::External<torch::Tensor>>().Data();
  bool grad_hy_null = info__[4].IsUndefined();
  torch::Tensor *grad_hy_v = grad_hy_null ? nullptr : info__[4].As<Napi::External<torch::Tensor>>().Data();
  bool grad_cy_null = info__[5].IsUndefined();
  torch::Tensor *grad_cy_v = grad_cy_null ? nullptr : info__[5].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *z_state = info__[6].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *cell_state_fwd = info__[7].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *input = info__[8].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *layersOutputs = info__[9].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array hx_array__ = info__[10].As<Napi::Array>();
  int hx_len = hx_array__.Length();
  torch::Tensor **hx_data = new torch::Tensor *[hx_len];
  for (int i = 0; i < hx_len; ++i)
    hx_data[i] = hx_array__.Get(i).As<Napi::External<torch::Tensor>>().Data();
  Napi::Array params_array__ = info__[11].As<Napi::Array>();
  int params_len = params_array__.Length();
  torch::Tensor **params_data = new torch::Tensor *[params_len];
  for (int i = 0; i < params_len; ++i)
    params_data[i] = params_array__.Get(i).As<Napi::External<torch::Tensor>>().Data();
  bool has_biases = info__[12].As<Napi::Boolean>().Value();
  int64_t num_layers = info__[13].As<Napi::Number>().Int64Value();
  double dropout = info__[14].As<Napi::Number>().DoubleValue();
  bool train = info__[15].As<Napi::Boolean>().Value();
  bool bidirectional = info__[16].As<Napi::Boolean>().Value();
  bool batch_first = info__[17].As<Napi::Boolean>().Value();
  torch::lstm_mps_backward_out(*out0, of_carray_tensor(out1_data, out1_len), of_carray_tensor(out2_data, out2_len), *grad_y, (grad_hy_null ? *grad_hy_v : torch::Tensor()), (grad_cy_null ? *grad_cy_v : torch::Tensor()), *z_state, *cell_state_fwd, *input, *layersOutputs, of_carray_tensor(hx_data, hx_len), of_carray_tensor(params_data, params_len), has_biases, num_layers, dropout, train, bidirectional, batch_first);
}

Napi::External<torch::Tensor> atg_set(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::set(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_set_source_tensor(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *source = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::set(*self, *source);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_set_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::set_out(*out, *self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_set_source_tensor_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *source = info__[2].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::set_out(*out, *self, *source);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_random(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::random(*self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_random_to(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t to = info__[1].As<Napi::Number>().Int64Value();
  auto output__ = torch::random(*self, to);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_random_from(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  int64_t from = info__[1].As<Napi::Number>().Int64Value();
  bool to_null = info__[2].IsUndefined();
  int64_t to_v = to_null ? 0 : info__[2].As<Napi::Number>().Int64Value();
  auto output__ = torch::random(*self, from, to_null ? c10::nullopt : c10::optional<int64_t>(to_v));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_random_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  auto output__ = torch::random_out(*out, *self);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_random_to_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  int64_t to = info__[2].As<Napi::Number>().Int64Value();
  auto output__ = torch::random_out(*out, *self, to);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_random_from_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  int64_t from = info__[2].As<Napi::Number>().Int64Value();
  bool to_null = info__[3].IsUndefined();
  int64_t to_v = to_null ? 0 : info__[3].As<Napi::Number>().Int64Value();
  auto output__ = torch::random_out(*out, *self, from, to_null ? c10::nullopt : c10::optional<int64_t>(to_v));
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_uniform(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  double from = info__[1].As<Napi::Number>().DoubleValue();
  double to = info__[2].As<Napi::Number>().DoubleValue();
  auto output__ = torch::uniform(*self, from, to);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_uniform_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  double from = info__[2].As<Napi::Number>().DoubleValue();
  double to = info__[3].As<Napi::Number>().DoubleValue();
  auto output__ = torch::uniform_out(*out, *self, from, to);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_cauchy(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  double median = info__[1].As<Napi::Number>().DoubleValue();
  double sigma = info__[2].As<Napi::Number>().DoubleValue();
  auto output__ = torch::cauchy(*self, median, sigma);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_cauchy_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  double median = info__[2].As<Napi::Number>().DoubleValue();
  double sigma = info__[3].As<Napi::Number>().DoubleValue();
  auto output__ = torch::cauchy_out(*out, *self, median, sigma);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_log_normal(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  double mean = info__[1].As<Napi::Number>().DoubleValue();
  double std = info__[2].As<Napi::Number>().DoubleValue();
  auto output__ = torch::log_normal(*self, mean, std);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_log_normal_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  double mean = info__[2].As<Napi::Number>().DoubleValue();
  double std = info__[3].As<Napi::Number>().DoubleValue();
  auto output__ = torch::log_normal_out(*out, *self, mean, std);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_exponential(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  double lambd = info__[1].As<Napi::Number>().DoubleValue();
  auto output__ = torch::exponential(*self, lambd);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_exponential_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  double lambd = info__[2].As<Napi::Number>().DoubleValue();
  auto output__ = torch::exponential_out(*out, *self, lambd);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_geometric(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  double p = info__[1].As<Napi::Number>().DoubleValue();
  auto output__ = torch::geometric(*self, p);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

Napi::External<torch::Tensor> atg_geometric_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  double p = info__[2].As<Napi::Number>().DoubleValue();
  auto output__ = torch::geometric_out(*out, *self, p);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

void atg__histogramdd_bin_edges(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  Napi::Array out_array__ = info__[0].As<Napi::Array>();
  int out_len = out_array__.Length();
  torch::Tensor **out_data = new torch::Tensor *[out_len];
  for (int i = 0; i < out_len; ++i)
    out_data[i] = out_array__.Get(i).As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  Napi::Array bins_array__ = info__[2].As<Napi::Array>();
  int bins_len = bins_array__.Length();
  int64_t *bins_data = new int64_t[bins_len];
  for (int i = 0; i < bins_len; ++i)
    bins_data[i] = bins_array__.Get(i).ToNumber().Int64Value();
  Napi::Array range_array__ = info__[3].As<Napi::Array>();
  int range_len = range_array__.Length();
  double *range_data = new double[range_len];
  for (int i = 0; i < range_len; ++i)
    range_data[i] = range_array__.Get(i).ToNumber().DoubleValue();
  bool weight_null = info__[4].IsUndefined();
  torch::Tensor *weight_v = weight_null ? nullptr : info__[4].As<Napi::External<torch::Tensor>>().Data();
  bool density = info__[5].As<Napi::Boolean>().Value();
  torch::_histogramdd_bin_edges_out(of_carray_tensor(out_data, out_len), *self, torch::IntArrayRef(bins_data, bins_len), at::ArrayRef<double>(range_data, range_len), (weight_null ? *weight_v : torch::Tensor()), density);
}

Napi::Array atg__amp_update_scale(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *self = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *growth_tracker = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *found_inf = info__[2].As<Napi::External<torch::Tensor>>().Data();
  double scale_growth_factor = info__[3].As<Napi::Number>().DoubleValue();
  double scale_backoff_factor = info__[4].As<Napi::Number>().DoubleValue();
  int64_t growth_interval = info__[5].As<Napi::Number>().Int64Value();
  auto output__ = torch::_amp_update_scale(*self, *growth_tracker, *found_inf, scale_growth_factor, scale_backoff_factor, growth_interval);
  Napi::Array output__array__ = Napi::Array::New(env__, 2);
  output__array__[0u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<0>(output__)));
  output__array__[1u] = Napi::External<torch::Tensor>::New(env__, new torch::Tensor(std::get<1>(output__)));
  return output__array__;
}

Napi::External<torch::Tensor> atg__amp_update_scale_out(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  torch::Tensor *out = info__[0].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *self = info__[1].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *growth_tracker = info__[2].As<Napi::External<torch::Tensor>>().Data();
  torch::Tensor *found_inf = info__[3].As<Napi::External<torch::Tensor>>().Data();
  double scale_growth_factor = info__[4].As<Napi::Number>().DoubleValue();
  double scale_backoff_factor = info__[5].As<Napi::Number>().DoubleValue();
  int64_t growth_interval = info__[6].As<Napi::Number>().Int64Value();
  auto output__ = torch::_amp_update_scale_out(*out, *self, *growth_tracker, *found_inf, scale_growth_factor, scale_backoff_factor, growth_interval);
  return Napi::External<torch::Tensor>::New(env__, new torch::Tensor(output__));
}

void atg__fused_adam(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  Napi::Array out_array__ = info__[0].As<Napi::Array>();
  int out_len = out_array__.Length();
  torch::Tensor **out_data = new torch::Tensor *[out_len];
  for (int i = 0; i < out_len; ++i)
    out_data[i] = out_array__.Get(i).As<Napi::External<torch::Tensor>>().Data();
  Napi::Array self_array__ = info__[1].As<Napi::Array>();
  int self_len = self_array__.Length();
  torch::Tensor **self_data = new torch::Tensor *[self_len];
  for (int i = 0; i < self_len; ++i)
    self_data[i] = self_array__.Get(i).As<Napi::External<torch::Tensor>>().Data();
  Napi::Array grads_array__ = info__[2].As<Napi::Array>();
  int grads_len = grads_array__.Length();
  torch::Tensor **grads_data = new torch::Tensor *[grads_len];
  for (int i = 0; i < grads_len; ++i)
    grads_data[i] = grads_array__.Get(i).As<Napi::External<torch::Tensor>>().Data();
  Napi::Array exp_avgs_array__ = info__[3].As<Napi::Array>();
  int exp_avgs_len = exp_avgs_array__.Length();
  torch::Tensor **exp_avgs_data = new torch::Tensor *[exp_avgs_len];
  for (int i = 0; i < exp_avgs_len; ++i)
    exp_avgs_data[i] = exp_avgs_array__.Get(i).As<Napi::External<torch::Tensor>>().Data();
  Napi::Array exp_avg_sqs_array__ = info__[4].As<Napi::Array>();
  int exp_avg_sqs_len = exp_avg_sqs_array__.Length();
  torch::Tensor **exp_avg_sqs_data = new torch::Tensor *[exp_avg_sqs_len];
  for (int i = 0; i < exp_avg_sqs_len; ++i)
    exp_avg_sqs_data[i] = exp_avg_sqs_array__.Get(i).As<Napi::External<torch::Tensor>>().Data();
  Napi::Array max_exp_avg_sqs_array__ = info__[5].As<Napi::Array>();
  int max_exp_avg_sqs_len = max_exp_avg_sqs_array__.Length();
  torch::Tensor **max_exp_avg_sqs_data = new torch::Tensor *[max_exp_avg_sqs_len];
  for (int i = 0; i < max_exp_avg_sqs_len; ++i)
    max_exp_avg_sqs_data[i] = max_exp_avg_sqs_array__.Get(i).As<Napi::External<torch::Tensor>>().Data();
  Napi::Array state_steps_array__ = info__[6].As<Napi::Array>();
  int state_steps_len = state_steps_array__.Length();
  torch::Tensor **state_steps_data = new torch::Tensor *[state_steps_len];
  for (int i = 0; i < state_steps_len; ++i)
    state_steps_data[i] = state_steps_array__.Get(i).As<Napi::External<torch::Tensor>>().Data();
  double lr = info__[7].As<Napi::Number>().DoubleValue();
  double beta1 = info__[8].As<Napi::Number>().DoubleValue();
  double beta2 = info__[9].As<Napi::Number>().DoubleValue();
  double weight_decay = info__[10].As<Napi::Number>().DoubleValue();
  double eps = info__[11].As<Napi::Number>().DoubleValue();
  bool amsgrad = info__[12].As<Napi::Boolean>().Value();
  bool maximize = info__[13].As<Napi::Boolean>().Value();
  bool grad_scale_null = info__[14].IsUndefined();
  torch::Tensor *grad_scale_v = grad_scale_null ? nullptr : info__[14].As<Napi::External<torch::Tensor>>().Data();
  bool found_inf_null = info__[15].IsUndefined();
  torch::Tensor *found_inf_v = found_inf_null ? nullptr : info__[15].As<Napi::External<torch::Tensor>>().Data();
  torch::_fused_adam_out(of_carray_tensor(out_data, out_len), of_carray_tensor(self_data, self_len), of_carray_tensor(grads_data, grads_len), of_carray_tensor(exp_avgs_data, exp_avgs_len), of_carray_tensor(exp_avg_sqs_data, exp_avg_sqs_len), of_carray_tensor(max_exp_avg_sqs_data, max_exp_avg_sqs_len), of_carray_tensor(state_steps_data, state_steps_len), lr, beta1, beta2, weight_decay, eps, amsgrad, maximize, (grad_scale_null ? *grad_scale_v : torch::Tensor()), (found_inf_null ? *found_inf_v : torch::Tensor()));
}

void atg__fused_adamw(const Napi::CallbackInfo &info__) {
  Napi::Env env__ = info__.Env();
  Napi::Array out_array__ = info__[0].As<Napi::Array>();
  int out_len = out_array__.Length();
  torch::Tensor **out_data = new torch::Tensor *[out_len];
  for (int i = 0; i < out_len; ++i)
    out_data[i] = out_array__.Get(i).As<Napi::External<torch::Tensor>>().Data();
  Napi::Array self_array__ = info__[1].As<Napi::Array>();
  int self_len = self_array__.Length();
  torch::Tensor **self_data = new torch::Tensor *[self_len];
  for (int i = 0; i < self_len; ++i)
    self_data[i] = self_array__.Get(i).As<Napi::External<torch::Tensor>>().Data();
  Napi::Array grads_array__ = info__[2].As<Napi::Array>();
  int grads_len = grads_array__.Length();
  torch::Tensor **grads_data = new torch::Tensor *[grads_len];
  for (int i = 0; i < grads_len; ++i)
    grads_data[i] = grads_array__.Get(i).As<Napi::External<torch::Tensor>>().Data();
  Napi::Array exp_avgs_array__ = info__[3].As<Napi::Array>();
  int exp_avgs_len = exp_avgs_array__.Length();
  torch::Tensor **exp_avgs_data = new torch::Tensor *[exp_avgs_len];
  for (int i = 0; i < exp_avgs_len; ++i)
    exp_avgs_data[i] = exp_avgs_array__.Get(i).As<Napi::External<torch::Tensor>>().Data();
  Napi::Array exp_avg_sqs_array__ = info__[4].As<Napi::Array>();
  int exp_avg_sqs_len = exp_avg_sqs_array__.Length();
  torch::Tensor **exp_avg_sqs_data = new torch::Tensor *[exp_avg_sqs_len];
  for (int i = 0; i < exp_avg_sqs_len; ++i)
    exp_avg_sqs_data[i] = exp_avg_sqs_array__.Get(i).As<Napi::External<torch::Tensor>>().Data();
  Napi::Array max_exp_avg_sqs_array__ = info__[5].As<Napi::Array>();
  int max_exp_avg_sqs_len = max_exp_avg_sqs_array__.Length();
  torch::Tensor **max_exp_avg_sqs_data = new torch::Tensor *[max_exp_avg_sqs_len];
  for (int i = 0; i < max_exp_avg_sqs_len; ++i)
    max_exp_avg_sqs_data[i] = max_exp_avg_sqs_array__.Get(i).As<Napi::External<torch::Tensor>>().Data();
  Napi::Array state_steps_array__ = info__[6].As<Napi::Array>();
  int state_steps_len = state_steps_array__.Length();
  torch::Tensor **state_steps_data = new torch::Tensor *[state_steps_len];
  for (int i = 0; i < state_steps_len; ++i)
    state_steps_data[i] = state_steps_array__.Get(i).As<Napi::External<torch::Tensor>>().Data();
  double lr = info__[7].As<Napi::Number>().DoubleValue();
  double beta1 = info__[8].As<Napi::Number>().DoubleValue();
  double beta2 = info__[9].As<Napi::Number>().DoubleValue();
  double weight_decay = info__[10].As<Napi::Number>().DoubleValue();
  double eps = info__[11].As<Napi::Number>().DoubleValue();
  bool amsgrad = info__[12].As<Napi::Boolean>().Value();
  bool maximize = info__[13].As<Napi::Boolean>().Value();
  bool grad_scale_null = info__[14].IsUndefined();
  torch::Tensor *grad_scale_v = grad_scale_null ? nullptr : info__[14].As<Napi::External<torch::Tensor>>().Data();
  bool found_inf_null = info__[15].IsUndefined();
  torch::Tensor *found_inf_v = found_inf_null ? nullptr : info__[15].As<Napi::External<torch::Tensor>>().Data();
  torch::_fused_adamw_out(of_carray_tensor(out_data, out_len), of_carray_tensor(self_data, self_len), of_carray_tensor(grads_data, grads_len), of_carray_tensor(exp_avgs_data, exp_avgs_len), of_carray_tensor(exp_avg_sqs_data, exp_avg_sqs_len), of_carray_tensor(max_exp_avg_sqs_data, max_exp_avg_sqs_len), of_carray_tensor(state_steps_data, state_steps_len), lr, beta1, beta2, weight_decay, eps, amsgrad, maximize, (grad_scale_null ? *grad_scale_v : torch::Tensor()), (found_inf_null ? *found_inf_v : torch::Tensor()));
}

Napi::Object InitTypeTorchGenerated(Napi::Env env__, Napi::Object exports) {
  exports.Set("atg__cast_Byte", Napi::Function::New(env__, atg__cast_Byte));
  exports.Set("atg__cast_Char", Napi::Function::New(env__, atg__cast_Char));
  exports.Set("atg__cast_Double", Napi::Function::New(env__, atg__cast_Double));
  exports.Set("atg__cast_Float", Napi::Function::New(env__, atg__cast_Float));
  exports.Set("atg__cast_Int", Napi::Function::New(env__, atg__cast_Int));
  exports.Set("atg__cast_Long", Napi::Function::New(env__, atg__cast_Long));
  exports.Set("atg__cast_Short", Napi::Function::New(env__, atg__cast_Short));
  exports.Set("atg__cast_Half", Napi::Function::New(env__, atg__cast_Half));
  exports.Set("atg_set_data", Napi::Function::New(env__, atg_set_data));
  exports.Set("atg_data", Napi::Function::New(env__, atg_data));
  exports.Set("atg_is_leaf", Napi::Function::New(env__, atg_is_leaf));
  exports.Set("atg_output_nr", Napi::Function::New(env__, atg_output_nr));
  exports.Set("atg__version", Napi::Function::New(env__, atg__version));
  exports.Set("atg_requires_grad_", Napi::Function::New(env__, atg_requires_grad_));
  exports.Set("atg_retains_grad", Napi::Function::New(env__, atg_retains_grad));
  exports.Set("atg__fw_primal", Napi::Function::New(env__, atg__fw_primal));
  exports.Set("atg__make_dual", Napi::Function::New(env__, atg__make_dual));
  exports.Set("atg__unpack_dual", Napi::Function::New(env__, atg__unpack_dual));
  exports.Set("atg__new_zeros_with_same_feature_meta", Napi::Function::New(env__, atg__new_zeros_with_same_feature_meta));
  exports.Set("atg__new_zeros_with_same_feature_meta_out", Napi::Function::New(env__, atg__new_zeros_with_same_feature_meta_out));
  exports.Set("atg__has_same_storage_numel", Napi::Function::New(env__, atg__has_same_storage_numel));
  exports.Set("atg_align_as", Napi::Function::New(env__, atg_align_as));
  exports.Set("atg__assert_tensor_metadata", Napi::Function::New(env__, atg__assert_tensor_metadata));
  exports.Set("atg__use_cudnn_ctc_loss", Napi::Function::New(env__, atg__use_cudnn_ctc_loss));
  exports.Set("atg__use_cudnn_ctc_loss_tensor", Napi::Function::New(env__, atg__use_cudnn_ctc_loss_tensor));
  exports.Set("atg__cudnn_ctc_loss", Napi::Function::New(env__, atg__cudnn_ctc_loss));
  exports.Set("atg__cudnn_ctc_loss_tensor", Napi::Function::New(env__, atg__cudnn_ctc_loss_tensor));
  exports.Set("atg__cudnn_ctc_loss_out", Napi::Function::New(env__, atg__cudnn_ctc_loss_out));
  exports.Set("atg__use_cudnn_rnn_flatten_weight", Napi::Function::New(env__, atg__use_cudnn_rnn_flatten_weight));
  exports.Set("atg__cudnn_rnn_flatten_weight", Napi::Function::New(env__, atg__cudnn_rnn_flatten_weight));
  exports.Set("atg__cudnn_rnn_flatten_weight_out", Napi::Function::New(env__, atg__cudnn_rnn_flatten_weight_out));
  exports.Set("atg__cudnn_rnn", Napi::Function::New(env__, atg__cudnn_rnn));
  exports.Set("atg__cudnn_rnn_out", Napi::Function::New(env__, atg__cudnn_rnn_out));
  exports.Set("atg__cudnn_init_dropout_state", Napi::Function::New(env__, atg__cudnn_init_dropout_state));
  exports.Set("atg__cudnn_init_dropout_state_out", Napi::Function::New(env__, atg__cudnn_init_dropout_state_out));
  exports.Set("atg__debug_has_internal_overlap", Napi::Function::New(env__, atg__debug_has_internal_overlap));
  exports.Set("atg__fused_dropout", Napi::Function::New(env__, atg__fused_dropout));
  exports.Set("atg__fused_dropout_out", Napi::Function::New(env__, atg__fused_dropout_out));
  exports.Set("atg__masked_scale", Napi::Function::New(env__, atg__masked_scale));
  exports.Set("atg__masked_scale_out", Napi::Function::New(env__, atg__masked_scale_out));
  exports.Set("atg_native_dropout", Napi::Function::New(env__, atg_native_dropout));
  exports.Set("atg_native_dropout_out", Napi::Function::New(env__, atg_native_dropout_out));
  exports.Set("atg_native_dropout_backward", Napi::Function::New(env__, atg_native_dropout_backward));
  exports.Set("atg_native_dropout_backward_out", Napi::Function::New(env__, atg_native_dropout_backward_out));
  exports.Set("atg__sobol_engine_draw", Napi::Function::New(env__, atg__sobol_engine_draw));
  exports.Set("atg__sobol_engine_ff_", Napi::Function::New(env__, atg__sobol_engine_ff_));
  exports.Set("atg__sobol_engine_scramble_", Napi::Function::New(env__, atg__sobol_engine_scramble_));
  exports.Set("atg__sobol_engine_initialize_state_", Napi::Function::New(env__, atg__sobol_engine_initialize_state_));
  exports.Set("atg__reshape_from_tensor", Napi::Function::New(env__, atg__reshape_from_tensor));
  exports.Set("atg__shape_as_tensor", Napi::Function::New(env__, atg__shape_as_tensor));
  exports.Set("atg_dropout", Napi::Function::New(env__, atg_dropout));
  exports.Set("atg_dropout_", Napi::Function::New(env__, atg_dropout_));
  exports.Set("atg_feature_dropout", Napi::Function::New(env__, atg_feature_dropout));
  exports.Set("atg_feature_dropout_", Napi::Function::New(env__, atg_feature_dropout_));
  exports.Set("atg_alpha_dropout", Napi::Function::New(env__, atg_alpha_dropout));
  exports.Set("atg_alpha_dropout_", Napi::Function::New(env__, atg_alpha_dropout_));
  exports.Set("atg_feature_alpha_dropout", Napi::Function::New(env__, atg_feature_alpha_dropout));
  exports.Set("atg_feature_alpha_dropout_", Napi::Function::New(env__, atg_feature_alpha_dropout_));
  exports.Set("atg_abs", Napi::Function::New(env__, atg_abs));
  exports.Set("atg_abs_out", Napi::Function::New(env__, atg_abs_out));
  exports.Set("atg_abs_", Napi::Function::New(env__, atg_abs_));
  exports.Set("atg_absolute", Napi::Function::New(env__, atg_absolute));
  exports.Set("atg_absolute_out", Napi::Function::New(env__, atg_absolute_out));
  exports.Set("atg_absolute_", Napi::Function::New(env__, atg_absolute_));
  exports.Set("atg_angle", Napi::Function::New(env__, atg_angle));
  exports.Set("atg_angle_out", Napi::Function::New(env__, atg_angle_out));
  exports.Set("atg_view_as_real", Napi::Function::New(env__, atg_view_as_real));
  exports.Set("atg_view_as_complex", Napi::Function::New(env__, atg_view_as_complex));
  exports.Set("atg_sgn", Napi::Function::New(env__, atg_sgn));
  exports.Set("atg_sgn_out", Napi::Function::New(env__, atg_sgn_out));
  exports.Set("atg_sgn_", Napi::Function::New(env__, atg_sgn_));
  exports.Set("atg_chalf", Napi::Function::New(env__, atg_chalf));
  exports.Set("atg_real", Napi::Function::New(env__, atg_real));
  exports.Set("atg_imag", Napi::Function::New(env__, atg_imag));
  exports.Set("atg__conj", Napi::Function::New(env__, atg__conj));
  exports.Set("atg_conj", Napi::Function::New(env__, atg_conj));
  exports.Set("atg__conj_physical", Napi::Function::New(env__, atg__conj_physical));
  exports.Set("atg__conj_physical_out", Napi::Function::New(env__, atg__conj_physical_out));
  exports.Set("atg_conj_physical", Napi::Function::New(env__, atg_conj_physical));
  exports.Set("atg_conj_physical_out", Napi::Function::New(env__, atg_conj_physical_out));
  exports.Set("atg_conj_physical_", Napi::Function::New(env__, atg_conj_physical_));
  exports.Set("atg_resolve_conj", Napi::Function::New(env__, atg_resolve_conj));
  exports.Set("atg_resolve_neg", Napi::Function::New(env__, atg_resolve_neg));
  exports.Set("atg__neg_view", Napi::Function::New(env__, atg__neg_view));
  exports.Set("atg_acos", Napi::Function::New(env__, atg_acos));
  exports.Set("atg_acos_out", Napi::Function::New(env__, atg_acos_out));
  exports.Set("atg_acos_", Napi::Function::New(env__, atg_acos_));
  exports.Set("atg_arccos", Napi::Function::New(env__, atg_arccos));
  exports.Set("atg_arccos_out", Napi::Function::New(env__, atg_arccos_out));
  exports.Set("atg_arccos_", Napi::Function::New(env__, atg_arccos_));
  exports.Set("atg_avg_pool1d", Napi::Function::New(env__, atg_avg_pool1d));
  exports.Set("atg_adaptive_avg_pool1d", Napi::Function::New(env__, atg_adaptive_avg_pool1d));
  exports.Set("atg_adaptive_max_pool1d", Napi::Function::New(env__, atg_adaptive_max_pool1d));
  exports.Set("atg_add", Napi::Function::New(env__, atg_add));
  exports.Set("atg_add_scalar", Napi::Function::New(env__, atg_add_scalar));
  exports.Set("atg_add_out", Napi::Function::New(env__, atg_add_out));
  exports.Set("atg_add_scalar_out", Napi::Function::New(env__, atg_add_scalar_out));
  exports.Set("atg_add_", Napi::Function::New(env__, atg_add_));
  exports.Set("atg_add_scalar_", Napi::Function::New(env__, atg_add_scalar_));
  exports.Set("atg__add_relu", Napi::Function::New(env__, atg__add_relu));
  exports.Set("atg__add_relu_scalar", Napi::Function::New(env__, atg__add_relu_scalar));
  exports.Set("atg__add_relu_out", Napi::Function::New(env__, atg__add_relu_out));
  exports.Set("atg__add_relu_scalar_out", Napi::Function::New(env__, atg__add_relu_scalar_out));
  exports.Set("atg__add_relu_", Napi::Function::New(env__, atg__add_relu_));
  exports.Set("atg__add_relu_scalar_", Napi::Function::New(env__, atg__add_relu_scalar_));
  exports.Set("atg_addmv", Napi::Function::New(env__, atg_addmv));
  exports.Set("atg_addmv_out", Napi::Function::New(env__, atg_addmv_out));
  exports.Set("atg_addmv_", Napi::Function::New(env__, atg_addmv_));
  exports.Set("atg_addr", Napi::Function::New(env__, atg_addr));
  exports.Set("atg_addr_out", Napi::Function::New(env__, atg_addr_out));
  exports.Set("atg_addr_", Napi::Function::New(env__, atg_addr_));
  exports.Set("atg_affine_grid_generator", Napi::Function::New(env__, atg_affine_grid_generator));
  exports.Set("atg_affine_grid_generator_out", Napi::Function::New(env__, atg_affine_grid_generator_out));
  exports.Set("atg_affine_grid_generator_backward", Napi::Function::New(env__, atg_affine_grid_generator_backward));
  exports.Set("atg__is_all_true", Napi::Function::New(env__, atg__is_all_true));
  exports.Set("atg__is_any_true", Napi::Function::New(env__, atg__is_any_true));
  exports.Set("atg__test_check_tensor", Napi::Function::New(env__, atg__test_check_tensor));
  exports.Set("atg_all", Napi::Function::New(env__, atg_all));
  exports.Set("atg_all_dim", Napi::Function::New(env__, atg_all_dim));
  exports.Set("atg_all_all_out", Napi::Function::New(env__, atg_all_all_out));
  exports.Set("atg_all_out", Napi::Function::New(env__, atg_all_out));
  exports.Set("atg_allclose", Napi::Function::New(env__, atg_allclose));
  exports.Set("atg_any", Napi::Function::New(env__, atg_any));
  exports.Set("atg_any_dim", Napi::Function::New(env__, atg_any_dim));
  exports.Set("atg_any_all_out", Napi::Function::New(env__, atg_any_all_out));
  exports.Set("atg_any_out", Napi::Function::New(env__, atg_any_out));
  exports.Set("atg_arange", Napi::Function::New(env__, atg_arange));
  exports.Set("atg_arange_start", Napi::Function::New(env__, atg_arange_start));
  exports.Set("atg_arange_start_step", Napi::Function::New(env__, atg_arange_start_step));
  exports.Set("atg_arange_out", Napi::Function::New(env__, atg_arange_out));
  exports.Set("atg_arange_start_out", Napi::Function::New(env__, atg_arange_start_out));
  exports.Set("atg__dim_arange", Napi::Function::New(env__, atg__dim_arange));
  exports.Set("atg_argmax", Napi::Function::New(env__, atg_argmax));
  exports.Set("atg_argmax_out", Napi::Function::New(env__, atg_argmax_out));
  exports.Set("atg_argmin", Napi::Function::New(env__, atg_argmin));
  exports.Set("atg_argmin_out", Napi::Function::New(env__, atg_argmin_out));
  exports.Set("atg_acosh", Napi::Function::New(env__, atg_acosh));
  exports.Set("atg_acosh_out", Napi::Function::New(env__, atg_acosh_out));
  exports.Set("atg_acosh_", Napi::Function::New(env__, atg_acosh_));
  exports.Set("atg_arccosh", Napi::Function::New(env__, atg_arccosh));
  exports.Set("atg_arccosh_out", Napi::Function::New(env__, atg_arccosh_out));
  exports.Set("atg_arccosh_", Napi::Function::New(env__, atg_arccosh_));
  exports.Set("atg_asinh", Napi::Function::New(env__, atg_asinh));
  exports.Set("atg_asinh_out", Napi::Function::New(env__, atg_asinh_out));
  exports.Set("atg_asinh_", Napi::Function::New(env__, atg_asinh_));
  exports.Set("atg_arcsinh", Napi::Function::New(env__, atg_arcsinh));
  exports.Set("atg_arcsinh_out", Napi::Function::New(env__, atg_arcsinh_out));
  exports.Set("atg_arcsinh_", Napi::Function::New(env__, atg_arcsinh_));
  exports.Set("atg_atanh", Napi::Function::New(env__, atg_atanh));
  exports.Set("atg_atanh_out", Napi::Function::New(env__, atg_atanh_out));
  exports.Set("atg_atanh_", Napi::Function::New(env__, atg_atanh_));
  exports.Set("atg_arctanh", Napi::Function::New(env__, atg_arctanh));
  exports.Set("atg_arctanh_out", Napi::Function::New(env__, atg_arctanh_out));
  exports.Set("atg_arctanh_", Napi::Function::New(env__, atg_arctanh_));
  exports.Set("atg_as_strided", Napi::Function::New(env__, atg_as_strided));
  exports.Set("atg_as_strided_", Napi::Function::New(env__, atg_as_strided_));
  exports.Set("atg_asin", Napi::Function::New(env__, atg_asin));
  exports.Set("atg_asin_out", Napi::Function::New(env__, atg_asin_out));
  exports.Set("atg_asin_", Napi::Function::New(env__, atg_asin_));
  exports.Set("atg_arcsin", Napi::Function::New(env__, atg_arcsin));
  exports.Set("atg_arcsin_out", Napi::Function::New(env__, atg_arcsin_out));
  exports.Set("atg_arcsin_", Napi::Function::New(env__, atg_arcsin_));
  exports.Set("atg_atan", Napi::Function::New(env__, atg_atan));
  exports.Set("atg_atan_out", Napi::Function::New(env__, atg_atan_out));
  exports.Set("atg_atan_", Napi::Function::New(env__, atg_atan_));
  exports.Set("atg_arctan", Napi::Function::New(env__, atg_arctan));
  exports.Set("atg_arctan_out", Napi::Function::New(env__, atg_arctan_out));
  exports.Set("atg_arctan_", Napi::Function::New(env__, atg_arctan_));
  exports.Set("atg_atleast_1d", Napi::Function::New(env__, atg_atleast_1d));
  exports.Set("atg_atleast_2d", Napi::Function::New(env__, atg_atleast_2d));
  exports.Set("atg_atleast_3d", Napi::Function::New(env__, atg_atleast_3d));
  exports.Set("atg_baddbmm", Napi::Function::New(env__, atg_baddbmm));
  exports.Set("atg_baddbmm_out", Napi::Function::New(env__, atg_baddbmm_out));
  exports.Set("atg_baddbmm_", Napi::Function::New(env__, atg_baddbmm_));
  exports.Set("atg_bartlett_window", Napi::Function::New(env__, atg_bartlett_window));
  exports.Set("atg_bartlett_window_periodic", Napi::Function::New(env__, atg_bartlett_window_periodic));
  exports.Set("atg_bartlett_window_out", Napi::Function::New(env__, atg_bartlett_window_out));
  exports.Set("atg_bartlett_window_periodic_out", Napi::Function::New(env__, atg_bartlett_window_periodic_out));
  exports.Set("atg_batch_norm", Napi::Function::New(env__, atg_batch_norm));
  exports.Set("atg_quantized_batch_norm", Napi::Function::New(env__, atg_quantized_batch_norm));
  exports.Set("atg_quantized_batch_norm_out", Napi::Function::New(env__, atg_quantized_batch_norm_out));
  exports.Set("atg_bernoulli", Napi::Function::New(env__, atg_bernoulli));
  exports.Set("atg_bernoulli_p", Napi::Function::New(env__, atg_bernoulli_p));
  exports.Set("atg_bernoulli_tensor", Napi::Function::New(env__, atg_bernoulli_tensor));
  exports.Set("atg_bernoulli_", Napi::Function::New(env__, atg_bernoulli_));
  exports.Set("atg_bernoulli_float_", Napi::Function::New(env__, atg_bernoulli_float_));
  exports.Set("atg_bilinear", Napi::Function::New(env__, atg_bilinear));
  exports.Set("atg_binary_cross_entropy", Napi::Function::New(env__, atg_binary_cross_entropy));
  exports.Set("atg_binary_cross_entropy_out", Napi::Function::New(env__, atg_binary_cross_entropy_out));
  exports.Set("atg_binary_cross_entropy_backward", Napi::Function::New(env__, atg_binary_cross_entropy_backward));
  exports.Set("atg_binary_cross_entropy_backward_grad_input", Napi::Function::New(env__, atg_binary_cross_entropy_backward_grad_input));
  exports.Set("atg_binary_cross_entropy_with_logits", Napi::Function::New(env__, atg_binary_cross_entropy_with_logits));
  exports.Set("atg_binary_cross_entropy_with_logits_out", Napi::Function::New(env__, atg_binary_cross_entropy_with_logits_out));
  exports.Set("atg_bincount", Napi::Function::New(env__, atg_bincount));
  exports.Set("atg_bincount_out", Napi::Function::New(env__, atg_bincount_out));
  exports.Set("atg_bitwise_not", Napi::Function::New(env__, atg_bitwise_not));
  exports.Set("atg_bitwise_not_out", Napi::Function::New(env__, atg_bitwise_not_out));
  exports.Set("atg_bitwise_not_", Napi::Function::New(env__, atg_bitwise_not_));
  exports.Set("atg_copysign", Napi::Function::New(env__, atg_copysign));
  exports.Set("atg_copysign_scalar", Napi::Function::New(env__, atg_copysign_scalar));
  exports.Set("atg_copysign_out", Napi::Function::New(env__, atg_copysign_out));
  exports.Set("atg_copysign_scalar_out", Napi::Function::New(env__, atg_copysign_scalar_out));
  exports.Set("atg_copysign_", Napi::Function::New(env__, atg_copysign_));
  exports.Set("atg_copysign_scalar_", Napi::Function::New(env__, atg_copysign_scalar_));
  exports.Set("atg_logical_not", Napi::Function::New(env__, atg_logical_not));
  exports.Set("atg_logical_not_out", Napi::Function::New(env__, atg_logical_not_out));
  exports.Set("atg_logical_not_", Napi::Function::New(env__, atg_logical_not_));
  exports.Set("atg_logical_xor", Napi::Function::New(env__, atg_logical_xor));
  exports.Set("atg_logical_xor_out", Napi::Function::New(env__, atg_logical_xor_out));
  exports.Set("atg_logical_xor_", Napi::Function::New(env__, atg_logical_xor_));
  exports.Set("atg_logical_and", Napi::Function::New(env__, atg_logical_and));
  exports.Set("atg_logical_and_out", Napi::Function::New(env__, atg_logical_and_out));
  exports.Set("atg_logical_and_", Napi::Function::New(env__, atg_logical_and_));
  exports.Set("atg_logical_or", Napi::Function::New(env__, atg_logical_or));
  exports.Set("atg_logical_or_out", Napi::Function::New(env__, atg_logical_or_out));
  exports.Set("atg_logical_or_", Napi::Function::New(env__, atg_logical_or_));
  exports.Set("atg_blackman_window", Napi::Function::New(env__, atg_blackman_window));
  exports.Set("atg_blackman_window_periodic", Napi::Function::New(env__, atg_blackman_window_periodic));
  exports.Set("atg_blackman_window_out", Napi::Function::New(env__, atg_blackman_window_out));
  exports.Set("atg_blackman_window_periodic_out", Napi::Function::New(env__, atg_blackman_window_periodic_out));
  exports.Set("atg_bmm", Napi::Function::New(env__, atg_bmm));
  exports.Set("atg_bmm_out", Napi::Function::New(env__, atg_bmm_out));
  exports.Set("atg_broadcast_to", Napi::Function::New(env__, atg_broadcast_to));
  exports.Set("atg__sparse_broadcast_to", Napi::Function::New(env__, atg__sparse_broadcast_to));
  exports.Set("atg_cat", Napi::Function::New(env__, atg_cat));
  exports.Set("atg_cat_out", Napi::Function::New(env__, atg_cat_out));
  exports.Set("atg_concat", Napi::Function::New(env__, atg_concat));
  exports.Set("atg_concat_out", Napi::Function::New(env__, atg_concat_out));
  exports.Set("atg_concatenate", Napi::Function::New(env__, atg_concatenate));
  exports.Set("atg_concatenate_out", Napi::Function::New(env__, atg_concatenate_out));
  exports.Set("atg_block_diag", Napi::Function::New(env__, atg_block_diag));
  exports.Set("atg_block_diag_out", Napi::Function::New(env__, atg_block_diag_out));
  exports.Set("atg_ceil", Napi::Function::New(env__, atg_ceil));
  exports.Set("atg_ceil_out", Napi::Function::New(env__, atg_ceil_out));
  exports.Set("atg_ceil_", Napi::Function::New(env__, atg_ceil_));
  exports.Set("atg_chain_matmul", Napi::Function::New(env__, atg_chain_matmul));
  exports.Set("atg_chain_matmul_out", Napi::Function::New(env__, atg_chain_matmul_out));
  exports.Set("atg_clamp", Napi::Function::New(env__, atg_clamp));
  exports.Set("atg_clamp_tensor", Napi::Function::New(env__, atg_clamp_tensor));
  exports.Set("atg_clamp_out", Napi::Function::New(env__, atg_clamp_out));
  exports.Set("atg_clamp_tensor_out", Napi::Function::New(env__, atg_clamp_tensor_out));
  exports.Set("atg_clamp_", Napi::Function::New(env__, atg_clamp_));
  exports.Set("atg_clamp_tensor_", Napi::Function::New(env__, atg_clamp_tensor_));
  exports.Set("atg_clamp_max", Napi::Function::New(env__, atg_clamp_max));
  exports.Set("atg_clamp_max_tensor", Napi::Function::New(env__, atg_clamp_max_tensor));
  exports.Set("atg_clamp_max_out", Napi::Function::New(env__, atg_clamp_max_out));
  exports.Set("atg_clamp_max_tensor_out", Napi::Function::New(env__, atg_clamp_max_tensor_out));
  exports.Set("atg_clamp_max_", Napi::Function::New(env__, atg_clamp_max_));
  exports.Set("atg_clamp_max_tensor_", Napi::Function::New(env__, atg_clamp_max_tensor_));
  exports.Set("atg_clamp_min", Napi::Function::New(env__, atg_clamp_min));
  exports.Set("atg_clamp_min_tensor", Napi::Function::New(env__, atg_clamp_min_tensor));
  exports.Set("atg_clamp_min_out", Napi::Function::New(env__, atg_clamp_min_out));
  exports.Set("atg_clamp_min_tensor_out", Napi::Function::New(env__, atg_clamp_min_tensor_out));
  exports.Set("atg_clamp_min_", Napi::Function::New(env__, atg_clamp_min_));
  exports.Set("atg_clamp_min_tensor_", Napi::Function::New(env__, atg_clamp_min_tensor_));
  exports.Set("atg_clip", Napi::Function::New(env__, atg_clip));
  exports.Set("atg_clip_tensor", Napi::Function::New(env__, atg_clip_tensor));
  exports.Set("atg_clip_out", Napi::Function::New(env__, atg_clip_out));
  exports.Set("atg_clip_tensor_out", Napi::Function::New(env__, atg_clip_tensor_out));
  exports.Set("atg_clip_", Napi::Function::New(env__, atg_clip_));
  exports.Set("atg_clip_tensor_", Napi::Function::New(env__, atg_clip_tensor_));
  exports.Set("atg_cudnn_is_acceptable", Napi::Function::New(env__, atg_cudnn_is_acceptable));
  exports.Set("atg_complex", Napi::Function::New(env__, atg_complex));
  exports.Set("atg_complex_out", Napi::Function::New(env__, atg_complex_out));
  exports.Set("atg_polar", Napi::Function::New(env__, atg_polar));
  exports.Set("atg_polar_out", Napi::Function::New(env__, atg_polar_out));
  exports.Set("atg_constant_pad_nd", Napi::Function::New(env__, atg_constant_pad_nd));
  exports.Set("atg_constant_pad_nd_out", Napi::Function::New(env__, atg_constant_pad_nd_out));
  exports.Set("atg_contiguous", Napi::Function::New(env__, atg_contiguous));
  exports.Set("atg_convolution", Napi::Function::New(env__, atg_convolution));
  exports.Set("atg_convolution_out", Napi::Function::New(env__, atg_convolution_out));
  exports.Set("atg_convolution_overrideable", Napi::Function::New(env__, atg_convolution_overrideable));
  exports.Set("atg_convolution_overrideable_out", Napi::Function::New(env__, atg_convolution_overrideable_out));
  exports.Set("atg__convolution_deprecated", Napi::Function::New(env__, atg__convolution_deprecated));
  exports.Set("atg__convolution", Napi::Function::New(env__, atg__convolution));
  exports.Set("atg__convolution_out", Napi::Function::New(env__, atg__convolution_out));
  exports.Set("atg__convolution_mode", Napi::Function::New(env__, atg__convolution_mode));
  exports.Set("atg_conv1d", Napi::Function::New(env__, atg_conv1d));
  exports.Set("atg_conv1d_padding", Napi::Function::New(env__, atg_conv1d_padding));
  exports.Set("atg_conv2d", Napi::Function::New(env__, atg_conv2d));
  exports.Set("atg_conv2d_padding", Napi::Function::New(env__, atg_conv2d_padding));
  exports.Set("atg_conv3d", Napi::Function::New(env__, atg_conv3d));
  exports.Set("atg_conv3d_padding", Napi::Function::New(env__, atg_conv3d_padding));
  exports.Set("atg_conv_tbc", Napi::Function::New(env__, atg_conv_tbc));
  exports.Set("atg_conv_tbc_out", Napi::Function::New(env__, atg_conv_tbc_out));
  exports.Set("atg_conv_tbc_backward", Napi::Function::New(env__, atg_conv_tbc_backward));
  exports.Set("atg_conv_transpose1d", Napi::Function::New(env__, atg_conv_transpose1d));
  exports.Set("atg_conv_transpose2d", Napi::Function::New(env__, atg_conv_transpose2d));
  exports.Set("atg_conv_transpose3d", Napi::Function::New(env__, atg_conv_transpose3d));
  exports.Set("atg__copy_from", Napi::Function::New(env__, atg__copy_from));
  exports.Set("atg__copy_from_out", Napi::Function::New(env__, atg__copy_from_out));
  exports.Set("atg__copy_from_and_resize", Napi::Function::New(env__, atg__copy_from_and_resize));
  exports.Set("atg__copy_from_and_resize_out", Napi::Function::New(env__, atg__copy_from_and_resize_out));
  exports.Set("atg_cos", Napi::Function::New(env__, atg_cos));
  exports.Set("atg_cos_out", Napi::Function::New(env__, atg_cos_out));
  exports.Set("atg_cos_", Napi::Function::New(env__, atg_cos_));
  exports.Set("atg_cosh", Napi::Function::New(env__, atg_cosh));
  exports.Set("atg_cosh_out", Napi::Function::New(env__, atg_cosh_out));
  exports.Set("atg_cosh_", Napi::Function::New(env__, atg_cosh_));
  exports.Set("atg_cosine_embedding_loss", Napi::Function::New(env__, atg_cosine_embedding_loss));
  exports.Set("atg_count_nonzero_dim_intlist", Napi::Function::New(env__, atg_count_nonzero_dim_intlist));
  exports.Set("atg_count_nonzero", Napi::Function::New(env__, atg_count_nonzero));
  exports.Set("atg_count_nonzero_dim_intlist_out", Napi::Function::New(env__, atg_count_nonzero_dim_intlist_out));
  exports.Set("atg_count_nonzero_out", Napi::Function::New(env__, atg_count_nonzero_out));
  exports.Set("atg_cov", Napi::Function::New(env__, atg_cov));
  exports.Set("atg_corrcoef", Napi::Function::New(env__, atg_corrcoef));
  exports.Set("atg_cudnn_affine_grid_generator", Napi::Function::New(env__, atg_cudnn_affine_grid_generator));
  exports.Set("atg_cudnn_affine_grid_generator_out", Napi::Function::New(env__, atg_cudnn_affine_grid_generator_out));
  exports.Set("atg_cudnn_affine_grid_generator_backward", Napi::Function::New(env__, atg_cudnn_affine_grid_generator_backward));
  exports.Set("atg_cudnn_affine_grid_generator_backward_out", Napi::Function::New(env__, atg_cudnn_affine_grid_generator_backward_out));
  exports.Set("atg_cudnn_batch_norm", Napi::Function::New(env__, atg_cudnn_batch_norm));
  exports.Set("atg_cudnn_batch_norm_out", Napi::Function::New(env__, atg_cudnn_batch_norm_out));
  exports.Set("atg_cudnn_batch_norm_backward", Napi::Function::New(env__, atg_cudnn_batch_norm_backward));
  exports.Set("atg_cudnn_batch_norm_backward_out", Napi::Function::New(env__, atg_cudnn_batch_norm_backward_out));
  exports.Set("atg_cudnn_convolution", Napi::Function::New(env__, atg_cudnn_convolution));
  exports.Set("atg_cudnn_convolution_out", Napi::Function::New(env__, atg_cudnn_convolution_out));
  exports.Set("atg_cudnn_convolution_transpose", Napi::Function::New(env__, atg_cudnn_convolution_transpose));
  exports.Set("atg_cudnn_convolution_transpose_out", Napi::Function::New(env__, atg_cudnn_convolution_transpose_out));
  exports.Set("atg__mps_convolution_transpose", Napi::Function::New(env__, atg__mps_convolution_transpose));
  exports.Set("atg__mps_convolution_transpose_out", Napi::Function::New(env__, atg__mps_convolution_transpose_out));
  exports.Set("atg_cudnn_convolution_relu", Napi::Function::New(env__, atg_cudnn_convolution_relu));
  exports.Set("atg_cudnn_convolution_relu_out", Napi::Function::New(env__, atg_cudnn_convolution_relu_out));
  exports.Set("atg_cudnn_convolution_add_relu", Napi::Function::New(env__, atg_cudnn_convolution_add_relu));
  exports.Set("atg_cudnn_convolution_add_relu_out", Napi::Function::New(env__, atg_cudnn_convolution_add_relu_out));
  exports.Set("atg_cudnn_grid_sampler", Napi::Function::New(env__, atg_cudnn_grid_sampler));
  exports.Set("atg_cudnn_grid_sampler_out", Napi::Function::New(env__, atg_cudnn_grid_sampler_out));
  exports.Set("atg_cudnn_grid_sampler_backward", Napi::Function::New(env__, atg_cudnn_grid_sampler_backward));
  exports.Set("atg_cudnn_grid_sampler_backward_out", Napi::Function::New(env__, atg_cudnn_grid_sampler_backward_out));
  exports.Set("atg_cummax", Napi::Function::New(env__, atg_cummax));
  exports.Set("atg_cummax_out", Napi::Function::New(env__, atg_cummax_out));
  exports.Set("atg_cummin", Napi::Function::New(env__, atg_cummin));
  exports.Set("atg_cummin_out", Napi::Function::New(env__, atg_cummin_out));
  exports.Set("atg_cummaxmin_backward", Napi::Function::New(env__, atg_cummaxmin_backward));
  exports.Set("atg_cumprod", Napi::Function::New(env__, atg_cumprod));
  exports.Set("atg_cumprod_out", Napi::Function::New(env__, atg_cumprod_out));
  exports.Set("atg_cumprod_", Napi::Function::New(env__, atg_cumprod_));
  exports.Set("atg_cumprod_backward", Napi::Function::New(env__, atg_cumprod_backward));
  exports.Set("atg_cumsum", Napi::Function::New(env__, atg_cumsum));
  exports.Set("atg_cumsum_out", Napi::Function::New(env__, atg_cumsum_out));
  exports.Set("atg_cumsum_", Napi::Function::New(env__, atg_cumsum_));
  exports.Set("atg_cumulative_trapezoid", Napi::Function::New(env__, atg_cumulative_trapezoid));
  exports.Set("atg_cumulative_trapezoid_dx", Napi::Function::New(env__, atg_cumulative_trapezoid_dx));
  exports.Set("atg_ctc_loss", Napi::Function::New(env__, atg_ctc_loss));
  exports.Set("atg_ctc_loss_tensor", Napi::Function::New(env__, atg_ctc_loss_tensor));
  exports.Set("atg__ctc_loss", Napi::Function::New(env__, atg__ctc_loss));
  exports.Set("atg__ctc_loss_tensor", Napi::Function::New(env__, atg__ctc_loss_tensor));
  exports.Set("atg__ctc_loss_out", Napi::Function::New(env__, atg__ctc_loss_out));
  exports.Set("atg__ctc_loss_tensor_out", Napi::Function::New(env__, atg__ctc_loss_tensor_out));
  exports.Set("atg__ctc_loss_backward", Napi::Function::New(env__, atg__ctc_loss_backward));
  exports.Set("atg__ctc_loss_backward_tensor", Napi::Function::New(env__, atg__ctc_loss_backward_tensor));
  exports.Set("atg__ctc_loss_backward_out", Napi::Function::New(env__, atg__ctc_loss_backward_out));
  exports.Set("atg_diag_embed", Napi::Function::New(env__, atg_diag_embed));
  exports.Set("atg_diag_embed_out", Napi::Function::New(env__, atg_diag_embed_out));
  exports.Set("atg_diagflat", Napi::Function::New(env__, atg_diagflat));
  exports.Set("atg_diagonal", Napi::Function::New(env__, atg_diagonal));
  exports.Set("atg_linalg_diagonal", Napi::Function::New(env__, atg_linalg_diagonal));
  exports.Set("atg_diagonal_backward", Napi::Function::New(env__, atg_diagonal_backward));
  exports.Set("atg_diagonal_backward_out", Napi::Function::New(env__, atg_diagonal_backward_out));
  exports.Set("atg_fill_diagonal_", Napi::Function::New(env__, atg_fill_diagonal_));
  exports.Set("atg_diff", Napi::Function::New(env__, atg_diff));
  exports.Set("atg_diff_out", Napi::Function::New(env__, atg_diff_out));
  exports.Set("atg_div", Napi::Function::New(env__, atg_div));
  exports.Set("atg_div_scalar", Napi::Function::New(env__, atg_div_scalar));
  exports.Set("atg_div_tensor_mode", Napi::Function::New(env__, atg_div_tensor_mode));
  exports.Set("atg_div_scalar_mode", Napi::Function::New(env__, atg_div_scalar_mode));
  exports.Set("atg_div_out", Napi::Function::New(env__, atg_div_out));
  exports.Set("atg_div_scalar_out", Napi::Function::New(env__, atg_div_scalar_out));
  exports.Set("atg_div_out_mode", Napi::Function::New(env__, atg_div_out_mode));
  exports.Set("atg_div_scalar_mode_out", Napi::Function::New(env__, atg_div_scalar_mode_out));
  exports.Set("atg_div_", Napi::Function::New(env__, atg_div_));
  exports.Set("atg_div_scalar_", Napi::Function::New(env__, atg_div_scalar_));
  exports.Set("atg_div_tensor_mode_", Napi::Function::New(env__, atg_div_tensor_mode_));
  exports.Set("atg_div_scalar_mode_", Napi::Function::New(env__, atg_div_scalar_mode_));
  exports.Set("atg_divide", Napi::Function::New(env__, atg_divide));
  exports.Set("atg_divide_scalar", Napi::Function::New(env__, atg_divide_scalar));
  exports.Set("atg_divide_tensor_mode", Napi::Function::New(env__, atg_divide_tensor_mode));
  exports.Set("atg_divide_scalar_mode", Napi::Function::New(env__, atg_divide_scalar_mode));
  exports.Set("atg_divide_out", Napi::Function::New(env__, atg_divide_out));
  exports.Set("atg_divide_out_mode", Napi::Function::New(env__, atg_divide_out_mode));
  exports.Set("atg_divide_", Napi::Function::New(env__, atg_divide_));
  exports.Set("atg_divide_scalar_", Napi::Function::New(env__, atg_divide_scalar_));
  exports.Set("atg_divide_tensor_mode_", Napi::Function::New(env__, atg_divide_tensor_mode_));
  exports.Set("atg_divide_scalar_mode_", Napi::Function::New(env__, atg_divide_scalar_mode_));
  exports.Set("atg_true_divide", Napi::Function::New(env__, atg_true_divide));
  exports.Set("atg_true_divide_scalar", Napi::Function::New(env__, atg_true_divide_scalar));
  exports.Set("atg_true_divide_out", Napi::Function::New(env__, atg_true_divide_out));
  exports.Set("atg_true_divide_", Napi::Function::New(env__, atg_true_divide_));
  exports.Set("atg_true_divide_scalar_", Napi::Function::New(env__, atg_true_divide_scalar_));
  exports.Set("atg_dot", Napi::Function::New(env__, atg_dot));
  exports.Set("atg_dot_out", Napi::Function::New(env__, atg_dot_out));
  exports.Set("atg_vdot", Napi::Function::New(env__, atg_vdot));
  exports.Set("atg_vdot_out", Napi::Function::New(env__, atg_vdot_out));
  exports.Set("atg_einsum", Napi::Function::New(env__, atg_einsum));
  exports.Set("atg_embedding", Napi::Function::New(env__, atg_embedding));
  exports.Set("atg_embedding_out", Napi::Function::New(env__, atg_embedding_out));
  exports.Set("atg_embedding_backward", Napi::Function::New(env__, atg_embedding_backward));
  exports.Set("atg_embedding_dense_backward", Napi::Function::New(env__, atg_embedding_dense_backward));
  exports.Set("atg_embedding_dense_backward_out", Napi::Function::New(env__, atg_embedding_dense_backward_out));
  exports.Set("atg_embedding_renorm_", Napi::Function::New(env__, atg_embedding_renorm_));
  exports.Set("atg_embedding_sparse_backward", Napi::Function::New(env__, atg_embedding_sparse_backward));
  exports.Set("atg__embedding_bag_forward_only", Napi::Function::New(env__, atg__embedding_bag_forward_only));
  exports.Set("atg__embedding_bag_forward_only_out", Napi::Function::New(env__, atg__embedding_bag_forward_only_out));
  exports.Set("atg__rowwise_prune", Napi::Function::New(env__, atg__rowwise_prune));
  exports.Set("atg_row_stack", Napi::Function::New(env__, atg_row_stack));
  exports.Set("atg_row_stack_out", Napi::Function::New(env__, atg_row_stack_out));
  exports.Set("atg_embedding_bag", Napi::Function::New(env__, atg_embedding_bag));
  exports.Set("atg_embedding_bag_padding_idx", Napi::Function::New(env__, atg_embedding_bag_padding_idx));
  exports.Set("atg__embedding_bag", Napi::Function::New(env__, atg__embedding_bag));
  exports.Set("atg__embedding_bag_out", Napi::Function::New(env__, atg__embedding_bag_out));
  exports.Set("atg__embedding_bag_backward", Napi::Function::New(env__, atg__embedding_bag_backward));
  exports.Set("atg__embedding_bag_sparse_backward", Napi::Function::New(env__, atg__embedding_bag_sparse_backward));
  exports.Set("atg__embedding_bag_dense_backward", Napi::Function::New(env__, atg__embedding_bag_dense_backward));
  exports.Set("atg__embedding_bag_dense_backward_out", Napi::Function::New(env__, atg__embedding_bag_dense_backward_out));
  exports.Set("atg__embedding_bag_per_sample_weights_backward", Napi::Function::New(env__, atg__embedding_bag_per_sample_weights_backward));
  exports.Set("atg__embedding_bag_per_sample_weights_backward_out", Napi::Function::New(env__, atg__embedding_bag_per_sample_weights_backward_out));
  exports.Set("atg_empty", Napi::Function::New(env__, atg_empty));
  exports.Set("atg_empty_out", Napi::Function::New(env__, atg_empty_out));
  exports.Set("atg_new_empty", Napi::Function::New(env__, atg_new_empty));
  exports.Set("atg_new_empty_out", Napi::Function::New(env__, atg_new_empty_out));
  exports.Set("atg_new_empty_strided", Napi::Function::New(env__, atg_new_empty_strided));
  exports.Set("atg_new_empty_strided_out", Napi::Function::New(env__, atg_new_empty_strided_out));
  exports.Set("atg_new_full", Napi::Function::New(env__, atg_new_full));
  exports.Set("atg_new_full_out", Napi::Function::New(env__, atg_new_full_out));
  exports.Set("atg_new_zeros", Napi::Function::New(env__, atg_new_zeros));
  exports.Set("atg_new_zeros_out", Napi::Function::New(env__, atg_new_zeros_out));
  exports.Set("atg_new_ones", Napi::Function::New(env__, atg_new_ones));
  exports.Set("atg_new_ones_out", Napi::Function::New(env__, atg_new_ones_out));
  exports.Set("atg__empty_affine_quantized", Napi::Function::New(env__, atg__empty_affine_quantized));
  exports.Set("atg__empty_affine_quantized_out", Napi::Function::New(env__, atg__empty_affine_quantized_out));
  exports.Set("atg__empty_per_channel_affine_quantized", Napi::Function::New(env__, atg__empty_per_channel_affine_quantized));
  exports.Set("atg__empty_per_channel_affine_quantized_out", Napi::Function::New(env__, atg__empty_per_channel_affine_quantized_out));
  exports.Set("atg_resize_", Napi::Function::New(env__, atg_resize_));
  exports.Set("atg__resize_output_", Napi::Function::New(env__, atg__resize_output_));
  exports.Set("atg_empty_quantized", Napi::Function::New(env__, atg_empty_quantized));
  exports.Set("atg_empty_quantized_out", Napi::Function::New(env__, atg_empty_quantized_out));
  exports.Set("atg_empty_like", Napi::Function::New(env__, atg_empty_like));
  exports.Set("atg_empty_like_out", Napi::Function::New(env__, atg_empty_like_out));
  exports.Set("atg_empty_strided", Napi::Function::New(env__, atg_empty_strided));
  exports.Set("atg_empty_strided_out", Napi::Function::New(env__, atg_empty_strided_out));
  exports.Set("atg_erf", Napi::Function::New(env__, atg_erf));
  exports.Set("atg_erf_out", Napi::Function::New(env__, atg_erf_out));
  exports.Set("atg_erf_", Napi::Function::New(env__, atg_erf_));
  exports.Set("atg_erfc", Napi::Function::New(env__, atg_erfc));
  exports.Set("atg_erfc_out", Napi::Function::New(env__, atg_erfc_out));
  exports.Set("atg_erfc_", Napi::Function::New(env__, atg_erfc_));
  exports.Set("atg_exp", Napi::Function::New(env__, atg_exp));
  exports.Set("atg_exp_out", Napi::Function::New(env__, atg_exp_out));
  exports.Set("atg_exp_", Napi::Function::New(env__, atg_exp_));
  exports.Set("atg_exp2", Napi::Function::New(env__, atg_exp2));
  exports.Set("atg_exp2_out", Napi::Function::New(env__, atg_exp2_out));
  exports.Set("atg_exp2_", Napi::Function::New(env__, atg_exp2_));
  exports.Set("atg_expm1", Napi::Function::New(env__, atg_expm1));
  exports.Set("atg_expm1_out", Napi::Function::New(env__, atg_expm1_out));
  exports.Set("atg_expm1_", Napi::Function::New(env__, atg_expm1_));
  exports.Set("atg_expand", Napi::Function::New(env__, atg_expand));
  exports.Set("atg_expand_as", Napi::Function::New(env__, atg_expand_as));
  exports.Set("atg_eye", Napi::Function::New(env__, atg_eye));
  exports.Set("atg_eye_m", Napi::Function::New(env__, atg_eye_m));
  exports.Set("atg_eye_out", Napi::Function::New(env__, atg_eye_out));
  exports.Set("atg_eye_m_out", Napi::Function::New(env__, atg_eye_m_out));
  exports.Set("atg_flatten", Napi::Function::New(env__, atg_flatten));
  exports.Set("atg_unflatten", Napi::Function::New(env__, atg_unflatten));
  exports.Set("atg_fill", Napi::Function::New(env__, atg_fill));
  exports.Set("atg_fill_tensor", Napi::Function::New(env__, atg_fill_tensor));
  exports.Set("atg_fill_scalar_out", Napi::Function::New(env__, atg_fill_scalar_out));
  exports.Set("atg_fill_tensor_out", Napi::Function::New(env__, atg_fill_tensor_out));
  exports.Set("atg_fill_", Napi::Function::New(env__, atg_fill_));
  exports.Set("atg_fill_tensor_", Napi::Function::New(env__, atg_fill_tensor_));
  exports.Set("atg_floor", Napi::Function::New(env__, atg_floor));
  exports.Set("atg_floor_out", Napi::Function::New(env__, atg_floor_out));
  exports.Set("atg_floor_", Napi::Function::New(env__, atg_floor_));
  exports.Set("atg_floor_divide", Napi::Function::New(env__, atg_floor_divide));
  exports.Set("atg_floor_divide_scalar", Napi::Function::New(env__, atg_floor_divide_scalar));
  exports.Set("atg_floor_divide_out", Napi::Function::New(env__, atg_floor_divide_out));
  exports.Set("atg_floor_divide_", Napi::Function::New(env__, atg_floor_divide_));
  exports.Set("atg_floor_divide_scalar_", Napi::Function::New(env__, atg_floor_divide_scalar_));
  exports.Set("atg_frac", Napi::Function::New(env__, atg_frac));
  exports.Set("atg_frac_out", Napi::Function::New(env__, atg_frac_out));
  exports.Set("atg_frac_", Napi::Function::New(env__, atg_frac_));
  exports.Set("atg_full", Napi::Function::New(env__, atg_full));
  exports.Set("atg_full_out", Napi::Function::New(env__, atg_full_out));
  exports.Set("atg_full_like", Napi::Function::New(env__, atg_full_like));
  exports.Set("atg_full_like_out", Napi::Function::New(env__, atg_full_like_out));
  exports.Set("atg_from_file", Napi::Function::New(env__, atg_from_file));
  exports.Set("atg_from_file_out", Napi::Function::New(env__, atg_from_file_out));
  exports.Set("atg_gcd", Napi::Function::New(env__, atg_gcd));
  exports.Set("atg_gcd_out", Napi::Function::New(env__, atg_gcd_out));
  exports.Set("atg_gcd_", Napi::Function::New(env__, atg_gcd_));
  exports.Set("atg_lcm", Napi::Function::New(env__, atg_lcm));
  exports.Set("atg_lcm_out", Napi::Function::New(env__, atg_lcm_out));
  exports.Set("atg_lcm_", Napi::Function::New(env__, atg_lcm_));
  exports.Set("atg_grid_sampler", Napi::Function::New(env__, atg_grid_sampler));
  exports.Set("atg_grid_sampler_2d", Napi::Function::New(env__, atg_grid_sampler_2d));
  exports.Set("atg_grid_sampler_2d_out", Napi::Function::New(env__, atg_grid_sampler_2d_out));
  exports.Set("atg__grid_sampler_2d_cpu_fallback", Napi::Function::New(env__, atg__grid_sampler_2d_cpu_fallback));
  exports.Set("atg__grid_sampler_2d_cpu_fallback_out", Napi::Function::New(env__, atg__grid_sampler_2d_cpu_fallback_out));
  exports.Set("atg__grid_sampler_2d_cpu_fallback_backward", Napi::Function::New(env__, atg__grid_sampler_2d_cpu_fallback_backward));
  exports.Set("atg_grid_sampler_3d", Napi::Function::New(env__, atg_grid_sampler_3d));
  exports.Set("atg_grid_sampler_3d_out", Napi::Function::New(env__, atg_grid_sampler_3d_out));
  exports.Set("atg_hann_window", Napi::Function::New(env__, atg_hann_window));
  exports.Set("atg_hann_window_periodic", Napi::Function::New(env__, atg_hann_window_periodic));
  exports.Set("atg_hann_window_out", Napi::Function::New(env__, atg_hann_window_out));
  exports.Set("atg_hann_window_periodic_out", Napi::Function::New(env__, atg_hann_window_periodic_out));
  exports.Set("atg_hamming_window", Napi::Function::New(env__, atg_hamming_window));
  exports.Set("atg_hamming_window_periodic", Napi::Function::New(env__, atg_hamming_window_periodic));
  exports.Set("atg_hamming_window_periodic_alpha", Napi::Function::New(env__, atg_hamming_window_periodic_alpha));
  exports.Set("atg_hamming_window_periodic_alpha_beta", Napi::Function::New(env__, atg_hamming_window_periodic_alpha_beta));
  exports.Set("atg_hamming_window_out", Napi::Function::New(env__, atg_hamming_window_out));
  exports.Set("atg_hamming_window_periodic_out", Napi::Function::New(env__, atg_hamming_window_periodic_out));
  exports.Set("atg_hamming_window_periodic_alpha_out", Napi::Function::New(env__, atg_hamming_window_periodic_alpha_out));
  exports.Set("atg_hamming_window_periodic_alpha_beta_out", Napi::Function::New(env__, atg_hamming_window_periodic_alpha_beta_out));
  exports.Set("atg_kaiser_window", Napi::Function::New(env__, atg_kaiser_window));
  exports.Set("atg_kaiser_window_periodic", Napi::Function::New(env__, atg_kaiser_window_periodic));
  exports.Set("atg_kaiser_window_beta", Napi::Function::New(env__, atg_kaiser_window_beta));
  exports.Set("atg_kaiser_window_out", Napi::Function::New(env__, atg_kaiser_window_out));
  exports.Set("atg_kaiser_window_periodic_out", Napi::Function::New(env__, atg_kaiser_window_periodic_out));
  exports.Set("atg_kaiser_window_beta_out", Napi::Function::New(env__, atg_kaiser_window_beta_out));
  exports.Set("atg_hinge_embedding_loss", Napi::Function::New(env__, atg_hinge_embedding_loss));
  exports.Set("atg_group_norm", Napi::Function::New(env__, atg_group_norm));
  exports.Set("atg_native_group_norm", Napi::Function::New(env__, atg_native_group_norm));
  exports.Set("atg_native_group_norm_out", Napi::Function::New(env__, atg_native_group_norm_out));
  exports.Set("atg__fft_r2c", Napi::Function::New(env__, atg__fft_r2c));
  exports.Set("atg__fft_r2c_out", Napi::Function::New(env__, atg__fft_r2c_out));
  exports.Set("atg__fft_c2r", Napi::Function::New(env__, atg__fft_c2r));
  exports.Set("atg__fft_c2r_out", Napi::Function::New(env__, atg__fft_c2r_out));
  exports.Set("atg__fft_c2c", Napi::Function::New(env__, atg__fft_c2c));
  exports.Set("atg__fft_c2c_out", Napi::Function::New(env__, atg__fft_c2c_out));
  exports.Set("atg__validate_compressed_sparse_indices", Napi::Function::New(env__, atg__validate_compressed_sparse_indices));
  exports.Set("atg__cufft_get_plan_cache_size", Napi::Function::New(env__, atg__cufft_get_plan_cache_size));
  exports.Set("atg__cufft_get_plan_cache_max_size", Napi::Function::New(env__, atg__cufft_get_plan_cache_max_size));
  exports.Set("atg_index", Napi::Function::New(env__, atg_index));
  exports.Set("atg_index_tensor_out", Napi::Function::New(env__, atg_index_tensor_out));
  exports.Set("atg_index_copy", Napi::Function::New(env__, atg_index_copy));
  exports.Set("atg_index_copy_out", Napi::Function::New(env__, atg_index_copy_out));
  exports.Set("atg_index_copy_", Napi::Function::New(env__, atg_index_copy_));
  exports.Set("atg_index_put_", Napi::Function::New(env__, atg_index_put_));
  exports.Set("atg_index_put", Napi::Function::New(env__, atg_index_put));
  exports.Set("atg_index_put_out", Napi::Function::New(env__, atg_index_put_out));
  exports.Set("atg__index_put_impl_", Napi::Function::New(env__, atg__index_put_impl_));
  exports.Set("atg_instance_norm", Napi::Function::New(env__, atg_instance_norm));
  exports.Set("atg_isclose", Napi::Function::New(env__, atg_isclose));
  exports.Set("atg_isin", Napi::Function::New(env__, atg_isin));
  exports.Set("atg_isin_tensor_scalar", Napi::Function::New(env__, atg_isin_tensor_scalar));
  exports.Set("atg_isin_scalar_tensor", Napi::Function::New(env__, atg_isin_scalar_tensor));
  exports.Set("atg_isin_tensor_tensor_out", Napi::Function::New(env__, atg_isin_tensor_tensor_out));
  exports.Set("atg_isin_tensor_scalar_out", Napi::Function::New(env__, atg_isin_tensor_scalar_out));
  exports.Set("atg_isin_scalar_tensor_out", Napi::Function::New(env__, atg_isin_scalar_tensor_out));
  exports.Set("atg_isnan", Napi::Function::New(env__, atg_isnan));
  exports.Set("atg_isnan_out", Napi::Function::New(env__, atg_isnan_out));
  exports.Set("atg_is_distributed", Napi::Function::New(env__, atg_is_distributed));
  exports.Set("atg_is_floating_point", Napi::Function::New(env__, atg_is_floating_point));
  exports.Set("atg_is_complex", Napi::Function::New(env__, atg_is_complex));
  exports.Set("atg_is_conj", Napi::Function::New(env__, atg_is_conj));
  exports.Set("atg__is_zerotensor", Napi::Function::New(env__, atg__is_zerotensor));
  exports.Set("atg_is_neg", Napi::Function::New(env__, atg_is_neg));
  exports.Set("atg_isreal", Napi::Function::New(env__, atg_isreal));
  exports.Set("atg_is_nonzero", Napi::Function::New(env__, atg_is_nonzero));
  exports.Set("atg_is_same_size", Napi::Function::New(env__, atg_is_same_size));
  exports.Set("atg_is_signed", Napi::Function::New(env__, atg_is_signed));
  exports.Set("atg_is_inference", Napi::Function::New(env__, atg_is_inference));
  exports.Set("atg_kl_div", Napi::Function::New(env__, atg_kl_div));
  exports.Set("atg_kron", Napi::Function::New(env__, atg_kron));
  exports.Set("atg_kron_out", Napi::Function::New(env__, atg_kron_out));
  exports.Set("atg_kthvalue", Napi::Function::New(env__, atg_kthvalue));
  exports.Set("atg_kthvalue_values", Napi::Function::New(env__, atg_kthvalue_values));
  exports.Set("atg_layer_norm", Napi::Function::New(env__, atg_layer_norm));
  exports.Set("atg_native_layer_norm", Napi::Function::New(env__, atg_native_layer_norm));
  exports.Set("atg_native_layer_norm_out", Napi::Function::New(env__, atg_native_layer_norm_out));
  exports.Set("atg_nan_to_num", Napi::Function::New(env__, atg_nan_to_num));
  exports.Set("atg_nan_to_num_out", Napi::Function::New(env__, atg_nan_to_num_out));
  exports.Set("atg_nan_to_num_", Napi::Function::New(env__, atg_nan_to_num_));
  exports.Set("atg_linear", Napi::Function::New(env__, atg_linear));
  exports.Set("atg_linear_out", Napi::Function::New(env__, atg_linear_out));
  exports.Set("atg_mkldnn_linear", Napi::Function::New(env__, atg_mkldnn_linear));
  exports.Set("atg_mkldnn_linear_out", Napi::Function::New(env__, atg_mkldnn_linear_out));
  exports.Set("atg_mkldnn_linear_backward_input", Napi::Function::New(env__, atg_mkldnn_linear_backward_input));
  exports.Set("atg_mkldnn_linear_backward_input_out", Napi::Function::New(env__, atg_mkldnn_linear_backward_input_out));
  exports.Set("atg_mkldnn_linear_backward_weights", Napi::Function::New(env__, atg_mkldnn_linear_backward_weights));
  exports.Set("atg_mkldnn_linear_backward_weights_out", Napi::Function::New(env__, atg_mkldnn_linear_backward_weights_out));
  exports.Set("atg_fbgemm_linear_int8_weight_fp32_activation", Napi::Function::New(env__, atg_fbgemm_linear_int8_weight_fp32_activation));
  exports.Set("atg_fbgemm_linear_int8_weight", Napi::Function::New(env__, atg_fbgemm_linear_int8_weight));
  exports.Set("atg_fbgemm_pack_gemm_matrix_fp16", Napi::Function::New(env__, atg_fbgemm_pack_gemm_matrix_fp16));
  exports.Set("atg_fbgemm_linear_fp16_weight_fp32_activation", Napi::Function::New(env__, atg_fbgemm_linear_fp16_weight_fp32_activation));
  exports.Set("atg_fbgemm_linear_fp16_weight", Napi::Function::New(env__, atg_fbgemm_linear_fp16_weight));
  exports.Set("atg_fbgemm_pack_quantized_matrix", Napi::Function::New(env__, atg_fbgemm_pack_quantized_matrix));
  exports.Set("atg_fbgemm_pack_quantized_matrix_kn", Napi::Function::New(env__, atg_fbgemm_pack_quantized_matrix_kn));
  exports.Set("atg_ldexp", Napi::Function::New(env__, atg_ldexp));
  exports.Set("atg_ldexp_out", Napi::Function::New(env__, atg_ldexp_out));
  exports.Set("atg_ldexp_", Napi::Function::New(env__, atg_ldexp_));
  exports.Set("atg_linspace", Napi::Function::New(env__, atg_linspace));
  exports.Set("atg_linspace_out", Napi::Function::New(env__, atg_linspace_out));
  exports.Set("atg_log", Napi::Function::New(env__, atg_log));
  exports.Set("atg_log_out", Napi::Function::New(env__, atg_log_out));
  exports.Set("atg_log_", Napi::Function::New(env__, atg_log_));
  exports.Set("atg_log10", Napi::Function::New(env__, atg_log10));
  exports.Set("atg_log10_out", Napi::Function::New(env__, atg_log10_out));
  exports.Set("atg_log10_", Napi::Function::New(env__, atg_log10_));
  exports.Set("atg_log1p", Napi::Function::New(env__, atg_log1p));
  exports.Set("atg_log1p_out", Napi::Function::New(env__, atg_log1p_out));
  exports.Set("atg_log1p_", Napi::Function::New(env__, atg_log1p_));
  exports.Set("atg_log2", Napi::Function::New(env__, atg_log2));
  exports.Set("atg_log2_out", Napi::Function::New(env__, atg_log2_out));
  exports.Set("atg_log2_", Napi::Function::New(env__, atg_log2_));
  exports.Set("atg_logaddexp", Napi::Function::New(env__, atg_logaddexp));
  exports.Set("atg_logaddexp_out", Napi::Function::New(env__, atg_logaddexp_out));
  exports.Set("atg_logaddexp2", Napi::Function::New(env__, atg_logaddexp2));
  exports.Set("atg_logaddexp2_out", Napi::Function::New(env__, atg_logaddexp2_out));
  exports.Set("atg_xlogy", Napi::Function::New(env__, atg_xlogy));
  exports.Set("atg_xlogy_scalar_self", Napi::Function::New(env__, atg_xlogy_scalar_self));
  exports.Set("atg_xlogy_scalar_other", Napi::Function::New(env__, atg_xlogy_scalar_other));
  exports.Set("atg_xlogy_outtensor", Napi::Function::New(env__, atg_xlogy_outtensor));
  exports.Set("atg_xlogy_outscalar_self", Napi::Function::New(env__, atg_xlogy_outscalar_self));
  exports.Set("atg_xlogy_outscalar_other", Napi::Function::New(env__, atg_xlogy_outscalar_other));
  exports.Set("atg_xlogy_", Napi::Function::New(env__, atg_xlogy_));
  exports.Set("atg_xlogy_scalar_other_", Napi::Function::New(env__, atg_xlogy_scalar_other_));
  exports.Set("atg_logspace", Napi::Function::New(env__, atg_logspace));
  exports.Set("atg_logspace_out", Napi::Function::New(env__, atg_logspace_out));
  exports.Set("atg_log_softmax", Napi::Function::New(env__, atg_log_softmax));
  exports.Set("atg_log_softmax_int_out", Napi::Function::New(env__, atg_log_softmax_int_out));
  exports.Set("atg__log_softmax", Napi::Function::New(env__, atg__log_softmax));
  exports.Set("atg__log_softmax_out", Napi::Function::New(env__, atg__log_softmax_out));
  exports.Set("atg__log_softmax_backward_data", Napi::Function::New(env__, atg__log_softmax_backward_data));
  exports.Set("atg__log_softmax_backward_data_out", Napi::Function::New(env__, atg__log_softmax_backward_data_out));
  exports.Set("atg__logcumsumexp", Napi::Function::New(env__, atg__logcumsumexp));
  exports.Set("atg__logcumsumexp_out", Napi::Function::New(env__, atg__logcumsumexp_out));
  exports.Set("atg_logcumsumexp", Napi::Function::New(env__, atg_logcumsumexp));
  exports.Set("atg_logcumsumexp_out", Napi::Function::New(env__, atg_logcumsumexp_out));
  exports.Set("atg_logsumexp", Napi::Function::New(env__, atg_logsumexp));
  exports.Set("atg_logsumexp_out", Napi::Function::New(env__, atg_logsumexp_out));
  exports.Set("atg_margin_ranking_loss", Napi::Function::New(env__, atg_margin_ranking_loss));
  exports.Set("atg_matmul", Napi::Function::New(env__, atg_matmul));
  exports.Set("atg_matmul_out", Napi::Function::New(env__, atg_matmul_out));
  exports.Set("atg_matrix_power", Napi::Function::New(env__, atg_matrix_power));
  exports.Set("atg_matrix_power_out", Napi::Function::New(env__, atg_matrix_power_out));
  exports.Set("atg_matrix_exp", Napi::Function::New(env__, atg_matrix_exp));
  exports.Set("atg_matrix_exp_backward", Napi::Function::New(env__, atg_matrix_exp_backward));
  exports.Set("atg__aminmax", Napi::Function::New(env__, atg__aminmax));
  exports.Set("atg__aminmax_dim", Napi::Function::New(env__, atg__aminmax_dim));
  exports.Set("atg__aminmax_out", Napi::Function::New(env__, atg__aminmax_out));
  exports.Set("atg__aminmax_dim_out", Napi::Function::New(env__, atg__aminmax_dim_out));
  exports.Set("atg_aminmax", Napi::Function::New(env__, atg_aminmax));
  exports.Set("atg_aminmax_out", Napi::Function::New(env__, atg_aminmax_out));
  exports.Set("atg__compute_linear_combination", Napi::Function::New(env__, atg__compute_linear_combination));
  exports.Set("atg__compute_linear_combination_out", Napi::Function::New(env__, atg__compute_linear_combination_out));
  exports.Set("atg_max", Napi::Function::New(env__, atg_max));
  exports.Set("atg_max_other", Napi::Function::New(env__, atg_max_other));
  exports.Set("atg_max_dim", Napi::Function::New(env__, atg_max_dim));
  exports.Set("atg_max_unary_out", Napi::Function::New(env__, atg_max_unary_out));
  exports.Set("atg_max_out", Napi::Function::New(env__, atg_max_out));
  exports.Set("atg_max_dim_max", Napi::Function::New(env__, atg_max_dim_max));
  exports.Set("atg_value_selecting_reduction_backward", Napi::Function::New(env__, atg_value_selecting_reduction_backward));
  exports.Set("atg_amax", Napi::Function::New(env__, atg_amax));
  exports.Set("atg_amax_out", Napi::Function::New(env__, atg_amax_out));
  exports.Set("atg_max_pool1d_with_indices", Napi::Function::New(env__, atg_max_pool1d_with_indices));
  exports.Set("atg_max_pool1d", Napi::Function::New(env__, atg_max_pool1d));
  exports.Set("atg_max_pool2d", Napi::Function::New(env__, atg_max_pool2d));
  exports.Set("atg_max_pool2d_backward", Napi::Function::New(env__, atg_max_pool2d_backward));
  exports.Set("atg_max_pool2d_backward_out", Napi::Function::New(env__, atg_max_pool2d_backward_out));
  exports.Set("atg_mkldnn_max_pool2d", Napi::Function::New(env__, atg_mkldnn_max_pool2d));
  exports.Set("atg_mkldnn_max_pool2d_out", Napi::Function::New(env__, atg_mkldnn_max_pool2d_out));
  exports.Set("atg_mkldnn_max_pool2d_backward", Napi::Function::New(env__, atg_mkldnn_max_pool2d_backward));
  exports.Set("atg_mkldnn_max_pool2d_backward_out", Napi::Function::New(env__, atg_mkldnn_max_pool2d_backward_out));
  exports.Set("atg_mkldnn_max_pool3d", Napi::Function::New(env__, atg_mkldnn_max_pool3d));
  exports.Set("atg_mkldnn_max_pool3d_out", Napi::Function::New(env__, atg_mkldnn_max_pool3d_out));
  exports.Set("atg_mkldnn_max_pool3d_backward", Napi::Function::New(env__, atg_mkldnn_max_pool3d_backward));
  exports.Set("atg_mkldnn_max_pool3d_backward_out", Napi::Function::New(env__, atg_mkldnn_max_pool3d_backward_out));
  exports.Set("atg_quantized_max_pool1d", Napi::Function::New(env__, atg_quantized_max_pool1d));
  exports.Set("atg_quantized_max_pool1d_out", Napi::Function::New(env__, atg_quantized_max_pool1d_out));
  exports.Set("atg_quantized_max_pool2d", Napi::Function::New(env__, atg_quantized_max_pool2d));
  exports.Set("atg_quantized_max_pool2d_out", Napi::Function::New(env__, atg_quantized_max_pool2d_out));
  exports.Set("atg_max_pool3d", Napi::Function::New(env__, atg_max_pool3d));
  exports.Set("atg_mean", Napi::Function::New(env__, atg_mean));
  exports.Set("atg_mean_dim", Napi::Function::New(env__, atg_mean_dim));
  exports.Set("atg_mean_out", Napi::Function::New(env__, atg_mean_out));
  exports.Set("atg_nanmean", Napi::Function::New(env__, atg_nanmean));
  exports.Set("atg_nanmean_out", Napi::Function::New(env__, atg_nanmean_out));
  exports.Set("atg_median", Napi::Function::New(env__, atg_median));
  exports.Set("atg_median_dim", Napi::Function::New(env__, atg_median_dim));
  exports.Set("atg_median_out", Napi::Function::New(env__, atg_median_out));
  exports.Set("atg_median_dim_values", Napi::Function::New(env__, atg_median_dim_values));
  exports.Set("atg_nanmedian", Napi::Function::New(env__, atg_nanmedian));
  exports.Set("atg_nanmedian_dim", Napi::Function::New(env__, atg_nanmedian_dim));
  exports.Set("atg_nanmedian_out", Napi::Function::New(env__, atg_nanmedian_out));
  exports.Set("atg_nanmedian_dim_values", Napi::Function::New(env__, atg_nanmedian_dim_values));
  exports.Set("atg_min", Napi::Function::New(env__, atg_min));
  exports.Set("atg_min_other", Napi::Function::New(env__, atg_min_other));
  exports.Set("atg_min_dim", Napi::Function::New(env__, atg_min_dim));
  exports.Set("atg_min_out", Napi::Function::New(env__, atg_min_out));
  exports.Set("atg_min_dim_min", Napi::Function::New(env__, atg_min_dim_min));
  exports.Set("atg_amin", Napi::Function::New(env__, atg_amin));
  exports.Set("atg_amin_out", Napi::Function::New(env__, atg_amin_out));
  exports.Set("atg__mps_convolution", Napi::Function::New(env__, atg__mps_convolution));
  exports.Set("atg__mps_convolution_out", Napi::Function::New(env__, atg__mps_convolution_out));
  exports.Set("atg_mkldnn_convolution", Napi::Function::New(env__, atg_mkldnn_convolution));
  exports.Set("atg_mkldnn_convolution_out", Napi::Function::New(env__, atg_mkldnn_convolution_out));
  exports.Set("atg_mkldnn_rnn_layer", Napi::Function::New(env__, atg_mkldnn_rnn_layer));
  exports.Set("atg_mkldnn_rnn_layer_out", Napi::Function::New(env__, atg_mkldnn_rnn_layer_out));
  exports.Set("atg_mkldnn_rnn_layer_backward", Napi::Function::New(env__, atg_mkldnn_rnn_layer_backward));
  exports.Set("atg_mkldnn_rnn_layer_backward_out", Napi::Function::New(env__, atg_mkldnn_rnn_layer_backward_out));
  exports.Set("atg_miopen_batch_norm", Napi::Function::New(env__, atg_miopen_batch_norm));
  exports.Set("atg_miopen_batch_norm_out", Napi::Function::New(env__, atg_miopen_batch_norm_out));
  exports.Set("atg_miopen_batch_norm_backward", Napi::Function::New(env__, atg_miopen_batch_norm_backward));
  exports.Set("atg_miopen_batch_norm_backward_out", Napi::Function::New(env__, atg_miopen_batch_norm_backward_out));
  exports.Set("atg_miopen_convolution", Napi::Function::New(env__, atg_miopen_convolution));
  exports.Set("atg_miopen_convolution_out", Napi::Function::New(env__, atg_miopen_convolution_out));
  exports.Set("atg_miopen_convolution_transpose", Napi::Function::New(env__, atg_miopen_convolution_transpose));
  exports.Set("atg_miopen_convolution_transpose_out", Napi::Function::New(env__, atg_miopen_convolution_transpose_out));
  exports.Set("atg_miopen_depthwise_convolution", Napi::Function::New(env__, atg_miopen_depthwise_convolution));
  exports.Set("atg_miopen_depthwise_convolution_out", Napi::Function::New(env__, atg_miopen_depthwise_convolution_out));
  exports.Set("atg_miopen_convolution_relu", Napi::Function::New(env__, atg_miopen_convolution_relu));
  exports.Set("atg_miopen_convolution_add_relu", Napi::Function::New(env__, atg_miopen_convolution_add_relu));
  exports.Set("atg_miopen_rnn", Napi::Function::New(env__, atg_miopen_rnn));
  exports.Set("atg_miopen_rnn_out", Napi::Function::New(env__, atg_miopen_rnn_out));
  exports.Set("atg_mm", Napi::Function::New(env__, atg_mm));
  exports.Set("atg_mm_out", Napi::Function::New(env__, atg_mm_out));
  exports.Set("atg__sparse_mm", Napi::Function::New(env__, atg__sparse_mm));
  exports.Set("atg__sparse_mm_reduce", Napi::Function::New(env__, atg__sparse_mm_reduce));
  exports.Set("atg__sparse_sparse_matmul", Napi::Function::New(env__, atg__sparse_sparse_matmul));
  exports.Set("atg__sparse_sparse_matmul_out", Napi::Function::New(env__, atg__sparse_sparse_matmul_out));
  exports.Set("atg_mode", Napi::Function::New(env__, atg_mode));
  exports.Set("atg_mode_values", Napi::Function::New(env__, atg_mode_values));
  exports.Set("atg_mul", Napi::Function::New(env__, atg_mul));
  exports.Set("atg_mul_scalar", Napi::Function::New(env__, atg_mul_scalar));
  exports.Set("atg_mul_out", Napi::Function::New(env__, atg_mul_out));
  exports.Set("atg_mul_scalar_out", Napi::Function::New(env__, atg_mul_scalar_out));
  exports.Set("atg_mul_", Napi::Function::New(env__, atg_mul_));
  exports.Set("atg_mul_scalar_", Napi::Function::New(env__, atg_mul_scalar_));
  exports.Set("atg_multiply", Napi::Function::New(env__, atg_multiply));
  exports.Set("atg_multiply_scalar", Napi::Function::New(env__, atg_multiply_scalar));
  exports.Set("atg_multiply_out", Napi::Function::New(env__, atg_multiply_out));
  exports.Set("atg_multiply_", Napi::Function::New(env__, atg_multiply_));
  exports.Set("atg_multiply_scalar_", Napi::Function::New(env__, atg_multiply_scalar_));
  exports.Set("atg_mv", Napi::Function::New(env__, atg_mv));
  exports.Set("atg_mv_out", Napi::Function::New(env__, atg_mv_out));
  exports.Set("atg_mvlgamma", Napi::Function::New(env__, atg_mvlgamma));
  exports.Set("atg_mvlgamma_out", Napi::Function::New(env__, atg_mvlgamma_out));
  exports.Set("atg_mvlgamma_", Napi::Function::New(env__, atg_mvlgamma_));
  exports.Set("atg_narrow_copy", Napi::Function::New(env__, atg_narrow_copy));
  exports.Set("atg_narrow_copy_out", Napi::Function::New(env__, atg_narrow_copy_out));
  exports.Set("atg_narrow", Napi::Function::New(env__, atg_narrow));
  exports.Set("atg_narrow_tensor", Napi::Function::New(env__, atg_narrow_tensor));
  exports.Set("atg_native_batch_norm", Napi::Function::New(env__, atg_native_batch_norm));
  exports.Set("atg_native_batch_norm_out", Napi::Function::New(env__, atg_native_batch_norm_out));
  exports.Set("atg__native_batch_norm_legit_no_stats", Napi::Function::New(env__, atg__native_batch_norm_legit_no_stats));
  exports.Set("atg__native_batch_norm_legit", Napi::Function::New(env__, atg__native_batch_norm_legit));
  exports.Set("atg__native_batch_norm_legit_no_stats_out", Napi::Function::New(env__, atg__native_batch_norm_legit_no_stats_out));
  exports.Set("atg__native_batch_norm_legit_out", Napi::Function::New(env__, atg__native_batch_norm_legit_out));
  exports.Set("atg_batch_norm_stats", Napi::Function::New(env__, atg_batch_norm_stats));
  exports.Set("atg_batch_norm_stats_out", Napi::Function::New(env__, atg_batch_norm_stats_out));
  exports.Set("atg_batch_norm_elemt", Napi::Function::New(env__, atg_batch_norm_elemt));
  exports.Set("atg_batch_norm_elemt_out", Napi::Function::New(env__, atg_batch_norm_elemt_out));
  exports.Set("atg_batch_norm_gather_stats", Napi::Function::New(env__, atg_batch_norm_gather_stats));
  exports.Set("atg_batch_norm_gather_stats_out", Napi::Function::New(env__, atg_batch_norm_gather_stats_out));
  exports.Set("atg_batch_norm_gather_stats_with_counts", Napi::Function::New(env__, atg_batch_norm_gather_stats_with_counts));
  exports.Set("atg_batch_norm_gather_stats_with_counts_out", Napi::Function::New(env__, atg_batch_norm_gather_stats_with_counts_out));
  exports.Set("atg_batch_norm_backward_reduce", Napi::Function::New(env__, atg_batch_norm_backward_reduce));
  exports.Set("atg_batch_norm_backward_reduce_out", Napi::Function::New(env__, atg_batch_norm_backward_reduce_out));
  exports.Set("atg_batch_norm_backward_elemt", Napi::Function::New(env__, atg_batch_norm_backward_elemt));
  exports.Set("atg_batch_norm_backward_elemt_out", Napi::Function::New(env__, atg_batch_norm_backward_elemt_out));
  exports.Set("atg_batch_norm_update_stats", Napi::Function::New(env__, atg_batch_norm_update_stats));
  exports.Set("atg_batch_norm_update_stats_out", Napi::Function::New(env__, atg_batch_norm_update_stats_out));
  exports.Set("atg_is_vulkan_available", Napi::Function::New(env__, atg_is_vulkan_available));
  exports.Set("atg__nnpack_available", Napi::Function::New(env__, atg__nnpack_available));
  exports.Set("atg__nnpack_spatial_convolution", Napi::Function::New(env__, atg__nnpack_spatial_convolution));
  exports.Set("atg__nnpack_spatial_convolution_out", Napi::Function::New(env__, atg__nnpack_spatial_convolution_out));
  exports.Set("atg_ones", Napi::Function::New(env__, atg_ones));
  exports.Set("atg_ones_out", Napi::Function::New(env__, atg_ones_out));
  exports.Set("atg_ones_like", Napi::Function::New(env__, atg_ones_like));
  exports.Set("atg_ones_like_out", Napi::Function::New(env__, atg_ones_like_out));
  exports.Set("atg_pairwise_distance", Napi::Function::New(env__, atg_pairwise_distance));
  exports.Set("atg_cdist", Napi::Function::New(env__, atg_cdist));
  exports.Set("atg__euclidean_dist", Napi::Function::New(env__, atg__euclidean_dist));
  exports.Set("atg__euclidean_dist_out", Napi::Function::New(env__, atg__euclidean_dist_out));
  exports.Set("atg__cdist_backward", Napi::Function::New(env__, atg__cdist_backward));
  exports.Set("atg__cdist_backward_out", Napi::Function::New(env__, atg__cdist_backward_out));
  exports.Set("atg_pdist", Napi::Function::New(env__, atg_pdist));
  exports.Set("atg__pdist_backward", Napi::Function::New(env__, atg__pdist_backward));
  exports.Set("atg__pdist_backward_out", Napi::Function::New(env__, atg__pdist_backward_out));
  exports.Set("atg_cosine_similarity", Napi::Function::New(env__, atg_cosine_similarity));
  exports.Set("atg_permute", Napi::Function::New(env__, atg_permute));
  exports.Set("atg_movedim", Napi::Function::New(env__, atg_movedim));
  exports.Set("atg_movedim_int", Napi::Function::New(env__, atg_movedim_int));
  exports.Set("atg_moveaxis", Napi::Function::New(env__, atg_moveaxis));
  exports.Set("atg_moveaxis_int", Napi::Function::New(env__, atg_moveaxis_int));
  exports.Set("atg_numpy_T", Napi::Function::New(env__, atg_numpy_T));
  exports.Set("atg_matrix_H", Napi::Function::New(env__, atg_matrix_H));
  exports.Set("atg_mT", Napi::Function::New(env__, atg_mT));
  exports.Set("atg_mH", Napi::Function::New(env__, atg_mH));
  exports.Set("atg_adjoint", Napi::Function::New(env__, atg_adjoint));
  exports.Set("atg_pixel_shuffle", Napi::Function::New(env__, atg_pixel_shuffle));
  exports.Set("atg_pixel_shuffle_out", Napi::Function::New(env__, atg_pixel_shuffle_out));
  exports.Set("atg_pixel_unshuffle", Napi::Function::New(env__, atg_pixel_unshuffle));
  exports.Set("atg_pixel_unshuffle_out", Napi::Function::New(env__, atg_pixel_unshuffle_out));
  exports.Set("atg_channel_shuffle", Napi::Function::New(env__, atg_channel_shuffle));
  exports.Set("atg_channel_shuffle_out", Napi::Function::New(env__, atg_channel_shuffle_out));
  exports.Set("atg_native_channel_shuffle", Napi::Function::New(env__, atg_native_channel_shuffle));
  exports.Set("atg_is_pinned", Napi::Function::New(env__, atg_is_pinned));
  exports.Set("atg_pin_memory", Napi::Function::New(env__, atg_pin_memory));
  exports.Set("atg__pin_memory", Napi::Function::New(env__, atg__pin_memory));
  exports.Set("atg__pin_memory_out", Napi::Function::New(env__, atg__pin_memory_out));
  exports.Set("atg_pinverse", Napi::Function::New(env__, atg_pinverse));
  exports.Set("atg_poisson_nll_loss", Napi::Function::New(env__, atg_poisson_nll_loss));
  exports.Set("atg_rad2deg", Napi::Function::New(env__, atg_rad2deg));
  exports.Set("atg_rad2deg_out", Napi::Function::New(env__, atg_rad2deg_out));
  exports.Set("atg_rad2deg_", Napi::Function::New(env__, atg_rad2deg_));
  exports.Set("atg_deg2rad", Napi::Function::New(env__, atg_deg2rad));
  exports.Set("atg_deg2rad_out", Napi::Function::New(env__, atg_deg2rad_out));
  exports.Set("atg_deg2rad_", Napi::Function::New(env__, atg_deg2rad_));
  exports.Set("atg_scalar_tensor", Napi::Function::New(env__, atg_scalar_tensor));
  exports.Set("atg_scalar_tensor_out", Napi::Function::New(env__, atg_scalar_tensor_out));
  exports.Set("atg_rand", Napi::Function::New(env__, atg_rand));
  exports.Set("atg_rand_out", Napi::Function::New(env__, atg_rand_out));
  exports.Set("atg_rand_like", Napi::Function::New(env__, atg_rand_like));
  exports.Set("atg_rand_like_out", Napi::Function::New(env__, atg_rand_like_out));
  exports.Set("atg_randint", Napi::Function::New(env__, atg_randint));
  exports.Set("atg_randint_low", Napi::Function::New(env__, atg_randint_low));
  exports.Set("atg_randint_out", Napi::Function::New(env__, atg_randint_out));
  exports.Set("atg_randint_low_out", Napi::Function::New(env__, atg_randint_low_out));
  exports.Set("atg_randint_like", Napi::Function::New(env__, atg_randint_like));
  exports.Set("atg_randint_like_low_dtype", Napi::Function::New(env__, atg_randint_like_low_dtype));
  exports.Set("atg_randint_like_out", Napi::Function::New(env__, atg_randint_like_out));
  exports.Set("atg_randint_like_low_dtype_out", Napi::Function::New(env__, atg_randint_like_low_dtype_out));
  exports.Set("atg_randn", Napi::Function::New(env__, atg_randn));
  exports.Set("atg_randn_out", Napi::Function::New(env__, atg_randn_out));
  exports.Set("atg_randn_like", Napi::Function::New(env__, atg_randn_like));
  exports.Set("atg_randn_like_out", Napi::Function::New(env__, atg_randn_like_out));
  exports.Set("atg_randperm", Napi::Function::New(env__, atg_randperm));
  exports.Set("atg_randperm_out", Napi::Function::New(env__, atg_randperm_out));
  exports.Set("atg_range", Napi::Function::New(env__, atg_range));
  exports.Set("atg_range_step", Napi::Function::New(env__, atg_range_step));
  exports.Set("atg_range_out_", Napi::Function::New(env__, atg_range_out_));
  exports.Set("atg_range_out", Napi::Function::New(env__, atg_range_out));
  exports.Set("atg_ravel", Napi::Function::New(env__, atg_ravel));
  exports.Set("atg_reciprocal", Napi::Function::New(env__, atg_reciprocal));
  exports.Set("atg_reciprocal_out", Napi::Function::New(env__, atg_reciprocal_out));
  exports.Set("atg_reciprocal_", Napi::Function::New(env__, atg_reciprocal_));
  exports.Set("atg_neg", Napi::Function::New(env__, atg_neg));
  exports.Set("atg_neg_out", Napi::Function::New(env__, atg_neg_out));
  exports.Set("atg_neg_", Napi::Function::New(env__, atg_neg_));
  exports.Set("atg_negative", Napi::Function::New(env__, atg_negative));
  exports.Set("atg_negative_out", Napi::Function::New(env__, atg_negative_out));
  exports.Set("atg_negative_", Napi::Function::New(env__, atg_negative_));
  exports.Set("atg_repeat", Napi::Function::New(env__, atg_repeat));
  exports.Set("atg_repeat_out", Napi::Function::New(env__, atg_repeat_out));
  exports.Set("atg_repeat_interleave", Napi::Function::New(env__, atg_repeat_interleave));
  exports.Set("atg_repeat_interleave_self_tensor", Napi::Function::New(env__, atg_repeat_interleave_self_tensor));
  exports.Set("atg_repeat_interleave_self_int", Napi::Function::New(env__, atg_repeat_interleave_self_int));
  exports.Set("atg_repeat_interleave_tensor_out", Napi::Function::New(env__, atg_repeat_interleave_tensor_out));
  exports.Set("atg_reshape", Napi::Function::New(env__, atg_reshape));
  exports.Set("atg__reshape_copy", Napi::Function::New(env__, atg__reshape_copy));
  exports.Set("atg__reshape_alias", Napi::Function::New(env__, atg__reshape_alias));
  exports.Set("atg__mkldnn_reshape", Napi::Function::New(env__, atg__mkldnn_reshape));
  exports.Set("atg__mkldnn_reshape_out", Napi::Function::New(env__, atg__mkldnn_reshape_out));
  exports.Set("atg_reshape_as", Napi::Function::New(env__, atg_reshape_as));
  exports.Set("atg_round", Napi::Function::New(env__, atg_round));
  exports.Set("atg_round_decimals", Napi::Function::New(env__, atg_round_decimals));
  exports.Set("atg_round_out", Napi::Function::New(env__, atg_round_out));
  exports.Set("atg_round_decimals_out", Napi::Function::New(env__, atg_round_decimals_out));
  exports.Set("atg_round_", Napi::Function::New(env__, atg_round_));
  exports.Set("atg_round_decimals_", Napi::Function::New(env__, atg_round_decimals_));
  exports.Set("atg_rrelu", Napi::Function::New(env__, atg_rrelu));
  exports.Set("atg_rrelu_", Napi::Function::New(env__, atg_rrelu_));
  exports.Set("atg_relu", Napi::Function::New(env__, atg_relu));
  exports.Set("atg_relu_out", Napi::Function::New(env__, atg_relu_out));
  exports.Set("atg_relu_", Napi::Function::New(env__, atg_relu_));
  exports.Set("atg_relu6", Napi::Function::New(env__, atg_relu6));
  exports.Set("atg_relu6_", Napi::Function::New(env__, atg_relu6_));
  exports.Set("atg_prelu", Napi::Function::New(env__, atg_prelu));
  exports.Set("atg__prelu_kernel", Napi::Function::New(env__, atg__prelu_kernel));
  exports.Set("atg__prelu_kernel_backward", Napi::Function::New(env__, atg__prelu_kernel_backward));
  exports.Set("atg_gelu", Napi::Function::New(env__, atg_gelu));
  exports.Set("atg_gelu_out", Napi::Function::New(env__, atg_gelu_out));
  exports.Set("atg_gelu_", Napi::Function::New(env__, atg_gelu_));
  exports.Set("atg_gelu_backward", Napi::Function::New(env__, atg_gelu_backward));
  exports.Set("atg_gelu_backward_grad_input", Napi::Function::New(env__, atg_gelu_backward_grad_input));
  exports.Set("atg_infinitely_differentiable_gelu_backward", Napi::Function::New(env__, atg_infinitely_differentiable_gelu_backward));
  exports.Set("atg_hardshrink", Napi::Function::New(env__, atg_hardshrink));
  exports.Set("atg_hardshrink_out", Napi::Function::New(env__, atg_hardshrink_out));
  exports.Set("atg_hardshrink_backward", Napi::Function::New(env__, atg_hardshrink_backward));
  exports.Set("atg_hardshrink_backward_grad_input", Napi::Function::New(env__, atg_hardshrink_backward_grad_input));
  exports.Set("atg_rsqrt", Napi::Function::New(env__, atg_rsqrt));
  exports.Set("atg_rsqrt_out", Napi::Function::New(env__, atg_rsqrt_out));
  exports.Set("atg_rsqrt_", Napi::Function::New(env__, atg_rsqrt_));
  exports.Set("atg_select", Napi::Function::New(env__, atg_select));
  exports.Set("atg_select_backward", Napi::Function::New(env__, atg_select_backward));
  exports.Set("atg_select_backward_out", Napi::Function::New(env__, atg_select_backward_out));
  exports.Set("atg__nested_select_backward", Napi::Function::New(env__, atg__nested_select_backward));
  exports.Set("atg_selu", Napi::Function::New(env__, atg_selu));
  exports.Set("atg_selu_", Napi::Function::New(env__, atg_selu_));
  exports.Set("atg_celu", Napi::Function::New(env__, atg_celu));
  exports.Set("atg_celu_out", Napi::Function::New(env__, atg_celu_out));
  exports.Set("atg_celu_", Napi::Function::New(env__, atg_celu_));
  exports.Set("atg_silu", Napi::Function::New(env__, atg_silu));
  exports.Set("atg_silu_out", Napi::Function::New(env__, atg_silu_out));
  exports.Set("atg_silu_", Napi::Function::New(env__, atg_silu_));
  exports.Set("atg_silu_backward", Napi::Function::New(env__, atg_silu_backward));
  exports.Set("atg_silu_backward_grad_input", Napi::Function::New(env__, atg_silu_backward_grad_input));
  exports.Set("atg_mish", Napi::Function::New(env__, atg_mish));
  exports.Set("atg_mish_out", Napi::Function::New(env__, atg_mish_out));
  exports.Set("atg_mish_", Napi::Function::New(env__, atg_mish_));
  exports.Set("atg_mish_backward", Napi::Function::New(env__, atg_mish_backward));
  exports.Set("atg_sigmoid", Napi::Function::New(env__, atg_sigmoid));
  exports.Set("atg_sigmoid_out", Napi::Function::New(env__, atg_sigmoid_out));
  exports.Set("atg_sigmoid_", Napi::Function::New(env__, atg_sigmoid_));
  exports.Set("atg_logit", Napi::Function::New(env__, atg_logit));
  exports.Set("atg_logit_out", Napi::Function::New(env__, atg_logit_out));
  exports.Set("atg_logit_", Napi::Function::New(env__, atg_logit_));
  exports.Set("atg_sin", Napi::Function::New(env__, atg_sin));
  exports.Set("atg_sin_out", Napi::Function::New(env__, atg_sin_out));
  exports.Set("atg_sin_", Napi::Function::New(env__, atg_sin_));
  exports.Set("atg_sinc", Napi::Function::New(env__, atg_sinc));
  exports.Set("atg_sinc_out", Napi::Function::New(env__, atg_sinc_out));
  exports.Set("atg_sinc_", Napi::Function::New(env__, atg_sinc_));
  exports.Set("atg_sinh", Napi::Function::New(env__, atg_sinh));
  exports.Set("atg_sinh_out", Napi::Function::New(env__, atg_sinh_out));
  exports.Set("atg_sinh_", Napi::Function::New(env__, atg_sinh_));
  exports.Set("atg_detach", Napi::Function::New(env__, atg_detach));
  exports.Set("atg_detach_", Napi::Function::New(env__, atg_detach_));
  exports.Set("atg_slice", Napi::Function::New(env__, atg_slice));
  exports.Set("atg_slice_backward", Napi::Function::New(env__, atg_slice_backward));
  exports.Set("atg_slice_backward_out", Napi::Function::New(env__, atg_slice_backward_out));
  exports.Set("atg_slice_scatter", Napi::Function::New(env__, atg_slice_scatter));
  exports.Set("atg_slice_scatter_out", Napi::Function::New(env__, atg_slice_scatter_out));
  exports.Set("atg_select_scatter", Napi::Function::New(env__, atg_select_scatter));
  exports.Set("atg_select_scatter_out", Napi::Function::New(env__, atg_select_scatter_out));
  exports.Set("atg_diagonal_scatter", Napi::Function::New(env__, atg_diagonal_scatter));
  exports.Set("atg_diagonal_scatter_out", Napi::Function::New(env__, atg_diagonal_scatter_out));
  exports.Set("atg_as_strided_scatter", Napi::Function::New(env__, atg_as_strided_scatter));
  exports.Set("atg_as_strided_scatter_out", Napi::Function::New(env__, atg_as_strided_scatter_out));
  exports.Set("atg_smm", Napi::Function::New(env__, atg_smm));
  exports.Set("atg_softmax", Napi::Function::New(env__, atg_softmax));
  exports.Set("atg_softmax_int_out", Napi::Function::New(env__, atg_softmax_int_out));
  exports.Set("atg__softmax", Napi::Function::New(env__, atg__softmax));
  exports.Set("atg__softmax_out", Napi::Function::New(env__, atg__softmax_out));
  exports.Set("atg__softmax_backward_data", Napi::Function::New(env__, atg__softmax_backward_data));
  exports.Set("atg__softmax_backward_data_out", Napi::Function::New(env__, atg__softmax_backward_data_out));
  exports.Set("atg_squeeze", Napi::Function::New(env__, atg_squeeze));
  exports.Set("atg_squeeze_dim", Napi::Function::New(env__, atg_squeeze_dim));
  exports.Set("atg_squeeze_dims", Napi::Function::New(env__, atg_squeeze_dims));
  exports.Set("atg_squeeze_", Napi::Function::New(env__, atg_squeeze_));
  exports.Set("atg_squeeze_dim_", Napi::Function::New(env__, atg_squeeze_dim_));
  exports.Set("atg_squeeze_dims_", Napi::Function::New(env__, atg_squeeze_dims_));
  exports.Set("atg_sspaddmm", Napi::Function::New(env__, atg_sspaddmm));
  exports.Set("atg_sspaddmm_out", Napi::Function::New(env__, atg_sspaddmm_out));
  exports.Set("atg_stack", Napi::Function::New(env__, atg_stack));
  exports.Set("atg_stack_out", Napi::Function::New(env__, atg_stack_out));
  exports.Set("atg__stack", Napi::Function::New(env__, atg__stack));
  exports.Set("atg__stack_out", Napi::Function::New(env__, atg__stack_out));
  exports.Set("atg_hstack", Napi::Function::New(env__, atg_hstack));
  exports.Set("atg_hstack_out", Napi::Function::New(env__, atg_hstack_out));
  exports.Set("atg_vstack", Napi::Function::New(env__, atg_vstack));
  exports.Set("atg_vstack_out", Napi::Function::New(env__, atg_vstack_out));
  exports.Set("atg_dstack", Napi::Function::New(env__, atg_dstack));
  exports.Set("atg_dstack_out", Napi::Function::New(env__, atg_dstack_out));
  exports.Set("atg_stft", Napi::Function::New(env__, atg_stft));
  exports.Set("atg_stft_center", Napi::Function::New(env__, atg_stft_center));
  exports.Set("atg_istft", Napi::Function::New(env__, atg_istft));
  exports.Set("atg_sum", Napi::Function::New(env__, atg_sum));
  exports.Set("atg_sum_dim_intlist", Napi::Function::New(env__, atg_sum_dim_intlist));
  exports.Set("atg_sum_out", Napi::Function::New(env__, atg_sum_out));
  exports.Set("atg_sum_intlist_out", Napi::Function::New(env__, atg_sum_intlist_out));
  exports.Set("atg__nested_sum_backward", Napi::Function::New(env__, atg__nested_sum_backward));
  exports.Set("atg_nansum", Napi::Function::New(env__, atg_nansum));
  exports.Set("atg_nansum_out", Napi::Function::New(env__, atg_nansum_out));
  exports.Set("atg_sum_to_size", Napi::Function::New(env__, atg_sum_to_size));
  exports.Set("atg_sqrt", Napi::Function::New(env__, atg_sqrt));
  exports.Set("atg_sqrt_out", Napi::Function::New(env__, atg_sqrt_out));
  exports.Set("atg_sqrt_", Napi::Function::New(env__, atg_sqrt_));
  exports.Set("atg_square", Napi::Function::New(env__, atg_square));
  exports.Set("atg_square_out", Napi::Function::New(env__, atg_square_out));
  exports.Set("atg_square_", Napi::Function::New(env__, atg_square_));
  exports.Set("atg_std", Napi::Function::New(env__, atg_std));
  exports.Set("atg_std_dim", Napi::Function::New(env__, atg_std_dim));
  exports.Set("atg_std_correction", Napi::Function::New(env__, atg_std_correction));
  exports.Set("atg_std_out", Napi::Function::New(env__, atg_std_out));
  exports.Set("atg_std_correction_out", Napi::Function::New(env__, atg_std_correction_out));
  exports.Set("atg_std_mean", Napi::Function::New(env__, atg_std_mean));
  exports.Set("atg_std_mean_dim", Napi::Function::New(env__, atg_std_mean_dim));
  exports.Set("atg_std_mean_correction", Napi::Function::New(env__, atg_std_mean_correction));
  exports.Set("atg_std_mean_correction_out", Napi::Function::New(env__, atg_std_mean_correction_out));
  exports.Set("atg_prod", Napi::Function::New(env__, atg_prod));
  exports.Set("atg_prod_dim_int", Napi::Function::New(env__, atg_prod_dim_int));
  exports.Set("atg_prod_out", Napi::Function::New(env__, atg_prod_out));
  exports.Set("atg_prod_int_out", Napi::Function::New(env__, atg_prod_int_out));
  exports.Set("atg_t", Napi::Function::New(env__, atg_t));
  exports.Set("atg_t_", Napi::Function::New(env__, atg_t_));
  exports.Set("atg_tan", Napi::Function::New(env__, atg_tan));
  exports.Set("atg_tan_out", Napi::Function::New(env__, atg_tan_out));
  exports.Set("atg_tan_", Napi::Function::New(env__, atg_tan_));
  exports.Set("atg_tanh", Napi::Function::New(env__, atg_tanh));
  exports.Set("atg_tanh_out", Napi::Function::New(env__, atg_tanh_out));
  exports.Set("atg_tanh_", Napi::Function::New(env__, atg_tanh_));
  exports.Set("atg_tensordot", Napi::Function::New(env__, atg_tensordot));
  exports.Set("atg_tensordot_out", Napi::Function::New(env__, atg_tensordot_out));
  exports.Set("atg_threshold", Napi::Function::New(env__, atg_threshold));
  exports.Set("atg_threshold_out", Napi::Function::New(env__, atg_threshold_out));
  exports.Set("atg_threshold_", Napi::Function::New(env__, atg_threshold_));
  exports.Set("atg_threshold_backward", Napi::Function::New(env__, atg_threshold_backward));
  exports.Set("atg_threshold_backward_grad_input", Napi::Function::New(env__, atg_threshold_backward_grad_input));
  exports.Set("atg_tile", Napi::Function::New(env__, atg_tile));
  exports.Set("atg_transpose", Napi::Function::New(env__, atg_transpose));
  exports.Set("atg__mkldnn_transpose", Napi::Function::New(env__, atg__mkldnn_transpose));
  exports.Set("atg__mkldnn_transpose_out", Napi::Function::New(env__, atg__mkldnn_transpose_out));
  exports.Set("atg_transpose_", Napi::Function::New(env__, atg_transpose_));
  exports.Set("atg__mkldnn_transpose_", Napi::Function::New(env__, atg__mkldnn_transpose_));
  exports.Set("atg_one_hot", Napi::Function::New(env__, atg_one_hot));
  exports.Set("atg_flip", Napi::Function::New(env__, atg_flip));
  exports.Set("atg_flip_out", Napi::Function::New(env__, atg_flip_out));
  exports.Set("atg_fliplr", Napi::Function::New(env__, atg_fliplr));
  exports.Set("atg_flipud", Napi::Function::New(env__, atg_flipud));
  exports.Set("atg_roll", Napi::Function::New(env__, atg_roll));
  exports.Set("atg_roll_out", Napi::Function::New(env__, atg_roll_out));
  exports.Set("atg_rot90", Napi::Function::New(env__, atg_rot90));
  exports.Set("atg_rot90_out", Napi::Function::New(env__, atg_rot90_out));
  exports.Set("atg_trapezoid", Napi::Function::New(env__, atg_trapezoid));
  exports.Set("atg_trapezoid_dx", Napi::Function::New(env__, atg_trapezoid_dx));
  exports.Set("atg_trapz", Napi::Function::New(env__, atg_trapz));
  exports.Set("atg_trapz_dx", Napi::Function::New(env__, atg_trapz_dx));
  exports.Set("atg__transform_bias_rescale_qkv", Napi::Function::New(env__, atg__transform_bias_rescale_qkv));
  exports.Set("atg__transform_bias_rescale_qkv_out", Napi::Function::New(env__, atg__transform_bias_rescale_qkv_out));
  exports.Set("atg__nested_tensor_from_mask", Napi::Function::New(env__, atg__nested_tensor_from_mask));
  exports.Set("atg__nested_tensor_from_mask_out", Napi::Function::New(env__, atg__nested_tensor_from_mask_out));
  exports.Set("atg__nested_tensor_from_mask_left_aligned", Napi::Function::New(env__, atg__nested_tensor_from_mask_left_aligned));
  exports.Set("atg__nested_from_padded", Napi::Function::New(env__, atg__nested_from_padded));
  exports.Set("atg__nested_from_padded_out", Napi::Function::New(env__, atg__nested_from_padded_out));
  exports.Set("atg__nested_tensor_size", Napi::Function::New(env__, atg__nested_tensor_size));
  exports.Set("atg__nested_tensor_size_out", Napi::Function::New(env__, atg__nested_tensor_size_out));
  exports.Set("atg__nested_tensor_strides", Napi::Function::New(env__, atg__nested_tensor_strides));
  exports.Set("atg__nested_tensor_strides_out", Napi::Function::New(env__, atg__nested_tensor_strides_out));
  exports.Set("atg__nested_from_padded_and_nested_example", Napi::Function::New(env__, atg__nested_from_padded_and_nested_example));
  exports.Set("atg__nested_from_padded_and_nested_example_out", Napi::Function::New(env__, atg__nested_from_padded_and_nested_example_out));
  exports.Set("atg__nested_view_from_buffer", Napi::Function::New(env__, atg__nested_view_from_buffer));
  exports.Set("atg__nested_view_from_buffer_copy", Napi::Function::New(env__, atg__nested_view_from_buffer_copy));
  exports.Set("atg__nested_view_from_buffer_copy_out", Napi::Function::New(env__, atg__nested_view_from_buffer_copy_out));
  exports.Set("atg__trilinear", Napi::Function::New(env__, atg__trilinear));
  exports.Set("atg__trilinear_out", Napi::Function::New(env__, atg__trilinear_out));
  exports.Set("atg_triplet_margin_loss", Napi::Function::New(env__, atg_triplet_margin_loss));
  exports.Set("atg_trunc", Napi::Function::New(env__, atg_trunc));
  exports.Set("atg_trunc_out", Napi::Function::New(env__, atg_trunc_out));
  exports.Set("atg_trunc_", Napi::Function::New(env__, atg_trunc_));
  exports.Set("atg_fix", Napi::Function::New(env__, atg_fix));
  exports.Set("atg_fix_out", Napi::Function::New(env__, atg_fix_out));
  exports.Set("atg_fix_", Napi::Function::New(env__, atg_fix_));
  exports.Set("atg_type_as", Napi::Function::New(env__, atg_type_as));
  exports.Set("atg__has_compatible_shallow_copy_type", Napi::Function::New(env__, atg__has_compatible_shallow_copy_type));
  exports.Set("atg__unique", Napi::Function::New(env__, atg__unique));
  exports.Set("atg__unique_out", Napi::Function::New(env__, atg__unique_out));
  exports.Set("atg_unique_dim", Napi::Function::New(env__, atg_unique_dim));
  exports.Set("atg_unique_dim_out", Napi::Function::New(env__, atg_unique_dim_out));
  exports.Set("atg_unique_consecutive", Napi::Function::New(env__, atg_unique_consecutive));
  exports.Set("atg_unique_consecutive_out", Napi::Function::New(env__, atg_unique_consecutive_out));
  exports.Set("atg_unique_dim_consecutive", Napi::Function::New(env__, atg_unique_dim_consecutive));
  exports.Set("atg_unique_dim_consecutive_out", Napi::Function::New(env__, atg_unique_dim_consecutive_out));
  exports.Set("atg__unique2", Napi::Function::New(env__, atg__unique2));
  exports.Set("atg__unique2_out", Napi::Function::New(env__, atg__unique2_out));
  exports.Set("atg__unsafe_view", Napi::Function::New(env__, atg__unsafe_view));
  exports.Set("atg__unsafe_view_out", Napi::Function::New(env__, atg__unsafe_view_out));
  exports.Set("atg_unsqueeze", Napi::Function::New(env__, atg_unsqueeze));
  exports.Set("atg_unsqueeze_", Napi::Function::New(env__, atg_unsqueeze_));
  exports.Set("atg_vander", Napi::Function::New(env__, atg_vander));
  exports.Set("atg_var", Napi::Function::New(env__, atg_var));
  exports.Set("atg_var_dim", Napi::Function::New(env__, atg_var_dim));
  exports.Set("atg_var_correction", Napi::Function::New(env__, atg_var_correction));
  exports.Set("atg_var_out", Napi::Function::New(env__, atg_var_out));
  exports.Set("atg_var_correction_out", Napi::Function::New(env__, atg_var_correction_out));
  exports.Set("atg_var_mean", Napi::Function::New(env__, atg_var_mean));
  exports.Set("atg_var_mean_dim", Napi::Function::New(env__, atg_var_mean_dim));
  exports.Set("atg_var_mean_correction", Napi::Function::New(env__, atg_var_mean_correction));
  exports.Set("atg_var_mean_correction_out", Napi::Function::New(env__, atg_var_mean_correction_out));
  exports.Set("atg_view_as", Napi::Function::New(env__, atg_view_as));
  exports.Set("atg_where", Napi::Function::New(env__, atg_where));
  exports.Set("atg_where_scalarself", Napi::Function::New(env__, atg_where_scalarself));
  exports.Set("atg_where_scalarother", Napi::Function::New(env__, atg_where_scalarother));
  exports.Set("atg_where_scalar", Napi::Function::New(env__, atg_where_scalar));
  exports.Set("atg_where_self_out", Napi::Function::New(env__, atg_where_self_out));
  exports.Set("atg_norm_except_dim", Napi::Function::New(env__, atg_norm_except_dim));
  exports.Set("atg__weight_norm", Napi::Function::New(env__, atg__weight_norm));
  exports.Set("atg__weight_norm_interface", Napi::Function::New(env__, atg__weight_norm_interface));
  exports.Set("atg__weight_norm_interface_out", Napi::Function::New(env__, atg__weight_norm_interface_out));
  exports.Set("atg__weight_norm_interface_backward", Napi::Function::New(env__, atg__weight_norm_interface_backward));
  exports.Set("atg__weight_norm_interface_backward_out", Napi::Function::New(env__, atg__weight_norm_interface_backward_out));
  exports.Set("atg__weight_norm_differentiable_backward", Napi::Function::New(env__, atg__weight_norm_differentiable_backward));
  exports.Set("atg__efficientzerotensor", Napi::Function::New(env__, atg__efficientzerotensor));
  exports.Set("atg__efficientzerotensor_out", Napi::Function::New(env__, atg__efficientzerotensor_out));
  exports.Set("atg_zeros", Napi::Function::New(env__, atg_zeros));
  exports.Set("atg_zeros_out", Napi::Function::New(env__, atg_zeros_out));
  exports.Set("atg_zeros_like", Napi::Function::New(env__, atg_zeros_like));
  exports.Set("atg_zeros_like_out", Napi::Function::New(env__, atg_zeros_like_out));
  exports.Set("atg__standard_gamma_grad", Napi::Function::New(env__, atg__standard_gamma_grad));
  exports.Set("atg__standard_gamma_grad_out", Napi::Function::New(env__, atg__standard_gamma_grad_out));
  exports.Set("atg__standard_gamma", Napi::Function::New(env__, atg__standard_gamma));
  exports.Set("atg__standard_gamma_out", Napi::Function::New(env__, atg__standard_gamma_out));
  exports.Set("atg__dirichlet_grad", Napi::Function::New(env__, atg__dirichlet_grad));
  exports.Set("atg__dirichlet_grad_out", Napi::Function::New(env__, atg__dirichlet_grad_out));
  exports.Set("atg__sample_dirichlet", Napi::Function::New(env__, atg__sample_dirichlet));
  exports.Set("atg__sample_dirichlet_out", Napi::Function::New(env__, atg__sample_dirichlet_out));
  exports.Set("atg_poisson", Napi::Function::New(env__, atg_poisson));
  exports.Set("atg_poisson_out", Napi::Function::New(env__, atg_poisson_out));
  exports.Set("atg_binomial", Napi::Function::New(env__, atg_binomial));
  exports.Set("atg_binomial_out", Napi::Function::New(env__, atg_binomial_out));
  exports.Set("atg_native_norm", Napi::Function::New(env__, atg_native_norm));
  exports.Set("atg_native_norm_scalaropt_dim_dtype", Napi::Function::New(env__, atg_native_norm_scalaropt_dim_dtype));
  exports.Set("atg_native_norm_out", Napi::Function::New(env__, atg_native_norm_out));
  exports.Set("atg_native_norm_scalaropt_dim_dtype_out", Napi::Function::New(env__, atg_native_norm_scalaropt_dim_dtype_out));
  exports.Set("atg__sparse_sum", Napi::Function::New(env__, atg__sparse_sum));
  exports.Set("atg__sparse_sum_dtype", Napi::Function::New(env__, atg__sparse_sum_dtype));
  exports.Set("atg__sparse_sum_dim", Napi::Function::New(env__, atg__sparse_sum_dim));
  exports.Set("atg__sparse_sum_dim_dtype", Napi::Function::New(env__, atg__sparse_sum_dim_dtype));
  exports.Set("atg__sparse_sum_dim_out", Napi::Function::New(env__, atg__sparse_sum_dim_out));
  exports.Set("atg__sparse_sum_backward", Napi::Function::New(env__, atg__sparse_sum_backward));
  exports.Set("atg__sparse_sum_backward_out", Napi::Function::New(env__, atg__sparse_sum_backward_out));
  exports.Set("atg__sparse_csr_sum", Napi::Function::New(env__, atg__sparse_csr_sum));
  exports.Set("atg__sparse_csr_sum_dim_dtype_out", Napi::Function::New(env__, atg__sparse_csr_sum_dim_dtype_out));
  exports.Set("atg__sparse_csr_prod", Napi::Function::New(env__, atg__sparse_csr_prod));
  exports.Set("atg__sparse_csr_prod_dim_dtype_out", Napi::Function::New(env__, atg__sparse_csr_prod_dim_dtype_out));
  exports.Set("atg__sparse_softmax_int", Napi::Function::New(env__, atg__sparse_softmax_int));
  exports.Set("atg__sparse_softmax", Napi::Function::New(env__, atg__sparse_softmax));
  exports.Set("atg__sparse_softmax_out", Napi::Function::New(env__, atg__sparse_softmax_out));
  exports.Set("atg__sparse_softmax_backward_data", Napi::Function::New(env__, atg__sparse_softmax_backward_data));
  exports.Set("atg__sparse_softmax_backward_data_out", Napi::Function::New(env__, atg__sparse_softmax_backward_data_out));
  exports.Set("atg__sparse_log_softmax_int", Napi::Function::New(env__, atg__sparse_log_softmax_int));
  exports.Set("atg__sparse_log_softmax", Napi::Function::New(env__, atg__sparse_log_softmax));
  exports.Set("atg__sparse_log_softmax_out", Napi::Function::New(env__, atg__sparse_log_softmax_out));
  exports.Set("atg__sparse_log_softmax_backward_data", Napi::Function::New(env__, atg__sparse_log_softmax_backward_data));
  exports.Set("atg__sparse_log_softmax_backward_data_out", Napi::Function::New(env__, atg__sparse_log_softmax_backward_data_out));
  exports.Set("atg__spdiags", Napi::Function::New(env__, atg__spdiags));
  exports.Set("atg__spdiags_out", Napi::Function::New(env__, atg__spdiags_out));
  exports.Set("atg_norm", Napi::Function::New(env__, atg_norm));
  exports.Set("atg_norm_scalaropt_dtype", Napi::Function::New(env__, atg_norm_scalaropt_dtype));
  exports.Set("atg_norm_scalaropt_dim", Napi::Function::New(env__, atg_norm_scalaropt_dim));
  exports.Set("atg_norm_scalaropt_dim_dtype", Napi::Function::New(env__, atg_norm_scalaropt_dim_dtype));
  exports.Set("atg_norm_scalar_out", Napi::Function::New(env__, atg_norm_scalar_out));
  exports.Set("atg_norm_scalaropt_dtype_out", Napi::Function::New(env__, atg_norm_scalaropt_dtype_out));
  exports.Set("atg_norm_out", Napi::Function::New(env__, atg_norm_out));
  exports.Set("atg_norm_dtype_out", Napi::Function::New(env__, atg_norm_dtype_out));
  exports.Set("atg_frexp", Napi::Function::New(env__, atg_frexp));
  exports.Set("atg_frexp_tensor_out", Napi::Function::New(env__, atg_frexp_tensor_out));
  exports.Set("atg_frobenius_norm", Napi::Function::New(env__, atg_frobenius_norm));
  exports.Set("atg_frobenius_norm_out", Napi::Function::New(env__, atg_frobenius_norm_out));
  exports.Set("atg_nuclear_norm", Napi::Function::New(env__, atg_nuclear_norm));
  exports.Set("atg_nuclear_norm_dim", Napi::Function::New(env__, atg_nuclear_norm_dim));
  exports.Set("atg_nuclear_norm_out", Napi::Function::New(env__, atg_nuclear_norm_out));
  exports.Set("atg_nuclear_norm_dim_out", Napi::Function::New(env__, atg_nuclear_norm_dim_out));
  exports.Set("atg_positive", Napi::Function::New(env__, atg_positive));
  exports.Set("atg_resize_as_", Napi::Function::New(env__, atg_resize_as_));
  exports.Set("atg_resize_as_sparse_", Napi::Function::New(env__, atg_resize_as_sparse_));
  exports.Set("atg_zero_", Napi::Function::New(env__, atg_zero_));
  exports.Set("atg_sub", Napi::Function::New(env__, atg_sub));
  exports.Set("atg_sub_scalar", Napi::Function::New(env__, atg_sub_scalar));
  exports.Set("atg_sub_out", Napi::Function::New(env__, atg_sub_out));
  exports.Set("atg_sub_scalar_out", Napi::Function::New(env__, atg_sub_scalar_out));
  exports.Set("atg_sub_", Napi::Function::New(env__, atg_sub_));
  exports.Set("atg_sub_scalar_", Napi::Function::New(env__, atg_sub_scalar_));
  exports.Set("atg_subtract", Napi::Function::New(env__, atg_subtract));
  exports.Set("atg_subtract_scalar", Napi::Function::New(env__, atg_subtract_scalar));
  exports.Set("atg_subtract_out", Napi::Function::New(env__, atg_subtract_out));
  exports.Set("atg_subtract_", Napi::Function::New(env__, atg_subtract_));
  exports.Set("atg_subtract_scalar_", Napi::Function::New(env__, atg_subtract_scalar_));
  exports.Set("atg_rsub", Napi::Function::New(env__, atg_rsub));
  exports.Set("atg_rsub_scalar", Napi::Function::New(env__, atg_rsub_scalar));
  exports.Set("atg_rsub_tensor_out", Napi::Function::New(env__, atg_rsub_tensor_out));
  exports.Set("atg_rsub_scalar_out", Napi::Function::New(env__, atg_rsub_scalar_out));
  exports.Set("atg_heaviside", Napi::Function::New(env__, atg_heaviside));
  exports.Set("atg_heaviside_out", Napi::Function::New(env__, atg_heaviside_out));
  exports.Set("atg_heaviside_", Napi::Function::New(env__, atg_heaviside_));
  exports.Set("atg__sparse_addmm", Napi::Function::New(env__, atg__sparse_addmm));
  exports.Set("atg__sparse_addmm_out", Napi::Function::New(env__, atg__sparse_addmm_out));
  exports.Set("atg_sparse_sampled_addmm", Napi::Function::New(env__, atg_sparse_sampled_addmm));
  exports.Set("atg_sparse_sampled_addmm_out", Napi::Function::New(env__, atg_sparse_sampled_addmm_out));
  exports.Set("atg__sparse_mm_reduce_impl", Napi::Function::New(env__, atg__sparse_mm_reduce_impl));
  exports.Set("atg_addmm", Napi::Function::New(env__, atg_addmm));
  exports.Set("atg_addmm_out", Napi::Function::New(env__, atg_addmm_out));
  exports.Set("atg_addmm_", Napi::Function::New(env__, atg_addmm_));
  exports.Set("atg__addmm_activation", Napi::Function::New(env__, atg__addmm_activation));
  exports.Set("atg__addmm_activation_out", Napi::Function::New(env__, atg__addmm_activation_out));
  exports.Set("atg_sparse_compressed_tensor", Napi::Function::New(env__, atg_sparse_compressed_tensor));
  exports.Set("atg_sparse_compressed_tensor_comp_plain_value_size", Napi::Function::New(env__, atg_sparse_compressed_tensor_comp_plain_value_size));
  exports.Set("atg_sparse_csr_tensor", Napi::Function::New(env__, atg_sparse_csr_tensor));
  exports.Set("atg_sparse_csr_tensor_crow_col_value_size", Napi::Function::New(env__, atg_sparse_csr_tensor_crow_col_value_size));
  exports.Set("atg_sparse_csc_tensor", Napi::Function::New(env__, atg_sparse_csc_tensor));
  exports.Set("atg_sparse_csc_tensor_ccol_row_value_size", Napi::Function::New(env__, atg_sparse_csc_tensor_ccol_row_value_size));
  exports.Set("atg_sparse_bsr_tensor", Napi::Function::New(env__, atg_sparse_bsr_tensor));
  exports.Set("atg_sparse_bsr_tensor_crow_col_value_size", Napi::Function::New(env__, atg_sparse_bsr_tensor_crow_col_value_size));
  exports.Set("atg_sparse_bsc_tensor", Napi::Function::New(env__, atg_sparse_bsc_tensor));
  exports.Set("atg_sparse_bsc_tensor_ccol_row_value_size", Napi::Function::New(env__, atg_sparse_bsc_tensor_ccol_row_value_size));
  exports.Set("atg__sparse_compressed_tensor_unsafe", Napi::Function::New(env__, atg__sparse_compressed_tensor_unsafe));
  exports.Set("atg__sparse_csr_tensor_unsafe", Napi::Function::New(env__, atg__sparse_csr_tensor_unsafe));
  exports.Set("atg__sparse_csc_tensor_unsafe", Napi::Function::New(env__, atg__sparse_csc_tensor_unsafe));
  exports.Set("atg__sparse_bsr_tensor_unsafe", Napi::Function::New(env__, atg__sparse_bsr_tensor_unsafe));
  exports.Set("atg__sparse_bsc_tensor_unsafe", Napi::Function::New(env__, atg__sparse_bsc_tensor_unsafe));
  exports.Set("atg_sparse_coo_tensor", Napi::Function::New(env__, atg_sparse_coo_tensor));
  exports.Set("atg_sparse_coo_tensor_indices", Napi::Function::New(env__, atg_sparse_coo_tensor_indices));
  exports.Set("atg_sparse_coo_tensor_indices_size", Napi::Function::New(env__, atg_sparse_coo_tensor_indices_size));
  exports.Set("atg_sparse_coo_tensor_size_out", Napi::Function::New(env__, atg_sparse_coo_tensor_size_out));
  exports.Set("atg__sparse_coo_tensor_unsafe", Napi::Function::New(env__, atg__sparse_coo_tensor_unsafe));
  exports.Set("atg__validate_sparse_compressed_tensor_args", Napi::Function::New(env__, atg__validate_sparse_compressed_tensor_args));
  exports.Set("atg__validate_sparse_csr_tensor_args", Napi::Function::New(env__, atg__validate_sparse_csr_tensor_args));
  exports.Set("atg__validate_sparse_csc_tensor_args", Napi::Function::New(env__, atg__validate_sparse_csc_tensor_args));
  exports.Set("atg__validate_sparse_bsr_tensor_args", Napi::Function::New(env__, atg__validate_sparse_bsr_tensor_args));
  exports.Set("atg__validate_sparse_bsc_tensor_args", Napi::Function::New(env__, atg__validate_sparse_bsc_tensor_args));
  exports.Set("atg__sparse_coo_tensor_with_dims", Napi::Function::New(env__, atg__sparse_coo_tensor_with_dims));
  exports.Set("atg__sparse_coo_tensor_with_dims_out", Napi::Function::New(env__, atg__sparse_coo_tensor_with_dims_out));
  exports.Set("atg__sparse_coo_tensor_with_dims_and_tensors", Napi::Function::New(env__, atg__sparse_coo_tensor_with_dims_and_tensors));
  exports.Set("atg__sparse_coo_tensor_with_dims_and_tensors_out", Napi::Function::New(env__, atg__sparse_coo_tensor_with_dims_and_tensors_out));
  exports.Set("atg_sparse_resize_", Napi::Function::New(env__, atg_sparse_resize_));
  exports.Set("atg_sparse_resize_and_clear_", Napi::Function::New(env__, atg_sparse_resize_and_clear_));
  exports.Set("atg_sparse_mask", Napi::Function::New(env__, atg_sparse_mask));
  exports.Set("atg_sparse_mask_out", Napi::Function::New(env__, atg_sparse_mask_out));
  exports.Set("atg_to_dense", Napi::Function::New(env__, atg_to_dense));
  exports.Set("atg__to_dense", Napi::Function::New(env__, atg__to_dense));
  exports.Set("atg__to_dense_out", Napi::Function::New(env__, atg__to_dense_out));
  exports.Set("atg_to_dense_backward", Napi::Function::New(env__, atg_to_dense_backward));
  exports.Set("atg_sparse_dim", Napi::Function::New(env__, atg_sparse_dim));
  exports.Set("atg__dimI", Napi::Function::New(env__, atg__dimI));
  exports.Set("atg_dense_dim", Napi::Function::New(env__, atg_dense_dim));
  exports.Set("atg__dimV", Napi::Function::New(env__, atg__dimV));
  exports.Set("atg__nnz", Napi::Function::New(env__, atg__nnz));
  exports.Set("atg_coalesce", Napi::Function::New(env__, atg_coalesce));
  exports.Set("atg__coalesce", Napi::Function::New(env__, atg__coalesce));
  exports.Set("atg__coalesce_out", Napi::Function::New(env__, atg__coalesce_out));
  exports.Set("atg_is_coalesced", Napi::Function::New(env__, atg_is_coalesced));
  exports.Set("atg__indices", Napi::Function::New(env__, atg__indices));
  exports.Set("atg__values", Napi::Function::New(env__, atg__values));
  exports.Set("atg__coalesced_", Napi::Function::New(env__, atg__coalesced_));
  exports.Set("atg_indices", Napi::Function::New(env__, atg_indices));
  exports.Set("atg_values", Napi::Function::New(env__, atg_values));
  exports.Set("atg_crow_indices", Napi::Function::New(env__, atg_crow_indices));
  exports.Set("atg_col_indices", Napi::Function::New(env__, atg_col_indices));
  exports.Set("atg_ccol_indices", Napi::Function::New(env__, atg_ccol_indices));
  exports.Set("atg_row_indices", Napi::Function::New(env__, atg_row_indices));
  exports.Set("atg_hspmm", Napi::Function::New(env__, atg_hspmm));
  exports.Set("atg_hspmm_out", Napi::Function::New(env__, atg_hspmm_out));
  exports.Set("atg_copy_sparse_to_sparse_", Napi::Function::New(env__, atg_copy_sparse_to_sparse_));
  exports.Set("atg_to_sparse_sparse_dim", Napi::Function::New(env__, atg_to_sparse_sparse_dim));
  exports.Set("atg_to_sparse", Napi::Function::New(env__, atg_to_sparse));
  exports.Set("atg_to_sparse_sparse_dim_out", Napi::Function::New(env__, atg_to_sparse_sparse_dim_out));
  exports.Set("atg_to_sparse_out", Napi::Function::New(env__, atg_to_sparse_out));
  exports.Set("atg_to_sparse_csr", Napi::Function::New(env__, atg_to_sparse_csr));
  exports.Set("atg_to_sparse_csr_out", Napi::Function::New(env__, atg_to_sparse_csr_out));
  exports.Set("atg_to_sparse_csc", Napi::Function::New(env__, atg_to_sparse_csc));
  exports.Set("atg_to_sparse_csc_out", Napi::Function::New(env__, atg_to_sparse_csc_out));
  exports.Set("atg_to_sparse_bsr", Napi::Function::New(env__, atg_to_sparse_bsr));
  exports.Set("atg_to_sparse_bsr_out", Napi::Function::New(env__, atg_to_sparse_bsr_out));
  exports.Set("atg_to_sparse_bsc", Napi::Function::New(env__, atg_to_sparse_bsc));
  exports.Set("atg_to_sparse_bsc_out", Napi::Function::New(env__, atg_to_sparse_bsc_out));
  exports.Set("atg_to_mkldnn", Napi::Function::New(env__, atg_to_mkldnn));
  exports.Set("atg_to_mkldnn_out", Napi::Function::New(env__, atg_to_mkldnn_out));
  exports.Set("atg_mkldnn_reorder_conv2d_weight", Napi::Function::New(env__, atg_mkldnn_reorder_conv2d_weight));
  exports.Set("atg_mkldnn_reorder_conv2d_weight_out", Napi::Function::New(env__, atg_mkldnn_reorder_conv2d_weight_out));
  exports.Set("atg_mkldnn_reorder_conv3d_weight", Napi::Function::New(env__, atg_mkldnn_reorder_conv3d_weight));
  exports.Set("atg_mkldnn_reorder_conv3d_weight_out", Napi::Function::New(env__, atg_mkldnn_reorder_conv3d_weight_out));
  exports.Set("atg_to_mkldnn_backward", Napi::Function::New(env__, atg_to_mkldnn_backward));
  exports.Set("atg_quantize_per_tensor_dynamic", Napi::Function::New(env__, atg_quantize_per_tensor_dynamic));
  exports.Set("atg_quantize_per_tensor_dynamic_out", Napi::Function::New(env__, atg_quantize_per_tensor_dynamic_out));
  exports.Set("atg_quantize_per_tensor", Napi::Function::New(env__, atg_quantize_per_tensor));
  exports.Set("atg_quantize_per_tensor_tensor_qparams", Napi::Function::New(env__, atg_quantize_per_tensor_tensor_qparams));
  exports.Set("atg_quantize_per_tensor_out", Napi::Function::New(env__, atg_quantize_per_tensor_out));
  exports.Set("atg_quantize_per_tensor_tensor_qparams_out", Napi::Function::New(env__, atg_quantize_per_tensor_tensor_qparams_out));
  exports.Set("atg_quantize_per_tensor_tensors_out", Napi::Function::New(env__, atg_quantize_per_tensor_tensors_out));
  exports.Set("atg_quantize_per_channel", Napi::Function::New(env__, atg_quantize_per_channel));
  exports.Set("atg_quantize_per_channel_out", Napi::Function::New(env__, atg_quantize_per_channel_out));
  exports.Set("atg_dequantize", Napi::Function::New(env__, atg_dequantize));
  exports.Set("atg_dequantize_self_out", Napi::Function::New(env__, atg_dequantize_self_out));
  exports.Set("atg_dequantize_tensors_out", Napi::Function::New(env__, atg_dequantize_tensors_out));
  exports.Set("atg_q_scale", Napi::Function::New(env__, atg_q_scale));
  exports.Set("atg_q_zero_point", Napi::Function::New(env__, atg_q_zero_point));
  exports.Set("atg_q_per_channel_scales", Napi::Function::New(env__, atg_q_per_channel_scales));
  exports.Set("atg_q_per_channel_scales_out", Napi::Function::New(env__, atg_q_per_channel_scales_out));
  exports.Set("atg_q_per_channel_zero_points", Napi::Function::New(env__, atg_q_per_channel_zero_points));
  exports.Set("atg_q_per_channel_zero_points_out", Napi::Function::New(env__, atg_q_per_channel_zero_points_out));
  exports.Set("atg_q_per_channel_axis", Napi::Function::New(env__, atg_q_per_channel_axis));
  exports.Set("atg_int_repr", Napi::Function::New(env__, atg_int_repr));
  exports.Set("atg_int_repr_out", Napi::Function::New(env__, atg_int_repr_out));
  exports.Set("atg__make_per_tensor_quantized_tensor", Napi::Function::New(env__, atg__make_per_tensor_quantized_tensor));
  exports.Set("atg__make_per_tensor_quantized_tensor_out", Napi::Function::New(env__, atg__make_per_tensor_quantized_tensor_out));
  exports.Set("atg__make_per_channel_quantized_tensor", Napi::Function::New(env__, atg__make_per_channel_quantized_tensor));
  exports.Set("atg__make_per_channel_quantized_tensor_out", Napi::Function::New(env__, atg__make_per_channel_quantized_tensor_out));
  exports.Set("atg_fake_quantize_per_tensor_affine", Napi::Function::New(env__, atg_fake_quantize_per_tensor_affine));
  exports.Set("atg_fake_quantize_per_tensor_affine_tensor_qparams", Napi::Function::New(env__, atg_fake_quantize_per_tensor_affine_tensor_qparams));
  exports.Set("atg_fake_quantize_per_tensor_affine_cachemask", Napi::Function::New(env__, atg_fake_quantize_per_tensor_affine_cachemask));
  exports.Set("atg_fake_quantize_per_tensor_affine_cachemask_out", Napi::Function::New(env__, atg_fake_quantize_per_tensor_affine_cachemask_out));
  exports.Set("atg__fake_quantize_per_tensor_affine_cachemask_tensor_qparams", Napi::Function::New(env__, atg__fake_quantize_per_tensor_affine_cachemask_tensor_qparams));
  exports.Set("atg__fake_quantize_per_tensor_affine_cachemask_tensor_qparams_out", Napi::Function::New(env__, atg__fake_quantize_per_tensor_affine_cachemask_tensor_qparams_out));
  exports.Set("atg_fake_quantize_per_tensor_affine_cachemask_backward", Napi::Function::New(env__, atg_fake_quantize_per_tensor_affine_cachemask_backward));
  exports.Set("atg__fake_quantize_learnable_per_tensor_affine", Napi::Function::New(env__, atg__fake_quantize_learnable_per_tensor_affine));
  exports.Set("atg__fake_quantize_learnable_per_tensor_affine_out", Napi::Function::New(env__, atg__fake_quantize_learnable_per_tensor_affine_out));
  exports.Set("atg__fake_quantize_learnable_per_tensor_affine_backward", Napi::Function::New(env__, atg__fake_quantize_learnable_per_tensor_affine_backward));
  exports.Set("atg_fake_quantize_per_channel_affine", Napi::Function::New(env__, atg_fake_quantize_per_channel_affine));
  exports.Set("atg_fake_quantize_per_channel_affine_cachemask", Napi::Function::New(env__, atg_fake_quantize_per_channel_affine_cachemask));
  exports.Set("atg_fake_quantize_per_channel_affine_cachemask_out", Napi::Function::New(env__, atg_fake_quantize_per_channel_affine_cachemask_out));
  exports.Set("atg_fake_quantize_per_channel_affine_cachemask_backward", Napi::Function::New(env__, atg_fake_quantize_per_channel_affine_cachemask_backward));
  exports.Set("atg__fake_quantize_learnable_per_channel_affine", Napi::Function::New(env__, atg__fake_quantize_learnable_per_channel_affine));
  exports.Set("atg__fake_quantize_learnable_per_channel_affine_out", Napi::Function::New(env__, atg__fake_quantize_learnable_per_channel_affine_out));
  exports.Set("atg__fake_quantize_learnable_per_channel_affine_backward", Napi::Function::New(env__, atg__fake_quantize_learnable_per_channel_affine_backward));
  exports.Set("atg_fused_moving_avg_obs_fake_quant", Napi::Function::New(env__, atg_fused_moving_avg_obs_fake_quant));
  exports.Set("atg__fused_moving_avg_obs_fq_helper", Napi::Function::New(env__, atg__fused_moving_avg_obs_fq_helper));
  exports.Set("atg__fused_moving_avg_obs_fq_helper_out", Napi::Function::New(env__, atg__fused_moving_avg_obs_fq_helper_out));
  exports.Set("atg__saturate_weight_to_fp16", Napi::Function::New(env__, atg__saturate_weight_to_fp16));
  exports.Set("atg_choose_qparams_optimized", Napi::Function::New(env__, atg_choose_qparams_optimized));
  exports.Set("atg__autocast_to_reduced_precision", Napi::Function::New(env__, atg__autocast_to_reduced_precision));
  exports.Set("atg__autocast_to_full_precision", Napi::Function::New(env__, atg__autocast_to_full_precision));
  exports.Set("atg__to_copy", Napi::Function::New(env__, atg__to_copy));
  exports.Set("atg__to_copy_out", Napi::Function::New(env__, atg__to_copy_out));
  exports.Set("atg_to", Napi::Function::New(env__, atg_to));
  exports.Set("atg_to_dtype", Napi::Function::New(env__, atg_to_dtype));
  exports.Set("atg_to_other", Napi::Function::New(env__, atg_to_other));
  exports.Set("atg_to_device", Napi::Function::New(env__, atg_to_device));
  exports.Set("atg_cartesian_prod", Napi::Function::New(env__, atg_cartesian_prod));
  exports.Set("atg_combinations", Napi::Function::New(env__, atg_combinations));
  exports.Set("atg_can_cast", Napi::Function::New(env__, atg_can_cast));
  exports.Set("atg__lstm_mps", Napi::Function::New(env__, atg__lstm_mps));
  exports.Set("atg__lstm_mps_out", Napi::Function::New(env__, atg__lstm_mps_out));
  exports.Set("atg_lstm", Napi::Function::New(env__, atg_lstm));
  exports.Set("atg_lstm_data", Napi::Function::New(env__, atg_lstm_data));
  exports.Set("atg_gru", Napi::Function::New(env__, atg_gru));
  exports.Set("atg_gru_data", Napi::Function::New(env__, atg_gru_data));
  exports.Set("atg_rnn_tanh", Napi::Function::New(env__, atg_rnn_tanh));
  exports.Set("atg_rnn_tanh_data", Napi::Function::New(env__, atg_rnn_tanh_data));
  exports.Set("atg_rnn_relu", Napi::Function::New(env__, atg_rnn_relu));
  exports.Set("atg_rnn_relu_data", Napi::Function::New(env__, atg_rnn_relu_data));
  exports.Set("atg_lstm_cell", Napi::Function::New(env__, atg_lstm_cell));
  exports.Set("atg_gru_cell", Napi::Function::New(env__, atg_gru_cell));
  exports.Set("atg_rnn_tanh_cell", Napi::Function::New(env__, atg_rnn_tanh_cell));
  exports.Set("atg_rnn_relu_cell", Napi::Function::New(env__, atg_rnn_relu_cell));
  exports.Set("atg_quantized_lstm_cell", Napi::Function::New(env__, atg_quantized_lstm_cell));
  exports.Set("atg_quantized_gru_cell", Napi::Function::New(env__, atg_quantized_gru_cell));
  exports.Set("atg_quantized_rnn_relu_cell", Napi::Function::New(env__, atg_quantized_rnn_relu_cell));
  exports.Set("atg_quantized_rnn_tanh_cell", Napi::Function::New(env__, atg_quantized_rnn_tanh_cell));
  exports.Set("atg__pack_padded_sequence", Napi::Function::New(env__, atg__pack_padded_sequence));
  exports.Set("atg__pack_padded_sequence_out", Napi::Function::New(env__, atg__pack_padded_sequence_out));
  exports.Set("atg__pack_padded_sequence_backward", Napi::Function::New(env__, atg__pack_padded_sequence_backward));
  exports.Set("atg__pad_packed_sequence", Napi::Function::New(env__, atg__pad_packed_sequence));
  exports.Set("atg_set_", Napi::Function::New(env__, atg_set_));
  exports.Set("atg_set_source_tensor_", Napi::Function::New(env__, atg_set_source_tensor_));
  exports.Set("atg_set_source_tensor_storage_offset_", Napi::Function::New(env__, atg_set_source_tensor_storage_offset_));
  exports.Set("atg_lift", Napi::Function::New(env__, atg_lift));
  exports.Set("atg_lift_out", Napi::Function::New(env__, atg_lift_out));
  exports.Set("atg_lift_fresh", Napi::Function::New(env__, atg_lift_fresh));
  exports.Set("atg_lift_fresh_copy", Napi::Function::New(env__, atg_lift_fresh_copy));
  exports.Set("atg_lift_fresh_copy_out", Napi::Function::New(env__, atg_lift_fresh_copy_out));
  exports.Set("atg_is_set_to", Napi::Function::New(env__, atg_is_set_to));
  exports.Set("atg_masked_fill_", Napi::Function::New(env__, atg_masked_fill_));
  exports.Set("atg_masked_fill_tensor_", Napi::Function::New(env__, atg_masked_fill_tensor_));
  exports.Set("atg_masked_fill", Napi::Function::New(env__, atg_masked_fill));
  exports.Set("atg_masked_fill_tensor", Napi::Function::New(env__, atg_masked_fill_tensor));
  exports.Set("atg_masked_fill_scalar_out", Napi::Function::New(env__, atg_masked_fill_scalar_out));
  exports.Set("atg_masked_fill_tensor_out", Napi::Function::New(env__, atg_masked_fill_tensor_out));
  exports.Set("atg_masked_scatter_", Napi::Function::New(env__, atg_masked_scatter_));
  exports.Set("atg_masked_scatter", Napi::Function::New(env__, atg_masked_scatter));
  exports.Set("atg_masked_scatter_out", Napi::Function::New(env__, atg_masked_scatter_out));
  exports.Set("atg__masked_softmax", Napi::Function::New(env__, atg__masked_softmax));
  exports.Set("atg__masked_softmax_out", Napi::Function::New(env__, atg__masked_softmax_out));
  exports.Set("atg__masked_softmax_backward", Napi::Function::New(env__, atg__masked_softmax_backward));
  exports.Set("atg__masked_softmax_backward_out", Napi::Function::New(env__, atg__masked_softmax_backward_out));
  exports.Set("atg_view", Napi::Function::New(env__, atg_view));
  exports.Set("atg_view_dtype", Napi::Function::New(env__, atg_view_dtype));
  exports.Set("atg_put_", Napi::Function::New(env__, atg_put_));
  exports.Set("atg_put", Napi::Function::New(env__, atg_put));
  exports.Set("atg_put_out", Napi::Function::New(env__, atg_put_out));
  exports.Set("atg_index_add", Napi::Function::New(env__, atg_index_add));
  exports.Set("atg_index_add_out", Napi::Function::New(env__, atg_index_add_out));
  exports.Set("atg_index_add_", Napi::Function::New(env__, atg_index_add_));
  exports.Set("atg_index_reduce", Napi::Function::New(env__, atg_index_reduce));
  exports.Set("atg_index_reduce_out", Napi::Function::New(env__, atg_index_reduce_out));
  exports.Set("atg_index_reduce_", Napi::Function::New(env__, atg_index_reduce_));
  exports.Set("atg_index_fill_", Napi::Function::New(env__, atg_index_fill_));
  exports.Set("atg_index_fill_int_tensor_", Napi::Function::New(env__, atg_index_fill_int_tensor_));
  exports.Set("atg_index_fill", Napi::Function::New(env__, atg_index_fill));
  exports.Set("atg_index_fill_int_tensor", Napi::Function::New(env__, atg_index_fill_int_tensor));
  exports.Set("atg_index_fill_int_scalar_out", Napi::Function::New(env__, atg_index_fill_int_scalar_out));
  exports.Set("atg_index_fill_int_tensor_out", Napi::Function::New(env__, atg_index_fill_int_tensor_out));
  exports.Set("atg_scatter", Napi::Function::New(env__, atg_scatter));
  exports.Set("atg_scatter_value", Napi::Function::New(env__, atg_scatter_value));
  exports.Set("atg_scatter_reduce", Napi::Function::New(env__, atg_scatter_reduce));
  exports.Set("atg_scatter_value_reduce", Napi::Function::New(env__, atg_scatter_value_reduce));
  exports.Set("atg_scatter_src_out", Napi::Function::New(env__, atg_scatter_src_out));
  exports.Set("atg_scatter_value_out", Napi::Function::New(env__, atg_scatter_value_out));
  exports.Set("atg_scatter_reduce_out", Napi::Function::New(env__, atg_scatter_reduce_out));
  exports.Set("atg_scatter_value_reduce_out", Napi::Function::New(env__, atg_scatter_value_reduce_out));
  exports.Set("atg_scatter_", Napi::Function::New(env__, atg_scatter_));
  exports.Set("atg_scatter_value_", Napi::Function::New(env__, atg_scatter_value_));
  exports.Set("atg_scatter_reduce_", Napi::Function::New(env__, atg_scatter_reduce_));
  exports.Set("atg_scatter_value_reduce_", Napi::Function::New(env__, atg_scatter_value_reduce_));
  exports.Set("atg_scatter_add", Napi::Function::New(env__, atg_scatter_add));
  exports.Set("atg_scatter_add_out", Napi::Function::New(env__, atg_scatter_add_out));
  exports.Set("atg_scatter_add_", Napi::Function::New(env__, atg_scatter_add_));
  exports.Set("atg_scatter_reduce_two_out", Napi::Function::New(env__, atg_scatter_reduce_two_out));
  exports.Set("atg__scatter_reduce_", Napi::Function::New(env__, atg__scatter_reduce_));
  exports.Set("atg_eq_", Napi::Function::New(env__, atg_eq_));
  exports.Set("atg_eq_tensor_", Napi::Function::New(env__, atg_eq_tensor_));
  exports.Set("atg_bitwise_and", Napi::Function::New(env__, atg_bitwise_and));
  exports.Set("atg_bitwise_and_scalar_tensor", Napi::Function::New(env__, atg_bitwise_and_scalar_tensor));
  exports.Set("atg_bitwise_and_tensor", Napi::Function::New(env__, atg_bitwise_and_tensor));
  exports.Set("atg_bitwise_and_tensor_out", Napi::Function::New(env__, atg_bitwise_and_tensor_out));
  exports.Set("atg_bitwise_and_scalar_out", Napi::Function::New(env__, atg_bitwise_and_scalar_out));
  exports.Set("atg_bitwise_and_scalar_tensor_out", Napi::Function::New(env__, atg_bitwise_and_scalar_tensor_out));
  exports.Set("atg_bitwise_and_", Napi::Function::New(env__, atg_bitwise_and_));
  exports.Set("atg_bitwise_and_tensor_", Napi::Function::New(env__, atg_bitwise_and_tensor_));
  exports.Set("atg___and__", Napi::Function::New(env__, atg___and__));
  exports.Set("atg___and__tensor_", Napi::Function::New(env__, atg___and__tensor_));
  exports.Set("atg___iand__", Napi::Function::New(env__, atg___iand__));
  exports.Set("atg___iand__tensor_", Napi::Function::New(env__, atg___iand__tensor_));
  exports.Set("atg_bitwise_or", Napi::Function::New(env__, atg_bitwise_or));
  exports.Set("atg_bitwise_or_scalar_tensor", Napi::Function::New(env__, atg_bitwise_or_scalar_tensor));
  exports.Set("atg_bitwise_or_tensor", Napi::Function::New(env__, atg_bitwise_or_tensor));
  exports.Set("atg_bitwise_or_tensor_out", Napi::Function::New(env__, atg_bitwise_or_tensor_out));
  exports.Set("atg_bitwise_or_scalar_out", Napi::Function::New(env__, atg_bitwise_or_scalar_out));
  exports.Set("atg_bitwise_or_scalar_tensor_out", Napi::Function::New(env__, atg_bitwise_or_scalar_tensor_out));
  exports.Set("atg_bitwise_or_", Napi::Function::New(env__, atg_bitwise_or_));
  exports.Set("atg_bitwise_or_tensor_", Napi::Function::New(env__, atg_bitwise_or_tensor_));
  exports.Set("atg___or__", Napi::Function::New(env__, atg___or__));
  exports.Set("atg___or__tensor_", Napi::Function::New(env__, atg___or__tensor_));
  exports.Set("atg___ior__", Napi::Function::New(env__, atg___ior__));
  exports.Set("atg___ior__tensor_", Napi::Function::New(env__, atg___ior__tensor_));
  exports.Set("atg_bitwise_xor", Napi::Function::New(env__, atg_bitwise_xor));
  exports.Set("atg_bitwise_xor_scalar_tensor", Napi::Function::New(env__, atg_bitwise_xor_scalar_tensor));
  exports.Set("atg_bitwise_xor_tensor", Napi::Function::New(env__, atg_bitwise_xor_tensor));
  exports.Set("atg_bitwise_xor_tensor_out", Napi::Function::New(env__, atg_bitwise_xor_tensor_out));
  exports.Set("atg_bitwise_xor_scalar_out", Napi::Function::New(env__, atg_bitwise_xor_scalar_out));
  exports.Set("atg_bitwise_xor_scalar_tensor_out", Napi::Function::New(env__, atg_bitwise_xor_scalar_tensor_out));
  exports.Set("atg_bitwise_xor_", Napi::Function::New(env__, atg_bitwise_xor_));
  exports.Set("atg_bitwise_xor_tensor_", Napi::Function::New(env__, atg_bitwise_xor_tensor_));
  exports.Set("atg___xor__", Napi::Function::New(env__, atg___xor__));
  exports.Set("atg___xor__tensor_", Napi::Function::New(env__, atg___xor__tensor_));
  exports.Set("atg___ixor__", Napi::Function::New(env__, atg___ixor__));
  exports.Set("atg___ixor__tensor_", Napi::Function::New(env__, atg___ixor__tensor_));
  exports.Set("atg___lshift__", Napi::Function::New(env__, atg___lshift__));
  exports.Set("atg___lshift__tensor_", Napi::Function::New(env__, atg___lshift__tensor_));
  exports.Set("atg___lshift__scalar_out_", Napi::Function::New(env__, atg___lshift__scalar_out_));
  exports.Set("atg___lshift__tensor_out_", Napi::Function::New(env__, atg___lshift__tensor_out_));
  exports.Set("atg___ilshift__", Napi::Function::New(env__, atg___ilshift__));
  exports.Set("atg___ilshift__tensor_", Napi::Function::New(env__, atg___ilshift__tensor_));
  exports.Set("atg_bitwise_left_shift", Napi::Function::New(env__, atg_bitwise_left_shift));
  exports.Set("atg_bitwise_left_shift_tensor_scalar", Napi::Function::New(env__, atg_bitwise_left_shift_tensor_scalar));
  exports.Set("atg_bitwise_left_shift_scalar_tensor", Napi::Function::New(env__, atg_bitwise_left_shift_scalar_tensor));
  exports.Set("atg_bitwise_left_shift_tensor_out", Napi::Function::New(env__, atg_bitwise_left_shift_tensor_out));
  exports.Set("atg_bitwise_left_shift_tensor_scalar_out", Napi::Function::New(env__, atg_bitwise_left_shift_tensor_scalar_out));
  exports.Set("atg_bitwise_left_shift_scalar_tensor_out", Napi::Function::New(env__, atg_bitwise_left_shift_scalar_tensor_out));
  exports.Set("atg_bitwise_left_shift_", Napi::Function::New(env__, atg_bitwise_left_shift_));
  exports.Set("atg_bitwise_left_shift_tensor_scalar_", Napi::Function::New(env__, atg_bitwise_left_shift_tensor_scalar_));
  exports.Set("atg___rshift__", Napi::Function::New(env__, atg___rshift__));
  exports.Set("atg___rshift__tensor_", Napi::Function::New(env__, atg___rshift__tensor_));
  exports.Set("atg___rshift__scalar_out_", Napi::Function::New(env__, atg___rshift__scalar_out_));
  exports.Set("atg___rshift__tensor_out_", Napi::Function::New(env__, atg___rshift__tensor_out_));
  exports.Set("atg___irshift__", Napi::Function::New(env__, atg___irshift__));
  exports.Set("atg___irshift__tensor_", Napi::Function::New(env__, atg___irshift__tensor_));
  exports.Set("atg_bitwise_right_shift", Napi::Function::New(env__, atg_bitwise_right_shift));
  exports.Set("atg_bitwise_right_shift_tensor_scalar", Napi::Function::New(env__, atg_bitwise_right_shift_tensor_scalar));
  exports.Set("atg_bitwise_right_shift_scalar_tensor", Napi::Function::New(env__, atg_bitwise_right_shift_scalar_tensor));
  exports.Set("atg_bitwise_right_shift_tensor_out", Napi::Function::New(env__, atg_bitwise_right_shift_tensor_out));
  exports.Set("atg_bitwise_right_shift_tensor_scalar_out", Napi::Function::New(env__, atg_bitwise_right_shift_tensor_scalar_out));
  exports.Set("atg_bitwise_right_shift_scalar_tensor_out", Napi::Function::New(env__, atg_bitwise_right_shift_scalar_tensor_out));
  exports.Set("atg_bitwise_right_shift_", Napi::Function::New(env__, atg_bitwise_right_shift_));
  exports.Set("atg_bitwise_right_shift_tensor_scalar_", Napi::Function::New(env__, atg_bitwise_right_shift_tensor_scalar_));
  exports.Set("atg_tril_", Napi::Function::New(env__, atg_tril_));
  exports.Set("atg_triu_", Napi::Function::New(env__, atg_triu_));
  exports.Set("atg_digamma_", Napi::Function::New(env__, atg_digamma_));
  exports.Set("atg_lerp_", Napi::Function::New(env__, atg_lerp_));
  exports.Set("atg_lerp_tensor_", Napi::Function::New(env__, atg_lerp_tensor_));
  exports.Set("atg_addbmm_", Napi::Function::New(env__, atg_addbmm_));
  exports.Set("atg_addbmm", Napi::Function::New(env__, atg_addbmm));
  exports.Set("atg_addbmm_out", Napi::Function::New(env__, atg_addbmm_out));
  exports.Set("atg_random_", Napi::Function::New(env__, atg_random_));
  exports.Set("atg_random_to_", Napi::Function::New(env__, atg_random_to_));
  exports.Set("atg_random_from_", Napi::Function::New(env__, atg_random_from_));
  exports.Set("atg_uniform_", Napi::Function::New(env__, atg_uniform_));
  exports.Set("atg_cauchy_", Napi::Function::New(env__, atg_cauchy_));
  exports.Set("atg_log_normal_", Napi::Function::New(env__, atg_log_normal_));
  exports.Set("atg_exponential_", Napi::Function::New(env__, atg_exponential_));
  exports.Set("atg_geometric_", Napi::Function::New(env__, atg_geometric_));
  exports.Set("atg_diag", Napi::Function::New(env__, atg_diag));
  exports.Set("atg_diag_out", Napi::Function::New(env__, atg_diag_out));
  exports.Set("atg_cross", Napi::Function::New(env__, atg_cross));
  exports.Set("atg_cross_out", Napi::Function::New(env__, atg_cross_out));
  exports.Set("atg_triu", Napi::Function::New(env__, atg_triu));
  exports.Set("atg_triu_out", Napi::Function::New(env__, atg_triu_out));
  exports.Set("atg_tril", Napi::Function::New(env__, atg_tril));
  exports.Set("atg_tril_out", Napi::Function::New(env__, atg_tril_out));
  exports.Set("atg_tril_indices", Napi::Function::New(env__, atg_tril_indices));
  exports.Set("atg_tril_indices_out", Napi::Function::New(env__, atg_tril_indices_out));
  exports.Set("atg_triu_indices", Napi::Function::New(env__, atg_triu_indices));
  exports.Set("atg_triu_indices_out", Napi::Function::New(env__, atg_triu_indices_out));
  exports.Set("atg_trace", Napi::Function::New(env__, atg_trace));
  exports.Set("atg_trace_out", Napi::Function::New(env__, atg_trace_out));
  exports.Set("atg_trace_backward", Napi::Function::New(env__, atg_trace_backward));
  exports.Set("atg_ne", Napi::Function::New(env__, atg_ne));
  exports.Set("atg_ne_tensor", Napi::Function::New(env__, atg_ne_tensor));
  exports.Set("atg_ne_scalar_out", Napi::Function::New(env__, atg_ne_scalar_out));
  exports.Set("atg_ne_tensor_out", Napi::Function::New(env__, atg_ne_tensor_out));
  exports.Set("atg_ne_", Napi::Function::New(env__, atg_ne_));
  exports.Set("atg_ne_tensor_", Napi::Function::New(env__, atg_ne_tensor_));
  exports.Set("atg_not_equal", Napi::Function::New(env__, atg_not_equal));
  exports.Set("atg_not_equal_tensor", Napi::Function::New(env__, atg_not_equal_tensor));
  exports.Set("atg_not_equal_scalar_out", Napi::Function::New(env__, atg_not_equal_scalar_out));
  exports.Set("atg_not_equal_tensor_out", Napi::Function::New(env__, atg_not_equal_tensor_out));
  exports.Set("atg_not_equal_", Napi::Function::New(env__, atg_not_equal_));
  exports.Set("atg_not_equal_tensor_", Napi::Function::New(env__, atg_not_equal_tensor_));
  exports.Set("atg_eq", Napi::Function::New(env__, atg_eq));
  exports.Set("atg_eq_tensor", Napi::Function::New(env__, atg_eq_tensor));
  exports.Set("atg_eq_scalar_out", Napi::Function::New(env__, atg_eq_scalar_out));
  exports.Set("atg_eq_tensor_out", Napi::Function::New(env__, atg_eq_tensor_out));
  exports.Set("atg_ge", Napi::Function::New(env__, atg_ge));
  exports.Set("atg_ge_tensor", Napi::Function::New(env__, atg_ge_tensor));
  exports.Set("atg_ge_scalar_out", Napi::Function::New(env__, atg_ge_scalar_out));
  exports.Set("atg_ge_tensor_out", Napi::Function::New(env__, atg_ge_tensor_out));
  exports.Set("atg_ge_", Napi::Function::New(env__, atg_ge_));
  exports.Set("atg_ge_tensor_", Napi::Function::New(env__, atg_ge_tensor_));
  exports.Set("atg_greater_equal", Napi::Function::New(env__, atg_greater_equal));
  exports.Set("atg_greater_equal_tensor", Napi::Function::New(env__, atg_greater_equal_tensor));
  exports.Set("atg_greater_equal_scalar_out", Napi::Function::New(env__, atg_greater_equal_scalar_out));
  exports.Set("atg_greater_equal_tensor_out", Napi::Function::New(env__, atg_greater_equal_tensor_out));
  exports.Set("atg_greater_equal_", Napi::Function::New(env__, atg_greater_equal_));
  exports.Set("atg_greater_equal_tensor_", Napi::Function::New(env__, atg_greater_equal_tensor_));
  exports.Set("atg_le", Napi::Function::New(env__, atg_le));
  exports.Set("atg_le_tensor", Napi::Function::New(env__, atg_le_tensor));
  exports.Set("atg_le_scalar_out", Napi::Function::New(env__, atg_le_scalar_out));
  exports.Set("atg_le_tensor_out", Napi::Function::New(env__, atg_le_tensor_out));
  exports.Set("atg_le_", Napi::Function::New(env__, atg_le_));
  exports.Set("atg_le_tensor_", Napi::Function::New(env__, atg_le_tensor_));
  exports.Set("atg_less_equal", Napi::Function::New(env__, atg_less_equal));
  exports.Set("atg_less_equal_tensor", Napi::Function::New(env__, atg_less_equal_tensor));
  exports.Set("atg_less_equal_scalar_out", Napi::Function::New(env__, atg_less_equal_scalar_out));
  exports.Set("atg_less_equal_tensor_out", Napi::Function::New(env__, atg_less_equal_tensor_out));
  exports.Set("atg_less_equal_", Napi::Function::New(env__, atg_less_equal_));
  exports.Set("atg_less_equal_tensor_", Napi::Function::New(env__, atg_less_equal_tensor_));
  exports.Set("atg_gt", Napi::Function::New(env__, atg_gt));
  exports.Set("atg_gt_tensor", Napi::Function::New(env__, atg_gt_tensor));
  exports.Set("atg_gt_scalar_out", Napi::Function::New(env__, atg_gt_scalar_out));
  exports.Set("atg_gt_tensor_out", Napi::Function::New(env__, atg_gt_tensor_out));
  exports.Set("atg_gt_", Napi::Function::New(env__, atg_gt_));
  exports.Set("atg_gt_tensor_", Napi::Function::New(env__, atg_gt_tensor_));
  exports.Set("atg_greater", Napi::Function::New(env__, atg_greater));
  exports.Set("atg_greater_tensor", Napi::Function::New(env__, atg_greater_tensor));
  exports.Set("atg_greater_scalar_out", Napi::Function::New(env__, atg_greater_scalar_out));
  exports.Set("atg_greater_tensor_out", Napi::Function::New(env__, atg_greater_tensor_out));
  exports.Set("atg_greater_", Napi::Function::New(env__, atg_greater_));
  exports.Set("atg_greater_tensor_", Napi::Function::New(env__, atg_greater_tensor_));
  exports.Set("atg_lt", Napi::Function::New(env__, atg_lt));
  exports.Set("atg_lt_tensor", Napi::Function::New(env__, atg_lt_tensor));
  exports.Set("atg_lt_scalar_out", Napi::Function::New(env__, atg_lt_scalar_out));
  exports.Set("atg_lt_tensor_out", Napi::Function::New(env__, atg_lt_tensor_out));
  exports.Set("atg_lt_", Napi::Function::New(env__, atg_lt_));
  exports.Set("atg_lt_tensor_", Napi::Function::New(env__, atg_lt_tensor_));
  exports.Set("atg_less", Napi::Function::New(env__, atg_less));
  exports.Set("atg_less_tensor", Napi::Function::New(env__, atg_less_tensor));
  exports.Set("atg_less_scalar_out", Napi::Function::New(env__, atg_less_scalar_out));
  exports.Set("atg_less_tensor_out", Napi::Function::New(env__, atg_less_tensor_out));
  exports.Set("atg_less_", Napi::Function::New(env__, atg_less_));
  exports.Set("atg_less_tensor_", Napi::Function::New(env__, atg_less_tensor_));
  exports.Set("atg_take", Napi::Function::New(env__, atg_take));
  exports.Set("atg_take_out", Napi::Function::New(env__, atg_take_out));
  exports.Set("atg_take_along_dim", Napi::Function::New(env__, atg_take_along_dim));
  exports.Set("atg_take_along_dim_out", Napi::Function::New(env__, atg_take_along_dim_out));
  exports.Set("atg_index_select", Napi::Function::New(env__, atg_index_select));
  exports.Set("atg_index_select_out", Napi::Function::New(env__, atg_index_select_out));
  exports.Set("atg_index_select_backward", Napi::Function::New(env__, atg_index_select_backward));
  exports.Set("atg_masked_select", Napi::Function::New(env__, atg_masked_select));
  exports.Set("atg_masked_select_out", Napi::Function::New(env__, atg_masked_select_out));
  exports.Set("atg_masked_select_backward", Napi::Function::New(env__, atg_masked_select_backward));
  exports.Set("atg_nonzero", Napi::Function::New(env__, atg_nonzero));
  exports.Set("atg_nonzero_out", Napi::Function::New(env__, atg_nonzero_out));
  exports.Set("atg_argwhere", Napi::Function::New(env__, atg_argwhere));
  exports.Set("atg_gather", Napi::Function::New(env__, atg_gather));
  exports.Set("atg_gather_out", Napi::Function::New(env__, atg_gather_out));
  exports.Set("atg_gather_backward", Napi::Function::New(env__, atg_gather_backward));
  exports.Set("atg__gather_sparse_backward", Napi::Function::New(env__, atg__gather_sparse_backward));
  exports.Set("atg_addcmul", Napi::Function::New(env__, atg_addcmul));
  exports.Set("atg_addcmul_out", Napi::Function::New(env__, atg_addcmul_out));
  exports.Set("atg_addcmul_", Napi::Function::New(env__, atg_addcmul_));
  exports.Set("atg_addcdiv", Napi::Function::New(env__, atg_addcdiv));
  exports.Set("atg_addcdiv_out", Napi::Function::New(env__, atg_addcdiv_out));
  exports.Set("atg_addcdiv_", Napi::Function::New(env__, atg_addcdiv_));
  exports.Set("atg_cross_entropy_loss", Napi::Function::New(env__, atg_cross_entropy_loss));
  exports.Set("atg_triangular_solve", Napi::Function::New(env__, atg_triangular_solve));
  exports.Set("atg_triangular_solve_x", Napi::Function::New(env__, atg_triangular_solve_x));
  exports.Set("atg__linalg_check_errors", Napi::Function::New(env__, atg__linalg_check_errors));
  exports.Set("atg_linalg_solve_triangular", Napi::Function::New(env__, atg_linalg_solve_triangular));
  exports.Set("atg_linalg_solve_triangular_out", Napi::Function::New(env__, atg_linalg_solve_triangular_out));
  exports.Set("atg_linalg_vander", Napi::Function::New(env__, atg_linalg_vander));
  exports.Set("atg_svd", Napi::Function::New(env__, atg_svd));
  exports.Set("atg_svd_u", Napi::Function::New(env__, atg_svd_u));
  exports.Set("atg_swapaxes", Napi::Function::New(env__, atg_swapaxes));
  exports.Set("atg_swapaxes_", Napi::Function::New(env__, atg_swapaxes_));
  exports.Set("atg_swapdims", Napi::Function::New(env__, atg_swapdims));
  exports.Set("atg_swapdims_", Napi::Function::New(env__, atg_swapdims_));
  exports.Set("atg_cholesky", Napi::Function::New(env__, atg_cholesky));
  exports.Set("atg_cholesky_out", Napi::Function::New(env__, atg_cholesky_out));
  exports.Set("atg_cholesky_solve", Napi::Function::New(env__, atg_cholesky_solve));
  exports.Set("atg_cholesky_solve_out", Napi::Function::New(env__, atg_cholesky_solve_out));
  exports.Set("atg__cholesky_solve_helper", Napi::Function::New(env__, atg__cholesky_solve_helper));
  exports.Set("atg__cholesky_solve_helper_out", Napi::Function::New(env__, atg__cholesky_solve_helper_out));
  exports.Set("atg_cholesky_inverse", Napi::Function::New(env__, atg_cholesky_inverse));
  exports.Set("atg_cholesky_inverse_out", Napi::Function::New(env__, atg_cholesky_inverse_out));
  exports.Set("atg_qr", Napi::Function::New(env__, atg_qr));
  exports.Set("atg_qr_q", Napi::Function::New(env__, atg_qr_q));
  exports.Set("atg_geqrf", Napi::Function::New(env__, atg_geqrf));
  exports.Set("atg_geqrf_a", Napi::Function::New(env__, atg_geqrf_a));
  exports.Set("atg_orgqr", Napi::Function::New(env__, atg_orgqr));
  exports.Set("atg_orgqr_out", Napi::Function::New(env__, atg_orgqr_out));
  exports.Set("atg_ormqr", Napi::Function::New(env__, atg_ormqr));
  exports.Set("atg_ormqr_out", Napi::Function::New(env__, atg_ormqr_out));
  exports.Set("atg__lu_with_info", Napi::Function::New(env__, atg__lu_with_info));
  exports.Set("atg_lu_solve", Napi::Function::New(env__, atg_lu_solve));
  exports.Set("atg_lu_solve_out", Napi::Function::New(env__, atg_lu_solve_out));
  exports.Set("atg_lu_unpack", Napi::Function::New(env__, atg_lu_unpack));
  exports.Set("atg_lu_unpack_out", Napi::Function::New(env__, atg_lu_unpack_out));
  exports.Set("atg_multinomial", Napi::Function::New(env__, atg_multinomial));
  exports.Set("atg_multinomial_out", Napi::Function::New(env__, atg_multinomial_out));
  exports.Set("atg_lgamma", Napi::Function::New(env__, atg_lgamma));
  exports.Set("atg_lgamma_out", Napi::Function::New(env__, atg_lgamma_out));
  exports.Set("atg_lgamma_", Napi::Function::New(env__, atg_lgamma_));
  exports.Set("atg_digamma", Napi::Function::New(env__, atg_digamma));
  exports.Set("atg_digamma_out", Napi::Function::New(env__, atg_digamma_out));
  exports.Set("atg_polygamma", Napi::Function::New(env__, atg_polygamma));
  exports.Set("atg_polygamma_out", Napi::Function::New(env__, atg_polygamma_out));
  exports.Set("atg_polygamma_", Napi::Function::New(env__, atg_polygamma_));
  exports.Set("atg_erfinv", Napi::Function::New(env__, atg_erfinv));
  exports.Set("atg_erfinv_out", Napi::Function::New(env__, atg_erfinv_out));
  exports.Set("atg_erfinv_", Napi::Function::New(env__, atg_erfinv_));
  exports.Set("atg_i0", Napi::Function::New(env__, atg_i0));
  exports.Set("atg_i0_out", Napi::Function::New(env__, atg_i0_out));
  exports.Set("atg_i0_", Napi::Function::New(env__, atg_i0_));
  exports.Set("atg_sign", Napi::Function::New(env__, atg_sign));
  exports.Set("atg_sign_out", Napi::Function::New(env__, atg_sign_out));
  exports.Set("atg_sign_", Napi::Function::New(env__, atg_sign_));
  exports.Set("atg_signbit", Napi::Function::New(env__, atg_signbit));
  exports.Set("atg_signbit_out", Napi::Function::New(env__, atg_signbit_out));
  exports.Set("atg_dist", Napi::Function::New(env__, atg_dist));
  exports.Set("atg_dist_out", Napi::Function::New(env__, atg_dist_out));
  exports.Set("atg_atan2", Napi::Function::New(env__, atg_atan2));
  exports.Set("atg_atan2_out", Napi::Function::New(env__, atg_atan2_out));
  exports.Set("atg_atan2_", Napi::Function::New(env__, atg_atan2_));
  exports.Set("atg_arctan2", Napi::Function::New(env__, atg_arctan2));
  exports.Set("atg_arctan2_out", Napi::Function::New(env__, atg_arctan2_out));
  exports.Set("atg_arctan2_", Napi::Function::New(env__, atg_arctan2_));
  exports.Set("atg_lerp", Napi::Function::New(env__, atg_lerp));
  exports.Set("atg_lerp_tensor", Napi::Function::New(env__, atg_lerp_tensor));
  exports.Set("atg_lerp_scalar_out", Napi::Function::New(env__, atg_lerp_scalar_out));
  exports.Set("atg_lerp_tensor_out", Napi::Function::New(env__, atg_lerp_tensor_out));
  exports.Set("atg_histc", Napi::Function::New(env__, atg_histc));
  exports.Set("atg_histc_out", Napi::Function::New(env__, atg_histc_out));
  exports.Set("atg_histogram", Napi::Function::New(env__, atg_histogram));
  exports.Set("atg_histogram_bin_ct", Napi::Function::New(env__, atg_histogram_bin_ct));
  exports.Set("atg_histogram_bins_tensor_out", Napi::Function::New(env__, atg_histogram_bins_tensor_out));
  exports.Set("atg_histogram_bin_ct_out", Napi::Function::New(env__, atg_histogram_bin_ct_out));
  exports.Set("atg__histogramdd_from_bin_cts", Napi::Function::New(env__, atg__histogramdd_from_bin_cts));
  exports.Set("atg__histogramdd_from_bin_cts_out", Napi::Function::New(env__, atg__histogramdd_from_bin_cts_out));
  exports.Set("atg__histogramdd_from_bin_tensors", Napi::Function::New(env__, atg__histogramdd_from_bin_tensors));
  exports.Set("atg__histogramdd_from_bin_tensors_out", Napi::Function::New(env__, atg__histogramdd_from_bin_tensors_out));
  exports.Set("atg_fmod", Napi::Function::New(env__, atg_fmod));
  exports.Set("atg_fmod_tensor", Napi::Function::New(env__, atg_fmod_tensor));
  exports.Set("atg_fmod_scalar_out", Napi::Function::New(env__, atg_fmod_scalar_out));
  exports.Set("atg_fmod_tensor_out", Napi::Function::New(env__, atg_fmod_tensor_out));
  exports.Set("atg_fmod_", Napi::Function::New(env__, atg_fmod_));
  exports.Set("atg_fmod_tensor_", Napi::Function::New(env__, atg_fmod_tensor_));
  exports.Set("atg_hypot", Napi::Function::New(env__, atg_hypot));
  exports.Set("atg_hypot_out", Napi::Function::New(env__, atg_hypot_out));
  exports.Set("atg_hypot_", Napi::Function::New(env__, atg_hypot_));
  exports.Set("atg_igamma", Napi::Function::New(env__, atg_igamma));
  exports.Set("atg_igamma_out", Napi::Function::New(env__, atg_igamma_out));
  exports.Set("atg_igamma_", Napi::Function::New(env__, atg_igamma_));
  exports.Set("atg_igammac", Napi::Function::New(env__, atg_igammac));
  exports.Set("atg_igammac_out", Napi::Function::New(env__, atg_igammac_out));
  exports.Set("atg_igammac_", Napi::Function::New(env__, atg_igammac_));
  exports.Set("atg_nextafter", Napi::Function::New(env__, atg_nextafter));
  exports.Set("atg_nextafter_out", Napi::Function::New(env__, atg_nextafter_out));
  exports.Set("atg_nextafter_", Napi::Function::New(env__, atg_nextafter_));
  exports.Set("atg_remainder", Napi::Function::New(env__, atg_remainder));
  exports.Set("atg_remainder_tensor", Napi::Function::New(env__, atg_remainder_tensor));
  exports.Set("atg_remainder_scalar_tensor", Napi::Function::New(env__, atg_remainder_scalar_tensor));
  exports.Set("atg_remainder_scalar_out", Napi::Function::New(env__, atg_remainder_scalar_out));
  exports.Set("atg_remainder_tensor_out", Napi::Function::New(env__, atg_remainder_tensor_out));
  exports.Set("atg_remainder_scalar_tensor_out", Napi::Function::New(env__, atg_remainder_scalar_tensor_out));
  exports.Set("atg_remainder_", Napi::Function::New(env__, atg_remainder_));
  exports.Set("atg_remainder_tensor_", Napi::Function::New(env__, atg_remainder_tensor_));
  exports.Set("atg_fmin", Napi::Function::New(env__, atg_fmin));
  exports.Set("atg_fmin_out", Napi::Function::New(env__, atg_fmin_out));
  exports.Set("atg_fmax", Napi::Function::New(env__, atg_fmax));
  exports.Set("atg_fmax_out", Napi::Function::New(env__, atg_fmax_out));
  exports.Set("atg_maximum", Napi::Function::New(env__, atg_maximum));
  exports.Set("atg_maximum_out", Napi::Function::New(env__, atg_maximum_out));
  exports.Set("atg_minimum", Napi::Function::New(env__, atg_minimum));
  exports.Set("atg_minimum_out", Napi::Function::New(env__, atg_minimum_out));
  exports.Set("atg_quantile", Napi::Function::New(env__, atg_quantile));
  exports.Set("atg_quantile_scalar", Napi::Function::New(env__, atg_quantile_scalar));
  exports.Set("atg_quantile_out", Napi::Function::New(env__, atg_quantile_out));
  exports.Set("atg_quantile_scalar_out", Napi::Function::New(env__, atg_quantile_scalar_out));
  exports.Set("atg_nanquantile", Napi::Function::New(env__, atg_nanquantile));
  exports.Set("atg_nanquantile_scalar", Napi::Function::New(env__, atg_nanquantile_scalar));
  exports.Set("atg_nanquantile_out", Napi::Function::New(env__, atg_nanquantile_out));
  exports.Set("atg_nanquantile_scalar_out", Napi::Function::New(env__, atg_nanquantile_scalar_out));
  exports.Set("atg_sort", Napi::Function::New(env__, atg_sort));
  exports.Set("atg_sort_stable", Napi::Function::New(env__, atg_sort_stable));
  exports.Set("atg_sort_values", Napi::Function::New(env__, atg_sort_values));
  exports.Set("atg_sort_values_stable", Napi::Function::New(env__, atg_sort_values_stable));
  exports.Set("atg_msort", Napi::Function::New(env__, atg_msort));
  exports.Set("atg_msort_out", Napi::Function::New(env__, atg_msort_out));
  exports.Set("atg_argsort", Napi::Function::New(env__, atg_argsort));
  exports.Set("atg_argsort_stable", Napi::Function::New(env__, atg_argsort_stable));
  exports.Set("atg_argsort_stable_out", Napi::Function::New(env__, atg_argsort_stable_out));
  exports.Set("atg_topk", Napi::Function::New(env__, atg_topk));
  exports.Set("atg_topk_values", Napi::Function::New(env__, atg_topk_values));
  exports.Set("atg_renorm", Napi::Function::New(env__, atg_renorm));
  exports.Set("atg_renorm_out", Napi::Function::New(env__, atg_renorm_out));
  exports.Set("atg_renorm_", Napi::Function::New(env__, atg_renorm_));
  exports.Set("atg_unfold", Napi::Function::New(env__, atg_unfold));
  exports.Set("atg_unfold_backward", Napi::Function::New(env__, atg_unfold_backward));
  exports.Set("atg_unfold_backward_out", Napi::Function::New(env__, atg_unfold_backward_out));
  exports.Set("atg_equal", Napi::Function::New(env__, atg_equal));
  exports.Set("atg_pow", Napi::Function::New(env__, atg_pow));
  exports.Set("atg_pow_scalar", Napi::Function::New(env__, atg_pow_scalar));
  exports.Set("atg_pow_tensor_scalar", Napi::Function::New(env__, atg_pow_tensor_scalar));
  exports.Set("atg_pow_tensor_tensor_out", Napi::Function::New(env__, atg_pow_tensor_tensor_out));
  exports.Set("atg_pow_scalar_out", Napi::Function::New(env__, atg_pow_scalar_out));
  exports.Set("atg_pow_tensor_scalar_out", Napi::Function::New(env__, atg_pow_tensor_scalar_out));
  exports.Set("atg_pow_", Napi::Function::New(env__, atg_pow_));
  exports.Set("atg_pow_tensor_", Napi::Function::New(env__, atg_pow_tensor_));
  exports.Set("atg_float_power", Napi::Function::New(env__, atg_float_power));
  exports.Set("atg_float_power_scalar", Napi::Function::New(env__, atg_float_power_scalar));
  exports.Set("atg_float_power_tensor_scalar", Napi::Function::New(env__, atg_float_power_tensor_scalar));
  exports.Set("atg_float_power_tensor_tensor_out", Napi::Function::New(env__, atg_float_power_tensor_tensor_out));
  exports.Set("atg_float_power_scalar_out", Napi::Function::New(env__, atg_float_power_scalar_out));
  exports.Set("atg_float_power_tensor_scalar_out", Napi::Function::New(env__, atg_float_power_tensor_scalar_out));
  exports.Set("atg_float_power_", Napi::Function::New(env__, atg_float_power_));
  exports.Set("atg_float_power_tensor_", Napi::Function::New(env__, atg_float_power_tensor_));
  exports.Set("atg_normal_", Napi::Function::New(env__, atg_normal_));
  exports.Set("atg_normal_functional", Napi::Function::New(env__, atg_normal_functional));
  exports.Set("atg_alias", Napi::Function::New(env__, atg_alias));
  exports.Set("atg__amp_update_scale_", Napi::Function::New(env__, atg__amp_update_scale_));
  exports.Set("atg_bucketize", Napi::Function::New(env__, atg_bucketize));
  exports.Set("atg_bucketize_scalar", Napi::Function::New(env__, atg_bucketize_scalar));
  exports.Set("atg_bucketize_tensor_out", Napi::Function::New(env__, atg_bucketize_tensor_out));
  exports.Set("atg_bucketize_scalar_out", Napi::Function::New(env__, atg_bucketize_scalar_out));
  exports.Set("atg_searchsorted", Napi::Function::New(env__, atg_searchsorted));
  exports.Set("atg_searchsorted_scalar", Napi::Function::New(env__, atg_searchsorted_scalar));
  exports.Set("atg_searchsorted_tensor_out", Napi::Function::New(env__, atg_searchsorted_tensor_out));
  exports.Set("atg_searchsorted_scalar_out", Napi::Function::New(env__, atg_searchsorted_scalar_out));
  exports.Set("atg__convert_indices_from_coo_to_csr", Napi::Function::New(env__, atg__convert_indices_from_coo_to_csr));
  exports.Set("atg__convert_indices_from_coo_to_csr_out", Napi::Function::New(env__, atg__convert_indices_from_coo_to_csr_out));
  exports.Set("atg__convert_indices_from_csr_to_coo", Napi::Function::New(env__, atg__convert_indices_from_csr_to_coo));
  exports.Set("atg__convert_indices_from_csr_to_coo_out", Napi::Function::New(env__, atg__convert_indices_from_csr_to_coo_out));
  exports.Set("atg_mse_loss", Napi::Function::New(env__, atg_mse_loss));
  exports.Set("atg_mse_loss_out", Napi::Function::New(env__, atg_mse_loss_out));
  exports.Set("atg_mse_loss_backward", Napi::Function::New(env__, atg_mse_loss_backward));
  exports.Set("atg_mse_loss_backward_grad_input", Napi::Function::New(env__, atg_mse_loss_backward_grad_input));
  exports.Set("atg_l1_loss", Napi::Function::New(env__, atg_l1_loss));
  exports.Set("atg_multi_margin_loss_backward", Napi::Function::New(env__, atg_multi_margin_loss_backward));
  exports.Set("atg_multi_margin_loss_backward_grad_input", Napi::Function::New(env__, atg_multi_margin_loss_backward_grad_input));
  exports.Set("atg_multilabel_margin_loss", Napi::Function::New(env__, atg_multilabel_margin_loss));
  exports.Set("atg_multilabel_margin_loss_out", Napi::Function::New(env__, atg_multilabel_margin_loss_out));
  exports.Set("atg_multilabel_margin_loss_backward", Napi::Function::New(env__, atg_multilabel_margin_loss_backward));
  exports.Set("atg_multilabel_margin_loss_backward_grad_input", Napi::Function::New(env__, atg_multilabel_margin_loss_backward_grad_input));
  exports.Set("atg_nll_loss", Napi::Function::New(env__, atg_nll_loss));
  exports.Set("atg_nll_loss_out", Napi::Function::New(env__, atg_nll_loss_out));
  exports.Set("atg_nll_loss_nd", Napi::Function::New(env__, atg_nll_loss_nd));
  exports.Set("atg_nll_loss_backward", Napi::Function::New(env__, atg_nll_loss_backward));
  exports.Set("atg_nll_loss_backward_grad_input", Napi::Function::New(env__, atg_nll_loss_backward_grad_input));
  exports.Set("atg_nll_loss2d", Napi::Function::New(env__, atg_nll_loss2d));
  exports.Set("atg_nll_loss2d_out", Napi::Function::New(env__, atg_nll_loss2d_out));
  exports.Set("atg_nll_loss2d_backward", Napi::Function::New(env__, atg_nll_loss2d_backward));
  exports.Set("atg_nll_loss2d_backward_grad_input", Napi::Function::New(env__, atg_nll_loss2d_backward_grad_input));
  exports.Set("atg_smooth_l1_loss", Napi::Function::New(env__, atg_smooth_l1_loss));
  exports.Set("atg_smooth_l1_loss_out", Napi::Function::New(env__, atg_smooth_l1_loss_out));
  exports.Set("atg_smooth_l1_loss_backward", Napi::Function::New(env__, atg_smooth_l1_loss_backward));
  exports.Set("atg_smooth_l1_loss_backward_grad_input", Napi::Function::New(env__, atg_smooth_l1_loss_backward_grad_input));
  exports.Set("atg_huber_loss", Napi::Function::New(env__, atg_huber_loss));
  exports.Set("atg_huber_loss_out", Napi::Function::New(env__, atg_huber_loss_out));
  exports.Set("atg_huber_loss_backward", Napi::Function::New(env__, atg_huber_loss_backward));
  exports.Set("atg_huber_loss_backward_out", Napi::Function::New(env__, atg_huber_loss_backward_out));
  exports.Set("atg_soft_margin_loss", Napi::Function::New(env__, atg_soft_margin_loss));
  exports.Set("atg_soft_margin_loss_out", Napi::Function::New(env__, atg_soft_margin_loss_out));
  exports.Set("atg_soft_margin_loss_backward", Napi::Function::New(env__, atg_soft_margin_loss_backward));
  exports.Set("atg_soft_margin_loss_backward_grad_input", Napi::Function::New(env__, atg_soft_margin_loss_backward_grad_input));
  exports.Set("atg_elu", Napi::Function::New(env__, atg_elu));
  exports.Set("atg_elu_out", Napi::Function::New(env__, atg_elu_out));
  exports.Set("atg_elu_backward", Napi::Function::New(env__, atg_elu_backward));
  exports.Set("atg_elu_backward_grad_input", Napi::Function::New(env__, atg_elu_backward_grad_input));
  exports.Set("atg_elu_", Napi::Function::New(env__, atg_elu_));
  exports.Set("atg_glu", Napi::Function::New(env__, atg_glu));
  exports.Set("atg_glu_out", Napi::Function::New(env__, atg_glu_out));
  exports.Set("atg_glu_backward", Napi::Function::New(env__, atg_glu_backward));
  exports.Set("atg_glu_backward_grad_input", Napi::Function::New(env__, atg_glu_backward_grad_input));
  exports.Set("atg_glu_jvp", Napi::Function::New(env__, atg_glu_jvp));
  exports.Set("atg_glu_jvp_out", Napi::Function::New(env__, atg_glu_jvp_out));
  exports.Set("atg_glu_backward_jvp", Napi::Function::New(env__, atg_glu_backward_jvp));
  exports.Set("atg_glu_backward_jvp_out", Napi::Function::New(env__, atg_glu_backward_jvp_out));
  exports.Set("atg_hardsigmoid", Napi::Function::New(env__, atg_hardsigmoid));
  exports.Set("atg_hardsigmoid_out", Napi::Function::New(env__, atg_hardsigmoid_out));
  exports.Set("atg_hardsigmoid_", Napi::Function::New(env__, atg_hardsigmoid_));
  exports.Set("atg_hardsigmoid_backward", Napi::Function::New(env__, atg_hardsigmoid_backward));
  exports.Set("atg_hardsigmoid_backward_grad_input", Napi::Function::New(env__, atg_hardsigmoid_backward_grad_input));
  exports.Set("atg_hardtanh", Napi::Function::New(env__, atg_hardtanh));
  exports.Set("atg_hardtanh_out", Napi::Function::New(env__, atg_hardtanh_out));
  exports.Set("atg_hardtanh_backward", Napi::Function::New(env__, atg_hardtanh_backward));
  exports.Set("atg_hardtanh_backward_grad_input", Napi::Function::New(env__, atg_hardtanh_backward_grad_input));
  exports.Set("atg_hardtanh_", Napi::Function::New(env__, atg_hardtanh_));
  exports.Set("atg_hardswish", Napi::Function::New(env__, atg_hardswish));
  exports.Set("atg_hardswish_out", Napi::Function::New(env__, atg_hardswish_out));
  exports.Set("atg_hardswish_", Napi::Function::New(env__, atg_hardswish_));
  exports.Set("atg_hardswish_backward", Napi::Function::New(env__, atg_hardswish_backward));
  exports.Set("atg_hardswish_backward_out", Napi::Function::New(env__, atg_hardswish_backward_out));
  exports.Set("atg_leaky_relu", Napi::Function::New(env__, atg_leaky_relu));
  exports.Set("atg_leaky_relu_out", Napi::Function::New(env__, atg_leaky_relu_out));
  exports.Set("atg_leaky_relu_backward", Napi::Function::New(env__, atg_leaky_relu_backward));
  exports.Set("atg_leaky_relu_backward_grad_input", Napi::Function::New(env__, atg_leaky_relu_backward_grad_input));
  exports.Set("atg_leaky_relu_", Napi::Function::New(env__, atg_leaky_relu_));
  exports.Set("atg_log_sigmoid", Napi::Function::New(env__, atg_log_sigmoid));
  exports.Set("atg_log_sigmoid_out", Napi::Function::New(env__, atg_log_sigmoid_out));
  exports.Set("atg_log_sigmoid_backward", Napi::Function::New(env__, atg_log_sigmoid_backward));
  exports.Set("atg_log_sigmoid_backward_grad_input", Napi::Function::New(env__, atg_log_sigmoid_backward_grad_input));
  exports.Set("atg_rrelu_with_noise", Napi::Function::New(env__, atg_rrelu_with_noise));
  exports.Set("atg_rrelu_with_noise_out", Napi::Function::New(env__, atg_rrelu_with_noise_out));
  exports.Set("atg_rrelu_with_noise_backward", Napi::Function::New(env__, atg_rrelu_with_noise_backward));
  exports.Set("atg_rrelu_with_noise_backward_out", Napi::Function::New(env__, atg_rrelu_with_noise_backward_out));
  exports.Set("atg_rrelu_with_noise_", Napi::Function::New(env__, atg_rrelu_with_noise_));
  exports.Set("atg_softplus", Napi::Function::New(env__, atg_softplus));
  exports.Set("atg_softplus_out", Napi::Function::New(env__, atg_softplus_out));
  exports.Set("atg_softplus_backward", Napi::Function::New(env__, atg_softplus_backward));
  exports.Set("atg_softplus_backward_grad_input", Napi::Function::New(env__, atg_softplus_backward_grad_input));
  exports.Set("atg_softshrink", Napi::Function::New(env__, atg_softshrink));
  exports.Set("atg_softshrink_out", Napi::Function::New(env__, atg_softshrink_out));
  exports.Set("atg_softshrink_backward", Napi::Function::New(env__, atg_softshrink_backward));
  exports.Set("atg_softshrink_backward_grad_input", Napi::Function::New(env__, atg_softshrink_backward_grad_input));
  exports.Set("atg_adaptive_avg_pool2d", Napi::Function::New(env__, atg_adaptive_avg_pool2d));
  exports.Set("atg_adaptive_avg_pool2d_out", Napi::Function::New(env__, atg_adaptive_avg_pool2d_out));
  exports.Set("atg_mkldnn_adaptive_avg_pool2d", Napi::Function::New(env__, atg_mkldnn_adaptive_avg_pool2d));
  exports.Set("atg_mkldnn_adaptive_avg_pool2d_out", Napi::Function::New(env__, atg_mkldnn_adaptive_avg_pool2d_out));
  exports.Set("atg_mkldnn_adaptive_avg_pool2d_backward", Napi::Function::New(env__, atg_mkldnn_adaptive_avg_pool2d_backward));
  exports.Set("atg_mkldnn_adaptive_avg_pool2d_backward_out", Napi::Function::New(env__, atg_mkldnn_adaptive_avg_pool2d_backward_out));
  exports.Set("atg__adaptive_avg_pool2d", Napi::Function::New(env__, atg__adaptive_avg_pool2d));
  exports.Set("atg__adaptive_avg_pool2d_out", Napi::Function::New(env__, atg__adaptive_avg_pool2d_out));
  exports.Set("atg__adaptive_avg_pool2d_backward", Napi::Function::New(env__, atg__adaptive_avg_pool2d_backward));
  exports.Set("atg__adaptive_avg_pool2d_backward_out", Napi::Function::New(env__, atg__adaptive_avg_pool2d_backward_out));
  exports.Set("atg_adaptive_avg_pool3d", Napi::Function::New(env__, atg_adaptive_avg_pool3d));
  exports.Set("atg_adaptive_avg_pool3d_out", Napi::Function::New(env__, atg_adaptive_avg_pool3d_out));
  exports.Set("atg__adaptive_avg_pool3d", Napi::Function::New(env__, atg__adaptive_avg_pool3d));
  exports.Set("atg__adaptive_avg_pool3d_out", Napi::Function::New(env__, atg__adaptive_avg_pool3d_out));
  exports.Set("atg_adaptive_avg_pool3d_backward", Napi::Function::New(env__, atg_adaptive_avg_pool3d_backward));
  exports.Set("atg__adaptive_avg_pool3d_backward", Napi::Function::New(env__, atg__adaptive_avg_pool3d_backward));
  exports.Set("atg__adaptive_avg_pool3d_backward_out", Napi::Function::New(env__, atg__adaptive_avg_pool3d_backward_out));
  exports.Set("atg_adaptive_max_pool2d", Napi::Function::New(env__, atg_adaptive_max_pool2d));
  exports.Set("atg_adaptive_max_pool2d_out", Napi::Function::New(env__, atg_adaptive_max_pool2d_out));
  exports.Set("atg_adaptive_max_pool2d_backward", Napi::Function::New(env__, atg_adaptive_max_pool2d_backward));
  exports.Set("atg_adaptive_max_pool2d_backward_grad_input", Napi::Function::New(env__, atg_adaptive_max_pool2d_backward_grad_input));
  exports.Set("atg_adaptive_max_pool3d", Napi::Function::New(env__, atg_adaptive_max_pool3d));
  exports.Set("atg_adaptive_max_pool3d_out", Napi::Function::New(env__, atg_adaptive_max_pool3d_out));
  exports.Set("atg_adaptive_max_pool3d_backward", Napi::Function::New(env__, atg_adaptive_max_pool3d_backward));
  exports.Set("atg_adaptive_max_pool3d_backward_grad_input", Napi::Function::New(env__, atg_adaptive_max_pool3d_backward_grad_input));
  exports.Set("atg_avg_pool2d", Napi::Function::New(env__, atg_avg_pool2d));
  exports.Set("atg_avg_pool2d_out", Napi::Function::New(env__, atg_avg_pool2d_out));
  exports.Set("atg_avg_pool2d_backward", Napi::Function::New(env__, atg_avg_pool2d_backward));
  exports.Set("atg_avg_pool2d_backward_grad_input", Napi::Function::New(env__, atg_avg_pool2d_backward_grad_input));
  exports.Set("atg_avg_pool3d", Napi::Function::New(env__, atg_avg_pool3d));
  exports.Set("atg_avg_pool3d_out", Napi::Function::New(env__, atg_avg_pool3d_out));
  exports.Set("atg_avg_pool3d_backward", Napi::Function::New(env__, atg_avg_pool3d_backward));
  exports.Set("atg_avg_pool3d_backward_grad_input", Napi::Function::New(env__, atg_avg_pool3d_backward_grad_input));
  exports.Set("atg_fractional_max_pool2d", Napi::Function::New(env__, atg_fractional_max_pool2d));
  exports.Set("atg_fractional_max_pool2d_output", Napi::Function::New(env__, atg_fractional_max_pool2d_output));
  exports.Set("atg_fractional_max_pool2d_backward", Napi::Function::New(env__, atg_fractional_max_pool2d_backward));
  exports.Set("atg_fractional_max_pool2d_backward_grad_input", Napi::Function::New(env__, atg_fractional_max_pool2d_backward_grad_input));
  exports.Set("atg_fractional_max_pool3d", Napi::Function::New(env__, atg_fractional_max_pool3d));
  exports.Set("atg_fractional_max_pool3d_output", Napi::Function::New(env__, atg_fractional_max_pool3d_output));
  exports.Set("atg_fractional_max_pool3d_backward", Napi::Function::New(env__, atg_fractional_max_pool3d_backward));
  exports.Set("atg_fractional_max_pool3d_backward_grad_input", Napi::Function::New(env__, atg_fractional_max_pool3d_backward_grad_input));
  exports.Set("atg_max_pool2d_with_indices", Napi::Function::New(env__, atg_max_pool2d_with_indices));
  exports.Set("atg_max_pool2d_with_indices_out", Napi::Function::New(env__, atg_max_pool2d_with_indices_out));
  exports.Set("atg_max_pool2d_with_indices_backward", Napi::Function::New(env__, atg_max_pool2d_with_indices_backward));
  exports.Set("atg_max_pool2d_with_indices_backward_grad_input", Napi::Function::New(env__, atg_max_pool2d_with_indices_backward_grad_input));
  exports.Set("atg_max_pool3d_with_indices", Napi::Function::New(env__, atg_max_pool3d_with_indices));
  exports.Set("atg_max_pool3d_with_indices_out", Napi::Function::New(env__, atg_max_pool3d_with_indices_out));
  exports.Set("atg_max_pool3d_with_indices_backward", Napi::Function::New(env__, atg_max_pool3d_with_indices_backward));
  exports.Set("atg_max_pool3d_with_indices_backward_grad_input", Napi::Function::New(env__, atg_max_pool3d_with_indices_backward_grad_input));
  exports.Set("atg_max_unpool2d", Napi::Function::New(env__, atg_max_unpool2d));
  exports.Set("atg_max_unpool2d_out", Napi::Function::New(env__, atg_max_unpool2d_out));
  exports.Set("atg_max_unpool3d", Napi::Function::New(env__, atg_max_unpool3d));
  exports.Set("atg_max_unpool3d_out", Napi::Function::New(env__, atg_max_unpool3d_out));
  exports.Set("atg_reflection_pad1d", Napi::Function::New(env__, atg_reflection_pad1d));
  exports.Set("atg_reflection_pad1d_out", Napi::Function::New(env__, atg_reflection_pad1d_out));
  exports.Set("atg_reflection_pad1d_backward", Napi::Function::New(env__, atg_reflection_pad1d_backward));
  exports.Set("atg_reflection_pad1d_backward_grad_input", Napi::Function::New(env__, atg_reflection_pad1d_backward_grad_input));
  exports.Set("atg_reflection_pad2d", Napi::Function::New(env__, atg_reflection_pad2d));
  exports.Set("atg_reflection_pad2d_out", Napi::Function::New(env__, atg_reflection_pad2d_out));
  exports.Set("atg_reflection_pad2d_backward", Napi::Function::New(env__, atg_reflection_pad2d_backward));
  exports.Set("atg_reflection_pad2d_backward_grad_input", Napi::Function::New(env__, atg_reflection_pad2d_backward_grad_input));
  exports.Set("atg_reflection_pad3d", Napi::Function::New(env__, atg_reflection_pad3d));
  exports.Set("atg_reflection_pad3d_out", Napi::Function::New(env__, atg_reflection_pad3d_out));
  exports.Set("atg_reflection_pad3d_backward", Napi::Function::New(env__, atg_reflection_pad3d_backward));
  exports.Set("atg_reflection_pad3d_backward_grad_input", Napi::Function::New(env__, atg_reflection_pad3d_backward_grad_input));
  exports.Set("atg_replication_pad1d", Napi::Function::New(env__, atg_replication_pad1d));
  exports.Set("atg_replication_pad1d_out", Napi::Function::New(env__, atg_replication_pad1d_out));
  exports.Set("atg_replication_pad1d_backward", Napi::Function::New(env__, atg_replication_pad1d_backward));
  exports.Set("atg_replication_pad1d_backward_grad_input", Napi::Function::New(env__, atg_replication_pad1d_backward_grad_input));
  exports.Set("atg_replication_pad2d", Napi::Function::New(env__, atg_replication_pad2d));
  exports.Set("atg_replication_pad2d_out", Napi::Function::New(env__, atg_replication_pad2d_out));
  exports.Set("atg_replication_pad2d_backward", Napi::Function::New(env__, atg_replication_pad2d_backward));
  exports.Set("atg_replication_pad2d_backward_grad_input", Napi::Function::New(env__, atg_replication_pad2d_backward_grad_input));
  exports.Set("atg_replication_pad3d", Napi::Function::New(env__, atg_replication_pad3d));
  exports.Set("atg_replication_pad3d_out", Napi::Function::New(env__, atg_replication_pad3d_out));
  exports.Set("atg_replication_pad3d_backward", Napi::Function::New(env__, atg_replication_pad3d_backward));
  exports.Set("atg_replication_pad3d_backward_grad_input", Napi::Function::New(env__, atg_replication_pad3d_backward_grad_input));
  exports.Set("atg__pad_circular", Napi::Function::New(env__, atg__pad_circular));
  exports.Set("atg__pad_enum", Napi::Function::New(env__, atg__pad_enum));
  exports.Set("atg_pad", Napi::Function::New(env__, atg_pad));
  exports.Set("atg_upsample_linear1d_vec", Napi::Function::New(env__, atg_upsample_linear1d_vec));
  exports.Set("atg_upsample_linear1d", Napi::Function::New(env__, atg_upsample_linear1d));
  exports.Set("atg_upsample_linear1d_out", Napi::Function::New(env__, atg_upsample_linear1d_out));
  exports.Set("atg_upsample_bilinear2d_vec", Napi::Function::New(env__, atg_upsample_bilinear2d_vec));
  exports.Set("atg_upsample_bilinear2d", Napi::Function::New(env__, atg_upsample_bilinear2d));
  exports.Set("atg_upsample_bilinear2d_out", Napi::Function::New(env__, atg_upsample_bilinear2d_out));
  exports.Set("atg__upsample_bilinear2d_aa_vec", Napi::Function::New(env__, atg__upsample_bilinear2d_aa_vec));
  exports.Set("atg__upsample_bilinear2d_aa", Napi::Function::New(env__, atg__upsample_bilinear2d_aa));
  exports.Set("atg__upsample_bilinear2d_aa_out", Napi::Function::New(env__, atg__upsample_bilinear2d_aa_out));
  exports.Set("atg_upsample_trilinear3d_vec", Napi::Function::New(env__, atg_upsample_trilinear3d_vec));
  exports.Set("atg_upsample_trilinear3d", Napi::Function::New(env__, atg_upsample_trilinear3d));
  exports.Set("atg_upsample_trilinear3d_out", Napi::Function::New(env__, atg_upsample_trilinear3d_out));
  exports.Set("atg_upsample_bicubic2d_vec", Napi::Function::New(env__, atg_upsample_bicubic2d_vec));
  exports.Set("atg_upsample_bicubic2d", Napi::Function::New(env__, atg_upsample_bicubic2d));
  exports.Set("atg_upsample_bicubic2d_out", Napi::Function::New(env__, atg_upsample_bicubic2d_out));
  exports.Set("atg__upsample_bicubic2d_aa_vec", Napi::Function::New(env__, atg__upsample_bicubic2d_aa_vec));
  exports.Set("atg__upsample_bicubic2d_aa", Napi::Function::New(env__, atg__upsample_bicubic2d_aa));
  exports.Set("atg__upsample_bicubic2d_aa_out", Napi::Function::New(env__, atg__upsample_bicubic2d_aa_out));
  exports.Set("atg_upsample_nearest1d_vec", Napi::Function::New(env__, atg_upsample_nearest1d_vec));
  exports.Set("atg_upsample_nearest1d", Napi::Function::New(env__, atg_upsample_nearest1d));
  exports.Set("atg_upsample_nearest1d_out", Napi::Function::New(env__, atg_upsample_nearest1d_out));
  exports.Set("atg__upsample_nearest_exact1d_vec", Napi::Function::New(env__, atg__upsample_nearest_exact1d_vec));
  exports.Set("atg__upsample_nearest_exact1d", Napi::Function::New(env__, atg__upsample_nearest_exact1d));
  exports.Set("atg__upsample_nearest_exact1d_out", Napi::Function::New(env__, atg__upsample_nearest_exact1d_out));
  exports.Set("atg_upsample_nearest2d_vec", Napi::Function::New(env__, atg_upsample_nearest2d_vec));
  exports.Set("atg_upsample_nearest2d", Napi::Function::New(env__, atg_upsample_nearest2d));
  exports.Set("atg_upsample_nearest2d_out", Napi::Function::New(env__, atg_upsample_nearest2d_out));
  exports.Set("atg__upsample_nearest_exact2d_vec", Napi::Function::New(env__, atg__upsample_nearest_exact2d_vec));
  exports.Set("atg__upsample_nearest_exact2d", Napi::Function::New(env__, atg__upsample_nearest_exact2d));
  exports.Set("atg__upsample_nearest_exact2d_out", Napi::Function::New(env__, atg__upsample_nearest_exact2d_out));
  exports.Set("atg_upsample_nearest3d_vec", Napi::Function::New(env__, atg_upsample_nearest3d_vec));
  exports.Set("atg_upsample_nearest3d", Napi::Function::New(env__, atg_upsample_nearest3d));
  exports.Set("atg_upsample_nearest3d_out", Napi::Function::New(env__, atg_upsample_nearest3d_out));
  exports.Set("atg__upsample_nearest_exact3d_vec", Napi::Function::New(env__, atg__upsample_nearest_exact3d_vec));
  exports.Set("atg__upsample_nearest_exact3d", Napi::Function::New(env__, atg__upsample_nearest_exact3d));
  exports.Set("atg__upsample_nearest_exact3d_out", Napi::Function::New(env__, atg__upsample_nearest_exact3d_out));
  exports.Set("atg_upsample_linear1d_backward", Napi::Function::New(env__, atg_upsample_linear1d_backward));
  exports.Set("atg_upsample_linear1d_backward_grad_input", Napi::Function::New(env__, atg_upsample_linear1d_backward_grad_input));
  exports.Set("atg_upsample_bilinear2d_backward", Napi::Function::New(env__, atg_upsample_bilinear2d_backward));
  exports.Set("atg_upsample_bilinear2d_backward_grad_input", Napi::Function::New(env__, atg_upsample_bilinear2d_backward_grad_input));
  exports.Set("atg__upsample_bilinear2d_aa_backward", Napi::Function::New(env__, atg__upsample_bilinear2d_aa_backward));
  exports.Set("atg__upsample_bilinear2d_aa_backward_grad_input", Napi::Function::New(env__, atg__upsample_bilinear2d_aa_backward_grad_input));
  exports.Set("atg_upsample_bicubic2d_backward", Napi::Function::New(env__, atg_upsample_bicubic2d_backward));
  exports.Set("atg_upsample_bicubic2d_backward_grad_input", Napi::Function::New(env__, atg_upsample_bicubic2d_backward_grad_input));
  exports.Set("atg__upsample_bicubic2d_aa_backward", Napi::Function::New(env__, atg__upsample_bicubic2d_aa_backward));
  exports.Set("atg__upsample_bicubic2d_aa_backward_grad_input", Napi::Function::New(env__, atg__upsample_bicubic2d_aa_backward_grad_input));
  exports.Set("atg_upsample_trilinear3d_backward", Napi::Function::New(env__, atg_upsample_trilinear3d_backward));
  exports.Set("atg_upsample_trilinear3d_backward_grad_input", Napi::Function::New(env__, atg_upsample_trilinear3d_backward_grad_input));
  exports.Set("atg_upsample_nearest1d_backward", Napi::Function::New(env__, atg_upsample_nearest1d_backward));
  exports.Set("atg_upsample_nearest1d_backward_grad_input", Napi::Function::New(env__, atg_upsample_nearest1d_backward_grad_input));
  exports.Set("atg__upsample_nearest_exact1d_backward", Napi::Function::New(env__, atg__upsample_nearest_exact1d_backward));
  exports.Set("atg__upsample_nearest_exact1d_backward_grad_input", Napi::Function::New(env__, atg__upsample_nearest_exact1d_backward_grad_input));
  exports.Set("atg_upsample_nearest2d_backward", Napi::Function::New(env__, atg_upsample_nearest2d_backward));
  exports.Set("atg_upsample_nearest2d_backward_grad_input", Napi::Function::New(env__, atg_upsample_nearest2d_backward_grad_input));
  exports.Set("atg__upsample_nearest_exact2d_backward", Napi::Function::New(env__, atg__upsample_nearest_exact2d_backward));
  exports.Set("atg__upsample_nearest_exact2d_backward_grad_input", Napi::Function::New(env__, atg__upsample_nearest_exact2d_backward_grad_input));
  exports.Set("atg_upsample_nearest3d_backward", Napi::Function::New(env__, atg_upsample_nearest3d_backward));
  exports.Set("atg_upsample_nearest3d_backward_grad_input", Napi::Function::New(env__, atg_upsample_nearest3d_backward_grad_input));
  exports.Set("atg__upsample_nearest_exact3d_backward", Napi::Function::New(env__, atg__upsample_nearest_exact3d_backward));
  exports.Set("atg__upsample_nearest_exact3d_backward_grad_input", Napi::Function::New(env__, atg__upsample_nearest_exact3d_backward_grad_input));
  exports.Set("atg_sigmoid_backward", Napi::Function::New(env__, atg_sigmoid_backward));
  exports.Set("atg_sigmoid_backward_grad_input", Napi::Function::New(env__, atg_sigmoid_backward_grad_input));
  exports.Set("atg_logit_backward", Napi::Function::New(env__, atg_logit_backward));
  exports.Set("atg_logit_backward_grad_input", Napi::Function::New(env__, atg_logit_backward_grad_input));
  exports.Set("atg_tanh_backward", Napi::Function::New(env__, atg_tanh_backward));
  exports.Set("atg_tanh_backward_grad_input", Napi::Function::New(env__, atg_tanh_backward_grad_input));
  exports.Set("atg_slow_conv_transpose2d", Napi::Function::New(env__, atg_slow_conv_transpose2d));
  exports.Set("atg_slow_conv_transpose2d_out", Napi::Function::New(env__, atg_slow_conv_transpose2d_out));
  exports.Set("atg_slow_conv_transpose3d", Napi::Function::New(env__, atg_slow_conv_transpose3d));
  exports.Set("atg_slow_conv_transpose3d_out", Napi::Function::New(env__, atg_slow_conv_transpose3d_out));
  exports.Set("atg__slow_conv2d_backward", Napi::Function::New(env__, atg__slow_conv2d_backward));
  exports.Set("atg__conv_depthwise2d", Napi::Function::New(env__, atg__conv_depthwise2d));
  exports.Set("atg__conv_depthwise2d_out", Napi::Function::New(env__, atg__conv_depthwise2d_out));
  exports.Set("atg_conv_depthwise3d", Napi::Function::New(env__, atg_conv_depthwise3d));
  exports.Set("atg_conv_depthwise3d_out", Napi::Function::New(env__, atg_conv_depthwise3d_out));
  exports.Set("atg_slow_conv3d", Napi::Function::New(env__, atg_slow_conv3d));
  exports.Set("atg_slow_conv3d_out", Napi::Function::New(env__, atg_slow_conv3d_out));
  exports.Set("atg_slow_conv_dilated2d", Napi::Function::New(env__, atg_slow_conv_dilated2d));
  exports.Set("atg_slow_conv_dilated2d_out", Napi::Function::New(env__, atg_slow_conv_dilated2d_out));
  exports.Set("atg_slow_conv_dilated3d", Napi::Function::New(env__, atg_slow_conv_dilated3d));
  exports.Set("atg_slow_conv_dilated3d_out", Napi::Function::New(env__, atg_slow_conv_dilated3d_out));
  exports.Set("atg_col2im", Napi::Function::New(env__, atg_col2im));
  exports.Set("atg_col2im_out", Napi::Function::New(env__, atg_col2im_out));
  exports.Set("atg_column_stack", Napi::Function::New(env__, atg_column_stack));
  exports.Set("atg_column_stack_out", Napi::Function::New(env__, atg_column_stack_out));
  exports.Set("atg_im2col", Napi::Function::New(env__, atg_im2col));
  exports.Set("atg_im2col_out", Napi::Function::New(env__, atg_im2col_out));
  exports.Set("atg_isfinite", Napi::Function::New(env__, atg_isfinite));
  exports.Set("atg_isinf", Napi::Function::New(env__, atg_isinf));
  exports.Set("atg_isinf_out", Napi::Function::New(env__, atg_isinf_out));
  exports.Set("atg_isposinf", Napi::Function::New(env__, atg_isposinf));
  exports.Set("atg_isposinf_out", Napi::Function::New(env__, atg_isposinf_out));
  exports.Set("atg_isneginf", Napi::Function::New(env__, atg_isneginf));
  exports.Set("atg_isneginf_out", Napi::Function::New(env__, atg_isneginf_out));
  exports.Set("atg__add_batch_dim", Napi::Function::New(env__, atg__add_batch_dim));
  exports.Set("atg__remove_batch_dim", Napi::Function::New(env__, atg__remove_batch_dim));
  exports.Set("atg_special_entr", Napi::Function::New(env__, atg_special_entr));
  exports.Set("atg_special_entr_out", Napi::Function::New(env__, atg_special_entr_out));
  exports.Set("atg_special_ndtri", Napi::Function::New(env__, atg_special_ndtri));
  exports.Set("atg_special_ndtri_out", Napi::Function::New(env__, atg_special_ndtri_out));
  exports.Set("atg_special_log_ndtr", Napi::Function::New(env__, atg_special_log_ndtr));
  exports.Set("atg_special_log_ndtr_out", Napi::Function::New(env__, atg_special_log_ndtr_out));
  exports.Set("atg_special_expm1", Napi::Function::New(env__, atg_special_expm1));
  exports.Set("atg_special_expm1_out", Napi::Function::New(env__, atg_special_expm1_out));
  exports.Set("atg_special_exp2", Napi::Function::New(env__, atg_special_exp2));
  exports.Set("atg_special_exp2_out", Napi::Function::New(env__, atg_special_exp2_out));
  exports.Set("atg_special_psi", Napi::Function::New(env__, atg_special_psi));
  exports.Set("atg_special_psi_out", Napi::Function::New(env__, atg_special_psi_out));
  exports.Set("atg_special_digamma", Napi::Function::New(env__, atg_special_digamma));
  exports.Set("atg_special_digamma_out", Napi::Function::New(env__, atg_special_digamma_out));
  exports.Set("atg_special_gammaln", Napi::Function::New(env__, atg_special_gammaln));
  exports.Set("atg_special_gammaln_out", Napi::Function::New(env__, atg_special_gammaln_out));
  exports.Set("atg_special_erf", Napi::Function::New(env__, atg_special_erf));
  exports.Set("atg_special_erf_out", Napi::Function::New(env__, atg_special_erf_out));
  exports.Set("atg_special_erfc", Napi::Function::New(env__, atg_special_erfc));
  exports.Set("atg_special_erfc_out", Napi::Function::New(env__, atg_special_erfc_out));
  exports.Set("atg_special_erfcx", Napi::Function::New(env__, atg_special_erfcx));
  exports.Set("atg_special_erfcx_out", Napi::Function::New(env__, atg_special_erfcx_out));
  exports.Set("atg_special_erfinv", Napi::Function::New(env__, atg_special_erfinv));
  exports.Set("atg_special_erfinv_out", Napi::Function::New(env__, atg_special_erfinv_out));
  exports.Set("atg_special_ndtr", Napi::Function::New(env__, atg_special_ndtr));
  exports.Set("atg_special_ndtr_out", Napi::Function::New(env__, atg_special_ndtr_out));
  exports.Set("atg_special_xlog1py", Napi::Function::New(env__, atg_special_xlog1py));
  exports.Set("atg_special_xlog1py_self_scalar", Napi::Function::New(env__, atg_special_xlog1py_self_scalar));
  exports.Set("atg_special_xlog1py_other_scalar", Napi::Function::New(env__, atg_special_xlog1py_other_scalar));
  exports.Set("atg_special_xlog1py_out", Napi::Function::New(env__, atg_special_xlog1py_out));
  exports.Set("atg_special_xlog1py_self_scalar_out", Napi::Function::New(env__, atg_special_xlog1py_self_scalar_out));
  exports.Set("atg_special_xlog1py_other_scalar_out", Napi::Function::New(env__, atg_special_xlog1py_other_scalar_out));
  exports.Set("atg_special_xlogy", Napi::Function::New(env__, atg_special_xlogy));
  exports.Set("atg_special_xlogy_self_scalar", Napi::Function::New(env__, atg_special_xlogy_self_scalar));
  exports.Set("atg_special_xlogy_other_scalar", Napi::Function::New(env__, atg_special_xlogy_other_scalar));
  exports.Set("atg_special_xlogy_out", Napi::Function::New(env__, atg_special_xlogy_out));
  exports.Set("atg_special_xlogy_self_scalar_out", Napi::Function::New(env__, atg_special_xlogy_self_scalar_out));
  exports.Set("atg_special_xlogy_other_scalar_out", Napi::Function::New(env__, atg_special_xlogy_other_scalar_out));
  exports.Set("atg_special_zeta", Napi::Function::New(env__, atg_special_zeta));
  exports.Set("atg_special_zeta_self_scalar", Napi::Function::New(env__, atg_special_zeta_self_scalar));
  exports.Set("atg_special_zeta_other_scalar", Napi::Function::New(env__, atg_special_zeta_other_scalar));
  exports.Set("atg_special_zeta_out", Napi::Function::New(env__, atg_special_zeta_out));
  exports.Set("atg_special_zeta_self_scalar_out", Napi::Function::New(env__, atg_special_zeta_self_scalar_out));
  exports.Set("atg_special_zeta_other_scalar_out", Napi::Function::New(env__, atg_special_zeta_other_scalar_out));
  exports.Set("atg_special_i0", Napi::Function::New(env__, atg_special_i0));
  exports.Set("atg_special_i0_out", Napi::Function::New(env__, atg_special_i0_out));
  exports.Set("atg_special_i0e", Napi::Function::New(env__, atg_special_i0e));
  exports.Set("atg_special_i0e_out", Napi::Function::New(env__, atg_special_i0e_out));
  exports.Set("atg_special_i1", Napi::Function::New(env__, atg_special_i1));
  exports.Set("atg_special_i1_out", Napi::Function::New(env__, atg_special_i1_out));
  exports.Set("atg_special_i1e", Napi::Function::New(env__, atg_special_i1e));
  exports.Set("atg_special_i1e_out", Napi::Function::New(env__, atg_special_i1e_out));
  exports.Set("atg_special_logit", Napi::Function::New(env__, atg_special_logit));
  exports.Set("atg_special_logit_out", Napi::Function::New(env__, atg_special_logit_out));
  exports.Set("atg_special_polygamma", Napi::Function::New(env__, atg_special_polygamma));
  exports.Set("atg_special_polygamma_out", Napi::Function::New(env__, atg_special_polygamma_out));
  exports.Set("atg_special_logsumexp", Napi::Function::New(env__, atg_special_logsumexp));
  exports.Set("atg_special_logsumexp_out", Napi::Function::New(env__, atg_special_logsumexp_out));
  exports.Set("atg_special_expit", Napi::Function::New(env__, atg_special_expit));
  exports.Set("atg_special_expit_out", Napi::Function::New(env__, atg_special_expit_out));
  exports.Set("atg_special_sinc", Napi::Function::New(env__, atg_special_sinc));
  exports.Set("atg_special_sinc_out", Napi::Function::New(env__, atg_special_sinc_out));
  exports.Set("atg_special_round", Napi::Function::New(env__, atg_special_round));
  exports.Set("atg_special_round_out", Napi::Function::New(env__, atg_special_round_out));
  exports.Set("atg_special_log1p", Napi::Function::New(env__, atg_special_log1p));
  exports.Set("atg_special_log1p_out", Napi::Function::New(env__, atg_special_log1p_out));
  exports.Set("atg_special_log_softmax", Napi::Function::New(env__, atg_special_log_softmax));
  exports.Set("atg_special_gammainc", Napi::Function::New(env__, atg_special_gammainc));
  exports.Set("atg_special_gammainc_out", Napi::Function::New(env__, atg_special_gammainc_out));
  exports.Set("atg_special_gammaincc", Napi::Function::New(env__, atg_special_gammaincc));
  exports.Set("atg_special_gammaincc_out", Napi::Function::New(env__, atg_special_gammaincc_out));
  exports.Set("atg_special_multigammaln", Napi::Function::New(env__, atg_special_multigammaln));
  exports.Set("atg_special_multigammaln_out", Napi::Function::New(env__, atg_special_multigammaln_out));
  exports.Set("atg_special_softmax", Napi::Function::New(env__, atg_special_softmax));
  exports.Set("atg_fft_fft", Napi::Function::New(env__, atg_fft_fft));
  exports.Set("atg_fft_fft_out", Napi::Function::New(env__, atg_fft_fft_out));
  exports.Set("atg_fft_ifft", Napi::Function::New(env__, atg_fft_ifft));
  exports.Set("atg_fft_ifft_out", Napi::Function::New(env__, atg_fft_ifft_out));
  exports.Set("atg_fft_rfft", Napi::Function::New(env__, atg_fft_rfft));
  exports.Set("atg_fft_rfft_out", Napi::Function::New(env__, atg_fft_rfft_out));
  exports.Set("atg_fft_irfft", Napi::Function::New(env__, atg_fft_irfft));
  exports.Set("atg_fft_irfft_out", Napi::Function::New(env__, atg_fft_irfft_out));
  exports.Set("atg_fft_hfft", Napi::Function::New(env__, atg_fft_hfft));
  exports.Set("atg_fft_hfft_out", Napi::Function::New(env__, atg_fft_hfft_out));
  exports.Set("atg_fft_ihfft", Napi::Function::New(env__, atg_fft_ihfft));
  exports.Set("atg_fft_ihfft_out", Napi::Function::New(env__, atg_fft_ihfft_out));
  exports.Set("atg_fft_fft2", Napi::Function::New(env__, atg_fft_fft2));
  exports.Set("atg_fft_fft2_out", Napi::Function::New(env__, atg_fft_fft2_out));
  exports.Set("atg_fft_ifft2", Napi::Function::New(env__, atg_fft_ifft2));
  exports.Set("atg_fft_ifft2_out", Napi::Function::New(env__, atg_fft_ifft2_out));
  exports.Set("atg_fft_rfft2", Napi::Function::New(env__, atg_fft_rfft2));
  exports.Set("atg_fft_rfft2_out", Napi::Function::New(env__, atg_fft_rfft2_out));
  exports.Set("atg_fft_irfft2", Napi::Function::New(env__, atg_fft_irfft2));
  exports.Set("atg_fft_irfft2_out", Napi::Function::New(env__, atg_fft_irfft2_out));
  exports.Set("atg_fft_hfft2", Napi::Function::New(env__, atg_fft_hfft2));
  exports.Set("atg_fft_hfft2_out", Napi::Function::New(env__, atg_fft_hfft2_out));
  exports.Set("atg_fft_ihfft2", Napi::Function::New(env__, atg_fft_ihfft2));
  exports.Set("atg_fft_ihfft2_out", Napi::Function::New(env__, atg_fft_ihfft2_out));
  exports.Set("atg_fft_fftn", Napi::Function::New(env__, atg_fft_fftn));
  exports.Set("atg_fft_fftn_out", Napi::Function::New(env__, atg_fft_fftn_out));
  exports.Set("atg_fft_ifftn", Napi::Function::New(env__, atg_fft_ifftn));
  exports.Set("atg_fft_ifftn_out", Napi::Function::New(env__, atg_fft_ifftn_out));
  exports.Set("atg_fft_rfftn", Napi::Function::New(env__, atg_fft_rfftn));
  exports.Set("atg_fft_rfftn_out", Napi::Function::New(env__, atg_fft_rfftn_out));
  exports.Set("atg_fft_irfftn", Napi::Function::New(env__, atg_fft_irfftn));
  exports.Set("atg_fft_irfftn_out", Napi::Function::New(env__, atg_fft_irfftn_out));
  exports.Set("atg_fft_hfftn", Napi::Function::New(env__, atg_fft_hfftn));
  exports.Set("atg_fft_hfftn_out", Napi::Function::New(env__, atg_fft_hfftn_out));
  exports.Set("atg_fft_ihfftn", Napi::Function::New(env__, atg_fft_ihfftn));
  exports.Set("atg_fft_ihfftn_out", Napi::Function::New(env__, atg_fft_ihfftn_out));
  exports.Set("atg_fft_fftfreq", Napi::Function::New(env__, atg_fft_fftfreq));
  exports.Set("atg_fft_fftfreq_out", Napi::Function::New(env__, atg_fft_fftfreq_out));
  exports.Set("atg_fft_rfftfreq", Napi::Function::New(env__, atg_fft_rfftfreq));
  exports.Set("atg_fft_rfftfreq_out", Napi::Function::New(env__, atg_fft_rfftfreq_out));
  exports.Set("atg_fft_fftshift", Napi::Function::New(env__, atg_fft_fftshift));
  exports.Set("atg_fft_ifftshift", Napi::Function::New(env__, atg_fft_ifftshift));
  exports.Set("atg_linalg_cholesky_ex", Napi::Function::New(env__, atg_linalg_cholesky_ex));
  exports.Set("atg_linalg_cholesky_ex_l", Napi::Function::New(env__, atg_linalg_cholesky_ex_l));
  exports.Set("atg_linalg_cholesky", Napi::Function::New(env__, atg_linalg_cholesky));
  exports.Set("atg_linalg_cholesky_out", Napi::Function::New(env__, atg_linalg_cholesky_out));
  exports.Set("atg_linalg_cross", Napi::Function::New(env__, atg_linalg_cross));
  exports.Set("atg_linalg_cross_out", Napi::Function::New(env__, atg_linalg_cross_out));
  exports.Set("atg_linalg_lu_factor", Napi::Function::New(env__, atg_linalg_lu_factor));
  exports.Set("atg_linalg_lu_factor_out", Napi::Function::New(env__, atg_linalg_lu_factor_out));
  exports.Set("atg_linalg_lu_factor_ex", Napi::Function::New(env__, atg_linalg_lu_factor_ex));
  exports.Set("atg_linalg_lu_factor_ex_out", Napi::Function::New(env__, atg_linalg_lu_factor_ex_out));
  exports.Set("atg_linalg_lu", Napi::Function::New(env__, atg_linalg_lu));
  exports.Set("atg_linalg_lu_out", Napi::Function::New(env__, atg_linalg_lu_out));
  exports.Set("atg_linalg_lu_solve", Napi::Function::New(env__, atg_linalg_lu_solve));
  exports.Set("atg_linalg_lu_solve_out", Napi::Function::New(env__, atg_linalg_lu_solve_out));
  exports.Set("atg__linalg_det", Napi::Function::New(env__, atg__linalg_det));
  exports.Set("atg__linalg_det_result", Napi::Function::New(env__, atg__linalg_det_result));
  exports.Set("atg_linalg_det", Napi::Function::New(env__, atg_linalg_det));
  exports.Set("atg_linalg_det_out", Napi::Function::New(env__, atg_linalg_det_out));
  exports.Set("atg_det", Napi::Function::New(env__, atg_det));
  exports.Set("atg_linalg_ldl_factor_ex", Napi::Function::New(env__, atg_linalg_ldl_factor_ex));
  exports.Set("atg_linalg_ldl_factor_ex_out", Napi::Function::New(env__, atg_linalg_ldl_factor_ex_out));
  exports.Set("atg_linalg_ldl_factor", Napi::Function::New(env__, atg_linalg_ldl_factor));
  exports.Set("atg_linalg_ldl_factor_out", Napi::Function::New(env__, atg_linalg_ldl_factor_out));
  exports.Set("atg_linalg_ldl_solve", Napi::Function::New(env__, atg_linalg_ldl_solve));
  exports.Set("atg_linalg_ldl_solve_out", Napi::Function::New(env__, atg_linalg_ldl_solve_out));
  exports.Set("atg_linalg_lstsq", Napi::Function::New(env__, atg_linalg_lstsq));
  exports.Set("atg_linalg_lstsq_out", Napi::Function::New(env__, atg_linalg_lstsq_out));
  exports.Set("atg_linalg_matmul", Napi::Function::New(env__, atg_linalg_matmul));
  exports.Set("atg_linalg_matmul_out", Napi::Function::New(env__, atg_linalg_matmul_out));
  exports.Set("atg_linalg_vecdot", Napi::Function::New(env__, atg_linalg_vecdot));
  exports.Set("atg_linalg_vecdot_out", Napi::Function::New(env__, atg_linalg_vecdot_out));
  exports.Set("atg_linalg_matrix_exp", Napi::Function::New(env__, atg_linalg_matrix_exp));
  exports.Set("atg_linalg_matrix_exp_out", Napi::Function::New(env__, atg_linalg_matrix_exp_out));
  exports.Set("atg__linalg_slogdet", Napi::Function::New(env__, atg__linalg_slogdet));
  exports.Set("atg__linalg_slogdet_sign", Napi::Function::New(env__, atg__linalg_slogdet_sign));
  exports.Set("atg_linalg_slogdet", Napi::Function::New(env__, atg_linalg_slogdet));
  exports.Set("atg_linalg_slogdet_out", Napi::Function::New(env__, atg_linalg_slogdet_out));
  exports.Set("atg_slogdet", Napi::Function::New(env__, atg_slogdet));
  exports.Set("atg_slogdet_out", Napi::Function::New(env__, atg_slogdet_out));
  exports.Set("atg_logdet", Napi::Function::New(env__, atg_logdet));
  exports.Set("atg_linalg_eig", Napi::Function::New(env__, atg_linalg_eig));
  exports.Set("atg_linalg_eig_out", Napi::Function::New(env__, atg_linalg_eig_out));
  exports.Set("atg_linalg_eigvals", Napi::Function::New(env__, atg_linalg_eigvals));
  exports.Set("atg_linalg_eigvals_out", Napi::Function::New(env__, atg_linalg_eigvals_out));
  exports.Set("atg__linalg_eigh", Napi::Function::New(env__, atg__linalg_eigh));
  exports.Set("atg__linalg_eigh_eigenvalues", Napi::Function::New(env__, atg__linalg_eigh_eigenvalues));
  exports.Set("atg_linalg_eigh", Napi::Function::New(env__, atg_linalg_eigh));
  exports.Set("atg_linalg_eigh_eigvals", Napi::Function::New(env__, atg_linalg_eigh_eigvals));
  exports.Set("atg_linalg_eigvalsh", Napi::Function::New(env__, atg_linalg_eigvalsh));
  exports.Set("atg_linalg_eigvalsh_out", Napi::Function::New(env__, atg_linalg_eigvalsh_out));
  exports.Set("atg_linalg_householder_product", Napi::Function::New(env__, atg_linalg_householder_product));
  exports.Set("atg_linalg_householder_product_out", Napi::Function::New(env__, atg_linalg_householder_product_out));
  exports.Set("atg_linalg_inv_ex", Napi::Function::New(env__, atg_linalg_inv_ex));
  exports.Set("atg_linalg_inv_ex_inverse", Napi::Function::New(env__, atg_linalg_inv_ex_inverse));
  exports.Set("atg_linalg_inv", Napi::Function::New(env__, atg_linalg_inv));
  exports.Set("atg_linalg_inv_out", Napi::Function::New(env__, atg_linalg_inv_out));
  exports.Set("atg_inverse", Napi::Function::New(env__, atg_inverse));
  exports.Set("atg_inverse_out", Napi::Function::New(env__, atg_inverse_out));
  exports.Set("atg_inner", Napi::Function::New(env__, atg_inner));
  exports.Set("atg_inner_out", Napi::Function::New(env__, atg_inner_out));
  exports.Set("atg_outer", Napi::Function::New(env__, atg_outer));
  exports.Set("atg_outer_out", Napi::Function::New(env__, atg_outer_out));
  exports.Set("atg_ger", Napi::Function::New(env__, atg_ger));
  exports.Set("atg_ger_out", Napi::Function::New(env__, atg_ger_out));
  exports.Set("atg_linalg_norm", Napi::Function::New(env__, atg_linalg_norm));
  exports.Set("atg_linalg_norm_ord_str", Napi::Function::New(env__, atg_linalg_norm_ord_str));
  exports.Set("atg_linalg_norm_out", Napi::Function::New(env__, atg_linalg_norm_out));
  exports.Set("atg_linalg_norm_ord_str_out", Napi::Function::New(env__, atg_linalg_norm_ord_str_out));
  exports.Set("atg__linalg_svd", Napi::Function::New(env__, atg__linalg_svd));
  exports.Set("atg__linalg_svd_u", Napi::Function::New(env__, atg__linalg_svd_u));
  exports.Set("atg_linalg_svd", Napi::Function::New(env__, atg_linalg_svd));
  exports.Set("atg_linalg_svd_u", Napi::Function::New(env__, atg_linalg_svd_u));
  exports.Set("atg_linalg_svdvals", Napi::Function::New(env__, atg_linalg_svdvals));
  exports.Set("atg_linalg_svdvals_out", Napi::Function::New(env__, atg_linalg_svdvals_out));
  exports.Set("atg_linalg_cond", Napi::Function::New(env__, atg_linalg_cond));
  exports.Set("atg_linalg_cond_p_str", Napi::Function::New(env__, atg_linalg_cond_p_str));
  exports.Set("atg_linalg_cond_out", Napi::Function::New(env__, atg_linalg_cond_out));
  exports.Set("atg_linalg_cond_p_str_out", Napi::Function::New(env__, atg_linalg_cond_p_str_out));
  exports.Set("atg_linalg_pinv", Napi::Function::New(env__, atg_linalg_pinv));
  exports.Set("atg_linalg_pinv_rcond_tensor", Napi::Function::New(env__, atg_linalg_pinv_rcond_tensor));
  exports.Set("atg_linalg_pinv_atol_rtol_tensor", Napi::Function::New(env__, atg_linalg_pinv_atol_rtol_tensor));
  exports.Set("atg_linalg_pinv_atol_rtol_float", Napi::Function::New(env__, atg_linalg_pinv_atol_rtol_float));
  exports.Set("atg_linalg_pinv_out", Napi::Function::New(env__, atg_linalg_pinv_out));
  exports.Set("atg_linalg_pinv_out_rcond_tensor", Napi::Function::New(env__, atg_linalg_pinv_out_rcond_tensor));
  exports.Set("atg_linalg_pinv_atol_rtol_tensor_out", Napi::Function::New(env__, atg_linalg_pinv_atol_rtol_tensor_out));
  exports.Set("atg_linalg_pinv_atol_rtol_float_out", Napi::Function::New(env__, atg_linalg_pinv_atol_rtol_float_out));
  exports.Set("atg__linalg_solve_ex", Napi::Function::New(env__, atg__linalg_solve_ex));
  exports.Set("atg__linalg_solve_ex_result", Napi::Function::New(env__, atg__linalg_solve_ex_result));
  exports.Set("atg_linalg_solve_ex", Napi::Function::New(env__, atg_linalg_solve_ex));
  exports.Set("atg_linalg_solve_ex_out", Napi::Function::New(env__, atg_linalg_solve_ex_out));
  exports.Set("atg_linalg_solve", Napi::Function::New(env__, atg_linalg_solve));
  exports.Set("atg_linalg_solve_out", Napi::Function::New(env__, atg_linalg_solve_out));
  exports.Set("atg_linalg_tensorinv", Napi::Function::New(env__, atg_linalg_tensorinv));
  exports.Set("atg_linalg_tensorinv_out", Napi::Function::New(env__, atg_linalg_tensorinv_out));
  exports.Set("atg_linalg_tensorsolve", Napi::Function::New(env__, atg_linalg_tensorsolve));
  exports.Set("atg_linalg_tensorsolve_out", Napi::Function::New(env__, atg_linalg_tensorsolve_out));
  exports.Set("atg_linalg_qr", Napi::Function::New(env__, atg_linalg_qr));
  exports.Set("atg_linalg_qr_out", Napi::Function::New(env__, atg_linalg_qr_out));
  exports.Set("atg_linalg_matrix_power", Napi::Function::New(env__, atg_linalg_matrix_power));
  exports.Set("atg_linalg_matrix_power_out", Napi::Function::New(env__, atg_linalg_matrix_power_out));
  exports.Set("atg_linalg_matrix_rank", Napi::Function::New(env__, atg_linalg_matrix_rank));
  exports.Set("atg_linalg_matrix_rank_tol_tensor", Napi::Function::New(env__, atg_linalg_matrix_rank_tol_tensor));
  exports.Set("atg_linalg_matrix_rank_atol_rtol_tensor", Napi::Function::New(env__, atg_linalg_matrix_rank_atol_rtol_tensor));
  exports.Set("atg_linalg_matrix_rank_atol_rtol_float", Napi::Function::New(env__, atg_linalg_matrix_rank_atol_rtol_float));
  exports.Set("atg_linalg_matrix_rank_out", Napi::Function::New(env__, atg_linalg_matrix_rank_out));
  exports.Set("atg_linalg_matrix_rank_out_tol_tensor", Napi::Function::New(env__, atg_linalg_matrix_rank_out_tol_tensor));
  exports.Set("atg_linalg_matrix_rank_atol_rtol_tensor_out", Napi::Function::New(env__, atg_linalg_matrix_rank_atol_rtol_tensor_out));
  exports.Set("atg_linalg_matrix_rank_atol_rtol_float_out", Napi::Function::New(env__, atg_linalg_matrix_rank_atol_rtol_float_out));
  exports.Set("atg_linalg_multi_dot", Napi::Function::New(env__, atg_linalg_multi_dot));
  exports.Set("atg_linalg_multi_dot_out", Napi::Function::New(env__, atg_linalg_multi_dot_out));
  exports.Set("atg_nested_to_padded_tensor", Napi::Function::New(env__, atg_nested_to_padded_tensor));
  exports.Set("atg__test_serialization_subcmul", Napi::Function::New(env__, atg__test_serialization_subcmul));
  exports.Set("atg__test_optional_intlist", Napi::Function::New(env__, atg__test_optional_intlist));
  exports.Set("atg__test_optional_intlist_out", Napi::Function::New(env__, atg__test_optional_intlist_out));
  exports.Set("atg__test_optional_filled_intlist", Napi::Function::New(env__, atg__test_optional_filled_intlist));
  exports.Set("atg__test_optional_filled_intlist_out", Napi::Function::New(env__, atg__test_optional_filled_intlist_out));
  exports.Set("atg__test_optional_floatlist", Napi::Function::New(env__, atg__test_optional_floatlist));
  exports.Set("atg__test_optional_floatlist_out", Napi::Function::New(env__, atg__test_optional_floatlist_out));
  exports.Set("atg__test_string_default", Napi::Function::New(env__, atg__test_string_default));
  exports.Set("atg__test_ambiguous_defaults", Napi::Function::New(env__, atg__test_ambiguous_defaults));
  exports.Set("atg__test_ambiguous_defaults_b", Napi::Function::New(env__, atg__test_ambiguous_defaults_b));
  exports.Set("atg__test_warn_in_autograd", Napi::Function::New(env__, atg__test_warn_in_autograd));
  exports.Set("atg__test_warn_in_autograd_out", Napi::Function::New(env__, atg__test_warn_in_autograd_out));
  exports.Set("atg__test_autograd_multiple_dispatch", Napi::Function::New(env__, atg__test_autograd_multiple_dispatch));
  exports.Set("atg__test_autograd_multiple_dispatch_ntonly", Napi::Function::New(env__, atg__test_autograd_multiple_dispatch_ntonly));
  exports.Set("atg__test_autograd_multiple_dispatch_fullcoverage_out", Napi::Function::New(env__, atg__test_autograd_multiple_dispatch_fullcoverage_out));
  exports.Set("atg__test_autograd_multiple_dispatch_view", Napi::Function::New(env__, atg__test_autograd_multiple_dispatch_view));
  exports.Set("atg__test_autograd_multiple_dispatch_view_copy", Napi::Function::New(env__, atg__test_autograd_multiple_dispatch_view_copy));
  exports.Set("atg__test_autograd_multiple_dispatch_view_copy_out", Napi::Function::New(env__, atg__test_autograd_multiple_dispatch_view_copy_out));
  exports.Set("atg_segment_reduce", Napi::Function::New(env__, atg_segment_reduce));
  exports.Set("atg_segment_reduce_out", Napi::Function::New(env__, atg_segment_reduce_out));
  exports.Set("atg__segment_reduce_backward", Napi::Function::New(env__, atg__segment_reduce_backward));
  exports.Set("atg__segment_reduce_backward_out", Napi::Function::New(env__, atg__segment_reduce_backward_out));
  exports.Set("atg_pad_sequence", Napi::Function::New(env__, atg_pad_sequence));
  exports.Set("atg_flatten_dense_tensors", Napi::Function::New(env__, atg_flatten_dense_tensors));
  exports.Set("atg__fw_primal_copy", Napi::Function::New(env__, atg__fw_primal_copy));
  exports.Set("atg__fw_primal_copy_out", Napi::Function::New(env__, atg__fw_primal_copy_out));
  exports.Set("atg__make_dual_copy", Napi::Function::New(env__, atg__make_dual_copy));
  exports.Set("atg__make_dual_copy_out", Napi::Function::New(env__, atg__make_dual_copy_out));
  exports.Set("atg_view_as_real_copy", Napi::Function::New(env__, atg_view_as_real_copy));
  exports.Set("atg_view_as_real_copy_out", Napi::Function::New(env__, atg_view_as_real_copy_out));
  exports.Set("atg_view_as_complex_copy", Napi::Function::New(env__, atg_view_as_complex_copy));
  exports.Set("atg_view_as_complex_copy_out", Napi::Function::New(env__, atg_view_as_complex_copy_out));
  exports.Set("atg__conj_copy", Napi::Function::New(env__, atg__conj_copy));
  exports.Set("atg__conj_copy_out", Napi::Function::New(env__, atg__conj_copy_out));
  exports.Set("atg__neg_view_copy", Napi::Function::New(env__, atg__neg_view_copy));
  exports.Set("atg__neg_view_copy_out", Napi::Function::New(env__, atg__neg_view_copy_out));
  exports.Set("atg_as_strided_copy", Napi::Function::New(env__, atg_as_strided_copy));
  exports.Set("atg_as_strided_copy_out", Napi::Function::New(env__, atg_as_strided_copy_out));
  exports.Set("atg__sparse_broadcast_to_copy", Napi::Function::New(env__, atg__sparse_broadcast_to_copy));
  exports.Set("atg__sparse_broadcast_to_copy_out", Napi::Function::New(env__, atg__sparse_broadcast_to_copy_out));
  exports.Set("atg_diagonal_copy", Napi::Function::New(env__, atg_diagonal_copy));
  exports.Set("atg_diagonal_copy_out", Napi::Function::New(env__, atg_diagonal_copy_out));
  exports.Set("atg_expand_copy", Napi::Function::New(env__, atg_expand_copy));
  exports.Set("atg_expand_copy_out", Napi::Function::New(env__, atg_expand_copy_out));
  exports.Set("atg_permute_copy", Napi::Function::New(env__, atg_permute_copy));
  exports.Set("atg_permute_copy_out", Napi::Function::New(env__, atg_permute_copy_out));
  exports.Set("atg__reshape_alias_copy", Napi::Function::New(env__, atg__reshape_alias_copy));
  exports.Set("atg__reshape_alias_copy_out", Napi::Function::New(env__, atg__reshape_alias_copy_out));
  exports.Set("atg_select_copy", Napi::Function::New(env__, atg_select_copy));
  exports.Set("atg_select_copy_int_out", Napi::Function::New(env__, atg_select_copy_int_out));
  exports.Set("atg_detach_copy", Napi::Function::New(env__, atg_detach_copy));
  exports.Set("atg_detach_copy_out", Napi::Function::New(env__, atg_detach_copy_out));
  exports.Set("atg_slice_copy", Napi::Function::New(env__, atg_slice_copy));
  exports.Set("atg_slice_copy_tensor_out", Napi::Function::New(env__, atg_slice_copy_tensor_out));
  exports.Set("atg_squeeze_copy", Napi::Function::New(env__, atg_squeeze_copy));
  exports.Set("atg_squeeze_copy_dim", Napi::Function::New(env__, atg_squeeze_copy_dim));
  exports.Set("atg_squeeze_copy_dims", Napi::Function::New(env__, atg_squeeze_copy_dims));
  exports.Set("atg_squeeze_copy_out", Napi::Function::New(env__, atg_squeeze_copy_out));
  exports.Set("atg_squeeze_copy_dim_out", Napi::Function::New(env__, atg_squeeze_copy_dim_out));
  exports.Set("atg_squeeze_copy_dims_out", Napi::Function::New(env__, atg_squeeze_copy_dims_out));
  exports.Set("atg_t_copy", Napi::Function::New(env__, atg_t_copy));
  exports.Set("atg_t_copy_out", Napi::Function::New(env__, atg_t_copy_out));
  exports.Set("atg_transpose_copy", Napi::Function::New(env__, atg_transpose_copy));
  exports.Set("atg_transpose_copy_int_out", Napi::Function::New(env__, atg_transpose_copy_int_out));
  exports.Set("atg_unsqueeze_copy", Napi::Function::New(env__, atg_unsqueeze_copy));
  exports.Set("atg_unsqueeze_copy_out", Napi::Function::New(env__, atg_unsqueeze_copy_out));
  exports.Set("atg__indices_copy", Napi::Function::New(env__, atg__indices_copy));
  exports.Set("atg__indices_copy_out", Napi::Function::New(env__, atg__indices_copy_out));
  exports.Set("atg__values_copy", Napi::Function::New(env__, atg__values_copy));
  exports.Set("atg__values_copy_out", Napi::Function::New(env__, atg__values_copy_out));
  exports.Set("atg_indices_copy", Napi::Function::New(env__, atg_indices_copy));
  exports.Set("atg_indices_copy_out", Napi::Function::New(env__, atg_indices_copy_out));
  exports.Set("atg_values_copy", Napi::Function::New(env__, atg_values_copy));
  exports.Set("atg_values_copy_out", Napi::Function::New(env__, atg_values_copy_out));
  exports.Set("atg_crow_indices_copy", Napi::Function::New(env__, atg_crow_indices_copy));
  exports.Set("atg_crow_indices_copy_out", Napi::Function::New(env__, atg_crow_indices_copy_out));
  exports.Set("atg_col_indices_copy", Napi::Function::New(env__, atg_col_indices_copy));
  exports.Set("atg_col_indices_copy_out", Napi::Function::New(env__, atg_col_indices_copy_out));
  exports.Set("atg_ccol_indices_copy", Napi::Function::New(env__, atg_ccol_indices_copy));
  exports.Set("atg_ccol_indices_copy_out", Napi::Function::New(env__, atg_ccol_indices_copy_out));
  exports.Set("atg_row_indices_copy", Napi::Function::New(env__, atg_row_indices_copy));
  exports.Set("atg_row_indices_copy_out", Napi::Function::New(env__, atg_row_indices_copy_out));
  exports.Set("atg_unbind_copy", Napi::Function::New(env__, atg_unbind_copy));
  exports.Set("atg_split_copy", Napi::Function::New(env__, atg_split_copy));
  exports.Set("atg_split_with_sizes_copy", Napi::Function::New(env__, atg_split_with_sizes_copy));
  exports.Set("atg_view_copy", Napi::Function::New(env__, atg_view_copy));
  exports.Set("atg_view_copy_dtype", Napi::Function::New(env__, atg_view_copy_dtype));
  exports.Set("atg_view_copy_out", Napi::Function::New(env__, atg_view_copy_out));
  exports.Set("atg_view_copy_dtype_out", Napi::Function::New(env__, atg_view_copy_dtype_out));
  exports.Set("atg_unfold_copy", Napi::Function::New(env__, atg_unfold_copy));
  exports.Set("atg_unfold_copy_out", Napi::Function::New(env__, atg_unfold_copy_out));
  exports.Set("atg_alias_copy", Napi::Function::New(env__, atg_alias_copy));
  exports.Set("atg_alias_copy_out", Napi::Function::New(env__, atg_alias_copy_out));
  exports.Set("atg_to_padded_tensor", Napi::Function::New(env__, atg_to_padded_tensor));
  exports.Set("atg_to_padded_tensor_out", Napi::Function::New(env__, atg_to_padded_tensor_out));
  exports.Set("atg__nested_tensor_softmax_with_shape", Napi::Function::New(env__, atg__nested_tensor_softmax_with_shape));
  exports.Set("atg__transformer_encoder_layer_fwd", Napi::Function::New(env__, atg__transformer_encoder_layer_fwd));
  exports.Set("atg__transformer_encoder_layer_fwd_out", Napi::Function::New(env__, atg__transformer_encoder_layer_fwd_out));
  exports.Set("atg__native_multi_head_attention", Napi::Function::New(env__, atg__native_multi_head_attention));
  exports.Set("atg__native_multi_head_attention_out", Napi::Function::New(env__, atg__native_multi_head_attention_out));
  exports.Set("atg_scaled_dot_product_attention", Napi::Function::New(env__, atg_scaled_dot_product_attention));
  exports.Set("atg__scaled_dot_product_attention", Napi::Function::New(env__, atg__scaled_dot_product_attention));
  exports.Set("atg__fused_sdp_choice", Napi::Function::New(env__, atg__fused_sdp_choice));
  exports.Set("atg__scaled_dot_product_attention_math", Napi::Function::New(env__, atg__scaled_dot_product_attention_math));
  exports.Set("atg__scaled_dot_product_flash_attention_backward", Napi::Function::New(env__, atg__scaled_dot_product_flash_attention_backward));
  exports.Set("atg__scaled_dot_product_efficient_attention", Napi::Function::New(env__, atg__scaled_dot_product_efficient_attention));
  exports.Set("atg__scaled_dot_product_efficient_attention_backward", Napi::Function::New(env__, atg__scaled_dot_product_efficient_attention_backward));
  exports.Set("atg__chunk_grad_outputs_efficient_attention", Napi::Function::New(env__, atg__chunk_grad_outputs_efficient_attention));
  exports.Set("atg__flash_attention_backward", Napi::Function::New(env__, atg__flash_attention_backward));
  exports.Set("atg__efficient_attention_backward", Napi::Function::New(env__, atg__efficient_attention_backward));
  exports.Set("atg__triton_scaled_dot_attention", Napi::Function::New(env__, atg__triton_scaled_dot_attention));
  exports.Set("atg__triton_scaled_dot_attention_out", Napi::Function::New(env__, atg__triton_scaled_dot_attention_out));
  exports.Set("atg__triton_multi_head_attention", Napi::Function::New(env__, atg__triton_multi_head_attention));
  exports.Set("atg__triton_multi_head_attention_out", Napi::Function::New(env__, atg__triton_multi_head_attention_out));
  exports.Set("atg_special_airy_ai", Napi::Function::New(env__, atg_special_airy_ai));
  exports.Set("atg_special_airy_ai_out", Napi::Function::New(env__, atg_special_airy_ai_out));
  exports.Set("atg__transformer_decoder_only_layer_fwd", Napi::Function::New(env__, atg__transformer_decoder_only_layer_fwd));
  exports.Set("atg__transformer_decoder_only_layer_fwd_out", Napi::Function::New(env__, atg__transformer_decoder_only_layer_fwd_out));
  exports.Set("atg__native_decoder_only_multi_head_attention", Napi::Function::New(env__, atg__native_decoder_only_multi_head_attention));
  exports.Set("atg__native_decoder_only_multi_head_attention_out", Napi::Function::New(env__, atg__native_decoder_only_multi_head_attention_out));
  exports.Set("atg_special_bessel_j0", Napi::Function::New(env__, atg_special_bessel_j0));
  exports.Set("atg_special_bessel_j0_out", Napi::Function::New(env__, atg_special_bessel_j0_out));
  exports.Set("atg_special_bessel_j1", Napi::Function::New(env__, atg_special_bessel_j1));
  exports.Set("atg_special_bessel_j1_out", Napi::Function::New(env__, atg_special_bessel_j1_out));
  exports.Set("atg_special_bessel_y0", Napi::Function::New(env__, atg_special_bessel_y0));
  exports.Set("atg_special_bessel_y0_out", Napi::Function::New(env__, atg_special_bessel_y0_out));
  exports.Set("atg_special_bessel_y1", Napi::Function::New(env__, atg_special_bessel_y1));
  exports.Set("atg_special_bessel_y1_out", Napi::Function::New(env__, atg_special_bessel_y1_out));
  exports.Set("atg_special_chebyshev_polynomial_t", Napi::Function::New(env__, atg_special_chebyshev_polynomial_t));
  exports.Set("atg_special_chebyshev_polynomial_t_x_scalar", Napi::Function::New(env__, atg_special_chebyshev_polynomial_t_x_scalar));
  exports.Set("atg_special_chebyshev_polynomial_t_n_scalar", Napi::Function::New(env__, atg_special_chebyshev_polynomial_t_n_scalar));
  exports.Set("atg_special_chebyshev_polynomial_t_out", Napi::Function::New(env__, atg_special_chebyshev_polynomial_t_out));
  exports.Set("atg_special_chebyshev_polynomial_t_x_scalar_out", Napi::Function::New(env__, atg_special_chebyshev_polynomial_t_x_scalar_out));
  exports.Set("atg_special_chebyshev_polynomial_t_n_scalar_out", Napi::Function::New(env__, atg_special_chebyshev_polynomial_t_n_scalar_out));
  exports.Set("atg_special_chebyshev_polynomial_u", Napi::Function::New(env__, atg_special_chebyshev_polynomial_u));
  exports.Set("atg_special_chebyshev_polynomial_u_x_scalar", Napi::Function::New(env__, atg_special_chebyshev_polynomial_u_x_scalar));
  exports.Set("atg_special_chebyshev_polynomial_u_n_scalar", Napi::Function::New(env__, atg_special_chebyshev_polynomial_u_n_scalar));
  exports.Set("atg_special_chebyshev_polynomial_u_out", Napi::Function::New(env__, atg_special_chebyshev_polynomial_u_out));
  exports.Set("atg_special_chebyshev_polynomial_u_x_scalar_out", Napi::Function::New(env__, atg_special_chebyshev_polynomial_u_x_scalar_out));
  exports.Set("atg_special_chebyshev_polynomial_u_n_scalar_out", Napi::Function::New(env__, atg_special_chebyshev_polynomial_u_n_scalar_out));
  exports.Set("atg_special_chebyshev_polynomial_v", Napi::Function::New(env__, atg_special_chebyshev_polynomial_v));
  exports.Set("atg_special_chebyshev_polynomial_v_x_scalar", Napi::Function::New(env__, atg_special_chebyshev_polynomial_v_x_scalar));
  exports.Set("atg_special_chebyshev_polynomial_v_n_scalar", Napi::Function::New(env__, atg_special_chebyshev_polynomial_v_n_scalar));
  exports.Set("atg_special_chebyshev_polynomial_v_out", Napi::Function::New(env__, atg_special_chebyshev_polynomial_v_out));
  exports.Set("atg_special_chebyshev_polynomial_v_x_scalar_out", Napi::Function::New(env__, atg_special_chebyshev_polynomial_v_x_scalar_out));
  exports.Set("atg_special_chebyshev_polynomial_v_n_scalar_out", Napi::Function::New(env__, atg_special_chebyshev_polynomial_v_n_scalar_out));
  exports.Set("atg_special_chebyshev_polynomial_w", Napi::Function::New(env__, atg_special_chebyshev_polynomial_w));
  exports.Set("atg_special_chebyshev_polynomial_w_x_scalar", Napi::Function::New(env__, atg_special_chebyshev_polynomial_w_x_scalar));
  exports.Set("atg_special_chebyshev_polynomial_w_n_scalar", Napi::Function::New(env__, atg_special_chebyshev_polynomial_w_n_scalar));
  exports.Set("atg_special_chebyshev_polynomial_w_out", Napi::Function::New(env__, atg_special_chebyshev_polynomial_w_out));
  exports.Set("atg_special_chebyshev_polynomial_w_x_scalar_out", Napi::Function::New(env__, atg_special_chebyshev_polynomial_w_x_scalar_out));
  exports.Set("atg_special_chebyshev_polynomial_w_n_scalar_out", Napi::Function::New(env__, atg_special_chebyshev_polynomial_w_n_scalar_out));
  exports.Set("atg_special_hermite_polynomial_h", Napi::Function::New(env__, atg_special_hermite_polynomial_h));
  exports.Set("atg_special_hermite_polynomial_h_x_scalar", Napi::Function::New(env__, atg_special_hermite_polynomial_h_x_scalar));
  exports.Set("atg_special_hermite_polynomial_h_n_scalar", Napi::Function::New(env__, atg_special_hermite_polynomial_h_n_scalar));
  exports.Set("atg_special_hermite_polynomial_h_out", Napi::Function::New(env__, atg_special_hermite_polynomial_h_out));
  exports.Set("atg_special_hermite_polynomial_h_x_scalar_out", Napi::Function::New(env__, atg_special_hermite_polynomial_h_x_scalar_out));
  exports.Set("atg_special_hermite_polynomial_h_n_scalar_out", Napi::Function::New(env__, atg_special_hermite_polynomial_h_n_scalar_out));
  exports.Set("atg_special_hermite_polynomial_he", Napi::Function::New(env__, atg_special_hermite_polynomial_he));
  exports.Set("atg_special_hermite_polynomial_he_x_scalar", Napi::Function::New(env__, atg_special_hermite_polynomial_he_x_scalar));
  exports.Set("atg_special_hermite_polynomial_he_n_scalar", Napi::Function::New(env__, atg_special_hermite_polynomial_he_n_scalar));
  exports.Set("atg_special_hermite_polynomial_he_out", Napi::Function::New(env__, atg_special_hermite_polynomial_he_out));
  exports.Set("atg_special_hermite_polynomial_he_x_scalar_out", Napi::Function::New(env__, atg_special_hermite_polynomial_he_x_scalar_out));
  exports.Set("atg_special_hermite_polynomial_he_n_scalar_out", Napi::Function::New(env__, atg_special_hermite_polynomial_he_n_scalar_out));
  exports.Set("atg_special_laguerre_polynomial_l", Napi::Function::New(env__, atg_special_laguerre_polynomial_l));
  exports.Set("atg_special_laguerre_polynomial_l_x_scalar", Napi::Function::New(env__, atg_special_laguerre_polynomial_l_x_scalar));
  exports.Set("atg_special_laguerre_polynomial_l_n_scalar", Napi::Function::New(env__, atg_special_laguerre_polynomial_l_n_scalar));
  exports.Set("atg_special_laguerre_polynomial_l_out", Napi::Function::New(env__, atg_special_laguerre_polynomial_l_out));
  exports.Set("atg_special_laguerre_polynomial_l_x_scalar_out", Napi::Function::New(env__, atg_special_laguerre_polynomial_l_x_scalar_out));
  exports.Set("atg_special_laguerre_polynomial_l_n_scalar_out", Napi::Function::New(env__, atg_special_laguerre_polynomial_l_n_scalar_out));
  exports.Set("atg_special_legendre_polynomial_p", Napi::Function::New(env__, atg_special_legendre_polynomial_p));
  exports.Set("atg_special_legendre_polynomial_p_x_scalar", Napi::Function::New(env__, atg_special_legendre_polynomial_p_x_scalar));
  exports.Set("atg_special_legendre_polynomial_p_n_scalar", Napi::Function::New(env__, atg_special_legendre_polynomial_p_n_scalar));
  exports.Set("atg_special_legendre_polynomial_p_out", Napi::Function::New(env__, atg_special_legendre_polynomial_p_out));
  exports.Set("atg_special_legendre_polynomial_p_x_scalar_out", Napi::Function::New(env__, atg_special_legendre_polynomial_p_x_scalar_out));
  exports.Set("atg_special_legendre_polynomial_p_n_scalar_out", Napi::Function::New(env__, atg_special_legendre_polynomial_p_n_scalar_out));
  exports.Set("atg_special_modified_bessel_i0", Napi::Function::New(env__, atg_special_modified_bessel_i0));
  exports.Set("atg_special_modified_bessel_i0_out", Napi::Function::New(env__, atg_special_modified_bessel_i0_out));
  exports.Set("atg_special_modified_bessel_i1", Napi::Function::New(env__, atg_special_modified_bessel_i1));
  exports.Set("atg_special_modified_bessel_i1_out", Napi::Function::New(env__, atg_special_modified_bessel_i1_out));
  exports.Set("atg_special_modified_bessel_k0", Napi::Function::New(env__, atg_special_modified_bessel_k0));
  exports.Set("atg_special_modified_bessel_k0_out", Napi::Function::New(env__, atg_special_modified_bessel_k0_out));
  exports.Set("atg_special_modified_bessel_k1", Napi::Function::New(env__, atg_special_modified_bessel_k1));
  exports.Set("atg_special_modified_bessel_k1_out", Napi::Function::New(env__, atg_special_modified_bessel_k1_out));
  exports.Set("atg_special_scaled_modified_bessel_k0", Napi::Function::New(env__, atg_special_scaled_modified_bessel_k0));
  exports.Set("atg_special_scaled_modified_bessel_k0_out", Napi::Function::New(env__, atg_special_scaled_modified_bessel_k0_out));
  exports.Set("atg_special_scaled_modified_bessel_k1", Napi::Function::New(env__, atg_special_scaled_modified_bessel_k1));
  exports.Set("atg_special_scaled_modified_bessel_k1_out", Napi::Function::New(env__, atg_special_scaled_modified_bessel_k1_out));
  exports.Set("atg_special_shifted_chebyshev_polynomial_t", Napi::Function::New(env__, atg_special_shifted_chebyshev_polynomial_t));
  exports.Set("atg_special_shifted_chebyshev_polynomial_t_x_scalar", Napi::Function::New(env__, atg_special_shifted_chebyshev_polynomial_t_x_scalar));
  exports.Set("atg_special_shifted_chebyshev_polynomial_t_n_scalar", Napi::Function::New(env__, atg_special_shifted_chebyshev_polynomial_t_n_scalar));
  exports.Set("atg_special_shifted_chebyshev_polynomial_t_out", Napi::Function::New(env__, atg_special_shifted_chebyshev_polynomial_t_out));
  exports.Set("atg_special_shifted_chebyshev_polynomial_t_x_scalar_out", Napi::Function::New(env__, atg_special_shifted_chebyshev_polynomial_t_x_scalar_out));
  exports.Set("atg_special_shifted_chebyshev_polynomial_t_n_scalar_out", Napi::Function::New(env__, atg_special_shifted_chebyshev_polynomial_t_n_scalar_out));
  exports.Set("atg_special_shifted_chebyshev_polynomial_u", Napi::Function::New(env__, atg_special_shifted_chebyshev_polynomial_u));
  exports.Set("atg_special_shifted_chebyshev_polynomial_u_x_scalar", Napi::Function::New(env__, atg_special_shifted_chebyshev_polynomial_u_x_scalar));
  exports.Set("atg_special_shifted_chebyshev_polynomial_u_n_scalar", Napi::Function::New(env__, atg_special_shifted_chebyshev_polynomial_u_n_scalar));
  exports.Set("atg_special_shifted_chebyshev_polynomial_u_out", Napi::Function::New(env__, atg_special_shifted_chebyshev_polynomial_u_out));
  exports.Set("atg_special_shifted_chebyshev_polynomial_u_x_scalar_out", Napi::Function::New(env__, atg_special_shifted_chebyshev_polynomial_u_x_scalar_out));
  exports.Set("atg_special_shifted_chebyshev_polynomial_u_n_scalar_out", Napi::Function::New(env__, atg_special_shifted_chebyshev_polynomial_u_n_scalar_out));
  exports.Set("atg_special_shifted_chebyshev_polynomial_v", Napi::Function::New(env__, atg_special_shifted_chebyshev_polynomial_v));
  exports.Set("atg_special_shifted_chebyshev_polynomial_v_x_scalar", Napi::Function::New(env__, atg_special_shifted_chebyshev_polynomial_v_x_scalar));
  exports.Set("atg_special_shifted_chebyshev_polynomial_v_n_scalar", Napi::Function::New(env__, atg_special_shifted_chebyshev_polynomial_v_n_scalar));
  exports.Set("atg_special_shifted_chebyshev_polynomial_v_out", Napi::Function::New(env__, atg_special_shifted_chebyshev_polynomial_v_out));
  exports.Set("atg_special_shifted_chebyshev_polynomial_v_x_scalar_out", Napi::Function::New(env__, atg_special_shifted_chebyshev_polynomial_v_x_scalar_out));
  exports.Set("atg_special_shifted_chebyshev_polynomial_v_n_scalar_out", Napi::Function::New(env__, atg_special_shifted_chebyshev_polynomial_v_n_scalar_out));
  exports.Set("atg_special_shifted_chebyshev_polynomial_w", Napi::Function::New(env__, atg_special_shifted_chebyshev_polynomial_w));
  exports.Set("atg_special_shifted_chebyshev_polynomial_w_x_scalar", Napi::Function::New(env__, atg_special_shifted_chebyshev_polynomial_w_x_scalar));
  exports.Set("atg_special_shifted_chebyshev_polynomial_w_n_scalar", Napi::Function::New(env__, atg_special_shifted_chebyshev_polynomial_w_n_scalar));
  exports.Set("atg_special_shifted_chebyshev_polynomial_w_out", Napi::Function::New(env__, atg_special_shifted_chebyshev_polynomial_w_out));
  exports.Set("atg_special_shifted_chebyshev_polynomial_w_x_scalar_out", Napi::Function::New(env__, atg_special_shifted_chebyshev_polynomial_w_x_scalar_out));
  exports.Set("atg_special_shifted_chebyshev_polynomial_w_n_scalar_out", Napi::Function::New(env__, atg_special_shifted_chebyshev_polynomial_w_n_scalar_out));
  exports.Set("atg_special_spherical_bessel_j0", Napi::Function::New(env__, atg_special_spherical_bessel_j0));
  exports.Set("atg_special_spherical_bessel_j0_out", Napi::Function::New(env__, atg_special_spherical_bessel_j0_out));
  exports.Set("atg__foobar", Napi::Function::New(env__, atg__foobar));
  exports.Set("atg__foobar_out", Napi::Function::New(env__, atg__foobar_out));
  exports.Set("atg__fused_adam_", Napi::Function::New(env__, atg__fused_adam_));
  exports.Set("atg__fused_adamw_", Napi::Function::New(env__, atg__fused_adamw_));
  exports.Set("atg_embedding_renorm", Napi::Function::New(env__, atg_embedding_renorm));
  exports.Set("atg_embedding_renorm_out", Napi::Function::New(env__, atg_embedding_renorm_out));
  exports.Set("atg_resize", Napi::Function::New(env__, atg_resize));
  exports.Set("atg_resize_out", Napi::Function::New(env__, atg_resize_out));
  exports.Set("atg__resize_output", Napi::Function::New(env__, atg__resize_output));
  exports.Set("atg__resize_output_out", Napi::Function::New(env__, atg__resize_output_out));
  exports.Set("atg__index_put_impl", Napi::Function::New(env__, atg__index_put_impl));
  exports.Set("atg__index_put_impl_out", Napi::Function::New(env__, atg__index_put_impl_out));
  exports.Set("atg__native_batch_norm_legit_functional", Napi::Function::New(env__, atg__native_batch_norm_legit_functional));
  exports.Set("atg_unsafe_split", Napi::Function::New(env__, atg_unsafe_split));
  exports.Set("atg_unsafe_split_with_sizes", Napi::Function::New(env__, atg_unsafe_split_with_sizes));
  exports.Set("atg_clone", Napi::Function::New(env__, atg_clone));
  exports.Set("atg_resize_as", Napi::Function::New(env__, atg_resize_as));
  exports.Set("atg_resize_as_out", Napi::Function::New(env__, atg_resize_as_out));
  exports.Set("atg_resize_as_sparse", Napi::Function::New(env__, atg_resize_as_sparse));
  exports.Set("atg_resize_as_sparse_out", Napi::Function::New(env__, atg_resize_as_sparse_out));
  exports.Set("atg_zero", Napi::Function::New(env__, atg_zero));
  exports.Set("atg_zero_out", Napi::Function::New(env__, atg_zero_out));
  exports.Set("atg_sparse_resize", Napi::Function::New(env__, atg_sparse_resize));
  exports.Set("atg_sparse_resize_out", Napi::Function::New(env__, atg_sparse_resize_out));
  exports.Set("atg_sparse_resize_and_clear", Napi::Function::New(env__, atg_sparse_resize_and_clear));
  exports.Set("atg_sparse_resize_and_clear_out", Napi::Function::New(env__, atg_sparse_resize_and_clear_out));
  exports.Set("atg__coalesced", Napi::Function::New(env__, atg__coalesced));
  exports.Set("atg__coalesced_out", Napi::Function::New(env__, atg__coalesced_out));
  exports.Set("atg_copy_sparse_to_sparse", Napi::Function::New(env__, atg_copy_sparse_to_sparse));
  exports.Set("atg_copy_sparse_to_sparse_out", Napi::Function::New(env__, atg_copy_sparse_to_sparse_out));
  exports.Set("atg__fused_moving_avg_obs_fq_helper_functional", Napi::Function::New(env__, atg__fused_moving_avg_obs_fq_helper_functional));
  exports.Set("atg_lstm_mps_backward", Napi::Function::New(env__, atg_lstm_mps_backward));
  exports.Set("atg_set", Napi::Function::New(env__, atg_set));
  exports.Set("atg_set_source_tensor", Napi::Function::New(env__, atg_set_source_tensor));
  exports.Set("atg_set_out", Napi::Function::New(env__, atg_set_out));
  exports.Set("atg_set_source_tensor_out", Napi::Function::New(env__, atg_set_source_tensor_out));
  exports.Set("atg_random", Napi::Function::New(env__, atg_random));
  exports.Set("atg_random_to", Napi::Function::New(env__, atg_random_to));
  exports.Set("atg_random_from", Napi::Function::New(env__, atg_random_from));
  exports.Set("atg_random_out", Napi::Function::New(env__, atg_random_out));
  exports.Set("atg_random_to_out", Napi::Function::New(env__, atg_random_to_out));
  exports.Set("atg_random_from_out", Napi::Function::New(env__, atg_random_from_out));
  exports.Set("atg_uniform", Napi::Function::New(env__, atg_uniform));
  exports.Set("atg_uniform_out", Napi::Function::New(env__, atg_uniform_out));
  exports.Set("atg_cauchy", Napi::Function::New(env__, atg_cauchy));
  exports.Set("atg_cauchy_out", Napi::Function::New(env__, atg_cauchy_out));
  exports.Set("atg_log_normal", Napi::Function::New(env__, atg_log_normal));
  exports.Set("atg_log_normal_out", Napi::Function::New(env__, atg_log_normal_out));
  exports.Set("atg_exponential", Napi::Function::New(env__, atg_exponential));
  exports.Set("atg_exponential_out", Napi::Function::New(env__, atg_exponential_out));
  exports.Set("atg_geometric", Napi::Function::New(env__, atg_geometric));
  exports.Set("atg_geometric_out", Napi::Function::New(env__, atg_geometric_out));
  exports.Set("atg__histogramdd_bin_edges", Napi::Function::New(env__, atg__histogramdd_bin_edges));
  exports.Set("atg__amp_update_scale", Napi::Function::New(env__, atg__amp_update_scale));
  exports.Set("atg__amp_update_scale_out", Napi::Function::New(env__, atg__amp_update_scale_out));
  exports.Set("atg__fused_adam", Napi::Function::New(env__, atg__fused_adam));
  exports.Set("atg__fused_adamw", Napi::Function::New(env__, atg__fused_adamw));
  return exports;
}

} // namespace TypeTorch
