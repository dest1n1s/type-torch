// THIS FILE IS AUTOMATICALLY GENERATED, DO NOT EDIT BY HAND!

import { CTensor, CScalar, addon } from "./torch_api.js"

export const atg__cast_Byte = ({ self, non_blocking }: { self: CTensor; non_blocking: boolean }): CTensor => {
  return addon.atg__cast_Byte(self, non_blocking)
}

export const atg__cast_Char = ({ self, non_blocking }: { self: CTensor; non_blocking: boolean }): CTensor => {
  return addon.atg__cast_Char(self, non_blocking)
}

export const atg__cast_Double = ({ self, non_blocking }: { self: CTensor; non_blocking: boolean }): CTensor => {
  return addon.atg__cast_Double(self, non_blocking)
}

export const atg__cast_Float = ({ self, non_blocking }: { self: CTensor; non_blocking: boolean }): CTensor => {
  return addon.atg__cast_Float(self, non_blocking)
}

export const atg__cast_Int = ({ self, non_blocking }: { self: CTensor; non_blocking: boolean }): CTensor => {
  return addon.atg__cast_Int(self, non_blocking)
}

export const atg__cast_Long = ({ self, non_blocking }: { self: CTensor; non_blocking: boolean }): CTensor => {
  return addon.atg__cast_Long(self, non_blocking)
}

export const atg__cast_Short = ({ self, non_blocking }: { self: CTensor; non_blocking: boolean }): CTensor => {
  return addon.atg__cast_Short(self, non_blocking)
}

export const atg__cast_Half = ({ self, non_blocking }: { self: CTensor; non_blocking: boolean }): CTensor => {
  return addon.atg__cast_Half(self, non_blocking)
}

export const atg_set_data = ({ self, new_data }: { self: CTensor; new_data: CTensor }): void => {
  return addon.atg_set_data(self, new_data)
}

export const atg_data = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_data(self)
}

export const atg_is_leaf = ({ self }: { self: CTensor }): boolean => {
  return addon.atg_is_leaf(self)
}

export const atg_output_nr = ({ self }: { self: CTensor }): number => {
  return addon.atg_output_nr(self)
}

export const atg__version = ({ self }: { self: CTensor }): number => {
  return addon.atg__version(self)
}

export const atg_requires_grad_ = ({ self, requires_grad }: { self: CTensor; requires_grad: boolean }): CTensor => {
  return addon.atg_requires_grad_(self, requires_grad)
}

export const atg_retains_grad = ({ self }: { self: CTensor }): boolean => {
  return addon.atg_retains_grad(self)
}

export const atg__fw_primal = ({ self, level }: { self: CTensor; level: number }): CTensor => {
  return addon.atg__fw_primal(self, level)
}

export const atg__make_dual = ({ primal, tangent, level }: { primal: CTensor; tangent: CTensor; level: number }): CTensor => {
  return addon.atg__make_dual(primal, tangent, level)
}

export const atg__unpack_dual = ({ dual, level }: { dual: CTensor; level: number }): CTensor[] => {
  return addon.atg__unpack_dual(dual, level)
}

export const atg__new_zeros_with_same_feature_meta = ({ self, other, self_num_batch_dims }: { self: CTensor; other: CTensor; self_num_batch_dims: number }): CTensor => {
  return addon.atg__new_zeros_with_same_feature_meta(self, other, self_num_batch_dims)
}

export const atg__new_zeros_with_same_feature_meta_out = ({ out, self, other, self_num_batch_dims }: { out: CTensor; self: CTensor; other: CTensor; self_num_batch_dims: number }): CTensor => {
  return addon.atg__new_zeros_with_same_feature_meta_out(out, self, other, self_num_batch_dims)
}

export const atg__has_same_storage_numel = ({ self, other }: { self: CTensor; other: CTensor }): boolean => {
  return addon.atg__has_same_storage_numel(self, other)
}

export const atg_align_as = ({ self, other }: { self: CTensor; other: CTensor }): CTensor => {
  return addon.atg_align_as(self, other)
}

export const atg__assert_tensor_metadata = ({ a, size, stride, dtype }: { a: CTensor; size?: number[]; stride?: number[]; dtype: number }): void => {
  return addon.atg__assert_tensor_metadata(a, size, stride, dtype)
}

export const atg__use_cudnn_ctc_loss = ({ log_probs, targets, input_lengths, target_lengths, blank }: { log_probs: CTensor; targets: CTensor; input_lengths: number[]; target_lengths: number[]; blank: number }): boolean => {
  return addon.atg__use_cudnn_ctc_loss(log_probs, targets, input_lengths, target_lengths, blank)
}

export const atg__use_cudnn_ctc_loss_tensor = ({ log_probs, targets, input_lengths, target_lengths, blank }: { log_probs: CTensor; targets: CTensor; input_lengths: CTensor; target_lengths: CTensor; blank: number }): boolean => {
  return addon.atg__use_cudnn_ctc_loss_tensor(log_probs, targets, input_lengths, target_lengths, blank)
}

export const atg__cudnn_ctc_loss = ({ log_probs, targets, input_lengths, target_lengths, blank, deterministic, zero_infinity }: { log_probs: CTensor; targets: CTensor; input_lengths: number[]; target_lengths: number[]; blank: number; deterministic: boolean; zero_infinity: boolean }): CTensor[] => {
  return addon.atg__cudnn_ctc_loss(log_probs, targets, input_lengths, target_lengths, blank, deterministic, zero_infinity)
}

export const atg__cudnn_ctc_loss_tensor = ({ log_probs, targets, input_lengths, target_lengths, blank, deterministic, zero_infinity }: { log_probs: CTensor; targets: CTensor; input_lengths: CTensor; target_lengths: CTensor; blank: number; deterministic: boolean; zero_infinity: boolean }): CTensor[] => {
  return addon.atg__cudnn_ctc_loss_tensor(log_probs, targets, input_lengths, target_lengths, blank, deterministic, zero_infinity)
}

export const atg__cudnn_ctc_loss_out = ({ out0, out1, log_probs, targets, input_lengths, target_lengths, blank, deterministic, zero_infinity }: { out0: CTensor; out1: CTensor; log_probs: CTensor; targets: CTensor; input_lengths: number[]; target_lengths: number[]; blank: number; deterministic: boolean; zero_infinity: boolean }): CTensor[] => {
  return addon.atg__cudnn_ctc_loss_out(out0, out1, log_probs, targets, input_lengths, target_lengths, blank, deterministic, zero_infinity)
}

export const atg__use_cudnn_rnn_flatten_weight = (_: Record<string, never>): boolean => {
  return addon.atg__use_cudnn_rnn_flatten_weight()
}

export const atg__cudnn_rnn_flatten_weight = ({ weight_arr, weight_stride0, input_size, mode, hidden_size, proj_size, num_layers, batch_first, bidirectional }: { weight_arr: CTensor[]; weight_stride0: number; input_size: number; mode: number; hidden_size: number; proj_size: number; num_layers: number; batch_first: boolean; bidirectional: boolean }): CTensor => {
  return addon.atg__cudnn_rnn_flatten_weight(weight_arr, weight_stride0, input_size, mode, hidden_size, proj_size, num_layers, batch_first, bidirectional)
}

export const atg__cudnn_rnn_flatten_weight_out = ({ out, weight_arr, weight_stride0, input_size, mode, hidden_size, proj_size, num_layers, batch_first, bidirectional }: { out: CTensor; weight_arr: CTensor[]; weight_stride0: number; input_size: number; mode: number; hidden_size: number; proj_size: number; num_layers: number; batch_first: boolean; bidirectional: boolean }): CTensor => {
  return addon.atg__cudnn_rnn_flatten_weight_out(out, weight_arr, weight_stride0, input_size, mode, hidden_size, proj_size, num_layers, batch_first, bidirectional)
}

export const atg__cudnn_rnn = ({ input, weight, weight_stride0, weight_buf, hx, cx, mode, hidden_size, proj_size, num_layers, batch_first, dropout, train, bidirectional, batch_sizes, dropout_state }: { input: CTensor; weight: CTensor[]; weight_stride0: number; weight_buf?: CTensor; hx: CTensor; cx?: CTensor; mode: number; hidden_size: number; proj_size: number; num_layers: number; batch_first: boolean; dropout: number; train: boolean; bidirectional: boolean; batch_sizes: number[]; dropout_state?: CTensor }): CTensor[] => {
  return addon.atg__cudnn_rnn(input, weight, weight_stride0, weight_buf, hx, cx, mode, hidden_size, proj_size, num_layers, batch_first, dropout, train, bidirectional, batch_sizes, dropout_state)
}

export const atg__cudnn_rnn_out = ({ out0, out1, out2, out3, out4, input, weight, weight_stride0, weight_buf, hx, cx, mode, hidden_size, proj_size, num_layers, batch_first, dropout, train, bidirectional, batch_sizes, dropout_state }: { out0: CTensor; out1: CTensor; out2: CTensor; out3: CTensor; out4: CTensor; input: CTensor; weight: CTensor[]; weight_stride0: number; weight_buf?: CTensor; hx: CTensor; cx?: CTensor; mode: number; hidden_size: number; proj_size: number; num_layers: number; batch_first: boolean; dropout: number; train: boolean; bidirectional: boolean; batch_sizes: number[]; dropout_state?: CTensor }): CTensor[] => {
  return addon.atg__cudnn_rnn_out(out0, out1, out2, out3, out4, input, weight, weight_stride0, weight_buf, hx, cx, mode, hidden_size, proj_size, num_layers, batch_first, dropout, train, bidirectional, batch_sizes, dropout_state)
}

export const atg__cudnn_init_dropout_state = ({ dropout, train, dropout_seed, options }: { dropout: number; train: boolean; dropout_seed: number; options: { device: number, dtype: number } }): CTensor => {
  return addon.atg__cudnn_init_dropout_state(dropout, train, dropout_seed, options)
}

export const atg__cudnn_init_dropout_state_out = ({ out, dropout, train, dropout_seed }: { out: CTensor; dropout: number; train: boolean; dropout_seed: number }): CTensor => {
  return addon.atg__cudnn_init_dropout_state_out(out, dropout, train, dropout_seed)
}

export const atg__debug_has_internal_overlap = ({ self }: { self: CTensor }): number => {
  return addon.atg__debug_has_internal_overlap(self)
}

export const atg__fused_dropout = ({ self, p }: { self: CTensor; p: number }): CTensor[] => {
  return addon.atg__fused_dropout(self, p)
}

export const atg__fused_dropout_out = ({ out0, out1, self, p }: { out0: CTensor; out1: CTensor; self: CTensor; p: number }): CTensor[] => {
  return addon.atg__fused_dropout_out(out0, out1, self, p)
}

export const atg__masked_scale = ({ self, mask, scale }: { self: CTensor; mask: CTensor; scale: number }): CTensor => {
  return addon.atg__masked_scale(self, mask, scale)
}

export const atg__masked_scale_out = ({ out, self, mask, scale }: { out: CTensor; self: CTensor; mask: CTensor; scale: number }): CTensor => {
  return addon.atg__masked_scale_out(out, self, mask, scale)
}

export const atg_native_dropout = ({ input, p, train }: { input: CTensor; p: number; train: boolean }): CTensor[] => {
  return addon.atg_native_dropout(input, p, train)
}

export const atg_native_dropout_out = ({ out0, out1, input, p, train }: { out0: CTensor; out1: CTensor; input: CTensor; p: number; train: boolean }): CTensor[] => {
  return addon.atg_native_dropout_out(out0, out1, input, p, train)
}

export const atg_native_dropout_backward = ({ grad_output, mask, scale }: { grad_output: CTensor; mask: CTensor; scale: number }): CTensor => {
  return addon.atg_native_dropout_backward(grad_output, mask, scale)
}

export const atg_native_dropout_backward_out = ({ out, grad_output, mask, scale }: { out: CTensor; grad_output: CTensor; mask: CTensor; scale: number }): CTensor => {
  return addon.atg_native_dropout_backward_out(out, grad_output, mask, scale)
}

export const atg__sobol_engine_draw = ({ quasi, n, sobolstate, dimension, num_generated, dtype }: { quasi: CTensor; n: number; sobolstate: CTensor; dimension: number; num_generated: number; dtype: number }): CTensor[] => {
  return addon.atg__sobol_engine_draw(quasi, n, sobolstate, dimension, num_generated, dtype)
}

export const atg__sobol_engine_ff_ = ({ self, n, sobolstate, dimension, num_generated }: { self: CTensor; n: number; sobolstate: CTensor; dimension: number; num_generated: number }): CTensor => {
  return addon.atg__sobol_engine_ff_(self, n, sobolstate, dimension, num_generated)
}

export const atg__sobol_engine_scramble_ = ({ self, ltm, dimension }: { self: CTensor; ltm: CTensor; dimension: number }): CTensor => {
  return addon.atg__sobol_engine_scramble_(self, ltm, dimension)
}

export const atg__sobol_engine_initialize_state_ = ({ self, dimension }: { self: CTensor; dimension: number }): CTensor => {
  return addon.atg__sobol_engine_initialize_state_(self, dimension)
}

export const atg__reshape_from_tensor = ({ self, shape }: { self: CTensor; shape: CTensor }): CTensor => {
  return addon.atg__reshape_from_tensor(self, shape)
}

export const atg__shape_as_tensor = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg__shape_as_tensor(self)
}

export const atg_dropout = ({ input, p, train }: { input: CTensor; p: number; train: boolean }): CTensor => {
  return addon.atg_dropout(input, p, train)
}

export const atg_dropout_ = ({ self, p, train }: { self: CTensor; p: number; train: boolean }): CTensor => {
  return addon.atg_dropout_(self, p, train)
}

export const atg_feature_dropout = ({ input, p, train }: { input: CTensor; p: number; train: boolean }): CTensor => {
  return addon.atg_feature_dropout(input, p, train)
}

export const atg_feature_dropout_ = ({ self, p, train }: { self: CTensor; p: number; train: boolean }): CTensor => {
  return addon.atg_feature_dropout_(self, p, train)
}

export const atg_alpha_dropout = ({ input, p, train }: { input: CTensor; p: number; train: boolean }): CTensor => {
  return addon.atg_alpha_dropout(input, p, train)
}

export const atg_alpha_dropout_ = ({ self, p, train }: { self: CTensor; p: number; train: boolean }): CTensor => {
  return addon.atg_alpha_dropout_(self, p, train)
}

export const atg_feature_alpha_dropout = ({ input, p, train }: { input: CTensor; p: number; train: boolean }): CTensor => {
  return addon.atg_feature_alpha_dropout(input, p, train)
}

export const atg_feature_alpha_dropout_ = ({ self, p, train }: { self: CTensor; p: number; train: boolean }): CTensor => {
  return addon.atg_feature_alpha_dropout_(self, p, train)
}

export const atg_abs = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_abs(self)
}

export const atg_abs_out = ({ out, self }: { out: CTensor; self: CTensor }): CTensor => {
  return addon.atg_abs_out(out, self)
}

export const atg_abs_ = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_abs_(self)
}

export const atg_absolute = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_absolute(self)
}

export const atg_absolute_out = ({ out, self }: { out: CTensor; self: CTensor }): CTensor => {
  return addon.atg_absolute_out(out, self)
}

export const atg_absolute_ = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_absolute_(self)
}

export const atg_angle = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_angle(self)
}

export const atg_angle_out = ({ out, self }: { out: CTensor; self: CTensor }): CTensor => {
  return addon.atg_angle_out(out, self)
}

export const atg_view_as_real = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_view_as_real(self)
}

export const atg_view_as_complex = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_view_as_complex(self)
}

export const atg_sgn = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_sgn(self)
}

export const atg_sgn_out = ({ out, self }: { out: CTensor; self: CTensor }): CTensor => {
  return addon.atg_sgn_out(out, self)
}

export const atg_sgn_ = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_sgn_(self)
}

export const atg_chalf = ({ self, memory_format }: { self: CTensor; memory_format: number }): CTensor => {
  return addon.atg_chalf(self, memory_format)
}

export const atg_real = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_real(self)
}

export const atg_imag = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_imag(self)
}

export const atg__conj = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg__conj(self)
}

export const atg_conj = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_conj(self)
}

export const atg__conj_physical = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg__conj_physical(self)
}

export const atg__conj_physical_out = ({ out, self }: { out: CTensor; self: CTensor }): CTensor => {
  return addon.atg__conj_physical_out(out, self)
}

export const atg_conj_physical = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_conj_physical(self)
}

export const atg_conj_physical_out = ({ out, self }: { out: CTensor; self: CTensor }): CTensor => {
  return addon.atg_conj_physical_out(out, self)
}

export const atg_conj_physical_ = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_conj_physical_(self)
}

export const atg_resolve_conj = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_resolve_conj(self)
}

export const atg_resolve_neg = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_resolve_neg(self)
}

export const atg__neg_view = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg__neg_view(self)
}

export const atg_acos = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_acos(self)
}

export const atg_acos_out = ({ out, self }: { out: CTensor; self: CTensor }): CTensor => {
  return addon.atg_acos_out(out, self)
}

export const atg_acos_ = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_acos_(self)
}

export const atg_arccos = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_arccos(self)
}

export const atg_arccos_out = ({ out, self }: { out: CTensor; self: CTensor }): CTensor => {
  return addon.atg_arccos_out(out, self)
}

export const atg_arccos_ = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_arccos_(self)
}

export const atg_avg_pool1d = ({ self, kernel_size, stride, padding, ceil_mode, count_include_pad }: { self: CTensor; kernel_size: number[]; stride: number[]; padding: number[]; ceil_mode: boolean; count_include_pad: boolean }): CTensor => {
  return addon.atg_avg_pool1d(self, kernel_size, stride, padding, ceil_mode, count_include_pad)
}

export const atg_adaptive_avg_pool1d = ({ self, output_size }: { self: CTensor; output_size: number[] }): CTensor => {
  return addon.atg_adaptive_avg_pool1d(self, output_size)
}

export const atg_adaptive_max_pool1d = ({ self, output_size }: { self: CTensor; output_size: number[] }): CTensor[] => {
  return addon.atg_adaptive_max_pool1d(self, output_size)
}

export const atg_add = ({ self, other, alpha }: { self: CTensor; other: CTensor; alpha: CScalar }): CTensor => {
  return addon.atg_add(self, other, alpha)
}

export const atg_add_scalar = ({ self, other, alpha }: { self: CTensor; other: CScalar; alpha: CScalar }): CTensor => {
  return addon.atg_add_scalar(self, other, alpha)
}

export const atg_add_out = ({ out, self, other, alpha }: { out: CTensor; self: CTensor; other: CTensor; alpha: CScalar }): CTensor => {
  return addon.atg_add_out(out, self, other, alpha)
}

export const atg_add_scalar_out = ({ out, self, other, alpha }: { out: CTensor; self: CTensor; other: CScalar; alpha: CScalar }): CTensor => {
  return addon.atg_add_scalar_out(out, self, other, alpha)
}

export const atg_add_ = ({ self, other, alpha }: { self: CTensor; other: CTensor; alpha: CScalar }): CTensor => {
  return addon.atg_add_(self, other, alpha)
}

export const atg_add_scalar_ = ({ self, other, alpha }: { self: CTensor; other: CScalar; alpha: CScalar }): CTensor => {
  return addon.atg_add_scalar_(self, other, alpha)
}

export const atg__add_relu = ({ self, other, alpha }: { self: CTensor; other: CTensor; alpha: CScalar }): CTensor => {
  return addon.atg__add_relu(self, other, alpha)
}

export const atg__add_relu_scalar = ({ self, other, alpha }: { self: CTensor; other: CScalar; alpha: CScalar }): CTensor => {
  return addon.atg__add_relu_scalar(self, other, alpha)
}

export const atg__add_relu_out = ({ out, self, other, alpha }: { out: CTensor; self: CTensor; other: CTensor; alpha: CScalar }): CTensor => {
  return addon.atg__add_relu_out(out, self, other, alpha)
}

export const atg__add_relu_scalar_out = ({ out, self, other, alpha }: { out: CTensor; self: CTensor; other: CScalar; alpha: CScalar }): CTensor => {
  return addon.atg__add_relu_scalar_out(out, self, other, alpha)
}

export const atg__add_relu_ = ({ self, other, alpha }: { self: CTensor; other: CTensor; alpha: CScalar }): CTensor => {
  return addon.atg__add_relu_(self, other, alpha)
}

export const atg__add_relu_scalar_ = ({ self, other, alpha }: { self: CTensor; other: CScalar; alpha: CScalar }): CTensor => {
  return addon.atg__add_relu_scalar_(self, other, alpha)
}

export const atg_addmv = ({ self, mat, vec, beta, alpha }: { self: CTensor; mat: CTensor; vec: CTensor; beta: CScalar; alpha: CScalar }): CTensor => {
  return addon.atg_addmv(self, mat, vec, beta, alpha)
}

export const atg_addmv_out = ({ out, self, mat, vec, beta, alpha }: { out: CTensor; self: CTensor; mat: CTensor; vec: CTensor; beta: CScalar; alpha: CScalar }): CTensor => {
  return addon.atg_addmv_out(out, self, mat, vec, beta, alpha)
}

export const atg_addmv_ = ({ self, mat, vec, beta, alpha }: { self: CTensor; mat: CTensor; vec: CTensor; beta: CScalar; alpha: CScalar }): CTensor => {
  return addon.atg_addmv_(self, mat, vec, beta, alpha)
}

export const atg_addr = ({ self, vec1, vec2, beta, alpha }: { self: CTensor; vec1: CTensor; vec2: CTensor; beta: CScalar; alpha: CScalar }): CTensor => {
  return addon.atg_addr(self, vec1, vec2, beta, alpha)
}

export const atg_addr_out = ({ out, self, vec1, vec2, beta, alpha }: { out: CTensor; self: CTensor; vec1: CTensor; vec2: CTensor; beta: CScalar; alpha: CScalar }): CTensor => {
  return addon.atg_addr_out(out, self, vec1, vec2, beta, alpha)
}

export const atg_addr_ = ({ self, vec1, vec2, beta, alpha }: { self: CTensor; vec1: CTensor; vec2: CTensor; beta: CScalar; alpha: CScalar }): CTensor => {
  return addon.atg_addr_(self, vec1, vec2, beta, alpha)
}

export const atg_affine_grid_generator = ({ theta, size, align_corners }: { theta: CTensor; size: number[]; align_corners: boolean }): CTensor => {
  return addon.atg_affine_grid_generator(theta, size, align_corners)
}

export const atg_affine_grid_generator_out = ({ out, theta, size, align_corners }: { out: CTensor; theta: CTensor; size: number[]; align_corners: boolean }): CTensor => {
  return addon.atg_affine_grid_generator_out(out, theta, size, align_corners)
}

export const atg_affine_grid_generator_backward = ({ grad, size, align_corners }: { grad: CTensor; size: number[]; align_corners: boolean }): CTensor => {
  return addon.atg_affine_grid_generator_backward(grad, size, align_corners)
}

export const atg__is_all_true = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg__is_all_true(self)
}

export const atg__is_any_true = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg__is_any_true(self)
}

export const atg__test_check_tensor = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg__test_check_tensor(self)
}

export const atg_all = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_all(self)
}

export const atg_all_dim = ({ self, dim, keepdim }: { self: CTensor; dim: number; keepdim: boolean }): CTensor => {
  return addon.atg_all_dim(self, dim, keepdim)
}

export const atg_all_all_out = ({ out, self }: { out: CTensor; self: CTensor }): CTensor => {
  return addon.atg_all_all_out(out, self)
}

export const atg_all_out = ({ out, self, dim, keepdim }: { out: CTensor; self: CTensor; dim: number; keepdim: boolean }): CTensor => {
  return addon.atg_all_out(out, self, dim, keepdim)
}

export const atg_allclose = ({ self, other, rtol, atol, equal_nan }: { self: CTensor; other: CTensor; rtol: number; atol: number; equal_nan: boolean }): boolean => {
  return addon.atg_allclose(self, other, rtol, atol, equal_nan)
}

export const atg_any = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_any(self)
}

export const atg_any_dim = ({ self, dim, keepdim }: { self: CTensor; dim: number; keepdim: boolean }): CTensor => {
  return addon.atg_any_dim(self, dim, keepdim)
}

export const atg_any_all_out = ({ out, self }: { out: CTensor; self: CTensor }): CTensor => {
  return addon.atg_any_all_out(out, self)
}

export const atg_any_out = ({ out, self, dim, keepdim }: { out: CTensor; self: CTensor; dim: number; keepdim: boolean }): CTensor => {
  return addon.atg_any_out(out, self, dim, keepdim)
}

export const atg_arange = ({ end, options }: { end: CScalar; options: { device: number, dtype: number } }): CTensor => {
  return addon.atg_arange(end, options)
}

export const atg_arange_start = ({ start, end, options }: { start: CScalar; end: CScalar; options: { device: number, dtype: number } }): CTensor => {
  return addon.atg_arange_start(start, end, options)
}

export const atg_arange_start_step = ({ start, end, step, options }: { start: CScalar; end: CScalar; step: CScalar; options: { device: number, dtype: number } }): CTensor => {
  return addon.atg_arange_start_step(start, end, step, options)
}

export const atg_arange_out = ({ out, end }: { out: CTensor; end: CScalar }): CTensor => {
  return addon.atg_arange_out(out, end)
}

export const atg_arange_start_out = ({ out, start, end, step }: { out: CTensor; start: CScalar; end: CScalar; step: CScalar }): CTensor => {
  return addon.atg_arange_start_out(out, start, end, step)
}

export const atg__dim_arange = ({ like, dim }: { like: CTensor; dim: number }): CTensor => {
  return addon.atg__dim_arange(like, dim)
}

export const atg_argmax = ({ self, dim, keepdim }: { self: CTensor; dim?: number; keepdim: boolean }): CTensor => {
  return addon.atg_argmax(self, dim, keepdim)
}

export const atg_argmax_out = ({ out, self, dim, keepdim }: { out: CTensor; self: CTensor; dim?: number; keepdim: boolean }): CTensor => {
  return addon.atg_argmax_out(out, self, dim, keepdim)
}

export const atg_argmin = ({ self, dim, keepdim }: { self: CTensor; dim?: number; keepdim: boolean }): CTensor => {
  return addon.atg_argmin(self, dim, keepdim)
}

export const atg_argmin_out = ({ out, self, dim, keepdim }: { out: CTensor; self: CTensor; dim?: number; keepdim: boolean }): CTensor => {
  return addon.atg_argmin_out(out, self, dim, keepdim)
}

export const atg_acosh = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_acosh(self)
}

export const atg_acosh_out = ({ out, self }: { out: CTensor; self: CTensor }): CTensor => {
  return addon.atg_acosh_out(out, self)
}

export const atg_acosh_ = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_acosh_(self)
}

export const atg_arccosh = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_arccosh(self)
}

export const atg_arccosh_out = ({ out, self }: { out: CTensor; self: CTensor }): CTensor => {
  return addon.atg_arccosh_out(out, self)
}

export const atg_arccosh_ = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_arccosh_(self)
}

export const atg_asinh = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_asinh(self)
}

export const atg_asinh_out = ({ out, self }: { out: CTensor; self: CTensor }): CTensor => {
  return addon.atg_asinh_out(out, self)
}

export const atg_asinh_ = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_asinh_(self)
}

export const atg_arcsinh = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_arcsinh(self)
}

export const atg_arcsinh_out = ({ out, self }: { out: CTensor; self: CTensor }): CTensor => {
  return addon.atg_arcsinh_out(out, self)
}

export const atg_arcsinh_ = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_arcsinh_(self)
}

export const atg_atanh = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_atanh(self)
}

export const atg_atanh_out = ({ out, self }: { out: CTensor; self: CTensor }): CTensor => {
  return addon.atg_atanh_out(out, self)
}

export const atg_atanh_ = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_atanh_(self)
}

export const atg_arctanh = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_arctanh(self)
}

export const atg_arctanh_out = ({ out, self }: { out: CTensor; self: CTensor }): CTensor => {
  return addon.atg_arctanh_out(out, self)
}

export const atg_arctanh_ = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_arctanh_(self)
}

export const atg_as_strided = ({ self, size, stride, storage_offset }: { self: CTensor; size: number[]; stride: number[]; storage_offset?: number }): CTensor => {
  return addon.atg_as_strided(self, size, stride, storage_offset)
}

export const atg_as_strided_ = ({ self, size, stride, storage_offset }: { self: CTensor; size: number[]; stride: number[]; storage_offset?: number }): CTensor => {
  return addon.atg_as_strided_(self, size, stride, storage_offset)
}

export const atg_asin = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_asin(self)
}

export const atg_asin_out = ({ out, self }: { out: CTensor; self: CTensor }): CTensor => {
  return addon.atg_asin_out(out, self)
}

export const atg_asin_ = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_asin_(self)
}

export const atg_arcsin = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_arcsin(self)
}

export const atg_arcsin_out = ({ out, self }: { out: CTensor; self: CTensor }): CTensor => {
  return addon.atg_arcsin_out(out, self)
}

export const atg_arcsin_ = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_arcsin_(self)
}

export const atg_atan = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_atan(self)
}

export const atg_atan_out = ({ out, self }: { out: CTensor; self: CTensor }): CTensor => {
  return addon.atg_atan_out(out, self)
}

export const atg_atan_ = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_atan_(self)
}

export const atg_arctan = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_arctan(self)
}

export const atg_arctan_out = ({ out, self }: { out: CTensor; self: CTensor }): CTensor => {
  return addon.atg_arctan_out(out, self)
}

export const atg_arctan_ = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_arctan_(self)
}

export const atg_atleast_1d = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_atleast_1d(self)
}

export const atg_atleast_2d = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_atleast_2d(self)
}

export const atg_atleast_3d = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_atleast_3d(self)
}

export const atg_baddbmm = ({ self, batch1, batch2, beta, alpha }: { self: CTensor; batch1: CTensor; batch2: CTensor; beta: CScalar; alpha: CScalar }): CTensor => {
  return addon.atg_baddbmm(self, batch1, batch2, beta, alpha)
}

export const atg_baddbmm_out = ({ out, self, batch1, batch2, beta, alpha }: { out: CTensor; self: CTensor; batch1: CTensor; batch2: CTensor; beta: CScalar; alpha: CScalar }): CTensor => {
  return addon.atg_baddbmm_out(out, self, batch1, batch2, beta, alpha)
}

export const atg_baddbmm_ = ({ self, batch1, batch2, beta, alpha }: { self: CTensor; batch1: CTensor; batch2: CTensor; beta: CScalar; alpha: CScalar }): CTensor => {
  return addon.atg_baddbmm_(self, batch1, batch2, beta, alpha)
}

export const atg_bartlett_window = ({ window_length, options }: { window_length: number; options: { device: number, dtype: number } }): CTensor => {
  return addon.atg_bartlett_window(window_length, options)
}

export const atg_bartlett_window_periodic = ({ window_length, periodic, options }: { window_length: number; periodic: boolean; options: { device: number, dtype: number } }): CTensor => {
  return addon.atg_bartlett_window_periodic(window_length, periodic, options)
}

export const atg_bartlett_window_out = ({ out, window_length }: { out: CTensor; window_length: number }): CTensor => {
  return addon.atg_bartlett_window_out(out, window_length)
}

export const atg_bartlett_window_periodic_out = ({ out, window_length, periodic }: { out: CTensor; window_length: number; periodic: boolean }): CTensor => {
  return addon.atg_bartlett_window_periodic_out(out, window_length, periodic)
}

export const atg_batch_norm = ({ input, weight, bias, running_mean, running_var, training, momentum, eps, cudnn_enabled }: { input: CTensor; weight?: CTensor; bias?: CTensor; running_mean?: CTensor; running_var?: CTensor; training: boolean; momentum: number; eps: number; cudnn_enabled: boolean }): CTensor => {
  return addon.atg_batch_norm(input, weight, bias, running_mean, running_var, training, momentum, eps, cudnn_enabled)
}

export const atg_quantized_batch_norm = ({ input, weight, bias, mean, var_, eps, output_scale, output_zero_point }: { input: CTensor; weight?: CTensor; bias?: CTensor; mean: CTensor; var_: CTensor; eps: number; output_scale: number; output_zero_point: number }): CTensor => {
  return addon.atg_quantized_batch_norm(input, weight, bias, mean, var_, eps, output_scale, output_zero_point)
}

export const atg_quantized_batch_norm_out = ({ out, input, weight, bias, mean, var_, eps, output_scale, output_zero_point }: { out: CTensor; input: CTensor; weight?: CTensor; bias?: CTensor; mean: CTensor; var_: CTensor; eps: number; output_scale: number; output_zero_point: number }): CTensor => {
  return addon.atg_quantized_batch_norm_out(out, input, weight, bias, mean, var_, eps, output_scale, output_zero_point)
}

export const atg_bernoulli = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_bernoulli(self)
}

export const atg_bernoulli_p = ({ self, p }: { self: CTensor; p: number }): CTensor => {
  return addon.atg_bernoulli_p(self, p)
}

export const atg_bernoulli_tensor = ({ self, p }: { self: CTensor; p: CTensor }): CTensor => {
  return addon.atg_bernoulli_tensor(self, p)
}

export const atg_bernoulli_ = ({ self, p }: { self: CTensor; p: CTensor }): CTensor => {
  return addon.atg_bernoulli_(self, p)
}

export const atg_bernoulli_float_ = ({ self, p }: { self: CTensor; p: number }): CTensor => {
  return addon.atg_bernoulli_float_(self, p)
}

export const atg_bilinear = ({ input1, input2, weight, bias }: { input1: CTensor; input2: CTensor; weight: CTensor; bias?: CTensor }): CTensor => {
  return addon.atg_bilinear(input1, input2, weight, bias)
}

export const atg_binary_cross_entropy = ({ self, target, weight, reduction }: { self: CTensor; target: CTensor; weight?: CTensor; reduction: number }): CTensor => {
  return addon.atg_binary_cross_entropy(self, target, weight, reduction)
}

export const atg_binary_cross_entropy_out = ({ out, self, target, weight, reduction }: { out: CTensor; self: CTensor; target: CTensor; weight?: CTensor; reduction: number }): CTensor => {
  return addon.atg_binary_cross_entropy_out(out, self, target, weight, reduction)
}

export const atg_binary_cross_entropy_backward = ({ grad_output, self, target, weight, reduction }: { grad_output: CTensor; self: CTensor; target: CTensor; weight?: CTensor; reduction: number }): CTensor => {
  return addon.atg_binary_cross_entropy_backward(grad_output, self, target, weight, reduction)
}

export const atg_binary_cross_entropy_backward_grad_input = ({ grad_input, grad_output, self, target, weight, reduction }: { grad_input: CTensor; grad_output: CTensor; self: CTensor; target: CTensor; weight?: CTensor; reduction: number }): CTensor => {
  return addon.atg_binary_cross_entropy_backward_grad_input(grad_input, grad_output, self, target, weight, reduction)
}

export const atg_binary_cross_entropy_with_logits = ({ self, target, weight, pos_weight, reduction }: { self: CTensor; target: CTensor; weight?: CTensor; pos_weight?: CTensor; reduction: number }): CTensor => {
  return addon.atg_binary_cross_entropy_with_logits(self, target, weight, pos_weight, reduction)
}

export const atg_binary_cross_entropy_with_logits_out = ({ out, self, target, weight, pos_weight, reduction }: { out: CTensor; self: CTensor; target: CTensor; weight?: CTensor; pos_weight?: CTensor; reduction: number }): CTensor => {
  return addon.atg_binary_cross_entropy_with_logits_out(out, self, target, weight, pos_weight, reduction)
}

export const atg_bincount = ({ self, weights, minlength }: { self: CTensor; weights?: CTensor; minlength: number }): CTensor => {
  return addon.atg_bincount(self, weights, minlength)
}

export const atg_bincount_out = ({ out, self, weights, minlength }: { out: CTensor; self: CTensor; weights?: CTensor; minlength: number }): CTensor => {
  return addon.atg_bincount_out(out, self, weights, minlength)
}

export const atg_bitwise_not = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_bitwise_not(self)
}

export const atg_bitwise_not_out = ({ out, self }: { out: CTensor; self: CTensor }): CTensor => {
  return addon.atg_bitwise_not_out(out, self)
}

export const atg_bitwise_not_ = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_bitwise_not_(self)
}

export const atg_copysign = ({ self, other }: { self: CTensor; other: CTensor }): CTensor => {
  return addon.atg_copysign(self, other)
}

export const atg_copysign_scalar = ({ self, other }: { self: CTensor; other: CScalar }): CTensor => {
  return addon.atg_copysign_scalar(self, other)
}

export const atg_copysign_out = ({ out, self, other }: { out: CTensor; self: CTensor; other: CTensor }): CTensor => {
  return addon.atg_copysign_out(out, self, other)
}

export const atg_copysign_scalar_out = ({ out, self, other }: { out: CTensor; self: CTensor; other: CScalar }): CTensor => {
  return addon.atg_copysign_scalar_out(out, self, other)
}

export const atg_copysign_ = ({ self, other }: { self: CTensor; other: CTensor }): CTensor => {
  return addon.atg_copysign_(self, other)
}

export const atg_copysign_scalar_ = ({ self, other }: { self: CTensor; other: CScalar }): CTensor => {
  return addon.atg_copysign_scalar_(self, other)
}

export const atg_logical_not = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_logical_not(self)
}

export const atg_logical_not_out = ({ out, self }: { out: CTensor; self: CTensor }): CTensor => {
  return addon.atg_logical_not_out(out, self)
}

export const atg_logical_not_ = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_logical_not_(self)
}

export const atg_logical_xor = ({ self, other }: { self: CTensor; other: CTensor }): CTensor => {
  return addon.atg_logical_xor(self, other)
}

export const atg_logical_xor_out = ({ out, self, other }: { out: CTensor; self: CTensor; other: CTensor }): CTensor => {
  return addon.atg_logical_xor_out(out, self, other)
}

export const atg_logical_xor_ = ({ self, other }: { self: CTensor; other: CTensor }): CTensor => {
  return addon.atg_logical_xor_(self, other)
}

export const atg_logical_and = ({ self, other }: { self: CTensor; other: CTensor }): CTensor => {
  return addon.atg_logical_and(self, other)
}

export const atg_logical_and_out = ({ out, self, other }: { out: CTensor; self: CTensor; other: CTensor }): CTensor => {
  return addon.atg_logical_and_out(out, self, other)
}

export const atg_logical_and_ = ({ self, other }: { self: CTensor; other: CTensor }): CTensor => {
  return addon.atg_logical_and_(self, other)
}

export const atg_logical_or = ({ self, other }: { self: CTensor; other: CTensor }): CTensor => {
  return addon.atg_logical_or(self, other)
}

export const atg_logical_or_out = ({ out, self, other }: { out: CTensor; self: CTensor; other: CTensor }): CTensor => {
  return addon.atg_logical_or_out(out, self, other)
}

export const atg_logical_or_ = ({ self, other }: { self: CTensor; other: CTensor }): CTensor => {
  return addon.atg_logical_or_(self, other)
}

export const atg_blackman_window = ({ window_length, options }: { window_length: number; options: { device: number, dtype: number } }): CTensor => {
  return addon.atg_blackman_window(window_length, options)
}

export const atg_blackman_window_periodic = ({ window_length, periodic, options }: { window_length: number; periodic: boolean; options: { device: number, dtype: number } }): CTensor => {
  return addon.atg_blackman_window_periodic(window_length, periodic, options)
}

export const atg_blackman_window_out = ({ out, window_length }: { out: CTensor; window_length: number }): CTensor => {
  return addon.atg_blackman_window_out(out, window_length)
}

export const atg_blackman_window_periodic_out = ({ out, window_length, periodic }: { out: CTensor; window_length: number; periodic: boolean }): CTensor => {
  return addon.atg_blackman_window_periodic_out(out, window_length, periodic)
}

export const atg_bmm = ({ self, mat2 }: { self: CTensor; mat2: CTensor }): CTensor => {
  return addon.atg_bmm(self, mat2)
}

export const atg_bmm_out = ({ out, self, mat2 }: { out: CTensor; self: CTensor; mat2: CTensor }): CTensor => {
  return addon.atg_bmm_out(out, self, mat2)
}

export const atg_broadcast_to = ({ self, size }: { self: CTensor; size: number[] }): CTensor => {
  return addon.atg_broadcast_to(self, size)
}

export const atg__sparse_broadcast_to = ({ self, size }: { self: CTensor; size: number[] }): CTensor => {
  return addon.atg__sparse_broadcast_to(self, size)
}

export const atg_cat = ({ tensors, dim }: { tensors: CTensor[]; dim: number }): CTensor => {
  return addon.atg_cat(tensors, dim)
}

export const atg_cat_out = ({ out, tensors, dim }: { out: CTensor; tensors: CTensor[]; dim: number }): CTensor => {
  return addon.atg_cat_out(out, tensors, dim)
}

export const atg_concat = ({ tensors, dim }: { tensors: CTensor[]; dim: number }): CTensor => {
  return addon.atg_concat(tensors, dim)
}

export const atg_concat_out = ({ out, tensors, dim }: { out: CTensor; tensors: CTensor[]; dim: number }): CTensor => {
  return addon.atg_concat_out(out, tensors, dim)
}

export const atg_concatenate = ({ tensors, dim }: { tensors: CTensor[]; dim: number }): CTensor => {
  return addon.atg_concatenate(tensors, dim)
}

export const atg_concatenate_out = ({ out, tensors, dim }: { out: CTensor; tensors: CTensor[]; dim: number }): CTensor => {
  return addon.atg_concatenate_out(out, tensors, dim)
}

export const atg_block_diag = ({ tensors }: { tensors: CTensor[] }): CTensor => {
  return addon.atg_block_diag(tensors)
}

export const atg_block_diag_out = ({ out, tensors }: { out: CTensor; tensors: CTensor[] }): CTensor => {
  return addon.atg_block_diag_out(out, tensors)
}

export const atg_ceil = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_ceil(self)
}

export const atg_ceil_out = ({ out, self }: { out: CTensor; self: CTensor }): CTensor => {
  return addon.atg_ceil_out(out, self)
}

export const atg_ceil_ = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_ceil_(self)
}

export const atg_chain_matmul = ({ matrices }: { matrices: CTensor[] }): CTensor => {
  return addon.atg_chain_matmul(matrices)
}

export const atg_chain_matmul_out = ({ out, matrices }: { out: CTensor; matrices: CTensor[] }): CTensor => {
  return addon.atg_chain_matmul_out(out, matrices)
}

export const atg_clamp = ({ self, min, max }: { self: CTensor; min: CScalar; max: CScalar }): CTensor => {
  return addon.atg_clamp(self, min, max)
}

export const atg_clamp_tensor = ({ self, min, max }: { self: CTensor; min?: CTensor; max?: CTensor }): CTensor => {
  return addon.atg_clamp_tensor(self, min, max)
}

export const atg_clamp_out = ({ out, self, min, max }: { out: CTensor; self: CTensor; min: CScalar; max: CScalar }): CTensor => {
  return addon.atg_clamp_out(out, self, min, max)
}

export const atg_clamp_tensor_out = ({ out, self, min, max }: { out: CTensor; self: CTensor; min?: CTensor; max?: CTensor }): CTensor => {
  return addon.atg_clamp_tensor_out(out, self, min, max)
}

export const atg_clamp_ = ({ self, min, max }: { self: CTensor; min: CScalar; max: CScalar }): CTensor => {
  return addon.atg_clamp_(self, min, max)
}

export const atg_clamp_tensor_ = ({ self, min, max }: { self: CTensor; min?: CTensor; max?: CTensor }): CTensor => {
  return addon.atg_clamp_tensor_(self, min, max)
}

export const atg_clamp_max = ({ self, max }: { self: CTensor; max: CScalar }): CTensor => {
  return addon.atg_clamp_max(self, max)
}

export const atg_clamp_max_tensor = ({ self, max }: { self: CTensor; max: CTensor }): CTensor => {
  return addon.atg_clamp_max_tensor(self, max)
}

export const atg_clamp_max_out = ({ out, self, max }: { out: CTensor; self: CTensor; max: CScalar }): CTensor => {
  return addon.atg_clamp_max_out(out, self, max)
}

export const atg_clamp_max_tensor_out = ({ out, self, max }: { out: CTensor; self: CTensor; max: CTensor }): CTensor => {
  return addon.atg_clamp_max_tensor_out(out, self, max)
}

export const atg_clamp_max_ = ({ self, max }: { self: CTensor; max: CScalar }): CTensor => {
  return addon.atg_clamp_max_(self, max)
}

export const atg_clamp_max_tensor_ = ({ self, max }: { self: CTensor; max: CTensor }): CTensor => {
  return addon.atg_clamp_max_tensor_(self, max)
}

export const atg_clamp_min = ({ self, min }: { self: CTensor; min: CScalar }): CTensor => {
  return addon.atg_clamp_min(self, min)
}

export const atg_clamp_min_tensor = ({ self, min }: { self: CTensor; min: CTensor }): CTensor => {
  return addon.atg_clamp_min_tensor(self, min)
}

export const atg_clamp_min_out = ({ out, self, min }: { out: CTensor; self: CTensor; min: CScalar }): CTensor => {
  return addon.atg_clamp_min_out(out, self, min)
}

export const atg_clamp_min_tensor_out = ({ out, self, min }: { out: CTensor; self: CTensor; min: CTensor }): CTensor => {
  return addon.atg_clamp_min_tensor_out(out, self, min)
}

export const atg_clamp_min_ = ({ self, min }: { self: CTensor; min: CScalar }): CTensor => {
  return addon.atg_clamp_min_(self, min)
}

export const atg_clamp_min_tensor_ = ({ self, min }: { self: CTensor; min: CTensor }): CTensor => {
  return addon.atg_clamp_min_tensor_(self, min)
}

export const atg_clip = ({ self, min, max }: { self: CTensor; min: CScalar; max: CScalar }): CTensor => {
  return addon.atg_clip(self, min, max)
}

export const atg_clip_tensor = ({ self, min, max }: { self: CTensor; min?: CTensor; max?: CTensor }): CTensor => {
  return addon.atg_clip_tensor(self, min, max)
}

export const atg_clip_out = ({ out, self, min, max }: { out: CTensor; self: CTensor; min: CScalar; max: CScalar }): CTensor => {
  return addon.atg_clip_out(out, self, min, max)
}

export const atg_clip_tensor_out = ({ out, self, min, max }: { out: CTensor; self: CTensor; min?: CTensor; max?: CTensor }): CTensor => {
  return addon.atg_clip_tensor_out(out, self, min, max)
}

export const atg_clip_ = ({ self, min, max }: { self: CTensor; min: CScalar; max: CScalar }): CTensor => {
  return addon.atg_clip_(self, min, max)
}

export const atg_clip_tensor_ = ({ self, min, max }: { self: CTensor; min?: CTensor; max?: CTensor }): CTensor => {
  return addon.atg_clip_tensor_(self, min, max)
}

export const atg_cudnn_is_acceptable = ({ self }: { self: CTensor }): boolean => {
  return addon.atg_cudnn_is_acceptable(self)
}

export const atg_complex = ({ real, imag }: { real: CTensor; imag: CTensor }): CTensor => {
  return addon.atg_complex(real, imag)
}

export const atg_complex_out = ({ out, real, imag }: { out: CTensor; real: CTensor; imag: CTensor }): CTensor => {
  return addon.atg_complex_out(out, real, imag)
}

export const atg_polar = ({ abs, angle }: { abs: CTensor; angle: CTensor }): CTensor => {
  return addon.atg_polar(abs, angle)
}

export const atg_polar_out = ({ out, abs, angle }: { out: CTensor; abs: CTensor; angle: CTensor }): CTensor => {
  return addon.atg_polar_out(out, abs, angle)
}

export const atg_constant_pad_nd = ({ self, pad, value }: { self: CTensor; pad: number[]; value: CScalar }): CTensor => {
  return addon.atg_constant_pad_nd(self, pad, value)
}

export const atg_constant_pad_nd_out = ({ out, self, pad, value }: { out: CTensor; self: CTensor; pad: number[]; value: CScalar }): CTensor => {
  return addon.atg_constant_pad_nd_out(out, self, pad, value)
}

export const atg_contiguous = ({ self, memory_format }: { self: CTensor; memory_format: number }): CTensor => {
  return addon.atg_contiguous(self, memory_format)
}

export const atg_convolution = ({ input, weight, bias, stride, padding, dilation, transposed, output_padding, groups }: { input: CTensor; weight: CTensor; bias?: CTensor; stride: number[]; padding: number[]; dilation: number[]; transposed: boolean; output_padding: number[]; groups: number }): CTensor => {
  return addon.atg_convolution(input, weight, bias, stride, padding, dilation, transposed, output_padding, groups)
}

export const atg_convolution_out = ({ out, input, weight, bias, stride, padding, dilation, transposed, output_padding, groups }: { out: CTensor; input: CTensor; weight: CTensor; bias?: CTensor; stride: number[]; padding: number[]; dilation: number[]; transposed: boolean; output_padding: number[]; groups: number }): CTensor => {
  return addon.atg_convolution_out(out, input, weight, bias, stride, padding, dilation, transposed, output_padding, groups)
}

export const atg_convolution_overrideable = ({ input, weight, bias, stride, padding, dilation, transposed, output_padding, groups }: { input: CTensor; weight: CTensor; bias?: CTensor; stride: number[]; padding: number[]; dilation: number[]; transposed: boolean; output_padding: number[]; groups: number }): CTensor => {
  return addon.atg_convolution_overrideable(input, weight, bias, stride, padding, dilation, transposed, output_padding, groups)
}

export const atg_convolution_overrideable_out = ({ out, input, weight, bias, stride, padding, dilation, transposed, output_padding, groups }: { out: CTensor; input: CTensor; weight: CTensor; bias?: CTensor; stride: number[]; padding: number[]; dilation: number[]; transposed: boolean; output_padding: number[]; groups: number }): CTensor => {
  return addon.atg_convolution_overrideable_out(out, input, weight, bias, stride, padding, dilation, transposed, output_padding, groups)
}

export const atg__convolution_deprecated = ({ input, weight, bias, stride, padding, dilation, transposed, output_padding, groups, benchmark, deterministic, cudnn_enabled }: { input: CTensor; weight: CTensor; bias?: CTensor; stride: number[]; padding: number[]; dilation: number[]; transposed: boolean; output_padding: number[]; groups: number; benchmark: boolean; deterministic: boolean; cudnn_enabled: boolean }): CTensor => {
  return addon.atg__convolution_deprecated(input, weight, bias, stride, padding, dilation, transposed, output_padding, groups, benchmark, deterministic, cudnn_enabled)
}

export const atg__convolution = ({ input, weight, bias, stride, padding, dilation, transposed, output_padding, groups, benchmark, deterministic, cudnn_enabled, allow_tf32 }: { input: CTensor; weight: CTensor; bias?: CTensor; stride: number[]; padding: number[]; dilation: number[]; transposed: boolean; output_padding: number[]; groups: number; benchmark: boolean; deterministic: boolean; cudnn_enabled: boolean; allow_tf32: boolean }): CTensor => {
  return addon.atg__convolution(input, weight, bias, stride, padding, dilation, transposed, output_padding, groups, benchmark, deterministic, cudnn_enabled, allow_tf32)
}

export const atg__convolution_out = ({ out, input, weight, bias, stride, padding, dilation, transposed, output_padding, groups, benchmark, deterministic, cudnn_enabled, allow_tf32 }: { out: CTensor; input: CTensor; weight: CTensor; bias?: CTensor; stride: number[]; padding: number[]; dilation: number[]; transposed: boolean; output_padding: number[]; groups: number; benchmark: boolean; deterministic: boolean; cudnn_enabled: boolean; allow_tf32: boolean }): CTensor => {
  return addon.atg__convolution_out(out, input, weight, bias, stride, padding, dilation, transposed, output_padding, groups, benchmark, deterministic, cudnn_enabled, allow_tf32)
}

export const atg__convolution_mode = ({ input, weight, bias, stride, padding, dilation, groups }: { input: CTensor; weight: CTensor; bias?: CTensor; stride: number[]; padding: string; dilation: number[]; groups: number }): CTensor => {
  return addon.atg__convolution_mode(input, weight, bias, stride, padding, dilation, groups)
}

export const atg_conv1d = ({ input, weight, bias, stride, padding, dilation, groups }: { input: CTensor; weight: CTensor; bias?: CTensor; stride: number[]; padding: number[]; dilation: number[]; groups: number }): CTensor => {
  return addon.atg_conv1d(input, weight, bias, stride, padding, dilation, groups)
}

export const atg_conv1d_padding = ({ input, weight, bias, stride, padding, dilation, groups }: { input: CTensor; weight: CTensor; bias?: CTensor; stride: number[]; padding: string; dilation: number[]; groups: number }): CTensor => {
  return addon.atg_conv1d_padding(input, weight, bias, stride, padding, dilation, groups)
}

export const atg_conv2d = ({ input, weight, bias, stride, padding, dilation, groups }: { input: CTensor; weight: CTensor; bias?: CTensor; stride: number[]; padding: number[]; dilation: number[]; groups: number }): CTensor => {
  return addon.atg_conv2d(input, weight, bias, stride, padding, dilation, groups)
}

export const atg_conv2d_padding = ({ input, weight, bias, stride, padding, dilation, groups }: { input: CTensor; weight: CTensor; bias?: CTensor; stride: number[]; padding: string; dilation: number[]; groups: number }): CTensor => {
  return addon.atg_conv2d_padding(input, weight, bias, stride, padding, dilation, groups)
}

export const atg_conv3d = ({ input, weight, bias, stride, padding, dilation, groups }: { input: CTensor; weight: CTensor; bias?: CTensor; stride: number[]; padding: number[]; dilation: number[]; groups: number }): CTensor => {
  return addon.atg_conv3d(input, weight, bias, stride, padding, dilation, groups)
}

export const atg_conv3d_padding = ({ input, weight, bias, stride, padding, dilation, groups }: { input: CTensor; weight: CTensor; bias?: CTensor; stride: number[]; padding: string; dilation: number[]; groups: number }): CTensor => {
  return addon.atg_conv3d_padding(input, weight, bias, stride, padding, dilation, groups)
}

export const atg_conv_tbc = ({ self, weight, bias, pad }: { self: CTensor; weight: CTensor; bias: CTensor; pad: number }): CTensor => {
  return addon.atg_conv_tbc(self, weight, bias, pad)
}

export const atg_conv_tbc_out = ({ out, self, weight, bias, pad }: { out: CTensor; self: CTensor; weight: CTensor; bias: CTensor; pad: number }): CTensor => {
  return addon.atg_conv_tbc_out(out, self, weight, bias, pad)
}

export const atg_conv_tbc_backward = ({ self, input, weight, bias, pad }: { self: CTensor; input: CTensor; weight: CTensor; bias: CTensor; pad: number }): CTensor[] => {
  return addon.atg_conv_tbc_backward(self, input, weight, bias, pad)
}

export const atg_conv_transpose1d = ({ input, weight, bias, stride, padding, output_padding, groups, dilation }: { input: CTensor; weight: CTensor; bias?: CTensor; stride: number[]; padding: number[]; output_padding: number[]; groups: number; dilation: number[] }): CTensor => {
  return addon.atg_conv_transpose1d(input, weight, bias, stride, padding, output_padding, groups, dilation)
}

export const atg_conv_transpose2d = ({ input, weight, bias, stride, padding, output_padding, groups, dilation }: { input: CTensor; weight: CTensor; bias?: CTensor; stride: number[]; padding: number[]; output_padding: number[]; groups: number; dilation: number[] }): CTensor => {
  return addon.atg_conv_transpose2d(input, weight, bias, stride, padding, output_padding, groups, dilation)
}

export const atg_conv_transpose3d = ({ input, weight, bias, stride, padding, output_padding, groups, dilation }: { input: CTensor; weight: CTensor; bias?: CTensor; stride: number[]; padding: number[]; output_padding: number[]; groups: number; dilation: number[] }): CTensor => {
  return addon.atg_conv_transpose3d(input, weight, bias, stride, padding, output_padding, groups, dilation)
}

export const atg__copy_from = ({ self, dst, non_blocking }: { self: CTensor; dst: CTensor; non_blocking: boolean }): CTensor => {
  return addon.atg__copy_from(self, dst, non_blocking)
}

export const atg__copy_from_out = ({ out, self, dst, non_blocking }: { out: CTensor; self: CTensor; dst: CTensor; non_blocking: boolean }): CTensor => {
  return addon.atg__copy_from_out(out, self, dst, non_blocking)
}

export const atg__copy_from_and_resize = ({ self, dst }: { self: CTensor; dst: CTensor }): CTensor => {
  return addon.atg__copy_from_and_resize(self, dst)
}

export const atg__copy_from_and_resize_out = ({ out, self, dst }: { out: CTensor; self: CTensor; dst: CTensor }): CTensor => {
  return addon.atg__copy_from_and_resize_out(out, self, dst)
}

export const atg_cos = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_cos(self)
}

export const atg_cos_out = ({ out, self }: { out: CTensor; self: CTensor }): CTensor => {
  return addon.atg_cos_out(out, self)
}

export const atg_cos_ = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_cos_(self)
}

export const atg_cosh = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_cosh(self)
}

export const atg_cosh_out = ({ out, self }: { out: CTensor; self: CTensor }): CTensor => {
  return addon.atg_cosh_out(out, self)
}

export const atg_cosh_ = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_cosh_(self)
}

export const atg_cosine_embedding_loss = ({ input1, input2, target, margin, reduction }: { input1: CTensor; input2: CTensor; target: CTensor; margin: number; reduction: number }): CTensor => {
  return addon.atg_cosine_embedding_loss(input1, input2, target, margin, reduction)
}

export const atg_count_nonzero_dim_intlist = ({ self, dim }: { self: CTensor; dim: number[] }): CTensor => {
  return addon.atg_count_nonzero_dim_intlist(self, dim)
}

export const atg_count_nonzero = ({ self, dim }: { self: CTensor; dim?: number }): CTensor => {
  return addon.atg_count_nonzero(self, dim)
}

export const atg_count_nonzero_dim_intlist_out = ({ out, self, dim }: { out: CTensor; self: CTensor; dim: number[] }): CTensor => {
  return addon.atg_count_nonzero_dim_intlist_out(out, self, dim)
}

export const atg_count_nonzero_out = ({ out, self, dim }: { out: CTensor; self: CTensor; dim?: number }): CTensor => {
  return addon.atg_count_nonzero_out(out, self, dim)
}

export const atg_cov = ({ self, correction, fweights, aweights }: { self: CTensor; correction: number; fweights?: CTensor; aweights?: CTensor }): CTensor => {
  return addon.atg_cov(self, correction, fweights, aweights)
}

export const atg_corrcoef = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_corrcoef(self)
}

export const atg_cudnn_affine_grid_generator = ({ theta, N, C, H, W }: { theta: CTensor; N: number; C: number; H: number; W: number }): CTensor => {
  return addon.atg_cudnn_affine_grid_generator(theta, N, C, H, W)
}

export const atg_cudnn_affine_grid_generator_out = ({ out, theta, N, C, H, W }: { out: CTensor; theta: CTensor; N: number; C: number; H: number; W: number }): CTensor => {
  return addon.atg_cudnn_affine_grid_generator_out(out, theta, N, C, H, W)
}

export const atg_cudnn_affine_grid_generator_backward = ({ grad, N, C, H, W }: { grad: CTensor; N: number; C: number; H: number; W: number }): CTensor => {
  return addon.atg_cudnn_affine_grid_generator_backward(grad, N, C, H, W)
}

export const atg_cudnn_affine_grid_generator_backward_out = ({ out, grad, N, C, H, W }: { out: CTensor; grad: CTensor; N: number; C: number; H: number; W: number }): CTensor => {
  return addon.atg_cudnn_affine_grid_generator_backward_out(out, grad, N, C, H, W)
}

export const atg_cudnn_batch_norm = ({ input, weight, bias, running_mean, running_var, training, exponential_average_factor, epsilon }: { input: CTensor; weight: CTensor; bias?: CTensor; running_mean?: CTensor; running_var?: CTensor; training: boolean; exponential_average_factor: number; epsilon: number }): CTensor[] => {
  return addon.atg_cudnn_batch_norm(input, weight, bias, running_mean, running_var, training, exponential_average_factor, epsilon)
}

export const atg_cudnn_batch_norm_out = ({ out0, out1, out2, out3, input, weight, bias, running_mean, running_var, training, exponential_average_factor, epsilon }: { out0: CTensor; out1: CTensor; out2: CTensor; out3: CTensor; input: CTensor; weight: CTensor; bias?: CTensor; running_mean?: CTensor; running_var?: CTensor; training: boolean; exponential_average_factor: number; epsilon: number }): CTensor[] => {
  return addon.atg_cudnn_batch_norm_out(out0, out1, out2, out3, input, weight, bias, running_mean, running_var, training, exponential_average_factor, epsilon)
}

export const atg_cudnn_batch_norm_backward = ({ input, grad_output, weight, running_mean, running_var, save_mean, save_var, epsilon, reserveSpace }: { input: CTensor; grad_output: CTensor; weight: CTensor; running_mean?: CTensor; running_var?: CTensor; save_mean?: CTensor; save_var?: CTensor; epsilon: number; reserveSpace: CTensor }): CTensor[] => {
  return addon.atg_cudnn_batch_norm_backward(input, grad_output, weight, running_mean, running_var, save_mean, save_var, epsilon, reserveSpace)
}

export const atg_cudnn_batch_norm_backward_out = ({ out0, out1, out2, input, grad_output, weight, running_mean, running_var, save_mean, save_var, epsilon, reserveSpace }: { out0: CTensor; out1: CTensor; out2: CTensor; input: CTensor; grad_output: CTensor; weight: CTensor; running_mean?: CTensor; running_var?: CTensor; save_mean?: CTensor; save_var?: CTensor; epsilon: number; reserveSpace: CTensor }): CTensor[] => {
  return addon.atg_cudnn_batch_norm_backward_out(out0, out1, out2, input, grad_output, weight, running_mean, running_var, save_mean, save_var, epsilon, reserveSpace)
}

export const atg_cudnn_convolution = ({ self, weight, padding, stride, dilation, groups, benchmark, deterministic, allow_tf32 }: { self: CTensor; weight: CTensor; padding: number[]; stride: number[]; dilation: number[]; groups: number; benchmark: boolean; deterministic: boolean; allow_tf32: boolean }): CTensor => {
  return addon.atg_cudnn_convolution(self, weight, padding, stride, dilation, groups, benchmark, deterministic, allow_tf32)
}

export const atg_cudnn_convolution_out = ({ out, self, weight, padding, stride, dilation, groups, benchmark, deterministic, allow_tf32 }: { out: CTensor; self: CTensor; weight: CTensor; padding: number[]; stride: number[]; dilation: number[]; groups: number; benchmark: boolean; deterministic: boolean; allow_tf32: boolean }): CTensor => {
  return addon.atg_cudnn_convolution_out(out, self, weight, padding, stride, dilation, groups, benchmark, deterministic, allow_tf32)
}

export const atg_cudnn_convolution_transpose = ({ self, weight, padding, output_padding, stride, dilation, groups, benchmark, deterministic, allow_tf32 }: { self: CTensor; weight: CTensor; padding: number[]; output_padding: number[]; stride: number[]; dilation: number[]; groups: number; benchmark: boolean; deterministic: boolean; allow_tf32: boolean }): CTensor => {
  return addon.atg_cudnn_convolution_transpose(self, weight, padding, output_padding, stride, dilation, groups, benchmark, deterministic, allow_tf32)
}

export const atg_cudnn_convolution_transpose_out = ({ out, self, weight, padding, output_padding, stride, dilation, groups, benchmark, deterministic, allow_tf32 }: { out: CTensor; self: CTensor; weight: CTensor; padding: number[]; output_padding: number[]; stride: number[]; dilation: number[]; groups: number; benchmark: boolean; deterministic: boolean; allow_tf32: boolean }): CTensor => {
  return addon.atg_cudnn_convolution_transpose_out(out, self, weight, padding, output_padding, stride, dilation, groups, benchmark, deterministic, allow_tf32)
}

export const atg__mps_convolution_transpose = ({ self, weight, padding, output_padding, stride, dilation, groups }: { self: CTensor; weight: CTensor; padding: number[]; output_padding: number[]; stride: number[]; dilation: number[]; groups: number }): CTensor => {
  return addon.atg__mps_convolution_transpose(self, weight, padding, output_padding, stride, dilation, groups)
}

export const atg__mps_convolution_transpose_out = ({ out, self, weight, padding, output_padding, stride, dilation, groups }: { out: CTensor; self: CTensor; weight: CTensor; padding: number[]; output_padding: number[]; stride: number[]; dilation: number[]; groups: number }): CTensor => {
  return addon.atg__mps_convolution_transpose_out(out, self, weight, padding, output_padding, stride, dilation, groups)
}

export const atg_cudnn_convolution_relu = ({ self, weight, bias, stride, padding, dilation, groups }: { self: CTensor; weight: CTensor; bias?: CTensor; stride: number[]; padding: number[]; dilation: number[]; groups: number }): CTensor => {
  return addon.atg_cudnn_convolution_relu(self, weight, bias, stride, padding, dilation, groups)
}

export const atg_cudnn_convolution_relu_out = ({ out, self, weight, bias, stride, padding, dilation, groups }: { out: CTensor; self: CTensor; weight: CTensor; bias?: CTensor; stride: number[]; padding: number[]; dilation: number[]; groups: number }): CTensor => {
  return addon.atg_cudnn_convolution_relu_out(out, self, weight, bias, stride, padding, dilation, groups)
}

export const atg_cudnn_convolution_add_relu = ({ self, weight, z, alpha, bias, stride, padding, dilation, groups }: { self: CTensor; weight: CTensor; z: CTensor; alpha: CScalar; bias?: CTensor; stride: number[]; padding: number[]; dilation: number[]; groups: number }): CTensor => {
  return addon.atg_cudnn_convolution_add_relu(self, weight, z, alpha, bias, stride, padding, dilation, groups)
}

export const atg_cudnn_convolution_add_relu_out = ({ out, self, weight, z, alpha, bias, stride, padding, dilation, groups }: { out: CTensor; self: CTensor; weight: CTensor; z: CTensor; alpha: CScalar; bias?: CTensor; stride: number[]; padding: number[]; dilation: number[]; groups: number }): CTensor => {
  return addon.atg_cudnn_convolution_add_relu_out(out, self, weight, z, alpha, bias, stride, padding, dilation, groups)
}

export const atg_cudnn_grid_sampler = ({ self, grid }: { self: CTensor; grid: CTensor }): CTensor => {
  return addon.atg_cudnn_grid_sampler(self, grid)
}

export const atg_cudnn_grid_sampler_out = ({ out, self, grid }: { out: CTensor; self: CTensor; grid: CTensor }): CTensor => {
  return addon.atg_cudnn_grid_sampler_out(out, self, grid)
}

export const atg_cudnn_grid_sampler_backward = ({ self, grid, grad_output }: { self: CTensor; grid: CTensor; grad_output: CTensor }): CTensor[] => {
  return addon.atg_cudnn_grid_sampler_backward(self, grid, grad_output)
}

export const atg_cudnn_grid_sampler_backward_out = ({ out0, out1, self, grid, grad_output }: { out0: CTensor; out1: CTensor; self: CTensor; grid: CTensor; grad_output: CTensor }): CTensor[] => {
  return addon.atg_cudnn_grid_sampler_backward_out(out0, out1, self, grid, grad_output)
}

export const atg_cummax = ({ self, dim }: { self: CTensor; dim: number }): CTensor[] => {
  return addon.atg_cummax(self, dim)
}

export const atg_cummax_out = ({ values, indices, self, dim }: { values: CTensor; indices: CTensor; self: CTensor; dim: number }): CTensor[] => {
  return addon.atg_cummax_out(values, indices, self, dim)
}

export const atg_cummin = ({ self, dim }: { self: CTensor; dim: number }): CTensor[] => {
  return addon.atg_cummin(self, dim)
}

export const atg_cummin_out = ({ values, indices, self, dim }: { values: CTensor; indices: CTensor; self: CTensor; dim: number }): CTensor[] => {
  return addon.atg_cummin_out(values, indices, self, dim)
}

export const atg_cummaxmin_backward = ({ grad, input, indices, dim }: { grad: CTensor; input: CTensor; indices: CTensor; dim: number }): CTensor => {
  return addon.atg_cummaxmin_backward(grad, input, indices, dim)
}

export const atg_cumprod = ({ self, dim, dtype }: { self: CTensor; dim: number; dtype: number }): CTensor => {
  return addon.atg_cumprod(self, dim, dtype)
}

export const atg_cumprod_out = ({ out, self, dim, dtype }: { out: CTensor; self: CTensor; dim: number; dtype: number }): CTensor => {
  return addon.atg_cumprod_out(out, self, dim, dtype)
}

export const atg_cumprod_ = ({ self, dim, dtype }: { self: CTensor; dim: number; dtype: number }): CTensor => {
  return addon.atg_cumprod_(self, dim, dtype)
}

export const atg_cumprod_backward = ({ grad, input, dim, output }: { grad: CTensor; input: CTensor; dim: number; output: CTensor }): CTensor => {
  return addon.atg_cumprod_backward(grad, input, dim, output)
}

export const atg_cumsum = ({ self, dim, dtype }: { self: CTensor; dim: number; dtype: number }): CTensor => {
  return addon.atg_cumsum(self, dim, dtype)
}

export const atg_cumsum_out = ({ out, self, dim, dtype }: { out: CTensor; self: CTensor; dim: number; dtype: number }): CTensor => {
  return addon.atg_cumsum_out(out, self, dim, dtype)
}

export const atg_cumsum_ = ({ self, dim, dtype }: { self: CTensor; dim: number; dtype: number }): CTensor => {
  return addon.atg_cumsum_(self, dim, dtype)
}

export const atg_cumulative_trapezoid = ({ y, x, dim }: { y: CTensor; x: CTensor; dim: number }): CTensor => {
  return addon.atg_cumulative_trapezoid(y, x, dim)
}

export const atg_cumulative_trapezoid_dx = ({ y, dx, dim }: { y: CTensor; dx: CScalar; dim: number }): CTensor => {
  return addon.atg_cumulative_trapezoid_dx(y, dx, dim)
}

export const atg_ctc_loss = ({ log_probs, targets, input_lengths, target_lengths, blank, reduction, zero_infinity }: { log_probs: CTensor; targets: CTensor; input_lengths: number[]; target_lengths: number[]; blank: number; reduction: number; zero_infinity: boolean }): CTensor => {
  return addon.atg_ctc_loss(log_probs, targets, input_lengths, target_lengths, blank, reduction, zero_infinity)
}

export const atg_ctc_loss_tensor = ({ log_probs, targets, input_lengths, target_lengths, blank, reduction, zero_infinity }: { log_probs: CTensor; targets: CTensor; input_lengths: CTensor; target_lengths: CTensor; blank: number; reduction: number; zero_infinity: boolean }): CTensor => {
  return addon.atg_ctc_loss_tensor(log_probs, targets, input_lengths, target_lengths, blank, reduction, zero_infinity)
}

export const atg__ctc_loss = ({ log_probs, targets, input_lengths, target_lengths, blank, zero_infinity }: { log_probs: CTensor; targets: CTensor; input_lengths: number[]; target_lengths: number[]; blank: number; zero_infinity: boolean }): CTensor[] => {
  return addon.atg__ctc_loss(log_probs, targets, input_lengths, target_lengths, blank, zero_infinity)
}

export const atg__ctc_loss_tensor = ({ log_probs, targets, input_lengths, target_lengths, blank, zero_infinity }: { log_probs: CTensor; targets: CTensor; input_lengths: CTensor; target_lengths: CTensor; blank: number; zero_infinity: boolean }): CTensor[] => {
  return addon.atg__ctc_loss_tensor(log_probs, targets, input_lengths, target_lengths, blank, zero_infinity)
}

export const atg__ctc_loss_out = ({ out0, out1, log_probs, targets, input_lengths, target_lengths, blank, zero_infinity }: { out0: CTensor; out1: CTensor; log_probs: CTensor; targets: CTensor; input_lengths: number[]; target_lengths: number[]; blank: number; zero_infinity: boolean }): CTensor[] => {
  return addon.atg__ctc_loss_out(out0, out1, log_probs, targets, input_lengths, target_lengths, blank, zero_infinity)
}

export const atg__ctc_loss_tensor_out = ({ out0, out1, log_probs, targets, input_lengths, target_lengths, blank, zero_infinity }: { out0: CTensor; out1: CTensor; log_probs: CTensor; targets: CTensor; input_lengths: CTensor; target_lengths: CTensor; blank: number; zero_infinity: boolean }): CTensor[] => {
  return addon.atg__ctc_loss_tensor_out(out0, out1, log_probs, targets, input_lengths, target_lengths, blank, zero_infinity)
}

export const atg__ctc_loss_backward = ({ grad, log_probs, targets, input_lengths, target_lengths, neg_log_likelihood, log_alpha, blank, zero_infinity }: { grad: CTensor; log_probs: CTensor; targets: CTensor; input_lengths: number[]; target_lengths: number[]; neg_log_likelihood: CTensor; log_alpha: CTensor; blank: number; zero_infinity: boolean }): CTensor => {
  return addon.atg__ctc_loss_backward(grad, log_probs, targets, input_lengths, target_lengths, neg_log_likelihood, log_alpha, blank, zero_infinity)
}

export const atg__ctc_loss_backward_tensor = ({ grad, log_probs, targets, input_lengths, target_lengths, neg_log_likelihood, log_alpha, blank, zero_infinity }: { grad: CTensor; log_probs: CTensor; targets: CTensor; input_lengths: CTensor; target_lengths: CTensor; neg_log_likelihood: CTensor; log_alpha: CTensor; blank: number; zero_infinity: boolean }): CTensor => {
  return addon.atg__ctc_loss_backward_tensor(grad, log_probs, targets, input_lengths, target_lengths, neg_log_likelihood, log_alpha, blank, zero_infinity)
}

export const atg__ctc_loss_backward_out = ({ out, grad, log_probs, targets, input_lengths, target_lengths, neg_log_likelihood, log_alpha, blank, zero_infinity }: { out: CTensor; grad: CTensor; log_probs: CTensor; targets: CTensor; input_lengths: number[]; target_lengths: number[]; neg_log_likelihood: CTensor; log_alpha: CTensor; blank: number; zero_infinity: boolean }): CTensor => {
  return addon.atg__ctc_loss_backward_out(out, grad, log_probs, targets, input_lengths, target_lengths, neg_log_likelihood, log_alpha, blank, zero_infinity)
}

export const atg_diag_embed = ({ self, offset, dim1, dim2 }: { self: CTensor; offset: number; dim1: number; dim2: number }): CTensor => {
  return addon.atg_diag_embed(self, offset, dim1, dim2)
}

export const atg_diag_embed_out = ({ out, self, offset, dim1, dim2 }: { out: CTensor; self: CTensor; offset: number; dim1: number; dim2: number }): CTensor => {
  return addon.atg_diag_embed_out(out, self, offset, dim1, dim2)
}

export const atg_diagflat = ({ self, offset }: { self: CTensor; offset: number }): CTensor => {
  return addon.atg_diagflat(self, offset)
}

export const atg_diagonal = ({ self, offset, dim1, dim2 }: { self: CTensor; offset: number; dim1: number; dim2: number }): CTensor => {
  return addon.atg_diagonal(self, offset, dim1, dim2)
}

export const atg_linalg_diagonal = ({ A, offset, dim1, dim2 }: { A: CTensor; offset: number; dim1: number; dim2: number }): CTensor => {
  return addon.atg_linalg_diagonal(A, offset, dim1, dim2)
}

export const atg_diagonal_backward = ({ grad_output, input_sizes, offset, dim1, dim2 }: { grad_output: CTensor; input_sizes: number[]; offset: number; dim1: number; dim2: number }): CTensor => {
  return addon.atg_diagonal_backward(grad_output, input_sizes, offset, dim1, dim2)
}

export const atg_diagonal_backward_out = ({ out, grad_output, input_sizes, offset, dim1, dim2 }: { out: CTensor; grad_output: CTensor; input_sizes: number[]; offset: number; dim1: number; dim2: number }): CTensor => {
  return addon.atg_diagonal_backward_out(out, grad_output, input_sizes, offset, dim1, dim2)
}

export const atg_fill_diagonal_ = ({ self, fill_value, wrap }: { self: CTensor; fill_value: CScalar; wrap: boolean }): CTensor => {
  return addon.atg_fill_diagonal_(self, fill_value, wrap)
}

export const atg_diff = ({ self, n, dim, prepend, append }: { self: CTensor; n: number; dim: number; prepend?: CTensor; append?: CTensor }): CTensor => {
  return addon.atg_diff(self, n, dim, prepend, append)
}

export const atg_diff_out = ({ out, self, n, dim, prepend, append }: { out: CTensor; self: CTensor; n: number; dim: number; prepend?: CTensor; append?: CTensor }): CTensor => {
  return addon.atg_diff_out(out, self, n, dim, prepend, append)
}

export const atg_div = ({ self, other }: { self: CTensor; other: CTensor }): CTensor => {
  return addon.atg_div(self, other)
}

export const atg_div_scalar = ({ self, other }: { self: CTensor; other: CScalar }): CTensor => {
  return addon.atg_div_scalar(self, other)
}

export const atg_div_tensor_mode = ({ self, other, rounding_mode }: { self: CTensor; other: CTensor; rounding_mode: string }): CTensor => {
  return addon.atg_div_tensor_mode(self, other, rounding_mode)
}

export const atg_div_scalar_mode = ({ self, other, rounding_mode }: { self: CTensor; other: CScalar; rounding_mode: string }): CTensor => {
  return addon.atg_div_scalar_mode(self, other, rounding_mode)
}

export const atg_div_out = ({ out, self, other }: { out: CTensor; self: CTensor; other: CTensor }): CTensor => {
  return addon.atg_div_out(out, self, other)
}

export const atg_div_scalar_out = ({ out, self, other }: { out: CTensor; self: CTensor; other: CScalar }): CTensor => {
  return addon.atg_div_scalar_out(out, self, other)
}

export const atg_div_out_mode = ({ out, self, other, rounding_mode }: { out: CTensor; self: CTensor; other: CTensor; rounding_mode: string }): CTensor => {
  return addon.atg_div_out_mode(out, self, other, rounding_mode)
}

export const atg_div_scalar_mode_out = ({ out, self, other, rounding_mode }: { out: CTensor; self: CTensor; other: CScalar; rounding_mode: string }): CTensor => {
  return addon.atg_div_scalar_mode_out(out, self, other, rounding_mode)
}

export const atg_div_ = ({ self, other }: { self: CTensor; other: CTensor }): CTensor => {
  return addon.atg_div_(self, other)
}

export const atg_div_scalar_ = ({ self, other }: { self: CTensor; other: CScalar }): CTensor => {
  return addon.atg_div_scalar_(self, other)
}

export const atg_div_tensor_mode_ = ({ self, other, rounding_mode }: { self: CTensor; other: CTensor; rounding_mode: string }): CTensor => {
  return addon.atg_div_tensor_mode_(self, other, rounding_mode)
}

export const atg_div_scalar_mode_ = ({ self, other, rounding_mode }: { self: CTensor; other: CScalar; rounding_mode: string }): CTensor => {
  return addon.atg_div_scalar_mode_(self, other, rounding_mode)
}

export const atg_divide = ({ self, other }: { self: CTensor; other: CTensor }): CTensor => {
  return addon.atg_divide(self, other)
}

export const atg_divide_scalar = ({ self, other }: { self: CTensor; other: CScalar }): CTensor => {
  return addon.atg_divide_scalar(self, other)
}

export const atg_divide_tensor_mode = ({ self, other, rounding_mode }: { self: CTensor; other: CTensor; rounding_mode: string }): CTensor => {
  return addon.atg_divide_tensor_mode(self, other, rounding_mode)
}

export const atg_divide_scalar_mode = ({ self, other, rounding_mode }: { self: CTensor; other: CScalar; rounding_mode: string }): CTensor => {
  return addon.atg_divide_scalar_mode(self, other, rounding_mode)
}

export const atg_divide_out = ({ out, self, other }: { out: CTensor; self: CTensor; other: CTensor }): CTensor => {
  return addon.atg_divide_out(out, self, other)
}

export const atg_divide_out_mode = ({ out, self, other, rounding_mode }: { out: CTensor; self: CTensor; other: CTensor; rounding_mode: string }): CTensor => {
  return addon.atg_divide_out_mode(out, self, other, rounding_mode)
}

export const atg_divide_ = ({ self, other }: { self: CTensor; other: CTensor }): CTensor => {
  return addon.atg_divide_(self, other)
}

export const atg_divide_scalar_ = ({ self, other }: { self: CTensor; other: CScalar }): CTensor => {
  return addon.atg_divide_scalar_(self, other)
}

export const atg_divide_tensor_mode_ = ({ self, other, rounding_mode }: { self: CTensor; other: CTensor; rounding_mode: string }): CTensor => {
  return addon.atg_divide_tensor_mode_(self, other, rounding_mode)
}

export const atg_divide_scalar_mode_ = ({ self, other, rounding_mode }: { self: CTensor; other: CScalar; rounding_mode: string }): CTensor => {
  return addon.atg_divide_scalar_mode_(self, other, rounding_mode)
}

export const atg_true_divide = ({ self, other }: { self: CTensor; other: CTensor }): CTensor => {
  return addon.atg_true_divide(self, other)
}

export const atg_true_divide_scalar = ({ self, other }: { self: CTensor; other: CScalar }): CTensor => {
  return addon.atg_true_divide_scalar(self, other)
}

export const atg_true_divide_out = ({ out, self, other }: { out: CTensor; self: CTensor; other: CTensor }): CTensor => {
  return addon.atg_true_divide_out(out, self, other)
}

export const atg_true_divide_ = ({ self, other }: { self: CTensor; other: CTensor }): CTensor => {
  return addon.atg_true_divide_(self, other)
}

export const atg_true_divide_scalar_ = ({ self, other }: { self: CTensor; other: CScalar }): CTensor => {
  return addon.atg_true_divide_scalar_(self, other)
}

export const atg_dot = ({ self, tensor }: { self: CTensor; tensor: CTensor }): CTensor => {
  return addon.atg_dot(self, tensor)
}

export const atg_dot_out = ({ out, self, tensor }: { out: CTensor; self: CTensor; tensor: CTensor }): CTensor => {
  return addon.atg_dot_out(out, self, tensor)
}

export const atg_vdot = ({ self, other }: { self: CTensor; other: CTensor }): CTensor => {
  return addon.atg_vdot(self, other)
}

export const atg_vdot_out = ({ out, self, other }: { out: CTensor; self: CTensor; other: CTensor }): CTensor => {
  return addon.atg_vdot_out(out, self, other)
}

export const atg_einsum = ({ equation, tensors, path }: { equation: string; tensors: CTensor[]; path?: number[] }): CTensor => {
  return addon.atg_einsum(equation, tensors, path)
}

export const atg_embedding = ({ weight, indices, padding_idx, scale_grad_by_freq, sparse }: { weight: CTensor; indices: CTensor; padding_idx: number; scale_grad_by_freq: boolean; sparse: boolean }): CTensor => {
  return addon.atg_embedding(weight, indices, padding_idx, scale_grad_by_freq, sparse)
}

export const atg_embedding_out = ({ out, weight, indices, padding_idx, scale_grad_by_freq, sparse }: { out: CTensor; weight: CTensor; indices: CTensor; padding_idx: number; scale_grad_by_freq: boolean; sparse: boolean }): CTensor => {
  return addon.atg_embedding_out(out, weight, indices, padding_idx, scale_grad_by_freq, sparse)
}

export const atg_embedding_backward = ({ grad, indices, num_weights, padding_idx, scale_grad_by_freq, sparse }: { grad: CTensor; indices: CTensor; num_weights: number; padding_idx: number; scale_grad_by_freq: boolean; sparse: boolean }): CTensor => {
  return addon.atg_embedding_backward(grad, indices, num_weights, padding_idx, scale_grad_by_freq, sparse)
}

export const atg_embedding_dense_backward = ({ grad_output, indices, num_weights, padding_idx, scale_grad_by_freq }: { grad_output: CTensor; indices: CTensor; num_weights: number; padding_idx: number; scale_grad_by_freq: boolean }): CTensor => {
  return addon.atg_embedding_dense_backward(grad_output, indices, num_weights, padding_idx, scale_grad_by_freq)
}

export const atg_embedding_dense_backward_out = ({ out, grad_output, indices, num_weights, padding_idx, scale_grad_by_freq }: { out: CTensor; grad_output: CTensor; indices: CTensor; num_weights: number; padding_idx: number; scale_grad_by_freq: boolean }): CTensor => {
  return addon.atg_embedding_dense_backward_out(out, grad_output, indices, num_weights, padding_idx, scale_grad_by_freq)
}

export const atg_embedding_renorm_ = ({ self, indices, max_norm, norm_type }: { self: CTensor; indices: CTensor; max_norm: number; norm_type: number }): CTensor => {
  return addon.atg_embedding_renorm_(self, indices, max_norm, norm_type)
}

export const atg_embedding_sparse_backward = ({ grad, indices, num_weights, padding_idx, scale_grad_by_freq }: { grad: CTensor; indices: CTensor; num_weights: number; padding_idx: number; scale_grad_by_freq: boolean }): CTensor => {
  return addon.atg_embedding_sparse_backward(grad, indices, num_weights, padding_idx, scale_grad_by_freq)
}

export const atg__embedding_bag_forward_only = ({ weight, indices, offsets, scale_grad_by_freq, mode, sparse, per_sample_weights, include_last_offset, padding_idx }: { weight: CTensor; indices: CTensor; offsets: CTensor; scale_grad_by_freq: boolean; mode: number; sparse: boolean; per_sample_weights?: CTensor; include_last_offset: boolean; padding_idx: number }): CTensor[] => {
  return addon.atg__embedding_bag_forward_only(weight, indices, offsets, scale_grad_by_freq, mode, sparse, per_sample_weights, include_last_offset, padding_idx)
}

export const atg__embedding_bag_forward_only_out = ({ out0, out1, out2, out3, weight, indices, offsets, scale_grad_by_freq, mode, sparse, per_sample_weights, include_last_offset, padding_idx }: { out0: CTensor; out1: CTensor; out2: CTensor; out3: CTensor; weight: CTensor; indices: CTensor; offsets: CTensor; scale_grad_by_freq: boolean; mode: number; sparse: boolean; per_sample_weights?: CTensor; include_last_offset: boolean; padding_idx: number }): CTensor[] => {
  return addon.atg__embedding_bag_forward_only_out(out0, out1, out2, out3, weight, indices, offsets, scale_grad_by_freq, mode, sparse, per_sample_weights, include_last_offset, padding_idx)
}

export const atg__rowwise_prune = ({ weight, mask, compressed_indices_dtype }: { weight: CTensor; mask: CTensor; compressed_indices_dtype: number }): CTensor[] => {
  return addon.atg__rowwise_prune(weight, mask, compressed_indices_dtype)
}

export const atg_row_stack = ({ tensors }: { tensors: CTensor[] }): CTensor => {
  return addon.atg_row_stack(tensors)
}

export const atg_row_stack_out = ({ out, tensors }: { out: CTensor; tensors: CTensor[] }): CTensor => {
  return addon.atg_row_stack_out(out, tensors)
}

export const atg_embedding_bag = ({ weight, indices, offsets, scale_grad_by_freq, mode, sparse, per_sample_weights, include_last_offset }: { weight: CTensor; indices: CTensor; offsets: CTensor; scale_grad_by_freq: boolean; mode: number; sparse: boolean; per_sample_weights?: CTensor; include_last_offset: boolean }): CTensor[] => {
  return addon.atg_embedding_bag(weight, indices, offsets, scale_grad_by_freq, mode, sparse, per_sample_weights, include_last_offset)
}

export const atg_embedding_bag_padding_idx = ({ weight, indices, offsets, scale_grad_by_freq, mode, sparse, per_sample_weights, include_last_offset, padding_idx }: { weight: CTensor; indices: CTensor; offsets: CTensor; scale_grad_by_freq: boolean; mode: number; sparse: boolean; per_sample_weights?: CTensor; include_last_offset: boolean; padding_idx?: number }): CTensor[] => {
  return addon.atg_embedding_bag_padding_idx(weight, indices, offsets, scale_grad_by_freq, mode, sparse, per_sample_weights, include_last_offset, padding_idx)
}

export const atg__embedding_bag = ({ weight, indices, offsets, scale_grad_by_freq, mode, sparse, per_sample_weights, include_last_offset, padding_idx }: { weight: CTensor; indices: CTensor; offsets: CTensor; scale_grad_by_freq: boolean; mode: number; sparse: boolean; per_sample_weights?: CTensor; include_last_offset: boolean; padding_idx: number }): CTensor[] => {
  return addon.atg__embedding_bag(weight, indices, offsets, scale_grad_by_freq, mode, sparse, per_sample_weights, include_last_offset, padding_idx)
}

export const atg__embedding_bag_out = ({ out0, out1, out2, out3, weight, indices, offsets, scale_grad_by_freq, mode, sparse, per_sample_weights, include_last_offset, padding_idx }: { out0: CTensor; out1: CTensor; out2: CTensor; out3: CTensor; weight: CTensor; indices: CTensor; offsets: CTensor; scale_grad_by_freq: boolean; mode: number; sparse: boolean; per_sample_weights?: CTensor; include_last_offset: boolean; padding_idx: number }): CTensor[] => {
  return addon.atg__embedding_bag_out(out0, out1, out2, out3, weight, indices, offsets, scale_grad_by_freq, mode, sparse, per_sample_weights, include_last_offset, padding_idx)
}

export const atg__embedding_bag_backward = ({ grad, indices, offsets, offset2bag, bag_size, maximum_indices, num_weights, scale_grad_by_freq, mode, sparse, per_sample_weights, padding_idx }: { grad: CTensor; indices: CTensor; offsets: CTensor; offset2bag: CTensor; bag_size: CTensor; maximum_indices: CTensor; num_weights: number; scale_grad_by_freq: boolean; mode: number; sparse: boolean; per_sample_weights?: CTensor; padding_idx: number }): CTensor => {
  return addon.atg__embedding_bag_backward(grad, indices, offsets, offset2bag, bag_size, maximum_indices, num_weights, scale_grad_by_freq, mode, sparse, per_sample_weights, padding_idx)
}

export const atg__embedding_bag_sparse_backward = ({ grad, indices, offsets, offset2bag, bag_size, num_weights, scale_grad_by_freq, mode, per_sample_weights, padding_idx }: { grad: CTensor; indices: CTensor; offsets: CTensor; offset2bag: CTensor; bag_size: CTensor; num_weights: number; scale_grad_by_freq: boolean; mode: number; per_sample_weights?: CTensor; padding_idx: number }): CTensor => {
  return addon.atg__embedding_bag_sparse_backward(grad, indices, offsets, offset2bag, bag_size, num_weights, scale_grad_by_freq, mode, per_sample_weights, padding_idx)
}

export const atg__embedding_bag_dense_backward = ({ grad, indices, offset2bag, bag_size, maximum_indices, num_weights, scale_grad_by_freq, mode, per_sample_weights, padding_idx }: { grad: CTensor; indices: CTensor; offset2bag: CTensor; bag_size: CTensor; maximum_indices: CTensor; num_weights: number; scale_grad_by_freq: boolean; mode: number; per_sample_weights?: CTensor; padding_idx: number }): CTensor => {
  return addon.atg__embedding_bag_dense_backward(grad, indices, offset2bag, bag_size, maximum_indices, num_weights, scale_grad_by_freq, mode, per_sample_weights, padding_idx)
}

export const atg__embedding_bag_dense_backward_out = ({ out, grad, indices, offset2bag, bag_size, maximum_indices, num_weights, scale_grad_by_freq, mode, per_sample_weights, padding_idx }: { out: CTensor; grad: CTensor; indices: CTensor; offset2bag: CTensor; bag_size: CTensor; maximum_indices: CTensor; num_weights: number; scale_grad_by_freq: boolean; mode: number; per_sample_weights?: CTensor; padding_idx: number }): CTensor => {
  return addon.atg__embedding_bag_dense_backward_out(out, grad, indices, offset2bag, bag_size, maximum_indices, num_weights, scale_grad_by_freq, mode, per_sample_weights, padding_idx)
}

export const atg__embedding_bag_per_sample_weights_backward = ({ grad, weight, indices, offsets, offset2bag, mode, padding_idx }: { grad: CTensor; weight: CTensor; indices: CTensor; offsets: CTensor; offset2bag: CTensor; mode: number; padding_idx: number }): CTensor => {
  return addon.atg__embedding_bag_per_sample_weights_backward(grad, weight, indices, offsets, offset2bag, mode, padding_idx)
}

export const atg__embedding_bag_per_sample_weights_backward_out = ({ out, grad, weight, indices, offsets, offset2bag, mode, padding_idx }: { out: CTensor; grad: CTensor; weight: CTensor; indices: CTensor; offsets: CTensor; offset2bag: CTensor; mode: number; padding_idx: number }): CTensor => {
  return addon.atg__embedding_bag_per_sample_weights_backward_out(out, grad, weight, indices, offsets, offset2bag, mode, padding_idx)
}

export const atg_empty = ({ size, options, memory_format }: { size: number[]; options: { device: number, dtype: number }; memory_format: number }): CTensor => {
  return addon.atg_empty(size, options, memory_format)
}

export const atg_empty_out = ({ out, size, memory_format }: { out: CTensor; size: number[]; memory_format: number }): CTensor => {
  return addon.atg_empty_out(out, size, memory_format)
}

export const atg_new_empty = ({ self, size, options }: { self: CTensor; size: number[]; options: { device: number, dtype: number } }): CTensor => {
  return addon.atg_new_empty(self, size, options)
}

export const atg_new_empty_out = ({ out, self, size }: { out: CTensor; self: CTensor; size: number[] }): CTensor => {
  return addon.atg_new_empty_out(out, self, size)
}

export const atg_new_empty_strided = ({ self, size, stride, options }: { self: CTensor; size: number[]; stride: number[]; options: { device: number, dtype: number } }): CTensor => {
  return addon.atg_new_empty_strided(self, size, stride, options)
}

export const atg_new_empty_strided_out = ({ out, self, size, stride }: { out: CTensor; self: CTensor; size: number[]; stride: number[] }): CTensor => {
  return addon.atg_new_empty_strided_out(out, self, size, stride)
}

export const atg_new_full = ({ self, size, fill_value, options }: { self: CTensor; size: number[]; fill_value: CScalar; options: { device: number, dtype: number } }): CTensor => {
  return addon.atg_new_full(self, size, fill_value, options)
}

export const atg_new_full_out = ({ out, self, size, fill_value }: { out: CTensor; self: CTensor; size: number[]; fill_value: CScalar }): CTensor => {
  return addon.atg_new_full_out(out, self, size, fill_value)
}

export const atg_new_zeros = ({ self, size, options }: { self: CTensor; size: number[]; options: { device: number, dtype: number } }): CTensor => {
  return addon.atg_new_zeros(self, size, options)
}

export const atg_new_zeros_out = ({ out, self, size }: { out: CTensor; self: CTensor; size: number[] }): CTensor => {
  return addon.atg_new_zeros_out(out, self, size)
}

export const atg_new_ones = ({ self, size, options }: { self: CTensor; size: number[]; options: { device: number, dtype: number } }): CTensor => {
  return addon.atg_new_ones(self, size, options)
}

export const atg_new_ones_out = ({ out, self, size }: { out: CTensor; self: CTensor; size: number[] }): CTensor => {
  return addon.atg_new_ones_out(out, self, size)
}

export const atg__empty_affine_quantized = ({ size, options, scale, zero_point, memory_format }: { size: number[]; options: { device: number, dtype: number }; scale: number; zero_point: number; memory_format: number }): CTensor => {
  return addon.atg__empty_affine_quantized(size, options, scale, zero_point, memory_format)
}

export const atg__empty_affine_quantized_out = ({ out, size, scale, zero_point, memory_format }: { out: CTensor; size: number[]; scale: number; zero_point: number; memory_format: number }): CTensor => {
  return addon.atg__empty_affine_quantized_out(out, size, scale, zero_point, memory_format)
}

export const atg__empty_per_channel_affine_quantized = ({ size, scales, zero_points, axis, options, memory_format }: { size: number[]; scales: CTensor; zero_points: CTensor; axis: number; options: { device: number, dtype: number }; memory_format: number }): CTensor => {
  return addon.atg__empty_per_channel_affine_quantized(size, scales, zero_points, axis, options, memory_format)
}

export const atg__empty_per_channel_affine_quantized_out = ({ out, size, scales, zero_points, axis, memory_format }: { out: CTensor; size: number[]; scales: CTensor; zero_points: CTensor; axis: number; memory_format: number }): CTensor => {
  return addon.atg__empty_per_channel_affine_quantized_out(out, size, scales, zero_points, axis, memory_format)
}

export const atg_resize_ = ({ self, size, memory_format }: { self: CTensor; size: number[]; memory_format: number }): CTensor => {
  return addon.atg_resize_(self, size, memory_format)
}

export const atg__resize_output_ = ({ self, size, device }: { self: CTensor; size: number[]; device: number }): CTensor => {
  return addon.atg__resize_output_(self, size, device)
}

export const atg_empty_quantized = ({ size, qtensor, options, memory_format }: { size: number[]; qtensor: CTensor; options: { device: number, dtype: number }; memory_format: number }): CTensor => {
  return addon.atg_empty_quantized(size, qtensor, options, memory_format)
}

export const atg_empty_quantized_out = ({ out, size, qtensor, memory_format }: { out: CTensor; size: number[]; qtensor: CTensor; memory_format: number }): CTensor => {
  return addon.atg_empty_quantized_out(out, size, qtensor, memory_format)
}

export const atg_empty_like = ({ self, options, memory_format }: { self: CTensor; options: { device: number, dtype: number }; memory_format: number }): CTensor => {
  return addon.atg_empty_like(self, options, memory_format)
}

export const atg_empty_like_out = ({ out, self, memory_format }: { out: CTensor; self: CTensor; memory_format: number }): CTensor => {
  return addon.atg_empty_like_out(out, self, memory_format)
}

export const atg_empty_strided = ({ size, stride, options }: { size: number[]; stride: number[]; options: { device: number, dtype: number } }): CTensor => {
  return addon.atg_empty_strided(size, stride, options)
}

export const atg_empty_strided_out = ({ out, size, stride }: { out: CTensor; size: number[]; stride: number[] }): CTensor => {
  return addon.atg_empty_strided_out(out, size, stride)
}

export const atg_erf = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_erf(self)
}

export const atg_erf_out = ({ out, self }: { out: CTensor; self: CTensor }): CTensor => {
  return addon.atg_erf_out(out, self)
}

export const atg_erf_ = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_erf_(self)
}

export const atg_erfc = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_erfc(self)
}

export const atg_erfc_out = ({ out, self }: { out: CTensor; self: CTensor }): CTensor => {
  return addon.atg_erfc_out(out, self)
}

export const atg_erfc_ = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_erfc_(self)
}

export const atg_exp = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_exp(self)
}

export const atg_exp_out = ({ out, self }: { out: CTensor; self: CTensor }): CTensor => {
  return addon.atg_exp_out(out, self)
}

export const atg_exp_ = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_exp_(self)
}

export const atg_exp2 = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_exp2(self)
}

export const atg_exp2_out = ({ out, self }: { out: CTensor; self: CTensor }): CTensor => {
  return addon.atg_exp2_out(out, self)
}

export const atg_exp2_ = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_exp2_(self)
}

export const atg_expm1 = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_expm1(self)
}

export const atg_expm1_out = ({ out, self }: { out: CTensor; self: CTensor }): CTensor => {
  return addon.atg_expm1_out(out, self)
}

export const atg_expm1_ = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_expm1_(self)
}

export const atg_expand = ({ self, size, implicit }: { self: CTensor; size: number[]; implicit: boolean }): CTensor => {
  return addon.atg_expand(self, size, implicit)
}

export const atg_expand_as = ({ self, other }: { self: CTensor; other: CTensor }): CTensor => {
  return addon.atg_expand_as(self, other)
}

export const atg_eye = ({ n, options }: { n: number; options: { device: number, dtype: number } }): CTensor => {
  return addon.atg_eye(n, options)
}

export const atg_eye_m = ({ n, m, options }: { n: number; m: number; options: { device: number, dtype: number } }): CTensor => {
  return addon.atg_eye_m(n, m, options)
}

export const atg_eye_out = ({ out, n }: { out: CTensor; n: number }): CTensor => {
  return addon.atg_eye_out(out, n)
}

export const atg_eye_m_out = ({ out, n, m }: { out: CTensor; n: number; m: number }): CTensor => {
  return addon.atg_eye_m_out(out, n, m)
}

export const atg_flatten = ({ self, start_dim, end_dim }: { self: CTensor; start_dim: number; end_dim: number }): CTensor => {
  return addon.atg_flatten(self, start_dim, end_dim)
}

export const atg_unflatten = ({ self, dim, sizes }: { self: CTensor; dim: number; sizes: number[] }): CTensor => {
  return addon.atg_unflatten(self, dim, sizes)
}

export const atg_fill = ({ self, value }: { self: CTensor; value: CScalar }): CTensor => {
  return addon.atg_fill(self, value)
}

export const atg_fill_tensor = ({ self, value }: { self: CTensor; value: CTensor }): CTensor => {
  return addon.atg_fill_tensor(self, value)
}

export const atg_fill_scalar_out = ({ out, self, value }: { out: CTensor; self: CTensor; value: CScalar }): CTensor => {
  return addon.atg_fill_scalar_out(out, self, value)
}

export const atg_fill_tensor_out = ({ out, self, value }: { out: CTensor; self: CTensor; value: CTensor }): CTensor => {
  return addon.atg_fill_tensor_out(out, self, value)
}

export const atg_fill_ = ({ self, value }: { self: CTensor; value: CScalar }): CTensor => {
  return addon.atg_fill_(self, value)
}

export const atg_fill_tensor_ = ({ self, value }: { self: CTensor; value: CTensor }): CTensor => {
  return addon.atg_fill_tensor_(self, value)
}

export const atg_floor = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_floor(self)
}

export const atg_floor_out = ({ out, self }: { out: CTensor; self: CTensor }): CTensor => {
  return addon.atg_floor_out(out, self)
}

export const atg_floor_ = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_floor_(self)
}

export const atg_floor_divide = ({ self, other }: { self: CTensor; other: CTensor }): CTensor => {
  return addon.atg_floor_divide(self, other)
}

export const atg_floor_divide_scalar = ({ self, other }: { self: CTensor; other: CScalar }): CTensor => {
  return addon.atg_floor_divide_scalar(self, other)
}

export const atg_floor_divide_out = ({ out, self, other }: { out: CTensor; self: CTensor; other: CTensor }): CTensor => {
  return addon.atg_floor_divide_out(out, self, other)
}

export const atg_floor_divide_ = ({ self, other }: { self: CTensor; other: CTensor }): CTensor => {
  return addon.atg_floor_divide_(self, other)
}

export const atg_floor_divide_scalar_ = ({ self, other }: { self: CTensor; other: CScalar }): CTensor => {
  return addon.atg_floor_divide_scalar_(self, other)
}

export const atg_frac = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_frac(self)
}

export const atg_frac_out = ({ out, self }: { out: CTensor; self: CTensor }): CTensor => {
  return addon.atg_frac_out(out, self)
}

export const atg_frac_ = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_frac_(self)
}

export const atg_full = ({ size, fill_value, options }: { size: number[]; fill_value: CScalar; options: { device: number, dtype: number } }): CTensor => {
  return addon.atg_full(size, fill_value, options)
}

export const atg_full_out = ({ out, size, fill_value }: { out: CTensor; size: number[]; fill_value: CScalar }): CTensor => {
  return addon.atg_full_out(out, size, fill_value)
}

export const atg_full_like = ({ self, fill_value, options, memory_format }: { self: CTensor; fill_value: CScalar; options: { device: number, dtype: number }; memory_format: number }): CTensor => {
  return addon.atg_full_like(self, fill_value, options, memory_format)
}

export const atg_full_like_out = ({ out, self, fill_value, memory_format }: { out: CTensor; self: CTensor; fill_value: CScalar; memory_format: number }): CTensor => {
  return addon.atg_full_like_out(out, self, fill_value, memory_format)
}

export const atg_from_file = ({ filename, shared, size, options }: { filename: string; shared: boolean; size?: number; options: { device: number, dtype: number } }): CTensor => {
  return addon.atg_from_file(filename, shared, size, options)
}

export const atg_from_file_out = ({ out, filename, shared, size }: { out: CTensor; filename: string; shared: boolean; size?: number }): CTensor => {
  return addon.atg_from_file_out(out, filename, shared, size)
}

export const atg_gcd = ({ self, other }: { self: CTensor; other: CTensor }): CTensor => {
  return addon.atg_gcd(self, other)
}

export const atg_gcd_out = ({ out, self, other }: { out: CTensor; self: CTensor; other: CTensor }): CTensor => {
  return addon.atg_gcd_out(out, self, other)
}

export const atg_gcd_ = ({ self, other }: { self: CTensor; other: CTensor }): CTensor => {
  return addon.atg_gcd_(self, other)
}

export const atg_lcm = ({ self, other }: { self: CTensor; other: CTensor }): CTensor => {
  return addon.atg_lcm(self, other)
}

export const atg_lcm_out = ({ out, self, other }: { out: CTensor; self: CTensor; other: CTensor }): CTensor => {
  return addon.atg_lcm_out(out, self, other)
}

export const atg_lcm_ = ({ self, other }: { self: CTensor; other: CTensor }): CTensor => {
  return addon.atg_lcm_(self, other)
}

export const atg_grid_sampler = ({ input, grid, interpolation_mode, padding_mode, align_corners }: { input: CTensor; grid: CTensor; interpolation_mode: number; padding_mode: number; align_corners: boolean }): CTensor => {
  return addon.atg_grid_sampler(input, grid, interpolation_mode, padding_mode, align_corners)
}

export const atg_grid_sampler_2d = ({ input, grid, interpolation_mode, padding_mode, align_corners }: { input: CTensor; grid: CTensor; interpolation_mode: number; padding_mode: number; align_corners: boolean }): CTensor => {
  return addon.atg_grid_sampler_2d(input, grid, interpolation_mode, padding_mode, align_corners)
}

export const atg_grid_sampler_2d_out = ({ out, input, grid, interpolation_mode, padding_mode, align_corners }: { out: CTensor; input: CTensor; grid: CTensor; interpolation_mode: number; padding_mode: number; align_corners: boolean }): CTensor => {
  return addon.atg_grid_sampler_2d_out(out, input, grid, interpolation_mode, padding_mode, align_corners)
}

export const atg__grid_sampler_2d_cpu_fallback = ({ input, grid, interpolation_mode, padding_mode, align_corners }: { input: CTensor; grid: CTensor; interpolation_mode: number; padding_mode: number; align_corners: boolean }): CTensor => {
  return addon.atg__grid_sampler_2d_cpu_fallback(input, grid, interpolation_mode, padding_mode, align_corners)
}

export const atg__grid_sampler_2d_cpu_fallback_out = ({ out, input, grid, interpolation_mode, padding_mode, align_corners }: { out: CTensor; input: CTensor; grid: CTensor; interpolation_mode: number; padding_mode: number; align_corners: boolean }): CTensor => {
  return addon.atg__grid_sampler_2d_cpu_fallback_out(out, input, grid, interpolation_mode, padding_mode, align_corners)
}

export const atg__grid_sampler_2d_cpu_fallback_backward = ({ grad_output, input, grid, interpolation_mode, padding_mode, align_corners }: { grad_output: CTensor; input: CTensor; grid: CTensor; interpolation_mode: number; padding_mode: number; align_corners: boolean }): CTensor[] => {
  return addon.atg__grid_sampler_2d_cpu_fallback_backward(grad_output, input, grid, interpolation_mode, padding_mode, align_corners)
}

export const atg_grid_sampler_3d = ({ input, grid, interpolation_mode, padding_mode, align_corners }: { input: CTensor; grid: CTensor; interpolation_mode: number; padding_mode: number; align_corners: boolean }): CTensor => {
  return addon.atg_grid_sampler_3d(input, grid, interpolation_mode, padding_mode, align_corners)
}

export const atg_grid_sampler_3d_out = ({ out, input, grid, interpolation_mode, padding_mode, align_corners }: { out: CTensor; input: CTensor; grid: CTensor; interpolation_mode: number; padding_mode: number; align_corners: boolean }): CTensor => {
  return addon.atg_grid_sampler_3d_out(out, input, grid, interpolation_mode, padding_mode, align_corners)
}

export const atg_hann_window = ({ window_length, options }: { window_length: number; options: { device: number, dtype: number } }): CTensor => {
  return addon.atg_hann_window(window_length, options)
}

export const atg_hann_window_periodic = ({ window_length, periodic, options }: { window_length: number; periodic: boolean; options: { device: number, dtype: number } }): CTensor => {
  return addon.atg_hann_window_periodic(window_length, periodic, options)
}

export const atg_hann_window_out = ({ out, window_length }: { out: CTensor; window_length: number }): CTensor => {
  return addon.atg_hann_window_out(out, window_length)
}

export const atg_hann_window_periodic_out = ({ out, window_length, periodic }: { out: CTensor; window_length: number; periodic: boolean }): CTensor => {
  return addon.atg_hann_window_periodic_out(out, window_length, periodic)
}

export const atg_hamming_window = ({ window_length, options }: { window_length: number; options: { device: number, dtype: number } }): CTensor => {
  return addon.atg_hamming_window(window_length, options)
}

export const atg_hamming_window_periodic = ({ window_length, periodic, options }: { window_length: number; periodic: boolean; options: { device: number, dtype: number } }): CTensor => {
  return addon.atg_hamming_window_periodic(window_length, periodic, options)
}

export const atg_hamming_window_periodic_alpha = ({ window_length, periodic, alpha, options }: { window_length: number; periodic: boolean; alpha: number; options: { device: number, dtype: number } }): CTensor => {
  return addon.atg_hamming_window_periodic_alpha(window_length, periodic, alpha, options)
}

export const atg_hamming_window_periodic_alpha_beta = ({ window_length, periodic, alpha, beta, options }: { window_length: number; periodic: boolean; alpha: number; beta: number; options: { device: number, dtype: number } }): CTensor => {
  return addon.atg_hamming_window_periodic_alpha_beta(window_length, periodic, alpha, beta, options)
}

export const atg_hamming_window_out = ({ out, window_length }: { out: CTensor; window_length: number }): CTensor => {
  return addon.atg_hamming_window_out(out, window_length)
}

export const atg_hamming_window_periodic_out = ({ out, window_length, periodic }: { out: CTensor; window_length: number; periodic: boolean }): CTensor => {
  return addon.atg_hamming_window_periodic_out(out, window_length, periodic)
}

export const atg_hamming_window_periodic_alpha_out = ({ out, window_length, periodic, alpha }: { out: CTensor; window_length: number; periodic: boolean; alpha: number }): CTensor => {
  return addon.atg_hamming_window_periodic_alpha_out(out, window_length, periodic, alpha)
}

export const atg_hamming_window_periodic_alpha_beta_out = ({ out, window_length, periodic, alpha, beta }: { out: CTensor; window_length: number; periodic: boolean; alpha: number; beta: number }): CTensor => {
  return addon.atg_hamming_window_periodic_alpha_beta_out(out, window_length, periodic, alpha, beta)
}

export const atg_kaiser_window = ({ window_length, options }: { window_length: number; options: { device: number, dtype: number } }): CTensor => {
  return addon.atg_kaiser_window(window_length, options)
}

export const atg_kaiser_window_periodic = ({ window_length, periodic, options }: { window_length: number; periodic: boolean; options: { device: number, dtype: number } }): CTensor => {
  return addon.atg_kaiser_window_periodic(window_length, periodic, options)
}

export const atg_kaiser_window_beta = ({ window_length, periodic, beta, options }: { window_length: number; periodic: boolean; beta: number; options: { device: number, dtype: number } }): CTensor => {
  return addon.atg_kaiser_window_beta(window_length, periodic, beta, options)
}

export const atg_kaiser_window_out = ({ out, window_length }: { out: CTensor; window_length: number }): CTensor => {
  return addon.atg_kaiser_window_out(out, window_length)
}

export const atg_kaiser_window_periodic_out = ({ out, window_length, periodic }: { out: CTensor; window_length: number; periodic: boolean }): CTensor => {
  return addon.atg_kaiser_window_periodic_out(out, window_length, periodic)
}

export const atg_kaiser_window_beta_out = ({ out, window_length, periodic, beta }: { out: CTensor; window_length: number; periodic: boolean; beta: number }): CTensor => {
  return addon.atg_kaiser_window_beta_out(out, window_length, periodic, beta)
}

export const atg_hinge_embedding_loss = ({ self, target, margin, reduction }: { self: CTensor; target: CTensor; margin: number; reduction: number }): CTensor => {
  return addon.atg_hinge_embedding_loss(self, target, margin, reduction)
}

export const atg_group_norm = ({ input, num_groups, weight, bias, eps, cudnn_enabled }: { input: CTensor; num_groups: number; weight?: CTensor; bias?: CTensor; eps: number; cudnn_enabled: boolean }): CTensor => {
  return addon.atg_group_norm(input, num_groups, weight, bias, eps, cudnn_enabled)
}

export const atg_native_group_norm = ({ input, weight, bias, N, C, HxW, group, eps }: { input: CTensor; weight?: CTensor; bias?: CTensor; N: number; C: number; HxW: number; group: number; eps: number }): CTensor[] => {
  return addon.atg_native_group_norm(input, weight, bias, N, C, HxW, group, eps)
}

export const atg_native_group_norm_out = ({ out0, out1, out2, input, weight, bias, N, C, HxW, group, eps }: { out0: CTensor; out1: CTensor; out2: CTensor; input: CTensor; weight?: CTensor; bias?: CTensor; N: number; C: number; HxW: number; group: number; eps: number }): CTensor[] => {
  return addon.atg_native_group_norm_out(out0, out1, out2, input, weight, bias, N, C, HxW, group, eps)
}

export const atg__fft_r2c = ({ self, dim, normalization, onesided }: { self: CTensor; dim: number[]; normalization: number; onesided: boolean }): CTensor => {
  return addon.atg__fft_r2c(self, dim, normalization, onesided)
}

export const atg__fft_r2c_out = ({ out, self, dim, normalization, onesided }: { out: CTensor; self: CTensor; dim: number[]; normalization: number; onesided: boolean }): CTensor => {
  return addon.atg__fft_r2c_out(out, self, dim, normalization, onesided)
}

export const atg__fft_c2r = ({ self, dim, normalization, last_dim_size }: { self: CTensor; dim: number[]; normalization: number; last_dim_size: number }): CTensor => {
  return addon.atg__fft_c2r(self, dim, normalization, last_dim_size)
}

export const atg__fft_c2r_out = ({ out, self, dim, normalization, last_dim_size }: { out: CTensor; self: CTensor; dim: number[]; normalization: number; last_dim_size: number }): CTensor => {
  return addon.atg__fft_c2r_out(out, self, dim, normalization, last_dim_size)
}

export const atg__fft_c2c = ({ self, dim, normalization, forward }: { self: CTensor; dim: number[]; normalization: number; forward: boolean }): CTensor => {
  return addon.atg__fft_c2c(self, dim, normalization, forward)
}

export const atg__fft_c2c_out = ({ out, self, dim, normalization, forward }: { out: CTensor; self: CTensor; dim: number[]; normalization: number; forward: boolean }): CTensor => {
  return addon.atg__fft_c2c_out(out, self, dim, normalization, forward)
}

export const atg__validate_compressed_sparse_indices = ({ is_crow, compressed_idx, plain_idx, cdim, dim, nnz }: { is_crow: boolean; compressed_idx: CTensor; plain_idx: CTensor; cdim: number; dim: number; nnz: number }): void => {
  return addon.atg__validate_compressed_sparse_indices(is_crow, compressed_idx, plain_idx, cdim, dim, nnz)
}

export const atg__cufft_get_plan_cache_size = ({ device_index }: { device_index: number }): number => {
  return addon.atg__cufft_get_plan_cache_size(device_index)
}

export const atg__cufft_get_plan_cache_max_size = ({ device_index }: { device_index: number }): number => {
  return addon.atg__cufft_get_plan_cache_max_size(device_index)
}

export const atg_index = ({ self, indices }: { self: CTensor; indices: CTensor[] }): CTensor => {
  return addon.atg_index(self, indices)
}

export const atg_index_tensor_out = ({ out, self, indices }: { out: CTensor; self: CTensor; indices: CTensor[] }): CTensor => {
  return addon.atg_index_tensor_out(out, self, indices)
}

export const atg_index_copy = ({ self, dim, index, source }: { self: CTensor; dim: number; index: CTensor; source: CTensor }): CTensor => {
  return addon.atg_index_copy(self, dim, index, source)
}

export const atg_index_copy_out = ({ out, self, dim, index, source }: { out: CTensor; self: CTensor; dim: number; index: CTensor; source: CTensor }): CTensor => {
  return addon.atg_index_copy_out(out, self, dim, index, source)
}

export const atg_index_copy_ = ({ self, dim, index, source }: { self: CTensor; dim: number; index: CTensor; source: CTensor }): CTensor => {
  return addon.atg_index_copy_(self, dim, index, source)
}

export const atg_index_put_ = ({ self, indices, values, accumulate }: { self: CTensor; indices: CTensor[]; values: CTensor; accumulate: boolean }): CTensor => {
  return addon.atg_index_put_(self, indices, values, accumulate)
}

export const atg_index_put = ({ self, indices, values, accumulate }: { self: CTensor; indices: CTensor[]; values: CTensor; accumulate: boolean }): CTensor => {
  return addon.atg_index_put(self, indices, values, accumulate)
}

export const atg_index_put_out = ({ out, self, indices, values, accumulate }: { out: CTensor; self: CTensor; indices: CTensor[]; values: CTensor; accumulate: boolean }): CTensor => {
  return addon.atg_index_put_out(out, self, indices, values, accumulate)
}

export const atg__index_put_impl_ = ({ self, indices, values, accumulate, unsafe }: { self: CTensor; indices: CTensor[]; values: CTensor; accumulate: boolean; unsafe: boolean }): CTensor => {
  return addon.atg__index_put_impl_(self, indices, values, accumulate, unsafe)
}

export const atg_instance_norm = ({ input, weight, bias, running_mean, running_var, use_input_stats, momentum, eps, cudnn_enabled }: { input: CTensor; weight?: CTensor; bias?: CTensor; running_mean?: CTensor; running_var?: CTensor; use_input_stats: boolean; momentum: number; eps: number; cudnn_enabled: boolean }): CTensor => {
  return addon.atg_instance_norm(input, weight, bias, running_mean, running_var, use_input_stats, momentum, eps, cudnn_enabled)
}

export const atg_isclose = ({ self, other, rtol, atol, equal_nan }: { self: CTensor; other: CTensor; rtol: number; atol: number; equal_nan: boolean }): CTensor => {
  return addon.atg_isclose(self, other, rtol, atol, equal_nan)
}

export const atg_isin = ({ elements, test_elements, assume_unique, invert }: { elements: CTensor; test_elements: CTensor; assume_unique: boolean; invert: boolean }): CTensor => {
  return addon.atg_isin(elements, test_elements, assume_unique, invert)
}

export const atg_isin_tensor_scalar = ({ elements, test_element, assume_unique, invert }: { elements: CTensor; test_element: CScalar; assume_unique: boolean; invert: boolean }): CTensor => {
  return addon.atg_isin_tensor_scalar(elements, test_element, assume_unique, invert)
}

export const atg_isin_scalar_tensor = ({ element, test_elements, assume_unique, invert }: { element: CScalar; test_elements: CTensor; assume_unique: boolean; invert: boolean }): CTensor => {
  return addon.atg_isin_scalar_tensor(element, test_elements, assume_unique, invert)
}

export const atg_isin_tensor_tensor_out = ({ out, elements, test_elements, assume_unique, invert }: { out: CTensor; elements: CTensor; test_elements: CTensor; assume_unique: boolean; invert: boolean }): CTensor => {
  return addon.atg_isin_tensor_tensor_out(out, elements, test_elements, assume_unique, invert)
}

export const atg_isin_tensor_scalar_out = ({ out, elements, test_element, assume_unique, invert }: { out: CTensor; elements: CTensor; test_element: CScalar; assume_unique: boolean; invert: boolean }): CTensor => {
  return addon.atg_isin_tensor_scalar_out(out, elements, test_element, assume_unique, invert)
}

export const atg_isin_scalar_tensor_out = ({ out, element, test_elements, assume_unique, invert }: { out: CTensor; element: CScalar; test_elements: CTensor; assume_unique: boolean; invert: boolean }): CTensor => {
  return addon.atg_isin_scalar_tensor_out(out, element, test_elements, assume_unique, invert)
}

export const atg_isnan = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_isnan(self)
}

export const atg_isnan_out = ({ out, self }: { out: CTensor; self: CTensor }): CTensor => {
  return addon.atg_isnan_out(out, self)
}

export const atg_is_distributed = ({ self }: { self: CTensor }): boolean => {
  return addon.atg_is_distributed(self)
}

export const atg_is_floating_point = ({ self }: { self: CTensor }): boolean => {
  return addon.atg_is_floating_point(self)
}

export const atg_is_complex = ({ self }: { self: CTensor }): boolean => {
  return addon.atg_is_complex(self)
}

export const atg_is_conj = ({ self }: { self: CTensor }): boolean => {
  return addon.atg_is_conj(self)
}

export const atg__is_zerotensor = ({ self }: { self: CTensor }): boolean => {
  return addon.atg__is_zerotensor(self)
}

export const atg_is_neg = ({ self }: { self: CTensor }): boolean => {
  return addon.atg_is_neg(self)
}

export const atg_isreal = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_isreal(self)
}

export const atg_is_nonzero = ({ self }: { self: CTensor }): boolean => {
  return addon.atg_is_nonzero(self)
}

export const atg_is_same_size = ({ self, other }: { self: CTensor; other: CTensor }): boolean => {
  return addon.atg_is_same_size(self, other)
}

export const atg_is_signed = ({ self }: { self: CTensor }): boolean => {
  return addon.atg_is_signed(self)
}

export const atg_is_inference = ({ self }: { self: CTensor }): boolean => {
  return addon.atg_is_inference(self)
}

export const atg_kl_div = ({ self, target, reduction, log_target }: { self: CTensor; target: CTensor; reduction: number; log_target: boolean }): CTensor => {
  return addon.atg_kl_div(self, target, reduction, log_target)
}

export const atg_kron = ({ self, other }: { self: CTensor; other: CTensor }): CTensor => {
  return addon.atg_kron(self, other)
}

export const atg_kron_out = ({ out, self, other }: { out: CTensor; self: CTensor; other: CTensor }): CTensor => {
  return addon.atg_kron_out(out, self, other)
}

export const atg_kthvalue = ({ self, k, dim, keepdim }: { self: CTensor; k: number; dim: number; keepdim: boolean }): CTensor[] => {
  return addon.atg_kthvalue(self, k, dim, keepdim)
}

export const atg_kthvalue_values = ({ values, indices, self, k, dim, keepdim }: { values: CTensor; indices: CTensor; self: CTensor; k: number; dim: number; keepdim: boolean }): CTensor[] => {
  return addon.atg_kthvalue_values(values, indices, self, k, dim, keepdim)
}

export const atg_layer_norm = ({ input, normalized_shape, weight, bias, eps, cudnn_enable }: { input: CTensor; normalized_shape: number[]; weight?: CTensor; bias?: CTensor; eps: number; cudnn_enable: boolean }): CTensor => {
  return addon.atg_layer_norm(input, normalized_shape, weight, bias, eps, cudnn_enable)
}

export const atg_native_layer_norm = ({ input, normalized_shape, weight, bias, eps }: { input: CTensor; normalized_shape: number[]; weight?: CTensor; bias?: CTensor; eps: number }): CTensor[] => {
  return addon.atg_native_layer_norm(input, normalized_shape, weight, bias, eps)
}

export const atg_native_layer_norm_out = ({ out0, out1, out2, input, normalized_shape, weight, bias, eps }: { out0: CTensor; out1: CTensor; out2: CTensor; input: CTensor; normalized_shape: number[]; weight?: CTensor; bias?: CTensor; eps: number }): CTensor[] => {
  return addon.atg_native_layer_norm_out(out0, out1, out2, input, normalized_shape, weight, bias, eps)
}

export const atg_nan_to_num = ({ self, nan, posinf, neginf }: { self: CTensor; nan?: number; posinf?: number; neginf?: number }): CTensor => {
  return addon.atg_nan_to_num(self, nan, posinf, neginf)
}

export const atg_nan_to_num_out = ({ out, self, nan, posinf, neginf }: { out: CTensor; self: CTensor; nan?: number; posinf?: number; neginf?: number }): CTensor => {
  return addon.atg_nan_to_num_out(out, self, nan, posinf, neginf)
}

export const atg_nan_to_num_ = ({ self, nan, posinf, neginf }: { self: CTensor; nan?: number; posinf?: number; neginf?: number }): CTensor => {
  return addon.atg_nan_to_num_(self, nan, posinf, neginf)
}

export const atg_linear = ({ input, weight, bias }: { input: CTensor; weight: CTensor; bias?: CTensor }): CTensor => {
  return addon.atg_linear(input, weight, bias)
}

export const atg_linear_out = ({ out, input, weight, bias }: { out: CTensor; input: CTensor; weight: CTensor; bias?: CTensor }): CTensor => {
  return addon.atg_linear_out(out, input, weight, bias)
}

export const atg_mkldnn_linear = ({ self, weight, bias }: { self: CTensor; weight: CTensor; bias?: CTensor }): CTensor => {
  return addon.atg_mkldnn_linear(self, weight, bias)
}

export const atg_mkldnn_linear_out = ({ out, self, weight, bias }: { out: CTensor; self: CTensor; weight: CTensor; bias?: CTensor }): CTensor => {
  return addon.atg_mkldnn_linear_out(out, self, weight, bias)
}

export const atg_mkldnn_linear_backward_input = ({ input_size, grad_output, weight }: { input_size: number[]; grad_output: CTensor; weight: CTensor }): CTensor => {
  return addon.atg_mkldnn_linear_backward_input(input_size, grad_output, weight)
}

export const atg_mkldnn_linear_backward_input_out = ({ out, input_size, grad_output, weight }: { out: CTensor; input_size: number[]; grad_output: CTensor; weight: CTensor }): CTensor => {
  return addon.atg_mkldnn_linear_backward_input_out(out, input_size, grad_output, weight)
}

export const atg_mkldnn_linear_backward_weights = ({ grad_output, input, weight, bias_defined }: { grad_output: CTensor; input: CTensor; weight: CTensor; bias_defined: boolean }): CTensor[] => {
  return addon.atg_mkldnn_linear_backward_weights(grad_output, input, weight, bias_defined)
}

export const atg_mkldnn_linear_backward_weights_out = ({ out0, out1, grad_output, input, weight, bias_defined }: { out0: CTensor; out1: CTensor; grad_output: CTensor; input: CTensor; weight: CTensor; bias_defined: boolean }): CTensor[] => {
  return addon.atg_mkldnn_linear_backward_weights_out(out0, out1, grad_output, input, weight, bias_defined)
}

export const atg_fbgemm_linear_int8_weight_fp32_activation = ({ input, weight, packed, col_offsets, weight_scale, weight_zero_point, bias }: { input: CTensor; weight: CTensor; packed: CTensor; col_offsets: CTensor; weight_scale: CScalar; weight_zero_point: CScalar; bias: CTensor }): CTensor => {
  return addon.atg_fbgemm_linear_int8_weight_fp32_activation(input, weight, packed, col_offsets, weight_scale, weight_zero_point, bias)
}

export const atg_fbgemm_linear_int8_weight = ({ input, weight, packed, col_offsets, weight_scale, weight_zero_point, bias }: { input: CTensor; weight: CTensor; packed: CTensor; col_offsets: CTensor; weight_scale: CScalar; weight_zero_point: CScalar; bias: CTensor }): CTensor => {
  return addon.atg_fbgemm_linear_int8_weight(input, weight, packed, col_offsets, weight_scale, weight_zero_point, bias)
}

export const atg_fbgemm_pack_gemm_matrix_fp16 = ({ input }: { input: CTensor }): CTensor => {
  return addon.atg_fbgemm_pack_gemm_matrix_fp16(input)
}

export const atg_fbgemm_linear_fp16_weight_fp32_activation = ({ input, packed_weight, bias }: { input: CTensor; packed_weight: CTensor; bias: CTensor }): CTensor => {
  return addon.atg_fbgemm_linear_fp16_weight_fp32_activation(input, packed_weight, bias)
}

export const atg_fbgemm_linear_fp16_weight = ({ input, packed_weight, bias }: { input: CTensor; packed_weight: CTensor; bias: CTensor }): CTensor => {
  return addon.atg_fbgemm_linear_fp16_weight(input, packed_weight, bias)
}

export const atg_fbgemm_pack_quantized_matrix = ({ input }: { input: CTensor }): CTensor => {
  return addon.atg_fbgemm_pack_quantized_matrix(input)
}

export const atg_fbgemm_pack_quantized_matrix_kn = ({ input, K, N }: { input: CTensor; K: number; N: number }): CTensor => {
  return addon.atg_fbgemm_pack_quantized_matrix_kn(input, K, N)
}

export const atg_ldexp = ({ self, other }: { self: CTensor; other: CTensor }): CTensor => {
  return addon.atg_ldexp(self, other)
}

export const atg_ldexp_out = ({ out, self, other }: { out: CTensor; self: CTensor; other: CTensor }): CTensor => {
  return addon.atg_ldexp_out(out, self, other)
}

export const atg_ldexp_ = ({ self, other }: { self: CTensor; other: CTensor }): CTensor => {
  return addon.atg_ldexp_(self, other)
}

export const atg_linspace = ({ start, end, steps, options }: { start: CScalar; end: CScalar; steps: number; options: { device: number, dtype: number } }): CTensor => {
  return addon.atg_linspace(start, end, steps, options)
}

export const atg_linspace_out = ({ out, start, end, steps }: { out: CTensor; start: CScalar; end: CScalar; steps: number }): CTensor => {
  return addon.atg_linspace_out(out, start, end, steps)
}

export const atg_log = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_log(self)
}

export const atg_log_out = ({ out, self }: { out: CTensor; self: CTensor }): CTensor => {
  return addon.atg_log_out(out, self)
}

export const atg_log_ = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_log_(self)
}

export const atg_log10 = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_log10(self)
}

export const atg_log10_out = ({ out, self }: { out: CTensor; self: CTensor }): CTensor => {
  return addon.atg_log10_out(out, self)
}

export const atg_log10_ = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_log10_(self)
}

export const atg_log1p = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_log1p(self)
}

export const atg_log1p_out = ({ out, self }: { out: CTensor; self: CTensor }): CTensor => {
  return addon.atg_log1p_out(out, self)
}

export const atg_log1p_ = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_log1p_(self)
}

export const atg_log2 = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_log2(self)
}

export const atg_log2_out = ({ out, self }: { out: CTensor; self: CTensor }): CTensor => {
  return addon.atg_log2_out(out, self)
}

export const atg_log2_ = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_log2_(self)
}

export const atg_logaddexp = ({ self, other }: { self: CTensor; other: CTensor }): CTensor => {
  return addon.atg_logaddexp(self, other)
}

export const atg_logaddexp_out = ({ out, self, other }: { out: CTensor; self: CTensor; other: CTensor }): CTensor => {
  return addon.atg_logaddexp_out(out, self, other)
}

export const atg_logaddexp2 = ({ self, other }: { self: CTensor; other: CTensor }): CTensor => {
  return addon.atg_logaddexp2(self, other)
}

export const atg_logaddexp2_out = ({ out, self, other }: { out: CTensor; self: CTensor; other: CTensor }): CTensor => {
  return addon.atg_logaddexp2_out(out, self, other)
}

export const atg_xlogy = ({ self, other }: { self: CTensor; other: CTensor }): CTensor => {
  return addon.atg_xlogy(self, other)
}

export const atg_xlogy_scalar_self = ({ self_scalar, other }: { self_scalar: CScalar; other: CTensor }): CTensor => {
  return addon.atg_xlogy_scalar_self(self_scalar, other)
}

export const atg_xlogy_scalar_other = ({ self, other }: { self: CTensor; other: CScalar }): CTensor => {
  return addon.atg_xlogy_scalar_other(self, other)
}

export const atg_xlogy_outtensor = ({ out, self, other }: { out: CTensor; self: CTensor; other: CTensor }): CTensor => {
  return addon.atg_xlogy_outtensor(out, self, other)
}

export const atg_xlogy_outscalar_self = ({ out, self_scalar, other }: { out: CTensor; self_scalar: CScalar; other: CTensor }): CTensor => {
  return addon.atg_xlogy_outscalar_self(out, self_scalar, other)
}

export const atg_xlogy_outscalar_other = ({ out, self, other }: { out: CTensor; self: CTensor; other: CScalar }): CTensor => {
  return addon.atg_xlogy_outscalar_other(out, self, other)
}

export const atg_xlogy_ = ({ self, other }: { self: CTensor; other: CTensor }): CTensor => {
  return addon.atg_xlogy_(self, other)
}

export const atg_xlogy_scalar_other_ = ({ self, other }: { self: CTensor; other: CScalar }): CTensor => {
  return addon.atg_xlogy_scalar_other_(self, other)
}

export const atg_logspace = ({ start, end, steps, base, options }: { start: CScalar; end: CScalar; steps: number; base: number; options: { device: number, dtype: number } }): CTensor => {
  return addon.atg_logspace(start, end, steps, base, options)
}

export const atg_logspace_out = ({ out, start, end, steps, base }: { out: CTensor; start: CScalar; end: CScalar; steps: number; base: number }): CTensor => {
  return addon.atg_logspace_out(out, start, end, steps, base)
}

export const atg_log_softmax = ({ self, dim, dtype }: { self: CTensor; dim: number; dtype: number }): CTensor => {
  return addon.atg_log_softmax(self, dim, dtype)
}

export const atg_log_softmax_int_out = ({ out, self, dim, dtype }: { out: CTensor; self: CTensor; dim: number; dtype: number }): CTensor => {
  return addon.atg_log_softmax_int_out(out, self, dim, dtype)
}

export const atg__log_softmax = ({ self, dim, half_to_float }: { self: CTensor; dim: number; half_to_float: boolean }): CTensor => {
  return addon.atg__log_softmax(self, dim, half_to_float)
}

export const atg__log_softmax_out = ({ out, self, dim, half_to_float }: { out: CTensor; self: CTensor; dim: number; half_to_float: boolean }): CTensor => {
  return addon.atg__log_softmax_out(out, self, dim, half_to_float)
}

export const atg__log_softmax_backward_data = ({ grad_output, output, dim, input_dtype }: { grad_output: CTensor; output: CTensor; dim: number; input_dtype: number }): CTensor => {
  return addon.atg__log_softmax_backward_data(grad_output, output, dim, input_dtype)
}

export const atg__log_softmax_backward_data_out = ({ out, grad_output, output, dim, input_dtype }: { out: CTensor; grad_output: CTensor; output: CTensor; dim: number; input_dtype: number }): CTensor => {
  return addon.atg__log_softmax_backward_data_out(out, grad_output, output, dim, input_dtype)
}

export const atg__logcumsumexp = ({ self, dim }: { self: CTensor; dim: number }): CTensor => {
  return addon.atg__logcumsumexp(self, dim)
}

export const atg__logcumsumexp_out = ({ out, self, dim }: { out: CTensor; self: CTensor; dim: number }): CTensor => {
  return addon.atg__logcumsumexp_out(out, self, dim)
}

export const atg_logcumsumexp = ({ self, dim }: { self: CTensor; dim: number }): CTensor => {
  return addon.atg_logcumsumexp(self, dim)
}

export const atg_logcumsumexp_out = ({ out, self, dim }: { out: CTensor; self: CTensor; dim: number }): CTensor => {
  return addon.atg_logcumsumexp_out(out, self, dim)
}

export const atg_logsumexp = ({ self, dim, keepdim }: { self: CTensor; dim: number[]; keepdim: boolean }): CTensor => {
  return addon.atg_logsumexp(self, dim, keepdim)
}

export const atg_logsumexp_out = ({ out, self, dim, keepdim }: { out: CTensor; self: CTensor; dim: number[]; keepdim: boolean }): CTensor => {
  return addon.atg_logsumexp_out(out, self, dim, keepdim)
}

export const atg_margin_ranking_loss = ({ input1, input2, target, margin, reduction }: { input1: CTensor; input2: CTensor; target: CTensor; margin: number; reduction: number }): CTensor => {
  return addon.atg_margin_ranking_loss(input1, input2, target, margin, reduction)
}

export const atg_matmul = ({ self, other }: { self: CTensor; other: CTensor }): CTensor => {
  return addon.atg_matmul(self, other)
}

export const atg_matmul_out = ({ out, self, other }: { out: CTensor; self: CTensor; other: CTensor }): CTensor => {
  return addon.atg_matmul_out(out, self, other)
}

export const atg_matrix_power = ({ self, n }: { self: CTensor; n: number }): CTensor => {
  return addon.atg_matrix_power(self, n)
}

export const atg_matrix_power_out = ({ out, self, n }: { out: CTensor; self: CTensor; n: number }): CTensor => {
  return addon.atg_matrix_power_out(out, self, n)
}

export const atg_matrix_exp = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_matrix_exp(self)
}

export const atg_matrix_exp_backward = ({ self, grad }: { self: CTensor; grad: CTensor }): CTensor => {
  return addon.atg_matrix_exp_backward(self, grad)
}

export const atg__aminmax = ({ self }: { self: CTensor }): CTensor[] => {
  return addon.atg__aminmax(self)
}

export const atg__aminmax_dim = ({ self, dim, keepdim }: { self: CTensor; dim: number; keepdim: boolean }): CTensor[] => {
  return addon.atg__aminmax_dim(self, dim, keepdim)
}

export const atg__aminmax_out = ({ out0, out1, self }: { out0: CTensor; out1: CTensor; self: CTensor }): CTensor[] => {
  return addon.atg__aminmax_out(out0, out1, self)
}

export const atg__aminmax_dim_out = ({ out0, out1, self, dim, keepdim }: { out0: CTensor; out1: CTensor; self: CTensor; dim: number; keepdim: boolean }): CTensor[] => {
  return addon.atg__aminmax_dim_out(out0, out1, self, dim, keepdim)
}

export const atg_aminmax = ({ self, dim, keepdim }: { self: CTensor; dim?: number; keepdim: boolean }): CTensor[] => {
  return addon.atg_aminmax(self, dim, keepdim)
}

export const atg_aminmax_out = ({ min, max, self, dim, keepdim }: { min: CTensor; max: CTensor; self: CTensor; dim?: number; keepdim: boolean }): CTensor[] => {
  return addon.atg_aminmax_out(min, max, self, dim, keepdim)
}

export const atg__compute_linear_combination = ({ input, coefficients }: { input: CTensor; coefficients: CTensor }): CTensor => {
  return addon.atg__compute_linear_combination(input, coefficients)
}

export const atg__compute_linear_combination_out = ({ out, input, coefficients }: { out: CTensor; input: CTensor; coefficients: CTensor }): CTensor => {
  return addon.atg__compute_linear_combination_out(out, input, coefficients)
}

export const atg_max = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_max(self)
}

export const atg_max_other = ({ self, other }: { self: CTensor; other: CTensor }): CTensor => {
  return addon.atg_max_other(self, other)
}

export const atg_max_dim = ({ self, dim, keepdim }: { self: CTensor; dim: number; keepdim: boolean }): CTensor[] => {
  return addon.atg_max_dim(self, dim, keepdim)
}

export const atg_max_unary_out = ({ out, self }: { out: CTensor; self: CTensor }): CTensor => {
  return addon.atg_max_unary_out(out, self)
}

export const atg_max_out = ({ out, self, other }: { out: CTensor; self: CTensor; other: CTensor }): CTensor => {
  return addon.atg_max_out(out, self, other)
}

export const atg_max_dim_max = ({ max, max_values, self, dim, keepdim }: { max: CTensor; max_values: CTensor; self: CTensor; dim: number; keepdim: boolean }): CTensor[] => {
  return addon.atg_max_dim_max(max, max_values, self, dim, keepdim)
}

export const atg_value_selecting_reduction_backward = ({ grad, dim, indices, sizes, keepdim }: { grad: CTensor; dim: number; indices: CTensor; sizes: number[]; keepdim: boolean }): CTensor => {
  return addon.atg_value_selecting_reduction_backward(grad, dim, indices, sizes, keepdim)
}

export const atg_amax = ({ self, dim, keepdim }: { self: CTensor; dim: number[]; keepdim: boolean }): CTensor => {
  return addon.atg_amax(self, dim, keepdim)
}

export const atg_amax_out = ({ out, self, dim, keepdim }: { out: CTensor; self: CTensor; dim: number[]; keepdim: boolean }): CTensor => {
  return addon.atg_amax_out(out, self, dim, keepdim)
}

export const atg_max_pool1d_with_indices = ({ self, kernel_size, stride, padding, dilation, ceil_mode }: { self: CTensor; kernel_size: number[]; stride: number[]; padding: number[]; dilation: number[]; ceil_mode: boolean }): CTensor[] => {
  return addon.atg_max_pool1d_with_indices(self, kernel_size, stride, padding, dilation, ceil_mode)
}

export const atg_max_pool1d = ({ self, kernel_size, stride, padding, dilation, ceil_mode }: { self: CTensor; kernel_size: number[]; stride: number[]; padding: number[]; dilation: number[]; ceil_mode: boolean }): CTensor => {
  return addon.atg_max_pool1d(self, kernel_size, stride, padding, dilation, ceil_mode)
}

export const atg_max_pool2d = ({ self, kernel_size, stride, padding, dilation, ceil_mode }: { self: CTensor; kernel_size: number[]; stride: number[]; padding: number[]; dilation: number[]; ceil_mode: boolean }): CTensor => {
  return addon.atg_max_pool2d(self, kernel_size, stride, padding, dilation, ceil_mode)
}

export const atg_max_pool2d_backward = ({ grad_output, self, kernel_size, stride, padding, dilation, ceil_mode }: { grad_output: CTensor; self: CTensor; kernel_size: number[]; stride: number[]; padding: number[]; dilation: number[]; ceil_mode: boolean }): CTensor => {
  return addon.atg_max_pool2d_backward(grad_output, self, kernel_size, stride, padding, dilation, ceil_mode)
}

export const atg_max_pool2d_backward_out = ({ out, grad_output, self, kernel_size, stride, padding, dilation, ceil_mode }: { out: CTensor; grad_output: CTensor; self: CTensor; kernel_size: number[]; stride: number[]; padding: number[]; dilation: number[]; ceil_mode: boolean }): CTensor => {
  return addon.atg_max_pool2d_backward_out(out, grad_output, self, kernel_size, stride, padding, dilation, ceil_mode)
}

export const atg_mkldnn_max_pool2d = ({ self, kernel_size, stride, padding, dilation, ceil_mode }: { self: CTensor; kernel_size: number[]; stride: number[]; padding: number[]; dilation: number[]; ceil_mode: boolean }): CTensor => {
  return addon.atg_mkldnn_max_pool2d(self, kernel_size, stride, padding, dilation, ceil_mode)
}

export const atg_mkldnn_max_pool2d_out = ({ out, self, kernel_size, stride, padding, dilation, ceil_mode }: { out: CTensor; self: CTensor; kernel_size: number[]; stride: number[]; padding: number[]; dilation: number[]; ceil_mode: boolean }): CTensor => {
  return addon.atg_mkldnn_max_pool2d_out(out, self, kernel_size, stride, padding, dilation, ceil_mode)
}

export const atg_mkldnn_max_pool2d_backward = ({ grad_output, output, input, kernel_size, stride, padding, dilation, ceil_mode }: { grad_output: CTensor; output: CTensor; input: CTensor; kernel_size: number[]; stride: number[]; padding: number[]; dilation: number[]; ceil_mode: boolean }): CTensor => {
  return addon.atg_mkldnn_max_pool2d_backward(grad_output, output, input, kernel_size, stride, padding, dilation, ceil_mode)
}

export const atg_mkldnn_max_pool2d_backward_out = ({ out, grad_output, output, input, kernel_size, stride, padding, dilation, ceil_mode }: { out: CTensor; grad_output: CTensor; output: CTensor; input: CTensor; kernel_size: number[]; stride: number[]; padding: number[]; dilation: number[]; ceil_mode: boolean }): CTensor => {
  return addon.atg_mkldnn_max_pool2d_backward_out(out, grad_output, output, input, kernel_size, stride, padding, dilation, ceil_mode)
}

export const atg_mkldnn_max_pool3d = ({ self, kernel_size, stride, padding, dilation, ceil_mode }: { self: CTensor; kernel_size: number[]; stride: number[]; padding: number[]; dilation: number[]; ceil_mode: boolean }): CTensor => {
  return addon.atg_mkldnn_max_pool3d(self, kernel_size, stride, padding, dilation, ceil_mode)
}

export const atg_mkldnn_max_pool3d_out = ({ out, self, kernel_size, stride, padding, dilation, ceil_mode }: { out: CTensor; self: CTensor; kernel_size: number[]; stride: number[]; padding: number[]; dilation: number[]; ceil_mode: boolean }): CTensor => {
  return addon.atg_mkldnn_max_pool3d_out(out, self, kernel_size, stride, padding, dilation, ceil_mode)
}

export const atg_mkldnn_max_pool3d_backward = ({ grad_output, output, input, kernel_size, stride, padding, dilation, ceil_mode }: { grad_output: CTensor; output: CTensor; input: CTensor; kernel_size: number[]; stride: number[]; padding: number[]; dilation: number[]; ceil_mode: boolean }): CTensor => {
  return addon.atg_mkldnn_max_pool3d_backward(grad_output, output, input, kernel_size, stride, padding, dilation, ceil_mode)
}

export const atg_mkldnn_max_pool3d_backward_out = ({ out, grad_output, output, input, kernel_size, stride, padding, dilation, ceil_mode }: { out: CTensor; grad_output: CTensor; output: CTensor; input: CTensor; kernel_size: number[]; stride: number[]; padding: number[]; dilation: number[]; ceil_mode: boolean }): CTensor => {
  return addon.atg_mkldnn_max_pool3d_backward_out(out, grad_output, output, input, kernel_size, stride, padding, dilation, ceil_mode)
}

export const atg_quantized_max_pool1d = ({ self, kernel_size, stride, padding, dilation, ceil_mode }: { self: CTensor; kernel_size: number[]; stride: number[]; padding: number[]; dilation: number[]; ceil_mode: boolean }): CTensor => {
  return addon.atg_quantized_max_pool1d(self, kernel_size, stride, padding, dilation, ceil_mode)
}

export const atg_quantized_max_pool1d_out = ({ out, self, kernel_size, stride, padding, dilation, ceil_mode }: { out: CTensor; self: CTensor; kernel_size: number[]; stride: number[]; padding: number[]; dilation: number[]; ceil_mode: boolean }): CTensor => {
  return addon.atg_quantized_max_pool1d_out(out, self, kernel_size, stride, padding, dilation, ceil_mode)
}

export const atg_quantized_max_pool2d = ({ self, kernel_size, stride, padding, dilation, ceil_mode }: { self: CTensor; kernel_size: number[]; stride: number[]; padding: number[]; dilation: number[]; ceil_mode: boolean }): CTensor => {
  return addon.atg_quantized_max_pool2d(self, kernel_size, stride, padding, dilation, ceil_mode)
}

export const atg_quantized_max_pool2d_out = ({ out, self, kernel_size, stride, padding, dilation, ceil_mode }: { out: CTensor; self: CTensor; kernel_size: number[]; stride: number[]; padding: number[]; dilation: number[]; ceil_mode: boolean }): CTensor => {
  return addon.atg_quantized_max_pool2d_out(out, self, kernel_size, stride, padding, dilation, ceil_mode)
}

export const atg_max_pool3d = ({ self, kernel_size, stride, padding, dilation, ceil_mode }: { self: CTensor; kernel_size: number[]; stride: number[]; padding: number[]; dilation: number[]; ceil_mode: boolean }): CTensor => {
  return addon.atg_max_pool3d(self, kernel_size, stride, padding, dilation, ceil_mode)
}

export const atg_mean = ({ self, dtype }: { self: CTensor; dtype: number }): CTensor => {
  return addon.atg_mean(self, dtype)
}

export const atg_mean_dim = ({ self, dim, keepdim, dtype }: { self: CTensor; dim?: number[]; keepdim: boolean; dtype: number }): CTensor => {
  return addon.atg_mean_dim(self, dim, keepdim, dtype)
}

export const atg_mean_out = ({ out, self, dim, keepdim, dtype }: { out: CTensor; self: CTensor; dim?: number[]; keepdim: boolean; dtype: number }): CTensor => {
  return addon.atg_mean_out(out, self, dim, keepdim, dtype)
}

export const atg_nanmean = ({ self, dim, keepdim, dtype }: { self: CTensor; dim?: number[]; keepdim: boolean; dtype: number }): CTensor => {
  return addon.atg_nanmean(self, dim, keepdim, dtype)
}

export const atg_nanmean_out = ({ out, self, dim, keepdim, dtype }: { out: CTensor; self: CTensor; dim?: number[]; keepdim: boolean; dtype: number }): CTensor => {
  return addon.atg_nanmean_out(out, self, dim, keepdim, dtype)
}

export const atg_median = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_median(self)
}

export const atg_median_dim = ({ self, dim, keepdim }: { self: CTensor; dim: number; keepdim: boolean }): CTensor[] => {
  return addon.atg_median_dim(self, dim, keepdim)
}

export const atg_median_out = ({ out, self }: { out: CTensor; self: CTensor }): CTensor => {
  return addon.atg_median_out(out, self)
}

export const atg_median_dim_values = ({ values, indices, self, dim, keepdim }: { values: CTensor; indices: CTensor; self: CTensor; dim: number; keepdim: boolean }): CTensor[] => {
  return addon.atg_median_dim_values(values, indices, self, dim, keepdim)
}

export const atg_nanmedian = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_nanmedian(self)
}

export const atg_nanmedian_dim = ({ self, dim, keepdim }: { self: CTensor; dim: number; keepdim: boolean }): CTensor[] => {
  return addon.atg_nanmedian_dim(self, dim, keepdim)
}

export const atg_nanmedian_out = ({ out, self }: { out: CTensor; self: CTensor }): CTensor => {
  return addon.atg_nanmedian_out(out, self)
}

export const atg_nanmedian_dim_values = ({ values, indices, self, dim, keepdim }: { values: CTensor; indices: CTensor; self: CTensor; dim: number; keepdim: boolean }): CTensor[] => {
  return addon.atg_nanmedian_dim_values(values, indices, self, dim, keepdim)
}

export const atg_min = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_min(self)
}

export const atg_min_other = ({ self, other }: { self: CTensor; other: CTensor }): CTensor => {
  return addon.atg_min_other(self, other)
}

export const atg_min_dim = ({ self, dim, keepdim }: { self: CTensor; dim: number; keepdim: boolean }): CTensor[] => {
  return addon.atg_min_dim(self, dim, keepdim)
}

export const atg_min_out = ({ out, self, other }: { out: CTensor; self: CTensor; other: CTensor }): CTensor => {
  return addon.atg_min_out(out, self, other)
}

export const atg_min_dim_min = ({ min, min_indices, self, dim, keepdim }: { min: CTensor; min_indices: CTensor; self: CTensor; dim: number; keepdim: boolean }): CTensor[] => {
  return addon.atg_min_dim_min(min, min_indices, self, dim, keepdim)
}

export const atg_amin = ({ self, dim, keepdim }: { self: CTensor; dim: number[]; keepdim: boolean }): CTensor => {
  return addon.atg_amin(self, dim, keepdim)
}

export const atg_amin_out = ({ out, self, dim, keepdim }: { out: CTensor; self: CTensor; dim: number[]; keepdim: boolean }): CTensor => {
  return addon.atg_amin_out(out, self, dim, keepdim)
}

export const atg__mps_convolution = ({ self, weight, bias, padding, stride, dilation, groups }: { self: CTensor; weight: CTensor; bias?: CTensor; padding: number[]; stride: number[]; dilation: number[]; groups: number }): CTensor => {
  return addon.atg__mps_convolution(self, weight, bias, padding, stride, dilation, groups)
}

export const atg__mps_convolution_out = ({ out, self, weight, bias, padding, stride, dilation, groups }: { out: CTensor; self: CTensor; weight: CTensor; bias?: CTensor; padding: number[]; stride: number[]; dilation: number[]; groups: number }): CTensor => {
  return addon.atg__mps_convolution_out(out, self, weight, bias, padding, stride, dilation, groups)
}

export const atg_mkldnn_convolution = ({ self, weight, bias, padding, stride, dilation, groups }: { self: CTensor; weight: CTensor; bias?: CTensor; padding: number[]; stride: number[]; dilation: number[]; groups: number }): CTensor => {
  return addon.atg_mkldnn_convolution(self, weight, bias, padding, stride, dilation, groups)
}

export const atg_mkldnn_convolution_out = ({ out, self, weight, bias, padding, stride, dilation, groups }: { out: CTensor; self: CTensor; weight: CTensor; bias?: CTensor; padding: number[]; stride: number[]; dilation: number[]; groups: number }): CTensor => {
  return addon.atg_mkldnn_convolution_out(out, self, weight, bias, padding, stride, dilation, groups)
}

export const atg_mkldnn_rnn_layer = ({ input, weight0, weight1, weight2, weight3, hx_, cx_, reverse, batch_sizes, mode, hidden_size, num_layers, has_biases, bidirectional, batch_first, train }: { input: CTensor; weight0: CTensor; weight1: CTensor; weight2: CTensor; weight3: CTensor; hx_: CTensor; cx_: CTensor; reverse: boolean; batch_sizes: number[]; mode: number; hidden_size: number; num_layers: number; has_biases: boolean; bidirectional: boolean; batch_first: boolean; train: boolean }): CTensor[] => {
  return addon.atg_mkldnn_rnn_layer(input, weight0, weight1, weight2, weight3, hx_, cx_, reverse, batch_sizes, mode, hidden_size, num_layers, has_biases, bidirectional, batch_first, train)
}

export const atg_mkldnn_rnn_layer_out = ({ out0, out1, out2, out3, input, weight0, weight1, weight2, weight3, hx_, cx_, reverse, batch_sizes, mode, hidden_size, num_layers, has_biases, bidirectional, batch_first, train }: { out0: CTensor; out1: CTensor; out2: CTensor; out3: CTensor; input: CTensor; weight0: CTensor; weight1: CTensor; weight2: CTensor; weight3: CTensor; hx_: CTensor; cx_: CTensor; reverse: boolean; batch_sizes: number[]; mode: number; hidden_size: number; num_layers: number; has_biases: boolean; bidirectional: boolean; batch_first: boolean; train: boolean }): CTensor[] => {
  return addon.atg_mkldnn_rnn_layer_out(out0, out1, out2, out3, input, weight0, weight1, weight2, weight3, hx_, cx_, reverse, batch_sizes, mode, hidden_size, num_layers, has_biases, bidirectional, batch_first, train)
}

export const atg_mkldnn_rnn_layer_backward = ({ input, weight1, weight2, weight3, weight4, hx_, cx_tmp, output, hy_, cy_, grad_output, grad_hy, grad_cy, reverse, mode, hidden_size, num_layers, has_biases, train, bidirectional, batch_sizes, batch_first, workspace }: { input: CTensor; weight1: CTensor; weight2: CTensor; weight3: CTensor; weight4: CTensor; hx_: CTensor; cx_tmp: CTensor; output: CTensor; hy_: CTensor; cy_: CTensor; grad_output?: CTensor; grad_hy?: CTensor; grad_cy?: CTensor; reverse: boolean; mode: number; hidden_size: number; num_layers: number; has_biases: boolean; train: boolean; bidirectional: boolean; batch_sizes: number[]; batch_first: boolean; workspace: CTensor }): CTensor[] => {
  return addon.atg_mkldnn_rnn_layer_backward(input, weight1, weight2, weight3, weight4, hx_, cx_tmp, output, hy_, cy_, grad_output, grad_hy, grad_cy, reverse, mode, hidden_size, num_layers, has_biases, train, bidirectional, batch_sizes, batch_first, workspace)
}

export const atg_mkldnn_rnn_layer_backward_out = ({ out0, out1, out2, out3, out4, out5, out6, input, weight1, weight2, weight3, weight4, hx_, cx_tmp, output, hy_, cy_, grad_output, grad_hy, grad_cy, reverse, mode, hidden_size, num_layers, has_biases, train, bidirectional, batch_sizes, batch_first, workspace }: { out0: CTensor; out1: CTensor; out2: CTensor; out3: CTensor; out4: CTensor; out5: CTensor; out6: CTensor; input: CTensor; weight1: CTensor; weight2: CTensor; weight3: CTensor; weight4: CTensor; hx_: CTensor; cx_tmp: CTensor; output: CTensor; hy_: CTensor; cy_: CTensor; grad_output?: CTensor; grad_hy?: CTensor; grad_cy?: CTensor; reverse: boolean; mode: number; hidden_size: number; num_layers: number; has_biases: boolean; train: boolean; bidirectional: boolean; batch_sizes: number[]; batch_first: boolean; workspace: CTensor }): CTensor[] => {
  return addon.atg_mkldnn_rnn_layer_backward_out(out0, out1, out2, out3, out4, out5, out6, input, weight1, weight2, weight3, weight4, hx_, cx_tmp, output, hy_, cy_, grad_output, grad_hy, grad_cy, reverse, mode, hidden_size, num_layers, has_biases, train, bidirectional, batch_sizes, batch_first, workspace)
}

export const atg_miopen_batch_norm = ({ input, weight, bias, running_mean, running_var, training, exponential_average_factor, epsilon }: { input: CTensor; weight: CTensor; bias?: CTensor; running_mean?: CTensor; running_var?: CTensor; training: boolean; exponential_average_factor: number; epsilon: number }): CTensor[] => {
  return addon.atg_miopen_batch_norm(input, weight, bias, running_mean, running_var, training, exponential_average_factor, epsilon)
}

export const atg_miopen_batch_norm_out = ({ out0, out1, out2, input, weight, bias, running_mean, running_var, training, exponential_average_factor, epsilon }: { out0: CTensor; out1: CTensor; out2: CTensor; input: CTensor; weight: CTensor; bias?: CTensor; running_mean?: CTensor; running_var?: CTensor; training: boolean; exponential_average_factor: number; epsilon: number }): CTensor[] => {
  return addon.atg_miopen_batch_norm_out(out0, out1, out2, input, weight, bias, running_mean, running_var, training, exponential_average_factor, epsilon)
}

export const atg_miopen_batch_norm_backward = ({ input, grad_output, weight, running_mean, running_var, save_mean, save_var, epsilon }: { input: CTensor; grad_output: CTensor; weight: CTensor; running_mean?: CTensor; running_var?: CTensor; save_mean?: CTensor; save_var?: CTensor; epsilon: number }): CTensor[] => {
  return addon.atg_miopen_batch_norm_backward(input, grad_output, weight, running_mean, running_var, save_mean, save_var, epsilon)
}

export const atg_miopen_batch_norm_backward_out = ({ out0, out1, out2, input, grad_output, weight, running_mean, running_var, save_mean, save_var, epsilon }: { out0: CTensor; out1: CTensor; out2: CTensor; input: CTensor; grad_output: CTensor; weight: CTensor; running_mean?: CTensor; running_var?: CTensor; save_mean?: CTensor; save_var?: CTensor; epsilon: number }): CTensor[] => {
  return addon.atg_miopen_batch_norm_backward_out(out0, out1, out2, input, grad_output, weight, running_mean, running_var, save_mean, save_var, epsilon)
}

export const atg_miopen_convolution = ({ self, weight, bias, padding, stride, dilation, groups, benchmark, deterministic }: { self: CTensor; weight: CTensor; bias?: CTensor; padding: number[]; stride: number[]; dilation: number[]; groups: number; benchmark: boolean; deterministic: boolean }): CTensor => {
  return addon.atg_miopen_convolution(self, weight, bias, padding, stride, dilation, groups, benchmark, deterministic)
}

export const atg_miopen_convolution_out = ({ out, self, weight, bias, padding, stride, dilation, groups, benchmark, deterministic }: { out: CTensor; self: CTensor; weight: CTensor; bias?: CTensor; padding: number[]; stride: number[]; dilation: number[]; groups: number; benchmark: boolean; deterministic: boolean }): CTensor => {
  return addon.atg_miopen_convolution_out(out, self, weight, bias, padding, stride, dilation, groups, benchmark, deterministic)
}

export const atg_miopen_convolution_transpose = ({ self, weight, bias, padding, output_padding, stride, dilation, groups, benchmark, deterministic }: { self: CTensor; weight: CTensor; bias?: CTensor; padding: number[]; output_padding: number[]; stride: number[]; dilation: number[]; groups: number; benchmark: boolean; deterministic: boolean }): CTensor => {
  return addon.atg_miopen_convolution_transpose(self, weight, bias, padding, output_padding, stride, dilation, groups, benchmark, deterministic)
}

export const atg_miopen_convolution_transpose_out = ({ out, self, weight, bias, padding, output_padding, stride, dilation, groups, benchmark, deterministic }: { out: CTensor; self: CTensor; weight: CTensor; bias?: CTensor; padding: number[]; output_padding: number[]; stride: number[]; dilation: number[]; groups: number; benchmark: boolean; deterministic: boolean }): CTensor => {
  return addon.atg_miopen_convolution_transpose_out(out, self, weight, bias, padding, output_padding, stride, dilation, groups, benchmark, deterministic)
}

export const atg_miopen_depthwise_convolution = ({ self, weight, bias, padding, stride, dilation, groups, benchmark, deterministic }: { self: CTensor; weight: CTensor; bias?: CTensor; padding: number[]; stride: number[]; dilation: number[]; groups: number; benchmark: boolean; deterministic: boolean }): CTensor => {
  return addon.atg_miopen_depthwise_convolution(self, weight, bias, padding, stride, dilation, groups, benchmark, deterministic)
}

export const atg_miopen_depthwise_convolution_out = ({ out, self, weight, bias, padding, stride, dilation, groups, benchmark, deterministic }: { out: CTensor; self: CTensor; weight: CTensor; bias?: CTensor; padding: number[]; stride: number[]; dilation: number[]; groups: number; benchmark: boolean; deterministic: boolean }): CTensor => {
  return addon.atg_miopen_depthwise_convolution_out(out, self, weight, bias, padding, stride, dilation, groups, benchmark, deterministic)
}

export const atg_miopen_convolution_relu = ({ self, weight, bias, stride, padding, dilation, groups }: { self: CTensor; weight: CTensor; bias?: CTensor; stride: number[]; padding: number[]; dilation: number[]; groups: number }): CTensor => {
  return addon.atg_miopen_convolution_relu(self, weight, bias, stride, padding, dilation, groups)
}

export const atg_miopen_convolution_add_relu = ({ self, weight, z, alpha, bias, stride, padding, dilation, groups }: { self: CTensor; weight: CTensor; z: CTensor; alpha: CScalar; bias?: CTensor; stride: number[]; padding: number[]; dilation: number[]; groups: number }): CTensor => {
  return addon.atg_miopen_convolution_add_relu(self, weight, z, alpha, bias, stride, padding, dilation, groups)
}

export const atg_miopen_rnn = ({ input, weight, weight_stride0, hx, cx, mode, hidden_size, num_layers, batch_first, dropout, train, bidirectional, batch_sizes, dropout_state }: { input: CTensor; weight: CTensor[]; weight_stride0: number; hx: CTensor; cx?: CTensor; mode: number; hidden_size: number; num_layers: number; batch_first: boolean; dropout: number; train: boolean; bidirectional: boolean; batch_sizes: number[]; dropout_state?: CTensor }): CTensor[] => {
  return addon.atg_miopen_rnn(input, weight, weight_stride0, hx, cx, mode, hidden_size, num_layers, batch_first, dropout, train, bidirectional, batch_sizes, dropout_state)
}

export const atg_miopen_rnn_out = ({ out0, out1, out2, out3, out4, input, weight, weight_stride0, hx, cx, mode, hidden_size, num_layers, batch_first, dropout, train, bidirectional, batch_sizes, dropout_state }: { out0: CTensor; out1: CTensor; out2: CTensor; out3: CTensor; out4: CTensor; input: CTensor; weight: CTensor[]; weight_stride0: number; hx: CTensor; cx?: CTensor; mode: number; hidden_size: number; num_layers: number; batch_first: boolean; dropout: number; train: boolean; bidirectional: boolean; batch_sizes: number[]; dropout_state?: CTensor }): CTensor[] => {
  return addon.atg_miopen_rnn_out(out0, out1, out2, out3, out4, input, weight, weight_stride0, hx, cx, mode, hidden_size, num_layers, batch_first, dropout, train, bidirectional, batch_sizes, dropout_state)
}

export const atg_mm = ({ self, mat2 }: { self: CTensor; mat2: CTensor }): CTensor => {
  return addon.atg_mm(self, mat2)
}

export const atg_mm_out = ({ out, self, mat2 }: { out: CTensor; self: CTensor; mat2: CTensor }): CTensor => {
  return addon.atg_mm_out(out, self, mat2)
}

export const atg__sparse_mm = ({ sparse, dense }: { sparse: CTensor; dense: CTensor }): CTensor => {
  return addon.atg__sparse_mm(sparse, dense)
}

export const atg__sparse_mm_reduce = ({ sparse, dense, reduce }: { sparse: CTensor; dense: CTensor; reduce: string }): CTensor => {
  return addon.atg__sparse_mm_reduce(sparse, dense, reduce)
}

export const atg__sparse_sparse_matmul = ({ self, other }: { self: CTensor; other: CTensor }): CTensor => {
  return addon.atg__sparse_sparse_matmul(self, other)
}

export const atg__sparse_sparse_matmul_out = ({ out, self, other }: { out: CTensor; self: CTensor; other: CTensor }): CTensor => {
  return addon.atg__sparse_sparse_matmul_out(out, self, other)
}

export const atg_mode = ({ self, dim, keepdim }: { self: CTensor; dim: number; keepdim: boolean }): CTensor[] => {
  return addon.atg_mode(self, dim, keepdim)
}

export const atg_mode_values = ({ values, indices, self, dim, keepdim }: { values: CTensor; indices: CTensor; self: CTensor; dim: number; keepdim: boolean }): CTensor[] => {
  return addon.atg_mode_values(values, indices, self, dim, keepdim)
}

export const atg_mul = ({ self, other }: { self: CTensor; other: CTensor }): CTensor => {
  return addon.atg_mul(self, other)
}

export const atg_mul_scalar = ({ self, other }: { self: CTensor; other: CScalar }): CTensor => {
  return addon.atg_mul_scalar(self, other)
}

export const atg_mul_out = ({ out, self, other }: { out: CTensor; self: CTensor; other: CTensor }): CTensor => {
  return addon.atg_mul_out(out, self, other)
}

export const atg_mul_scalar_out = ({ out, self, other }: { out: CTensor; self: CTensor; other: CScalar }): CTensor => {
  return addon.atg_mul_scalar_out(out, self, other)
}

export const atg_mul_ = ({ self, other }: { self: CTensor; other: CTensor }): CTensor => {
  return addon.atg_mul_(self, other)
}

export const atg_mul_scalar_ = ({ self, other }: { self: CTensor; other: CScalar }): CTensor => {
  return addon.atg_mul_scalar_(self, other)
}

export const atg_multiply = ({ self, other }: { self: CTensor; other: CTensor }): CTensor => {
  return addon.atg_multiply(self, other)
}

export const atg_multiply_scalar = ({ self, other }: { self: CTensor; other: CScalar }): CTensor => {
  return addon.atg_multiply_scalar(self, other)
}

export const atg_multiply_out = ({ out, self, other }: { out: CTensor; self: CTensor; other: CTensor }): CTensor => {
  return addon.atg_multiply_out(out, self, other)
}

export const atg_multiply_ = ({ self, other }: { self: CTensor; other: CTensor }): CTensor => {
  return addon.atg_multiply_(self, other)
}

export const atg_multiply_scalar_ = ({ self, other }: { self: CTensor; other: CScalar }): CTensor => {
  return addon.atg_multiply_scalar_(self, other)
}

export const atg_mv = ({ self, vec }: { self: CTensor; vec: CTensor }): CTensor => {
  return addon.atg_mv(self, vec)
}

export const atg_mv_out = ({ out, self, vec }: { out: CTensor; self: CTensor; vec: CTensor }): CTensor => {
  return addon.atg_mv_out(out, self, vec)
}

export const atg_mvlgamma = ({ self, p }: { self: CTensor; p: number }): CTensor => {
  return addon.atg_mvlgamma(self, p)
}

export const atg_mvlgamma_out = ({ out, self, p }: { out: CTensor; self: CTensor; p: number }): CTensor => {
  return addon.atg_mvlgamma_out(out, self, p)
}

export const atg_mvlgamma_ = ({ self, p }: { self: CTensor; p: number }): CTensor => {
  return addon.atg_mvlgamma_(self, p)
}

export const atg_narrow_copy = ({ self, dim, start, length }: { self: CTensor; dim: number; start: number; length: number }): CTensor => {
  return addon.atg_narrow_copy(self, dim, start, length)
}

export const atg_narrow_copy_out = ({ out, self, dim, start, length }: { out: CTensor; self: CTensor; dim: number; start: number; length: number }): CTensor => {
  return addon.atg_narrow_copy_out(out, self, dim, start, length)
}

export const atg_narrow = ({ self, dim, start, length }: { self: CTensor; dim: number; start: number; length: number }): CTensor => {
  return addon.atg_narrow(self, dim, start, length)
}

export const atg_narrow_tensor = ({ self, dim, start, length }: { self: CTensor; dim: number; start: CTensor; length: number }): CTensor => {
  return addon.atg_narrow_tensor(self, dim, start, length)
}

export const atg_native_batch_norm = ({ input, weight, bias, running_mean, running_var, training, momentum, eps }: { input: CTensor; weight?: CTensor; bias?: CTensor; running_mean?: CTensor; running_var?: CTensor; training: boolean; momentum: number; eps: number }): CTensor[] => {
  return addon.atg_native_batch_norm(input, weight, bias, running_mean, running_var, training, momentum, eps)
}

export const atg_native_batch_norm_out = ({ out, save_mean, save_invstd, input, weight, bias, running_mean, running_var, training, momentum, eps }: { out: CTensor; save_mean: CTensor; save_invstd: CTensor; input: CTensor; weight?: CTensor; bias?: CTensor; running_mean?: CTensor; running_var?: CTensor; training: boolean; momentum: number; eps: number }): CTensor[] => {
  return addon.atg_native_batch_norm_out(out, save_mean, save_invstd, input, weight, bias, running_mean, running_var, training, momentum, eps)
}

export const atg__native_batch_norm_legit_no_stats = ({ input, weight, bias, training, momentum, eps }: { input: CTensor; weight?: CTensor; bias?: CTensor; training: boolean; momentum: number; eps: number }): CTensor[] => {
  return addon.atg__native_batch_norm_legit_no_stats(input, weight, bias, training, momentum, eps)
}

export const atg__native_batch_norm_legit = ({ input, weight, bias, running_mean, running_var, training, momentum, eps }: { input: CTensor; weight?: CTensor; bias?: CTensor; running_mean: CTensor; running_var: CTensor; training: boolean; momentum: number; eps: number }): CTensor[] => {
  return addon.atg__native_batch_norm_legit(input, weight, bias, running_mean, running_var, training, momentum, eps)
}

export const atg__native_batch_norm_legit_no_stats_out = ({ out, save_mean, save_invstd, input, weight, bias, training, momentum, eps }: { out: CTensor; save_mean: CTensor; save_invstd: CTensor; input: CTensor; weight?: CTensor; bias?: CTensor; training: boolean; momentum: number; eps: number }): CTensor[] => {
  return addon.atg__native_batch_norm_legit_no_stats_out(out, save_mean, save_invstd, input, weight, bias, training, momentum, eps)
}

export const atg__native_batch_norm_legit_out = ({ out, save_mean, save_invstd, input, weight, bias, running_mean, running_var, training, momentum, eps }: { out: CTensor; save_mean: CTensor; save_invstd: CTensor; input: CTensor; weight?: CTensor; bias?: CTensor; running_mean: CTensor; running_var: CTensor; training: boolean; momentum: number; eps: number }): CTensor[] => {
  return addon.atg__native_batch_norm_legit_out(out, save_mean, save_invstd, input, weight, bias, running_mean, running_var, training, momentum, eps)
}

export const atg_batch_norm_stats = ({ input, eps }: { input: CTensor; eps: number }): CTensor[] => {
  return addon.atg_batch_norm_stats(input, eps)
}

export const atg_batch_norm_stats_out = ({ out0, out1, input, eps }: { out0: CTensor; out1: CTensor; input: CTensor; eps: number }): CTensor[] => {
  return addon.atg_batch_norm_stats_out(out0, out1, input, eps)
}

export const atg_batch_norm_elemt = ({ input, weight, bias, mean, invstd, eps }: { input: CTensor; weight?: CTensor; bias?: CTensor; mean: CTensor; invstd: CTensor; eps: number }): CTensor => {
  return addon.atg_batch_norm_elemt(input, weight, bias, mean, invstd, eps)
}

export const atg_batch_norm_elemt_out = ({ out, input, weight, bias, mean, invstd, eps }: { out: CTensor; input: CTensor; weight?: CTensor; bias?: CTensor; mean: CTensor; invstd: CTensor; eps: number }): CTensor => {
  return addon.atg_batch_norm_elemt_out(out, input, weight, bias, mean, invstd, eps)
}

export const atg_batch_norm_gather_stats = ({ input, mean, invstd, running_mean, running_var, momentum, eps, count }: { input: CTensor; mean: CTensor; invstd: CTensor; running_mean?: CTensor; running_var?: CTensor; momentum: number; eps: number; count: number }): CTensor[] => {
  return addon.atg_batch_norm_gather_stats(input, mean, invstd, running_mean, running_var, momentum, eps, count)
}

export const atg_batch_norm_gather_stats_out = ({ out0, out1, input, mean, invstd, running_mean, running_var, momentum, eps, count }: { out0: CTensor; out1: CTensor; input: CTensor; mean: CTensor; invstd: CTensor; running_mean?: CTensor; running_var?: CTensor; momentum: number; eps: number; count: number }): CTensor[] => {
  return addon.atg_batch_norm_gather_stats_out(out0, out1, input, mean, invstd, running_mean, running_var, momentum, eps, count)
}

export const atg_batch_norm_gather_stats_with_counts = ({ input, mean, invstd, running_mean, running_var, momentum, eps, counts }: { input: CTensor; mean: CTensor; invstd: CTensor; running_mean?: CTensor; running_var?: CTensor; momentum: number; eps: number; counts: CTensor }): CTensor[] => {
  return addon.atg_batch_norm_gather_stats_with_counts(input, mean, invstd, running_mean, running_var, momentum, eps, counts)
}

export const atg_batch_norm_gather_stats_with_counts_out = ({ out0, out1, input, mean, invstd, running_mean, running_var, momentum, eps, counts }: { out0: CTensor; out1: CTensor; input: CTensor; mean: CTensor; invstd: CTensor; running_mean?: CTensor; running_var?: CTensor; momentum: number; eps: number; counts: CTensor }): CTensor[] => {
  return addon.atg_batch_norm_gather_stats_with_counts_out(out0, out1, input, mean, invstd, running_mean, running_var, momentum, eps, counts)
}

export const atg_batch_norm_backward_reduce = ({ grad_out, input, mean, invstd, weight, input_g, weight_g, bias_g }: { grad_out: CTensor; input: CTensor; mean: CTensor; invstd: CTensor; weight?: CTensor; input_g: boolean; weight_g: boolean; bias_g: boolean }): CTensor[] => {
  return addon.atg_batch_norm_backward_reduce(grad_out, input, mean, invstd, weight, input_g, weight_g, bias_g)
}

export const atg_batch_norm_backward_reduce_out = ({ out0, out1, out2, out3, grad_out, input, mean, invstd, weight, input_g, weight_g, bias_g }: { out0: CTensor; out1: CTensor; out2: CTensor; out3: CTensor; grad_out: CTensor; input: CTensor; mean: CTensor; invstd: CTensor; weight?: CTensor; input_g: boolean; weight_g: boolean; bias_g: boolean }): CTensor[] => {
  return addon.atg_batch_norm_backward_reduce_out(out0, out1, out2, out3, grad_out, input, mean, invstd, weight, input_g, weight_g, bias_g)
}

export const atg_batch_norm_backward_elemt = ({ grad_out, input, mean, invstd, weight, mean_dy, mean_dy_xmu, count }: { grad_out: CTensor; input: CTensor; mean: CTensor; invstd: CTensor; weight?: CTensor; mean_dy: CTensor; mean_dy_xmu: CTensor; count: CTensor }): CTensor => {
  return addon.atg_batch_norm_backward_elemt(grad_out, input, mean, invstd, weight, mean_dy, mean_dy_xmu, count)
}

export const atg_batch_norm_backward_elemt_out = ({ out, grad_out, input, mean, invstd, weight, mean_dy, mean_dy_xmu, count }: { out: CTensor; grad_out: CTensor; input: CTensor; mean: CTensor; invstd: CTensor; weight?: CTensor; mean_dy: CTensor; mean_dy_xmu: CTensor; count: CTensor }): CTensor => {
  return addon.atg_batch_norm_backward_elemt_out(out, grad_out, input, mean, invstd, weight, mean_dy, mean_dy_xmu, count)
}

export const atg_batch_norm_update_stats = ({ input, running_mean, running_var, momentum }: { input: CTensor; running_mean?: CTensor; running_var?: CTensor; momentum: number }): CTensor[] => {
  return addon.atg_batch_norm_update_stats(input, running_mean, running_var, momentum)
}

export const atg_batch_norm_update_stats_out = ({ out0, out1, input, running_mean, running_var, momentum }: { out0: CTensor; out1: CTensor; input: CTensor; running_mean?: CTensor; running_var?: CTensor; momentum: number }): CTensor[] => {
  return addon.atg_batch_norm_update_stats_out(out0, out1, input, running_mean, running_var, momentum)
}

export const atg_is_vulkan_available = (_: Record<string, never>): boolean => {
  return addon.atg_is_vulkan_available()
}

export const atg__nnpack_available = (_: Record<string, never>): boolean => {
  return addon.atg__nnpack_available()
}

export const atg__nnpack_spatial_convolution = ({ input, weight, bias, padding, stride }: { input: CTensor; weight: CTensor; bias?: CTensor; padding: number[]; stride: number[] }): CTensor => {
  return addon.atg__nnpack_spatial_convolution(input, weight, bias, padding, stride)
}

export const atg__nnpack_spatial_convolution_out = ({ out, input, weight, bias, padding, stride }: { out: CTensor; input: CTensor; weight: CTensor; bias?: CTensor; padding: number[]; stride: number[] }): CTensor => {
  return addon.atg__nnpack_spatial_convolution_out(out, input, weight, bias, padding, stride)
}

export const atg_ones = ({ size, options }: { size: number[]; options: { device: number, dtype: number } }): CTensor => {
  return addon.atg_ones(size, options)
}

export const atg_ones_out = ({ out, size }: { out: CTensor; size: number[] }): CTensor => {
  return addon.atg_ones_out(out, size)
}

export const atg_ones_like = ({ self, options, memory_format }: { self: CTensor; options: { device: number, dtype: number }; memory_format: number }): CTensor => {
  return addon.atg_ones_like(self, options, memory_format)
}

export const atg_ones_like_out = ({ out, self, memory_format }: { out: CTensor; self: CTensor; memory_format: number }): CTensor => {
  return addon.atg_ones_like_out(out, self, memory_format)
}

export const atg_pairwise_distance = ({ x1, x2, p, eps, keepdim }: { x1: CTensor; x2: CTensor; p: number; eps: number; keepdim: boolean }): CTensor => {
  return addon.atg_pairwise_distance(x1, x2, p, eps, keepdim)
}

export const atg_cdist = ({ x1, x2, p, compute_mode }: { x1: CTensor; x2: CTensor; p: number; compute_mode?: number }): CTensor => {
  return addon.atg_cdist(x1, x2, p, compute_mode)
}

export const atg__euclidean_dist = ({ x1, x2 }: { x1: CTensor; x2: CTensor }): CTensor => {
  return addon.atg__euclidean_dist(x1, x2)
}

export const atg__euclidean_dist_out = ({ out, x1, x2 }: { out: CTensor; x1: CTensor; x2: CTensor }): CTensor => {
  return addon.atg__euclidean_dist_out(out, x1, x2)
}

export const atg__cdist_backward = ({ grad, x1, x2, p, cdist }: { grad: CTensor; x1: CTensor; x2: CTensor; p: number; cdist: CTensor }): CTensor => {
  return addon.atg__cdist_backward(grad, x1, x2, p, cdist)
}

export const atg__cdist_backward_out = ({ out, grad, x1, x2, p, cdist }: { out: CTensor; grad: CTensor; x1: CTensor; x2: CTensor; p: number; cdist: CTensor }): CTensor => {
  return addon.atg__cdist_backward_out(out, grad, x1, x2, p, cdist)
}

export const atg_pdist = ({ self, p }: { self: CTensor; p: number }): CTensor => {
  return addon.atg_pdist(self, p)
}

export const atg__pdist_backward = ({ grad, self, p, pdist }: { grad: CTensor; self: CTensor; p: number; pdist: CTensor }): CTensor => {
  return addon.atg__pdist_backward(grad, self, p, pdist)
}

export const atg__pdist_backward_out = ({ out, grad, self, p, pdist }: { out: CTensor; grad: CTensor; self: CTensor; p: number; pdist: CTensor }): CTensor => {
  return addon.atg__pdist_backward_out(out, grad, self, p, pdist)
}

export const atg_cosine_similarity = ({ x1, x2, dim, eps }: { x1: CTensor; x2: CTensor; dim: number; eps: number }): CTensor => {
  return addon.atg_cosine_similarity(x1, x2, dim, eps)
}

export const atg_permute = ({ self, dims }: { self: CTensor; dims: number[] }): CTensor => {
  return addon.atg_permute(self, dims)
}

export const atg_movedim = ({ self, source, destination }: { self: CTensor; source: number[]; destination: number[] }): CTensor => {
  return addon.atg_movedim(self, source, destination)
}

export const atg_movedim_int = ({ self, source, destination }: { self: CTensor; source: number; destination: number }): CTensor => {
  return addon.atg_movedim_int(self, source, destination)
}

export const atg_moveaxis = ({ self, source, destination }: { self: CTensor; source: number[]; destination: number[] }): CTensor => {
  return addon.atg_moveaxis(self, source, destination)
}

export const atg_moveaxis_int = ({ self, source, destination }: { self: CTensor; source: number; destination: number }): CTensor => {
  return addon.atg_moveaxis_int(self, source, destination)
}

export const atg_numpy_T = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_numpy_T(self)
}

export const atg_matrix_H = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_matrix_H(self)
}

export const atg_mT = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_mT(self)
}

export const atg_mH = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_mH(self)
}

export const atg_adjoint = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_adjoint(self)
}

export const atg_pixel_shuffle = ({ self, upscale_factor }: { self: CTensor; upscale_factor: number }): CTensor => {
  return addon.atg_pixel_shuffle(self, upscale_factor)
}

export const atg_pixel_shuffle_out = ({ out, self, upscale_factor }: { out: CTensor; self: CTensor; upscale_factor: number }): CTensor => {
  return addon.atg_pixel_shuffle_out(out, self, upscale_factor)
}

export const atg_pixel_unshuffle = ({ self, downscale_factor }: { self: CTensor; downscale_factor: number }): CTensor => {
  return addon.atg_pixel_unshuffle(self, downscale_factor)
}

export const atg_pixel_unshuffle_out = ({ out, self, downscale_factor }: { out: CTensor; self: CTensor; downscale_factor: number }): CTensor => {
  return addon.atg_pixel_unshuffle_out(out, self, downscale_factor)
}

export const atg_channel_shuffle = ({ self, groups }: { self: CTensor; groups: number }): CTensor => {
  return addon.atg_channel_shuffle(self, groups)
}

export const atg_channel_shuffle_out = ({ out, self, groups }: { out: CTensor; self: CTensor; groups: number }): CTensor => {
  return addon.atg_channel_shuffle_out(out, self, groups)
}

export const atg_native_channel_shuffle = ({ self, groups }: { self: CTensor; groups: number }): CTensor => {
  return addon.atg_native_channel_shuffle(self, groups)
}

export const atg_is_pinned = ({ self, device }: { self: CTensor; device: number }): boolean => {
  return addon.atg_is_pinned(self, device)
}

export const atg_pin_memory = ({ self, device }: { self: CTensor; device: number }): CTensor => {
  return addon.atg_pin_memory(self, device)
}

export const atg__pin_memory = ({ self, device }: { self: CTensor; device: number }): CTensor => {
  return addon.atg__pin_memory(self, device)
}

export const atg__pin_memory_out = ({ out, self, device }: { out: CTensor; self: CTensor; device: number }): CTensor => {
  return addon.atg__pin_memory_out(out, self, device)
}

export const atg_pinverse = ({ self, rcond }: { self: CTensor; rcond: number }): CTensor => {
  return addon.atg_pinverse(self, rcond)
}

export const atg_poisson_nll_loss = ({ input, target, log_input, full, eps, reduction }: { input: CTensor; target: CTensor; log_input: boolean; full: boolean; eps: number; reduction: number }): CTensor => {
  return addon.atg_poisson_nll_loss(input, target, log_input, full, eps, reduction)
}

export const atg_rad2deg = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_rad2deg(self)
}

export const atg_rad2deg_out = ({ out, self }: { out: CTensor; self: CTensor }): CTensor => {
  return addon.atg_rad2deg_out(out, self)
}

export const atg_rad2deg_ = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_rad2deg_(self)
}

export const atg_deg2rad = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_deg2rad(self)
}

export const atg_deg2rad_out = ({ out, self }: { out: CTensor; self: CTensor }): CTensor => {
  return addon.atg_deg2rad_out(out, self)
}

export const atg_deg2rad_ = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_deg2rad_(self)
}

export const atg_scalar_tensor = ({ s, options }: { s: CScalar; options: { device: number, dtype: number } }): CTensor => {
  return addon.atg_scalar_tensor(s, options)
}

export const atg_scalar_tensor_out = ({ out, s }: { out: CTensor; s: CScalar }): CTensor => {
  return addon.atg_scalar_tensor_out(out, s)
}

export const atg_rand = ({ size, options }: { size: number[]; options: { device: number, dtype: number } }): CTensor => {
  return addon.atg_rand(size, options)
}

export const atg_rand_out = ({ out, size }: { out: CTensor; size: number[] }): CTensor => {
  return addon.atg_rand_out(out, size)
}

export const atg_rand_like = ({ self, options, memory_format }: { self: CTensor; options: { device: number, dtype: number }; memory_format: number }): CTensor => {
  return addon.atg_rand_like(self, options, memory_format)
}

export const atg_rand_like_out = ({ out, self, memory_format }: { out: CTensor; self: CTensor; memory_format: number }): CTensor => {
  return addon.atg_rand_like_out(out, self, memory_format)
}

export const atg_randint = ({ high, size, options }: { high: number; size: number[]; options: { device: number, dtype: number } }): CTensor => {
  return addon.atg_randint(high, size, options)
}

export const atg_randint_low = ({ low, high, size, options }: { low: number; high: number; size: number[]; options: { device: number, dtype: number } }): CTensor => {
  return addon.atg_randint_low(low, high, size, options)
}

export const atg_randint_out = ({ out, high, size }: { out: CTensor; high: number; size: number[] }): CTensor => {
  return addon.atg_randint_out(out, high, size)
}

export const atg_randint_low_out = ({ out, low, high, size }: { out: CTensor; low: number; high: number; size: number[] }): CTensor => {
  return addon.atg_randint_low_out(out, low, high, size)
}

export const atg_randint_like = ({ self, high, options, memory_format }: { self: CTensor; high: number; options: { device: number, dtype: number }; memory_format: number }): CTensor => {
  return addon.atg_randint_like(self, high, options, memory_format)
}

export const atg_randint_like_low_dtype = ({ self, low, high, options, memory_format }: { self: CTensor; low: number; high: number; options: { device: number, dtype: number }; memory_format: number }): CTensor => {
  return addon.atg_randint_like_low_dtype(self, low, high, options, memory_format)
}

export const atg_randint_like_out = ({ out, self, high, memory_format }: { out: CTensor; self: CTensor; high: number; memory_format: number }): CTensor => {
  return addon.atg_randint_like_out(out, self, high, memory_format)
}

export const atg_randint_like_low_dtype_out = ({ out, self, low, high, memory_format }: { out: CTensor; self: CTensor; low: number; high: number; memory_format: number }): CTensor => {
  return addon.atg_randint_like_low_dtype_out(out, self, low, high, memory_format)
}

export const atg_randn = ({ size, options }: { size: number[]; options: { device: number, dtype: number } }): CTensor => {
  return addon.atg_randn(size, options)
}

export const atg_randn_out = ({ out, size }: { out: CTensor; size: number[] }): CTensor => {
  return addon.atg_randn_out(out, size)
}

export const atg_randn_like = ({ self, options, memory_format }: { self: CTensor; options: { device: number, dtype: number }; memory_format: number }): CTensor => {
  return addon.atg_randn_like(self, options, memory_format)
}

export const atg_randn_like_out = ({ out, self, memory_format }: { out: CTensor; self: CTensor; memory_format: number }): CTensor => {
  return addon.atg_randn_like_out(out, self, memory_format)
}

export const atg_randperm = ({ n, options }: { n: number; options: { device: number, dtype: number } }): CTensor => {
  return addon.atg_randperm(n, options)
}

export const atg_randperm_out = ({ out, n }: { out: CTensor; n: number }): CTensor => {
  return addon.atg_randperm_out(out, n)
}

export const atg_range = ({ start, end, options }: { start: CScalar; end: CScalar; options: { device: number, dtype: number } }): CTensor => {
  return addon.atg_range(start, end, options)
}

export const atg_range_step = ({ start, end, step, options }: { start: CScalar; end: CScalar; step: CScalar; options: { device: number, dtype: number } }): CTensor => {
  return addon.atg_range_step(start, end, step, options)
}

export const atg_range_out_ = ({ out, start, end }: { out: CTensor; start: CScalar; end: CScalar }): CTensor => {
  return addon.atg_range_out_(out, start, end)
}

export const atg_range_out = ({ out, start, end, step }: { out: CTensor; start: CScalar; end: CScalar; step: CScalar }): CTensor => {
  return addon.atg_range_out(out, start, end, step)
}

export const atg_ravel = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_ravel(self)
}

export const atg_reciprocal = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_reciprocal(self)
}

export const atg_reciprocal_out = ({ out, self }: { out: CTensor; self: CTensor }): CTensor => {
  return addon.atg_reciprocal_out(out, self)
}

export const atg_reciprocal_ = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_reciprocal_(self)
}

export const atg_neg = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_neg(self)
}

export const atg_neg_out = ({ out, self }: { out: CTensor; self: CTensor }): CTensor => {
  return addon.atg_neg_out(out, self)
}

export const atg_neg_ = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_neg_(self)
}

export const atg_negative = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_negative(self)
}

export const atg_negative_out = ({ out, self }: { out: CTensor; self: CTensor }): CTensor => {
  return addon.atg_negative_out(out, self)
}

export const atg_negative_ = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_negative_(self)
}

export const atg_repeat = ({ self, repeats }: { self: CTensor; repeats: number[] }): CTensor => {
  return addon.atg_repeat(self, repeats)
}

export const atg_repeat_out = ({ out, self, repeats }: { out: CTensor; self: CTensor; repeats: number[] }): CTensor => {
  return addon.atg_repeat_out(out, self, repeats)
}

export const atg_repeat_interleave = ({ repeats, output_size }: { repeats: CTensor; output_size?: number }): CTensor => {
  return addon.atg_repeat_interleave(repeats, output_size)
}

export const atg_repeat_interleave_self_tensor = ({ self, repeats, dim, output_size }: { self: CTensor; repeats: CTensor; dim?: number; output_size?: number }): CTensor => {
  return addon.atg_repeat_interleave_self_tensor(self, repeats, dim, output_size)
}

export const atg_repeat_interleave_self_int = ({ self, repeats, dim, output_size }: { self: CTensor; repeats: number; dim?: number; output_size?: number }): CTensor => {
  return addon.atg_repeat_interleave_self_int(self, repeats, dim, output_size)
}

export const atg_repeat_interleave_tensor_out = ({ out, repeats, output_size }: { out: CTensor; repeats: CTensor; output_size?: number }): CTensor => {
  return addon.atg_repeat_interleave_tensor_out(out, repeats, output_size)
}

export const atg_reshape = ({ self, shape }: { self: CTensor; shape: number[] }): CTensor => {
  return addon.atg_reshape(self, shape)
}

export const atg__reshape_copy = ({ self, size }: { self: CTensor; size: number[] }): CTensor => {
  return addon.atg__reshape_copy(self, size)
}

export const atg__reshape_alias = ({ self, size, stride }: { self: CTensor; size: number[]; stride: number[] }): CTensor => {
  return addon.atg__reshape_alias(self, size, stride)
}

export const atg__mkldnn_reshape = ({ self, shape }: { self: CTensor; shape: number[] }): CTensor => {
  return addon.atg__mkldnn_reshape(self, shape)
}

export const atg__mkldnn_reshape_out = ({ out, self, shape }: { out: CTensor; self: CTensor; shape: number[] }): CTensor => {
  return addon.atg__mkldnn_reshape_out(out, self, shape)
}

export const atg_reshape_as = ({ self, other }: { self: CTensor; other: CTensor }): CTensor => {
  return addon.atg_reshape_as(self, other)
}

export const atg_round = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_round(self)
}

export const atg_round_decimals = ({ self, decimals }: { self: CTensor; decimals: number }): CTensor => {
  return addon.atg_round_decimals(self, decimals)
}

export const atg_round_out = ({ out, self }: { out: CTensor; self: CTensor }): CTensor => {
  return addon.atg_round_out(out, self)
}

export const atg_round_decimals_out = ({ out, self, decimals }: { out: CTensor; self: CTensor; decimals: number }): CTensor => {
  return addon.atg_round_decimals_out(out, self, decimals)
}

export const atg_round_ = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_round_(self)
}

export const atg_round_decimals_ = ({ self, decimals }: { self: CTensor; decimals: number }): CTensor => {
  return addon.atg_round_decimals_(self, decimals)
}

export const atg_rrelu = ({ self, lower, upper, training }: { self: CTensor; lower: CScalar; upper: CScalar; training: boolean }): CTensor => {
  return addon.atg_rrelu(self, lower, upper, training)
}

export const atg_rrelu_ = ({ self, lower, upper, training }: { self: CTensor; lower: CScalar; upper: CScalar; training: boolean }): CTensor => {
  return addon.atg_rrelu_(self, lower, upper, training)
}

export const atg_relu = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_relu(self)
}

export const atg_relu_out = ({ out, self }: { out: CTensor; self: CTensor }): CTensor => {
  return addon.atg_relu_out(out, self)
}

export const atg_relu_ = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_relu_(self)
}

export const atg_relu6 = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_relu6(self)
}

export const atg_relu6_ = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_relu6_(self)
}

export const atg_prelu = ({ self, weight }: { self: CTensor; weight: CTensor }): CTensor => {
  return addon.atg_prelu(self, weight)
}

export const atg__prelu_kernel = ({ self, weight }: { self: CTensor; weight: CTensor }): CTensor => {
  return addon.atg__prelu_kernel(self, weight)
}

export const atg__prelu_kernel_backward = ({ grad_output, self, weight }: { grad_output: CTensor; self: CTensor; weight: CTensor }): CTensor[] => {
  return addon.atg__prelu_kernel_backward(grad_output, self, weight)
}

export const atg_gelu = ({ self, approximate }: { self: CTensor; approximate: string }): CTensor => {
  return addon.atg_gelu(self, approximate)
}

export const atg_gelu_out = ({ out, self, approximate }: { out: CTensor; self: CTensor; approximate: string }): CTensor => {
  return addon.atg_gelu_out(out, self, approximate)
}

export const atg_gelu_ = ({ self, approximate }: { self: CTensor; approximate: string }): CTensor => {
  return addon.atg_gelu_(self, approximate)
}

export const atg_gelu_backward = ({ grad_output, self, approximate }: { grad_output: CTensor; self: CTensor; approximate: string }): CTensor => {
  return addon.atg_gelu_backward(grad_output, self, approximate)
}

export const atg_gelu_backward_grad_input = ({ grad_input, grad_output, self, approximate }: { grad_input: CTensor; grad_output: CTensor; self: CTensor; approximate: string }): CTensor => {
  return addon.atg_gelu_backward_grad_input(grad_input, grad_output, self, approximate)
}

export const atg_infinitely_differentiable_gelu_backward = ({ grad, self }: { grad: CTensor; self: CTensor }): CTensor => {
  return addon.atg_infinitely_differentiable_gelu_backward(grad, self)
}

export const atg_hardshrink = ({ self, lambd }: { self: CTensor; lambd: CScalar }): CTensor => {
  return addon.atg_hardshrink(self, lambd)
}

export const atg_hardshrink_out = ({ out, self, lambd }: { out: CTensor; self: CTensor; lambd: CScalar }): CTensor => {
  return addon.atg_hardshrink_out(out, self, lambd)
}

export const atg_hardshrink_backward = ({ grad_out, self, lambd }: { grad_out: CTensor; self: CTensor; lambd: CScalar }): CTensor => {
  return addon.atg_hardshrink_backward(grad_out, self, lambd)
}

export const atg_hardshrink_backward_grad_input = ({ grad_input, grad_out, self, lambd }: { grad_input: CTensor; grad_out: CTensor; self: CTensor; lambd: CScalar }): CTensor => {
  return addon.atg_hardshrink_backward_grad_input(grad_input, grad_out, self, lambd)
}

export const atg_rsqrt = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_rsqrt(self)
}

export const atg_rsqrt_out = ({ out, self }: { out: CTensor; self: CTensor }): CTensor => {
  return addon.atg_rsqrt_out(out, self)
}

export const atg_rsqrt_ = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_rsqrt_(self)
}

export const atg_select = ({ self, dim, index }: { self: CTensor; dim: number; index: number }): CTensor => {
  return addon.atg_select(self, dim, index)
}

export const atg_select_backward = ({ grad_output, input_sizes, dim, index }: { grad_output: CTensor; input_sizes: number[]; dim: number; index: number }): CTensor => {
  return addon.atg_select_backward(grad_output, input_sizes, dim, index)
}

export const atg_select_backward_out = ({ out, grad_output, input_sizes, dim, index }: { out: CTensor; grad_output: CTensor; input_sizes: number[]; dim: number; index: number }): CTensor => {
  return addon.atg_select_backward_out(out, grad_output, input_sizes, dim, index)
}

export const atg__nested_select_backward = ({ grad_output, self, dim, index }: { grad_output: CTensor; self: CTensor; dim: number; index: number }): CTensor => {
  return addon.atg__nested_select_backward(grad_output, self, dim, index)
}

export const atg_selu = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_selu(self)
}

export const atg_selu_ = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_selu_(self)
}

export const atg_celu = ({ self, alpha }: { self: CTensor; alpha: CScalar }): CTensor => {
  return addon.atg_celu(self, alpha)
}

export const atg_celu_out = ({ out, self, alpha }: { out: CTensor; self: CTensor; alpha: CScalar }): CTensor => {
  return addon.atg_celu_out(out, self, alpha)
}

export const atg_celu_ = ({ self, alpha }: { self: CTensor; alpha: CScalar }): CTensor => {
  return addon.atg_celu_(self, alpha)
}

export const atg_silu = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_silu(self)
}

export const atg_silu_out = ({ out, self }: { out: CTensor; self: CTensor }): CTensor => {
  return addon.atg_silu_out(out, self)
}

export const atg_silu_ = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_silu_(self)
}

export const atg_silu_backward = ({ grad_output, self }: { grad_output: CTensor; self: CTensor }): CTensor => {
  return addon.atg_silu_backward(grad_output, self)
}

export const atg_silu_backward_grad_input = ({ grad_input, grad_output, self }: { grad_input: CTensor; grad_output: CTensor; self: CTensor }): CTensor => {
  return addon.atg_silu_backward_grad_input(grad_input, grad_output, self)
}

export const atg_mish = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_mish(self)
}

export const atg_mish_out = ({ out, self }: { out: CTensor; self: CTensor }): CTensor => {
  return addon.atg_mish_out(out, self)
}

export const atg_mish_ = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_mish_(self)
}

export const atg_mish_backward = ({ grad_output, self }: { grad_output: CTensor; self: CTensor }): CTensor => {
  return addon.atg_mish_backward(grad_output, self)
}

export const atg_sigmoid = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_sigmoid(self)
}

export const atg_sigmoid_out = ({ out, self }: { out: CTensor; self: CTensor }): CTensor => {
  return addon.atg_sigmoid_out(out, self)
}

export const atg_sigmoid_ = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_sigmoid_(self)
}

export const atg_logit = ({ self, eps }: { self: CTensor; eps?: number }): CTensor => {
  return addon.atg_logit(self, eps)
}

export const atg_logit_out = ({ out, self, eps }: { out: CTensor; self: CTensor; eps?: number }): CTensor => {
  return addon.atg_logit_out(out, self, eps)
}

export const atg_logit_ = ({ self, eps }: { self: CTensor; eps?: number }): CTensor => {
  return addon.atg_logit_(self, eps)
}

export const atg_sin = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_sin(self)
}

export const atg_sin_out = ({ out, self }: { out: CTensor; self: CTensor }): CTensor => {
  return addon.atg_sin_out(out, self)
}

export const atg_sin_ = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_sin_(self)
}

export const atg_sinc = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_sinc(self)
}

export const atg_sinc_out = ({ out, self }: { out: CTensor; self: CTensor }): CTensor => {
  return addon.atg_sinc_out(out, self)
}

export const atg_sinc_ = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_sinc_(self)
}

export const atg_sinh = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_sinh(self)
}

export const atg_sinh_out = ({ out, self }: { out: CTensor; self: CTensor }): CTensor => {
  return addon.atg_sinh_out(out, self)
}

export const atg_sinh_ = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_sinh_(self)
}

export const atg_detach = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_detach(self)
}

export const atg_detach_ = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_detach_(self)
}

export const atg_slice = ({ self, dim, start, end, step }: { self: CTensor; dim: number; start?: number; end?: number; step: number }): CTensor => {
  return addon.atg_slice(self, dim, start, end, step)
}

export const atg_slice_backward = ({ grad_output, input_sizes, dim, start, end, step }: { grad_output: CTensor; input_sizes: number[]; dim: number; start: number; end: number; step: number }): CTensor => {
  return addon.atg_slice_backward(grad_output, input_sizes, dim, start, end, step)
}

export const atg_slice_backward_out = ({ out, grad_output, input_sizes, dim, start, end, step }: { out: CTensor; grad_output: CTensor; input_sizes: number[]; dim: number; start: number; end: number; step: number }): CTensor => {
  return addon.atg_slice_backward_out(out, grad_output, input_sizes, dim, start, end, step)
}

export const atg_slice_scatter = ({ self, src, dim, start, end, step }: { self: CTensor; src: CTensor; dim: number; start?: number; end?: number; step: number }): CTensor => {
  return addon.atg_slice_scatter(self, src, dim, start, end, step)
}

export const atg_slice_scatter_out = ({ out, self, src, dim, start, end, step }: { out: CTensor; self: CTensor; src: CTensor; dim: number; start?: number; end?: number; step: number }): CTensor => {
  return addon.atg_slice_scatter_out(out, self, src, dim, start, end, step)
}

export const atg_select_scatter = ({ self, src, dim, index }: { self: CTensor; src: CTensor; dim: number; index: number }): CTensor => {
  return addon.atg_select_scatter(self, src, dim, index)
}

export const atg_select_scatter_out = ({ out, self, src, dim, index }: { out: CTensor; self: CTensor; src: CTensor; dim: number; index: number }): CTensor => {
  return addon.atg_select_scatter_out(out, self, src, dim, index)
}

export const atg_diagonal_scatter = ({ self, src, offset, dim1, dim2 }: { self: CTensor; src: CTensor; offset: number; dim1: number; dim2: number }): CTensor => {
  return addon.atg_diagonal_scatter(self, src, offset, dim1, dim2)
}

export const atg_diagonal_scatter_out = ({ out, self, src, offset, dim1, dim2 }: { out: CTensor; self: CTensor; src: CTensor; offset: number; dim1: number; dim2: number }): CTensor => {
  return addon.atg_diagonal_scatter_out(out, self, src, offset, dim1, dim2)
}

export const atg_as_strided_scatter = ({ self, src, size, stride, storage_offset }: { self: CTensor; src: CTensor; size: number[]; stride: number[]; storage_offset?: number }): CTensor => {
  return addon.atg_as_strided_scatter(self, src, size, stride, storage_offset)
}

export const atg_as_strided_scatter_out = ({ out, self, src, size, stride, storage_offset }: { out: CTensor; self: CTensor; src: CTensor; size: number[]; stride: number[]; storage_offset?: number }): CTensor => {
  return addon.atg_as_strided_scatter_out(out, self, src, size, stride, storage_offset)
}

export const atg_smm = ({ self, mat2 }: { self: CTensor; mat2: CTensor }): CTensor => {
  return addon.atg_smm(self, mat2)
}

export const atg_softmax = ({ self, dim, dtype }: { self: CTensor; dim: number; dtype: number }): CTensor => {
  return addon.atg_softmax(self, dim, dtype)
}

export const atg_softmax_int_out = ({ out, self, dim, dtype }: { out: CTensor; self: CTensor; dim: number; dtype: number }): CTensor => {
  return addon.atg_softmax_int_out(out, self, dim, dtype)
}

export const atg__softmax = ({ self, dim, half_to_float }: { self: CTensor; dim: number; half_to_float: boolean }): CTensor => {
  return addon.atg__softmax(self, dim, half_to_float)
}

export const atg__softmax_out = ({ out, self, dim, half_to_float }: { out: CTensor; self: CTensor; dim: number; half_to_float: boolean }): CTensor => {
  return addon.atg__softmax_out(out, self, dim, half_to_float)
}

export const atg__softmax_backward_data = ({ grad_output, output, dim, input_dtype }: { grad_output: CTensor; output: CTensor; dim: number; input_dtype: number }): CTensor => {
  return addon.atg__softmax_backward_data(grad_output, output, dim, input_dtype)
}

export const atg__softmax_backward_data_out = ({ grad_input, grad_output, output, dim, input_dtype }: { grad_input: CTensor; grad_output: CTensor; output: CTensor; dim: number; input_dtype: number }): CTensor => {
  return addon.atg__softmax_backward_data_out(grad_input, grad_output, output, dim, input_dtype)
}

export const atg_squeeze = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_squeeze(self)
}

export const atg_squeeze_dim = ({ self, dim }: { self: CTensor; dim: number }): CTensor => {
  return addon.atg_squeeze_dim(self, dim)
}

export const atg_squeeze_dims = ({ self, dim }: { self: CTensor; dim: number[] }): CTensor => {
  return addon.atg_squeeze_dims(self, dim)
}

export const atg_squeeze_ = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_squeeze_(self)
}

export const atg_squeeze_dim_ = ({ self, dim }: { self: CTensor; dim: number }): CTensor => {
  return addon.atg_squeeze_dim_(self, dim)
}

export const atg_squeeze_dims_ = ({ self, dim }: { self: CTensor; dim: number[] }): CTensor => {
  return addon.atg_squeeze_dims_(self, dim)
}

export const atg_sspaddmm = ({ self, mat1, mat2, beta, alpha }: { self: CTensor; mat1: CTensor; mat2: CTensor; beta: CScalar; alpha: CScalar }): CTensor => {
  return addon.atg_sspaddmm(self, mat1, mat2, beta, alpha)
}

export const atg_sspaddmm_out = ({ out, self, mat1, mat2, beta, alpha }: { out: CTensor; self: CTensor; mat1: CTensor; mat2: CTensor; beta: CScalar; alpha: CScalar }): CTensor => {
  return addon.atg_sspaddmm_out(out, self, mat1, mat2, beta, alpha)
}

export const atg_stack = ({ tensors, dim }: { tensors: CTensor[]; dim: number }): CTensor => {
  return addon.atg_stack(tensors, dim)
}

export const atg_stack_out = ({ out, tensors, dim }: { out: CTensor; tensors: CTensor[]; dim: number }): CTensor => {
  return addon.atg_stack_out(out, tensors, dim)
}

export const atg__stack = ({ tensors, dim }: { tensors: CTensor[]; dim: number }): CTensor => {
  return addon.atg__stack(tensors, dim)
}

export const atg__stack_out = ({ out, tensors, dim }: { out: CTensor; tensors: CTensor[]; dim: number }): CTensor => {
  return addon.atg__stack_out(out, tensors, dim)
}

export const atg_hstack = ({ tensors }: { tensors: CTensor[] }): CTensor => {
  return addon.atg_hstack(tensors)
}

export const atg_hstack_out = ({ out, tensors }: { out: CTensor; tensors: CTensor[] }): CTensor => {
  return addon.atg_hstack_out(out, tensors)
}

export const atg_vstack = ({ tensors }: { tensors: CTensor[] }): CTensor => {
  return addon.atg_vstack(tensors)
}

export const atg_vstack_out = ({ out, tensors }: { out: CTensor; tensors: CTensor[] }): CTensor => {
  return addon.atg_vstack_out(out, tensors)
}

export const atg_dstack = ({ tensors }: { tensors: CTensor[] }): CTensor => {
  return addon.atg_dstack(tensors)
}

export const atg_dstack_out = ({ out, tensors }: { out: CTensor; tensors: CTensor[] }): CTensor => {
  return addon.atg_dstack_out(out, tensors)
}

export const atg_stft = ({ self, n_fft, hop_length, win_length, window, normalized, onesided, return_complex }: { self: CTensor; n_fft: number; hop_length?: number; win_length?: number; window?: CTensor; normalized: boolean; onesided: boolean; return_complex: boolean }): CTensor => {
  return addon.atg_stft(self, n_fft, hop_length, win_length, window, normalized, onesided, return_complex)
}

export const atg_stft_center = ({ self, n_fft, hop_length, win_length, window, center, pad_mode, normalized, onesided, return_complex }: { self: CTensor; n_fft: number; hop_length?: number; win_length?: number; window?: CTensor; center: boolean; pad_mode: string; normalized: boolean; onesided: boolean; return_complex: boolean }): CTensor => {
  return addon.atg_stft_center(self, n_fft, hop_length, win_length, window, center, pad_mode, normalized, onesided, return_complex)
}

export const atg_istft = ({ self, n_fft, hop_length, win_length, window, center, normalized, onesided, length, return_complex }: { self: CTensor; n_fft: number; hop_length?: number; win_length?: number; window?: CTensor; center: boolean; normalized: boolean; onesided: boolean; length?: number; return_complex: boolean }): CTensor => {
  return addon.atg_istft(self, n_fft, hop_length, win_length, window, center, normalized, onesided, length, return_complex)
}

export const atg_sum = ({ self, dtype }: { self: CTensor; dtype: number }): CTensor => {
  return addon.atg_sum(self, dtype)
}

export const atg_sum_dim_intlist = ({ self, dim, keepdim, dtype }: { self: CTensor; dim?: number[]; keepdim: boolean; dtype: number }): CTensor => {
  return addon.atg_sum_dim_intlist(self, dim, keepdim, dtype)
}

export const atg_sum_out = ({ out, self, dtype }: { out: CTensor; self: CTensor; dtype: number }): CTensor => {
  return addon.atg_sum_out(out, self, dtype)
}

export const atg_sum_intlist_out = ({ out, self, dim, keepdim, dtype }: { out: CTensor; self: CTensor; dim?: number[]; keepdim: boolean; dtype: number }): CTensor => {
  return addon.atg_sum_intlist_out(out, self, dim, keepdim, dtype)
}

export const atg__nested_sum_backward = ({ grad, self, dim, keepdim }: { grad: CTensor; self: CTensor; dim?: number[]; keepdim: boolean }): CTensor => {
  return addon.atg__nested_sum_backward(grad, self, dim, keepdim)
}

export const atg_nansum = ({ self, dim, keepdim, dtype }: { self: CTensor; dim?: number[]; keepdim: boolean; dtype: number }): CTensor => {
  return addon.atg_nansum(self, dim, keepdim, dtype)
}

export const atg_nansum_out = ({ out, self, dim, keepdim, dtype }: { out: CTensor; self: CTensor; dim?: number[]; keepdim: boolean; dtype: number }): CTensor => {
  return addon.atg_nansum_out(out, self, dim, keepdim, dtype)
}

export const atg_sum_to_size = ({ self, size }: { self: CTensor; size: number[] }): CTensor => {
  return addon.atg_sum_to_size(self, size)
}

export const atg_sqrt = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_sqrt(self)
}

export const atg_sqrt_out = ({ out, self }: { out: CTensor; self: CTensor }): CTensor => {
  return addon.atg_sqrt_out(out, self)
}

export const atg_sqrt_ = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_sqrt_(self)
}

export const atg_square = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_square(self)
}

export const atg_square_out = ({ out, self }: { out: CTensor; self: CTensor }): CTensor => {
  return addon.atg_square_out(out, self)
}

export const atg_square_ = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_square_(self)
}

export const atg_std = ({ self, unbiased }: { self: CTensor; unbiased: boolean }): CTensor => {
  return addon.atg_std(self, unbiased)
}

export const atg_std_dim = ({ self, dim, unbiased, keepdim }: { self: CTensor; dim?: number[]; unbiased: boolean; keepdim: boolean }): CTensor => {
  return addon.atg_std_dim(self, dim, unbiased, keepdim)
}

export const atg_std_correction = ({ self, dim, correction, keepdim }: { self: CTensor; dim?: number[]; correction?: number; keepdim: boolean }): CTensor => {
  return addon.atg_std_correction(self, dim, correction, keepdim)
}

export const atg_std_out = ({ out, self, dim, unbiased, keepdim }: { out: CTensor; self: CTensor; dim?: number[]; unbiased: boolean; keepdim: boolean }): CTensor => {
  return addon.atg_std_out(out, self, dim, unbiased, keepdim)
}

export const atg_std_correction_out = ({ out, self, dim, correction, keepdim }: { out: CTensor; self: CTensor; dim?: number[]; correction?: number; keepdim: boolean }): CTensor => {
  return addon.atg_std_correction_out(out, self, dim, correction, keepdim)
}

export const atg_std_mean = ({ self, unbiased }: { self: CTensor; unbiased: boolean }): CTensor[] => {
  return addon.atg_std_mean(self, unbiased)
}

export const atg_std_mean_dim = ({ self, dim, unbiased, keepdim }: { self: CTensor; dim?: number[]; unbiased: boolean; keepdim: boolean }): CTensor[] => {
  return addon.atg_std_mean_dim(self, dim, unbiased, keepdim)
}

export const atg_std_mean_correction = ({ self, dim, correction, keepdim }: { self: CTensor; dim?: number[]; correction?: number; keepdim: boolean }): CTensor[] => {
  return addon.atg_std_mean_correction(self, dim, correction, keepdim)
}

export const atg_std_mean_correction_out = ({ out0, out1, self, dim, correction, keepdim }: { out0: CTensor; out1: CTensor; self: CTensor; dim?: number[]; correction?: number; keepdim: boolean }): CTensor[] => {
  return addon.atg_std_mean_correction_out(out0, out1, self, dim, correction, keepdim)
}

export const atg_prod = ({ self, dtype }: { self: CTensor; dtype: number }): CTensor => {
  return addon.atg_prod(self, dtype)
}

export const atg_prod_dim_int = ({ self, dim, keepdim, dtype }: { self: CTensor; dim: number; keepdim: boolean; dtype: number }): CTensor => {
  return addon.atg_prod_dim_int(self, dim, keepdim, dtype)
}

export const atg_prod_out = ({ out, self, dtype }: { out: CTensor; self: CTensor; dtype: number }): CTensor => {
  return addon.atg_prod_out(out, self, dtype)
}

export const atg_prod_int_out = ({ out, self, dim, keepdim, dtype }: { out: CTensor; self: CTensor; dim: number; keepdim: boolean; dtype: number }): CTensor => {
  return addon.atg_prod_int_out(out, self, dim, keepdim, dtype)
}

export const atg_t = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_t(self)
}

export const atg_t_ = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_t_(self)
}

export const atg_tan = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_tan(self)
}

export const atg_tan_out = ({ out, self }: { out: CTensor; self: CTensor }): CTensor => {
  return addon.atg_tan_out(out, self)
}

export const atg_tan_ = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_tan_(self)
}

export const atg_tanh = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_tanh(self)
}

export const atg_tanh_out = ({ out, self }: { out: CTensor; self: CTensor }): CTensor => {
  return addon.atg_tanh_out(out, self)
}

export const atg_tanh_ = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_tanh_(self)
}

export const atg_tensordot = ({ self, other, dims_self, dims_other }: { self: CTensor; other: CTensor; dims_self: number[]; dims_other: number[] }): CTensor => {
  return addon.atg_tensordot(self, other, dims_self, dims_other)
}

export const atg_tensordot_out = ({ out, self, other, dims_self, dims_other }: { out: CTensor; self: CTensor; other: CTensor; dims_self: number[]; dims_other: number[] }): CTensor => {
  return addon.atg_tensordot_out(out, self, other, dims_self, dims_other)
}

export const atg_threshold = ({ self, threshold, value }: { self: CTensor; threshold: CScalar; value: CScalar }): CTensor => {
  return addon.atg_threshold(self, threshold, value)
}

export const atg_threshold_out = ({ out, self, threshold, value }: { out: CTensor; self: CTensor; threshold: CScalar; value: CScalar }): CTensor => {
  return addon.atg_threshold_out(out, self, threshold, value)
}

export const atg_threshold_ = ({ self, threshold, value }: { self: CTensor; threshold: CScalar; value: CScalar }): CTensor => {
  return addon.atg_threshold_(self, threshold, value)
}

export const atg_threshold_backward = ({ grad_output, self, threshold }: { grad_output: CTensor; self: CTensor; threshold: CScalar }): CTensor => {
  return addon.atg_threshold_backward(grad_output, self, threshold)
}

export const atg_threshold_backward_grad_input = ({ grad_input, grad_output, self, threshold }: { grad_input: CTensor; grad_output: CTensor; self: CTensor; threshold: CScalar }): CTensor => {
  return addon.atg_threshold_backward_grad_input(grad_input, grad_output, self, threshold)
}

export const atg_tile = ({ self, dims }: { self: CTensor; dims: number[] }): CTensor => {
  return addon.atg_tile(self, dims)
}

export const atg_transpose = ({ self, dim0, dim1 }: { self: CTensor; dim0: number; dim1: number }): CTensor => {
  return addon.atg_transpose(self, dim0, dim1)
}

export const atg__mkldnn_transpose = ({ self, dim0, dim1 }: { self: CTensor; dim0: number; dim1: number }): CTensor => {
  return addon.atg__mkldnn_transpose(self, dim0, dim1)
}

export const atg__mkldnn_transpose_out = ({ out, self, dim0, dim1 }: { out: CTensor; self: CTensor; dim0: number; dim1: number }): CTensor => {
  return addon.atg__mkldnn_transpose_out(out, self, dim0, dim1)
}

export const atg_transpose_ = ({ self, dim0, dim1 }: { self: CTensor; dim0: number; dim1: number }): CTensor => {
  return addon.atg_transpose_(self, dim0, dim1)
}

export const atg__mkldnn_transpose_ = ({ self, dim0, dim1 }: { self: CTensor; dim0: number; dim1: number }): CTensor => {
  return addon.atg__mkldnn_transpose_(self, dim0, dim1)
}

export const atg_one_hot = ({ self, num_classes }: { self: CTensor; num_classes: number }): CTensor => {
  return addon.atg_one_hot(self, num_classes)
}

export const atg_flip = ({ self, dims }: { self: CTensor; dims: number[] }): CTensor => {
  return addon.atg_flip(self, dims)
}

export const atg_flip_out = ({ out, self, dims }: { out: CTensor; self: CTensor; dims: number[] }): CTensor => {
  return addon.atg_flip_out(out, self, dims)
}

export const atg_fliplr = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_fliplr(self)
}

export const atg_flipud = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_flipud(self)
}

export const atg_roll = ({ self, shifts, dims }: { self: CTensor; shifts: number[]; dims: number[] }): CTensor => {
  return addon.atg_roll(self, shifts, dims)
}

export const atg_roll_out = ({ out, self, shifts, dims }: { out: CTensor; self: CTensor; shifts: number[]; dims: number[] }): CTensor => {
  return addon.atg_roll_out(out, self, shifts, dims)
}

export const atg_rot90 = ({ self, k, dims }: { self: CTensor; k: number; dims: number[] }): CTensor => {
  return addon.atg_rot90(self, k, dims)
}

export const atg_rot90_out = ({ out, self, k, dims }: { out: CTensor; self: CTensor; k: number; dims: number[] }): CTensor => {
  return addon.atg_rot90_out(out, self, k, dims)
}

export const atg_trapezoid = ({ y, x, dim }: { y: CTensor; x: CTensor; dim: number }): CTensor => {
  return addon.atg_trapezoid(y, x, dim)
}

export const atg_trapezoid_dx = ({ y, dx, dim }: { y: CTensor; dx: CScalar; dim: number }): CTensor => {
  return addon.atg_trapezoid_dx(y, dx, dim)
}

export const atg_trapz = ({ y, x, dim }: { y: CTensor; x: CTensor; dim: number }): CTensor => {
  return addon.atg_trapz(y, x, dim)
}

export const atg_trapz_dx = ({ y, dx, dim }: { y: CTensor; dx: number; dim: number }): CTensor => {
  return addon.atg_trapz_dx(y, dx, dim)
}

export const atg__transform_bias_rescale_qkv = ({ qkv, qkv_bias, num_heads }: { qkv: CTensor; qkv_bias: CTensor; num_heads: number }): CTensor[] => {
  return addon.atg__transform_bias_rescale_qkv(qkv, qkv_bias, num_heads)
}

export const atg__transform_bias_rescale_qkv_out = ({ out0, out1, out2, qkv, qkv_bias, num_heads }: { out0: CTensor; out1: CTensor; out2: CTensor; qkv: CTensor; qkv_bias: CTensor; num_heads: number }): CTensor[] => {
  return addon.atg__transform_bias_rescale_qkv_out(out0, out1, out2, qkv, qkv_bias, num_heads)
}

export const atg__nested_tensor_from_mask = ({ t, mask, mask_check }: { t: CTensor; mask: CTensor; mask_check: boolean }): CTensor => {
  return addon.atg__nested_tensor_from_mask(t, mask, mask_check)
}

export const atg__nested_tensor_from_mask_out = ({ out, t, mask, mask_check }: { out: CTensor; t: CTensor; mask: CTensor; mask_check: boolean }): CTensor => {
  return addon.atg__nested_tensor_from_mask_out(out, t, mask, mask_check)
}

export const atg__nested_tensor_from_mask_left_aligned = ({ t, mask }: { t: CTensor; mask: CTensor }): boolean => {
  return addon.atg__nested_tensor_from_mask_left_aligned(t, mask)
}

export const atg__nested_from_padded = ({ padded, cpu_nested_shape_example, fuse_transform_0213 }: { padded: CTensor; cpu_nested_shape_example: CTensor; fuse_transform_0213: boolean }): CTensor => {
  return addon.atg__nested_from_padded(padded, cpu_nested_shape_example, fuse_transform_0213)
}

export const atg__nested_from_padded_out = ({ out, padded, cpu_nested_shape_example, fuse_transform_0213 }: { out: CTensor; padded: CTensor; cpu_nested_shape_example: CTensor; fuse_transform_0213: boolean }): CTensor => {
  return addon.atg__nested_from_padded_out(out, padded, cpu_nested_shape_example, fuse_transform_0213)
}

export const atg__nested_tensor_size = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg__nested_tensor_size(self)
}

export const atg__nested_tensor_size_out = ({ out, self }: { out: CTensor; self: CTensor }): CTensor => {
  return addon.atg__nested_tensor_size_out(out, self)
}

export const atg__nested_tensor_strides = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg__nested_tensor_strides(self)
}

export const atg__nested_tensor_strides_out = ({ out, self }: { out: CTensor; self: CTensor }): CTensor => {
  return addon.atg__nested_tensor_strides_out(out, self)
}

export const atg__nested_from_padded_and_nested_example = ({ padded, nt_example }: { padded: CTensor; nt_example: CTensor }): CTensor => {
  return addon.atg__nested_from_padded_and_nested_example(padded, nt_example)
}

export const atg__nested_from_padded_and_nested_example_out = ({ out, padded, nt_example }: { out: CTensor; padded: CTensor; nt_example: CTensor }): CTensor => {
  return addon.atg__nested_from_padded_and_nested_example_out(out, padded, nt_example)
}

export const atg__nested_view_from_buffer = ({ self, nested_size, nested_strides, offsets }: { self: CTensor; nested_size: CTensor; nested_strides: CTensor; offsets: number[] }): CTensor => {
  return addon.atg__nested_view_from_buffer(self, nested_size, nested_strides, offsets)
}

export const atg__nested_view_from_buffer_copy = ({ self, nested_size, nested_strides, offsets }: { self: CTensor; nested_size: CTensor; nested_strides: CTensor; offsets: number[] }): CTensor => {
  return addon.atg__nested_view_from_buffer_copy(self, nested_size, nested_strides, offsets)
}

export const atg__nested_view_from_buffer_copy_out = ({ out, self, nested_size, nested_strides, offsets }: { out: CTensor; self: CTensor; nested_size: CTensor; nested_strides: CTensor; offsets: number[] }): CTensor => {
  return addon.atg__nested_view_from_buffer_copy_out(out, self, nested_size, nested_strides, offsets)
}

export const atg__trilinear = ({ i1, i2, i3, expand1, expand2, expand3, sumdim, unroll_dim }: { i1: CTensor; i2: CTensor; i3: CTensor; expand1: number[]; expand2: number[]; expand3: number[]; sumdim: number[]; unroll_dim: number }): CTensor => {
  return addon.atg__trilinear(i1, i2, i3, expand1, expand2, expand3, sumdim, unroll_dim)
}

export const atg__trilinear_out = ({ out, i1, i2, i3, expand1, expand2, expand3, sumdim, unroll_dim }: { out: CTensor; i1: CTensor; i2: CTensor; i3: CTensor; expand1: number[]; expand2: number[]; expand3: number[]; sumdim: number[]; unroll_dim: number }): CTensor => {
  return addon.atg__trilinear_out(out, i1, i2, i3, expand1, expand2, expand3, sumdim, unroll_dim)
}

export const atg_triplet_margin_loss = ({ anchor, positive, negative, margin, p, eps, swap, reduction }: { anchor: CTensor; positive: CTensor; negative: CTensor; margin: number; p: number; eps: number; swap: boolean; reduction: number }): CTensor => {
  return addon.atg_triplet_margin_loss(anchor, positive, negative, margin, p, eps, swap, reduction)
}

export const atg_trunc = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_trunc(self)
}

export const atg_trunc_out = ({ out, self }: { out: CTensor; self: CTensor }): CTensor => {
  return addon.atg_trunc_out(out, self)
}

export const atg_trunc_ = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_trunc_(self)
}

export const atg_fix = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_fix(self)
}

export const atg_fix_out = ({ out, self }: { out: CTensor; self: CTensor }): CTensor => {
  return addon.atg_fix_out(out, self)
}

export const atg_fix_ = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_fix_(self)
}

export const atg_type_as = ({ self, other }: { self: CTensor; other: CTensor }): CTensor => {
  return addon.atg_type_as(self, other)
}

export const atg__has_compatible_shallow_copy_type = ({ self, from }: { self: CTensor; from: CTensor }): boolean => {
  return addon.atg__has_compatible_shallow_copy_type(self, from)
}

export const atg__unique = ({ self, sorted, return_inverse }: { self: CTensor; sorted: boolean; return_inverse: boolean }): CTensor[] => {
  return addon.atg__unique(self, sorted, return_inverse)
}

export const atg__unique_out = ({ out0, out1, self, sorted, return_inverse }: { out0: CTensor; out1: CTensor; self: CTensor; sorted: boolean; return_inverse: boolean }): CTensor[] => {
  return addon.atg__unique_out(out0, out1, self, sorted, return_inverse)
}

export const atg_unique_dim = ({ self, dim, sorted, return_inverse, return_counts }: { self: CTensor; dim: number; sorted: boolean; return_inverse: boolean; return_counts: boolean }): CTensor[] => {
  return addon.atg_unique_dim(self, dim, sorted, return_inverse, return_counts)
}

export const atg_unique_dim_out = ({ out0, out1, out2, self, dim, sorted, return_inverse, return_counts }: { out0: CTensor; out1: CTensor; out2: CTensor; self: CTensor; dim: number; sorted: boolean; return_inverse: boolean; return_counts: boolean }): CTensor[] => {
  return addon.atg_unique_dim_out(out0, out1, out2, self, dim, sorted, return_inverse, return_counts)
}

export const atg_unique_consecutive = ({ self, return_inverse, return_counts, dim }: { self: CTensor; return_inverse: boolean; return_counts: boolean; dim?: number }): CTensor[] => {
  return addon.atg_unique_consecutive(self, return_inverse, return_counts, dim)
}

export const atg_unique_consecutive_out = ({ out0, out1, out2, self, return_inverse, return_counts, dim }: { out0: CTensor; out1: CTensor; out2: CTensor; self: CTensor; return_inverse: boolean; return_counts: boolean; dim?: number }): CTensor[] => {
  return addon.atg_unique_consecutive_out(out0, out1, out2, self, return_inverse, return_counts, dim)
}

export const atg_unique_dim_consecutive = ({ self, dim, return_inverse, return_counts }: { self: CTensor; dim: number; return_inverse: boolean; return_counts: boolean }): CTensor[] => {
  return addon.atg_unique_dim_consecutive(self, dim, return_inverse, return_counts)
}

export const atg_unique_dim_consecutive_out = ({ out0, out1, out2, self, dim, return_inverse, return_counts }: { out0: CTensor; out1: CTensor; out2: CTensor; self: CTensor; dim: number; return_inverse: boolean; return_counts: boolean }): CTensor[] => {
  return addon.atg_unique_dim_consecutive_out(out0, out1, out2, self, dim, return_inverse, return_counts)
}

export const atg__unique2 = ({ self, sorted, return_inverse, return_counts }: { self: CTensor; sorted: boolean; return_inverse: boolean; return_counts: boolean }): CTensor[] => {
  return addon.atg__unique2(self, sorted, return_inverse, return_counts)
}

export const atg__unique2_out = ({ out0, out1, out2, self, sorted, return_inverse, return_counts }: { out0: CTensor; out1: CTensor; out2: CTensor; self: CTensor; sorted: boolean; return_inverse: boolean; return_counts: boolean }): CTensor[] => {
  return addon.atg__unique2_out(out0, out1, out2, self, sorted, return_inverse, return_counts)
}

export const atg__unsafe_view = ({ self, size }: { self: CTensor; size: number[] }): CTensor => {
  return addon.atg__unsafe_view(self, size)
}

export const atg__unsafe_view_out = ({ out, self, size }: { out: CTensor; self: CTensor; size: number[] }): CTensor => {
  return addon.atg__unsafe_view_out(out, self, size)
}

export const atg_unsqueeze = ({ self, dim }: { self: CTensor; dim: number }): CTensor => {
  return addon.atg_unsqueeze(self, dim)
}

export const atg_unsqueeze_ = ({ self, dim }: { self: CTensor; dim: number }): CTensor => {
  return addon.atg_unsqueeze_(self, dim)
}

export const atg_vander = ({ x, N, increasing }: { x: CTensor; N?: number; increasing: boolean }): CTensor => {
  return addon.atg_vander(x, N, increasing)
}

export const atg_var = ({ self, unbiased }: { self: CTensor; unbiased: boolean }): CTensor => {
  return addon.atg_var(self, unbiased)
}

export const atg_var_dim = ({ self, dim, unbiased, keepdim }: { self: CTensor; dim?: number[]; unbiased: boolean; keepdim: boolean }): CTensor => {
  return addon.atg_var_dim(self, dim, unbiased, keepdim)
}

export const atg_var_correction = ({ self, dim, correction, keepdim }: { self: CTensor; dim?: number[]; correction?: number; keepdim: boolean }): CTensor => {
  return addon.atg_var_correction(self, dim, correction, keepdim)
}

export const atg_var_out = ({ out, self, dim, unbiased, keepdim }: { out: CTensor; self: CTensor; dim?: number[]; unbiased: boolean; keepdim: boolean }): CTensor => {
  return addon.atg_var_out(out, self, dim, unbiased, keepdim)
}

export const atg_var_correction_out = ({ out, self, dim, correction, keepdim }: { out: CTensor; self: CTensor; dim?: number[]; correction?: number; keepdim: boolean }): CTensor => {
  return addon.atg_var_correction_out(out, self, dim, correction, keepdim)
}

export const atg_var_mean = ({ self, unbiased }: { self: CTensor; unbiased: boolean }): CTensor[] => {
  return addon.atg_var_mean(self, unbiased)
}

export const atg_var_mean_dim = ({ self, dim, unbiased, keepdim }: { self: CTensor; dim?: number[]; unbiased: boolean; keepdim: boolean }): CTensor[] => {
  return addon.atg_var_mean_dim(self, dim, unbiased, keepdim)
}

export const atg_var_mean_correction = ({ self, dim, correction, keepdim }: { self: CTensor; dim?: number[]; correction?: number; keepdim: boolean }): CTensor[] => {
  return addon.atg_var_mean_correction(self, dim, correction, keepdim)
}

export const atg_var_mean_correction_out = ({ out0, out1, self, dim, correction, keepdim }: { out0: CTensor; out1: CTensor; self: CTensor; dim?: number[]; correction?: number; keepdim: boolean }): CTensor[] => {
  return addon.atg_var_mean_correction_out(out0, out1, self, dim, correction, keepdim)
}

export const atg_view_as = ({ self, other }: { self: CTensor; other: CTensor }): CTensor => {
  return addon.atg_view_as(self, other)
}

export const atg_where = ({ condition, self, other }: { condition: CTensor; self: CTensor; other: CTensor }): CTensor => {
  return addon.atg_where(condition, self, other)
}

export const atg_where_scalarself = ({ condition, self_scalar, other }: { condition: CTensor; self_scalar: CScalar; other: CTensor }): CTensor => {
  return addon.atg_where_scalarself(condition, self_scalar, other)
}

export const atg_where_scalarother = ({ condition, self, other }: { condition: CTensor; self: CTensor; other: CScalar }): CTensor => {
  return addon.atg_where_scalarother(condition, self, other)
}

export const atg_where_scalar = ({ condition, self_scalar, other }: { condition: CTensor; self_scalar: CScalar; other: CScalar }): CTensor => {
  return addon.atg_where_scalar(condition, self_scalar, other)
}

export const atg_where_self_out = ({ out, condition, self, other }: { out: CTensor; condition: CTensor; self: CTensor; other: CTensor }): CTensor => {
  return addon.atg_where_self_out(out, condition, self, other)
}

export const atg_norm_except_dim = ({ v, pow, dim }: { v: CTensor; pow: number; dim: number }): CTensor => {
  return addon.atg_norm_except_dim(v, pow, dim)
}

export const atg__weight_norm = ({ v, g, dim }: { v: CTensor; g: CTensor; dim: number }): CTensor => {
  return addon.atg__weight_norm(v, g, dim)
}

export const atg__weight_norm_interface = ({ v, g, dim }: { v: CTensor; g: CTensor; dim: number }): CTensor[] => {
  return addon.atg__weight_norm_interface(v, g, dim)
}

export const atg__weight_norm_interface_out = ({ out0, out1, v, g, dim }: { out0: CTensor; out1: CTensor; v: CTensor; g: CTensor; dim: number }): CTensor[] => {
  return addon.atg__weight_norm_interface_out(out0, out1, v, g, dim)
}

export const atg__weight_norm_interface_backward = ({ grad_w, saved_v, saved_g, saved_norms, dim }: { grad_w: CTensor; saved_v: CTensor; saved_g: CTensor; saved_norms: CTensor; dim: number }): CTensor[] => {
  return addon.atg__weight_norm_interface_backward(grad_w, saved_v, saved_g, saved_norms, dim)
}

export const atg__weight_norm_interface_backward_out = ({ out0, out1, grad_w, saved_v, saved_g, saved_norms, dim }: { out0: CTensor; out1: CTensor; grad_w: CTensor; saved_v: CTensor; saved_g: CTensor; saved_norms: CTensor; dim: number }): CTensor[] => {
  return addon.atg__weight_norm_interface_backward_out(out0, out1, grad_w, saved_v, saved_g, saved_norms, dim)
}

export const atg__weight_norm_differentiable_backward = ({ grad_w, saved_v, saved_g, saved_norms, dim }: { grad_w: CTensor; saved_v: CTensor; saved_g: CTensor; saved_norms: CTensor; dim: number }): CTensor[] => {
  return addon.atg__weight_norm_differentiable_backward(grad_w, saved_v, saved_g, saved_norms, dim)
}

export const atg__efficientzerotensor = ({ size, options }: { size: number[]; options: { device: number, dtype: number } }): CTensor => {
  return addon.atg__efficientzerotensor(size, options)
}

export const atg__efficientzerotensor_out = ({ out, size }: { out: CTensor; size: number[] }): CTensor => {
  return addon.atg__efficientzerotensor_out(out, size)
}

export const atg_zeros = ({ size, options }: { size: number[]; options: { device: number, dtype: number } }): CTensor => {
  return addon.atg_zeros(size, options)
}

export const atg_zeros_out = ({ out, size }: { out: CTensor; size: number[] }): CTensor => {
  return addon.atg_zeros_out(out, size)
}

export const atg_zeros_like = ({ self, options, memory_format }: { self: CTensor; options: { device: number, dtype: number }; memory_format: number }): CTensor => {
  return addon.atg_zeros_like(self, options, memory_format)
}

export const atg_zeros_like_out = ({ out, self, memory_format }: { out: CTensor; self: CTensor; memory_format: number }): CTensor => {
  return addon.atg_zeros_like_out(out, self, memory_format)
}

export const atg__standard_gamma_grad = ({ self, output }: { self: CTensor; output: CTensor }): CTensor => {
  return addon.atg__standard_gamma_grad(self, output)
}

export const atg__standard_gamma_grad_out = ({ out, self, output }: { out: CTensor; self: CTensor; output: CTensor }): CTensor => {
  return addon.atg__standard_gamma_grad_out(out, self, output)
}

export const atg__standard_gamma = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg__standard_gamma(self)
}

export const atg__standard_gamma_out = ({ out, self }: { out: CTensor; self: CTensor }): CTensor => {
  return addon.atg__standard_gamma_out(out, self)
}

export const atg__dirichlet_grad = ({ x, alpha, total }: { x: CTensor; alpha: CTensor; total: CTensor }): CTensor => {
  return addon.atg__dirichlet_grad(x, alpha, total)
}

export const atg__dirichlet_grad_out = ({ out, x, alpha, total }: { out: CTensor; x: CTensor; alpha: CTensor; total: CTensor }): CTensor => {
  return addon.atg__dirichlet_grad_out(out, x, alpha, total)
}

export const atg__sample_dirichlet = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg__sample_dirichlet(self)
}

export const atg__sample_dirichlet_out = ({ out, self }: { out: CTensor; self: CTensor }): CTensor => {
  return addon.atg__sample_dirichlet_out(out, self)
}

export const atg_poisson = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_poisson(self)
}

export const atg_poisson_out = ({ out, self }: { out: CTensor; self: CTensor }): CTensor => {
  return addon.atg_poisson_out(out, self)
}

export const atg_binomial = ({ count, prob }: { count: CTensor; prob: CTensor }): CTensor => {
  return addon.atg_binomial(count, prob)
}

export const atg_binomial_out = ({ out, count, prob }: { out: CTensor; count: CTensor; prob: CTensor }): CTensor => {
  return addon.atg_binomial_out(out, count, prob)
}

export const atg_native_norm = ({ self, p }: { self: CTensor; p: CScalar }): CTensor => {
  return addon.atg_native_norm(self, p)
}

export const atg_native_norm_scalaropt_dim_dtype = ({ self, p, dim, keepdim, dtype }: { self: CTensor; p: CScalar; dim: number[]; keepdim: boolean; dtype: number }): CTensor => {
  return addon.atg_native_norm_scalaropt_dim_dtype(self, p, dim, keepdim, dtype)
}

export const atg_native_norm_out = ({ out, self, p }: { out: CTensor; self: CTensor; p: CScalar }): CTensor => {
  return addon.atg_native_norm_out(out, self, p)
}

export const atg_native_norm_scalaropt_dim_dtype_out = ({ out, self, p, dim, keepdim, dtype }: { out: CTensor; self: CTensor; p: CScalar; dim: number[]; keepdim: boolean; dtype: number }): CTensor => {
  return addon.atg_native_norm_scalaropt_dim_dtype_out(out, self, p, dim, keepdim, dtype)
}

export const atg__sparse_sum = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg__sparse_sum(self)
}

export const atg__sparse_sum_dtype = ({ self, dtype }: { self: CTensor; dtype: number }): CTensor => {
  return addon.atg__sparse_sum_dtype(self, dtype)
}

export const atg__sparse_sum_dim = ({ self, dim }: { self: CTensor; dim: number[] }): CTensor => {
  return addon.atg__sparse_sum_dim(self, dim)
}

export const atg__sparse_sum_dim_dtype = ({ self, dim, dtype }: { self: CTensor; dim: number[]; dtype: number }): CTensor => {
  return addon.atg__sparse_sum_dim_dtype(self, dim, dtype)
}

export const atg__sparse_sum_dim_out = ({ out, self, dim }: { out: CTensor; self: CTensor; dim: number[] }): CTensor => {
  return addon.atg__sparse_sum_dim_out(out, self, dim)
}

export const atg__sparse_sum_backward = ({ grad, self, dim }: { grad: CTensor; self: CTensor; dim: number[] }): CTensor => {
  return addon.atg__sparse_sum_backward(grad, self, dim)
}

export const atg__sparse_sum_backward_out = ({ out, grad, self, dim }: { out: CTensor; grad: CTensor; self: CTensor; dim: number[] }): CTensor => {
  return addon.atg__sparse_sum_backward_out(out, grad, self, dim)
}

export const atg__sparse_csr_sum = ({ self, dim, keepdim, dtype }: { self: CTensor; dim: number[]; keepdim: boolean; dtype: number }): CTensor => {
  return addon.atg__sparse_csr_sum(self, dim, keepdim, dtype)
}

export const atg__sparse_csr_sum_dim_dtype_out = ({ out, self, dim, keepdim, dtype }: { out: CTensor; self: CTensor; dim: number[]; keepdim: boolean; dtype: number }): CTensor => {
  return addon.atg__sparse_csr_sum_dim_dtype_out(out, self, dim, keepdim, dtype)
}

export const atg__sparse_csr_prod = ({ self, dim, keepdim, dtype }: { self: CTensor; dim: number[]; keepdim: boolean; dtype: number }): CTensor => {
  return addon.atg__sparse_csr_prod(self, dim, keepdim, dtype)
}

export const atg__sparse_csr_prod_dim_dtype_out = ({ out, self, dim, keepdim, dtype }: { out: CTensor; self: CTensor; dim: number[]; keepdim: boolean; dtype: number }): CTensor => {
  return addon.atg__sparse_csr_prod_dim_dtype_out(out, self, dim, keepdim, dtype)
}

export const atg__sparse_softmax_int = ({ self, dim, dtype }: { self: CTensor; dim: number; dtype: number }): CTensor => {
  return addon.atg__sparse_softmax_int(self, dim, dtype)
}

export const atg__sparse_softmax = ({ self, dim, half_to_float }: { self: CTensor; dim: number; half_to_float: boolean }): CTensor => {
  return addon.atg__sparse_softmax(self, dim, half_to_float)
}

export const atg__sparse_softmax_out = ({ out, self, dim, half_to_float }: { out: CTensor; self: CTensor; dim: number; half_to_float: boolean }): CTensor => {
  return addon.atg__sparse_softmax_out(out, self, dim, half_to_float)
}

export const atg__sparse_softmax_backward_data = ({ grad_output, output, dim, self }: { grad_output: CTensor; output: CTensor; dim: number; self: CTensor }): CTensor => {
  return addon.atg__sparse_softmax_backward_data(grad_output, output, dim, self)
}

export const atg__sparse_softmax_backward_data_out = ({ out, grad_output, output, dim, self }: { out: CTensor; grad_output: CTensor; output: CTensor; dim: number; self: CTensor }): CTensor => {
  return addon.atg__sparse_softmax_backward_data_out(out, grad_output, output, dim, self)
}

export const atg__sparse_log_softmax_int = ({ self, dim, dtype }: { self: CTensor; dim: number; dtype: number }): CTensor => {
  return addon.atg__sparse_log_softmax_int(self, dim, dtype)
}

export const atg__sparse_log_softmax = ({ self, dim, half_to_float }: { self: CTensor; dim: number; half_to_float: boolean }): CTensor => {
  return addon.atg__sparse_log_softmax(self, dim, half_to_float)
}

export const atg__sparse_log_softmax_out = ({ out, self, dim, half_to_float }: { out: CTensor; self: CTensor; dim: number; half_to_float: boolean }): CTensor => {
  return addon.atg__sparse_log_softmax_out(out, self, dim, half_to_float)
}

export const atg__sparse_log_softmax_backward_data = ({ grad_output, output, dim, self }: { grad_output: CTensor; output: CTensor; dim: number; self: CTensor }): CTensor => {
  return addon.atg__sparse_log_softmax_backward_data(grad_output, output, dim, self)
}

export const atg__sparse_log_softmax_backward_data_out = ({ out, grad_output, output, dim, self }: { out: CTensor; grad_output: CTensor; output: CTensor; dim: number; self: CTensor }): CTensor => {
  return addon.atg__sparse_log_softmax_backward_data_out(out, grad_output, output, dim, self)
}

export const atg__spdiags = ({ diagonals, offsets, shape, layout }: { diagonals: CTensor; offsets: CTensor; shape: number[]; layout: number }): CTensor => {
  return addon.atg__spdiags(diagonals, offsets, shape, layout)
}

export const atg__spdiags_out = ({ out, diagonals, offsets, shape, layout }: { out: CTensor; diagonals: CTensor; offsets: CTensor; shape: number[]; layout: number }): CTensor => {
  return addon.atg__spdiags_out(out, diagonals, offsets, shape, layout)
}

export const atg_norm = ({ self, p }: { self: CTensor; p: CScalar }): CTensor => {
  return addon.atg_norm(self, p)
}

export const atg_norm_scalaropt_dtype = ({ self, p, dtype }: { self: CTensor; p: CScalar; dtype: number }): CTensor => {
  return addon.atg_norm_scalaropt_dtype(self, p, dtype)
}

export const atg_norm_scalaropt_dim = ({ self, p, dim, keepdim }: { self: CTensor; p: CScalar; dim: number[]; keepdim: boolean }): CTensor => {
  return addon.atg_norm_scalaropt_dim(self, p, dim, keepdim)
}

export const atg_norm_scalaropt_dim_dtype = ({ self, p, dim, keepdim, dtype }: { self: CTensor; p: CScalar; dim: number[]; keepdim: boolean; dtype: number }): CTensor => {
  return addon.atg_norm_scalaropt_dim_dtype(self, p, dim, keepdim, dtype)
}

export const atg_norm_scalar_out = ({ out, self, p }: { out: CTensor; self: CTensor; p: CScalar }): CTensor => {
  return addon.atg_norm_scalar_out(out, self, p)
}

export const atg_norm_scalaropt_dtype_out = ({ out, self, p, dtype }: { out: CTensor; self: CTensor; p: CScalar; dtype: number }): CTensor => {
  return addon.atg_norm_scalaropt_dtype_out(out, self, p, dtype)
}

export const atg_norm_out = ({ out, self, p, dim, keepdim }: { out: CTensor; self: CTensor; p: CScalar; dim: number[]; keepdim: boolean }): CTensor => {
  return addon.atg_norm_out(out, self, p, dim, keepdim)
}

export const atg_norm_dtype_out = ({ out, self, p, dim, keepdim, dtype }: { out: CTensor; self: CTensor; p: CScalar; dim: number[]; keepdim: boolean; dtype: number }): CTensor => {
  return addon.atg_norm_dtype_out(out, self, p, dim, keepdim, dtype)
}

export const atg_frexp = ({ self }: { self: CTensor }): CTensor[] => {
  return addon.atg_frexp(self)
}

export const atg_frexp_tensor_out = ({ mantissa, exponent, self }: { mantissa: CTensor; exponent: CTensor; self: CTensor }): CTensor[] => {
  return addon.atg_frexp_tensor_out(mantissa, exponent, self)
}

export const atg_frobenius_norm = ({ self, dim, keepdim }: { self: CTensor; dim: number[]; keepdim: boolean }): CTensor => {
  return addon.atg_frobenius_norm(self, dim, keepdim)
}

export const atg_frobenius_norm_out = ({ out, self, dim, keepdim }: { out: CTensor; self: CTensor; dim: number[]; keepdim: boolean }): CTensor => {
  return addon.atg_frobenius_norm_out(out, self, dim, keepdim)
}

export const atg_nuclear_norm = ({ self, keepdim }: { self: CTensor; keepdim: boolean }): CTensor => {
  return addon.atg_nuclear_norm(self, keepdim)
}

export const atg_nuclear_norm_dim = ({ self, dim, keepdim }: { self: CTensor; dim: number[]; keepdim: boolean }): CTensor => {
  return addon.atg_nuclear_norm_dim(self, dim, keepdim)
}

export const atg_nuclear_norm_out = ({ out, self, keepdim }: { out: CTensor; self: CTensor; keepdim: boolean }): CTensor => {
  return addon.atg_nuclear_norm_out(out, self, keepdim)
}

export const atg_nuclear_norm_dim_out = ({ out, self, dim, keepdim }: { out: CTensor; self: CTensor; dim: number[]; keepdim: boolean }): CTensor => {
  return addon.atg_nuclear_norm_dim_out(out, self, dim, keepdim)
}

export const atg_positive = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_positive(self)
}

export const atg_resize_as_ = ({ self, the_template, memory_format }: { self: CTensor; the_template: CTensor; memory_format: number }): CTensor => {
  return addon.atg_resize_as_(self, the_template, memory_format)
}

export const atg_resize_as_sparse_ = ({ self, the_template }: { self: CTensor; the_template: CTensor }): CTensor => {
  return addon.atg_resize_as_sparse_(self, the_template)
}

export const atg_zero_ = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_zero_(self)
}

export const atg_sub = ({ self, other, alpha }: { self: CTensor; other: CTensor; alpha: CScalar }): CTensor => {
  return addon.atg_sub(self, other, alpha)
}

export const atg_sub_scalar = ({ self, other, alpha }: { self: CTensor; other: CScalar; alpha: CScalar }): CTensor => {
  return addon.atg_sub_scalar(self, other, alpha)
}

export const atg_sub_out = ({ out, self, other, alpha }: { out: CTensor; self: CTensor; other: CTensor; alpha: CScalar }): CTensor => {
  return addon.atg_sub_out(out, self, other, alpha)
}

export const atg_sub_scalar_out = ({ out, self, other, alpha }: { out: CTensor; self: CTensor; other: CScalar; alpha: CScalar }): CTensor => {
  return addon.atg_sub_scalar_out(out, self, other, alpha)
}

export const atg_sub_ = ({ self, other, alpha }: { self: CTensor; other: CTensor; alpha: CScalar }): CTensor => {
  return addon.atg_sub_(self, other, alpha)
}

export const atg_sub_scalar_ = ({ self, other, alpha }: { self: CTensor; other: CScalar; alpha: CScalar }): CTensor => {
  return addon.atg_sub_scalar_(self, other, alpha)
}

export const atg_subtract = ({ self, other, alpha }: { self: CTensor; other: CTensor; alpha: CScalar }): CTensor => {
  return addon.atg_subtract(self, other, alpha)
}

export const atg_subtract_scalar = ({ self, other, alpha }: { self: CTensor; other: CScalar; alpha: CScalar }): CTensor => {
  return addon.atg_subtract_scalar(self, other, alpha)
}

export const atg_subtract_out = ({ out, self, other, alpha }: { out: CTensor; self: CTensor; other: CTensor; alpha: CScalar }): CTensor => {
  return addon.atg_subtract_out(out, self, other, alpha)
}

export const atg_subtract_ = ({ self, other, alpha }: { self: CTensor; other: CTensor; alpha: CScalar }): CTensor => {
  return addon.atg_subtract_(self, other, alpha)
}

export const atg_subtract_scalar_ = ({ self, other, alpha }: { self: CTensor; other: CScalar; alpha: CScalar }): CTensor => {
  return addon.atg_subtract_scalar_(self, other, alpha)
}

export const atg_rsub = ({ self, other, alpha }: { self: CTensor; other: CTensor; alpha: CScalar }): CTensor => {
  return addon.atg_rsub(self, other, alpha)
}

export const atg_rsub_scalar = ({ self, other, alpha }: { self: CTensor; other: CScalar; alpha: CScalar }): CTensor => {
  return addon.atg_rsub_scalar(self, other, alpha)
}

export const atg_rsub_tensor_out = ({ out, self, other, alpha }: { out: CTensor; self: CTensor; other: CTensor; alpha: CScalar }): CTensor => {
  return addon.atg_rsub_tensor_out(out, self, other, alpha)
}

export const atg_rsub_scalar_out = ({ out, self, other, alpha }: { out: CTensor; self: CTensor; other: CScalar; alpha: CScalar }): CTensor => {
  return addon.atg_rsub_scalar_out(out, self, other, alpha)
}

export const atg_heaviside = ({ self, values }: { self: CTensor; values: CTensor }): CTensor => {
  return addon.atg_heaviside(self, values)
}

export const atg_heaviside_out = ({ out, self, values }: { out: CTensor; self: CTensor; values: CTensor }): CTensor => {
  return addon.atg_heaviside_out(out, self, values)
}

export const atg_heaviside_ = ({ self, values }: { self: CTensor; values: CTensor }): CTensor => {
  return addon.atg_heaviside_(self, values)
}

export const atg__sparse_addmm = ({ self, mat1, mat2, beta, alpha }: { self: CTensor; mat1: CTensor; mat2: CTensor; beta: CScalar; alpha: CScalar }): CTensor => {
  return addon.atg__sparse_addmm(self, mat1, mat2, beta, alpha)
}

export const atg__sparse_addmm_out = ({ out, self, mat1, mat2, beta, alpha }: { out: CTensor; self: CTensor; mat1: CTensor; mat2: CTensor; beta: CScalar; alpha: CScalar }): CTensor => {
  return addon.atg__sparse_addmm_out(out, self, mat1, mat2, beta, alpha)
}

export const atg_sparse_sampled_addmm = ({ self, mat1, mat2, beta, alpha }: { self: CTensor; mat1: CTensor; mat2: CTensor; beta: CScalar; alpha: CScalar }): CTensor => {
  return addon.atg_sparse_sampled_addmm(self, mat1, mat2, beta, alpha)
}

export const atg_sparse_sampled_addmm_out = ({ out, self, mat1, mat2, beta, alpha }: { out: CTensor; self: CTensor; mat1: CTensor; mat2: CTensor; beta: CScalar; alpha: CScalar }): CTensor => {
  return addon.atg_sparse_sampled_addmm_out(out, self, mat1, mat2, beta, alpha)
}

export const atg__sparse_mm_reduce_impl = ({ self, other, reduce }: { self: CTensor; other: CTensor; reduce: string }): CTensor[] => {
  return addon.atg__sparse_mm_reduce_impl(self, other, reduce)
}

export const atg_addmm = ({ self, mat1, mat2, beta, alpha }: { self: CTensor; mat1: CTensor; mat2: CTensor; beta: CScalar; alpha: CScalar }): CTensor => {
  return addon.atg_addmm(self, mat1, mat2, beta, alpha)
}

export const atg_addmm_out = ({ out, self, mat1, mat2, beta, alpha }: { out: CTensor; self: CTensor; mat1: CTensor; mat2: CTensor; beta: CScalar; alpha: CScalar }): CTensor => {
  return addon.atg_addmm_out(out, self, mat1, mat2, beta, alpha)
}

export const atg_addmm_ = ({ self, mat1, mat2, beta, alpha }: { self: CTensor; mat1: CTensor; mat2: CTensor; beta: CScalar; alpha: CScalar }): CTensor => {
  return addon.atg_addmm_(self, mat1, mat2, beta, alpha)
}

export const atg__addmm_activation = ({ self, mat1, mat2, beta, alpha, use_gelu }: { self: CTensor; mat1: CTensor; mat2: CTensor; beta: CScalar; alpha: CScalar; use_gelu: boolean }): CTensor => {
  return addon.atg__addmm_activation(self, mat1, mat2, beta, alpha, use_gelu)
}

export const atg__addmm_activation_out = ({ out, self, mat1, mat2, beta, alpha, use_gelu }: { out: CTensor; self: CTensor; mat1: CTensor; mat2: CTensor; beta: CScalar; alpha: CScalar; use_gelu: boolean }): CTensor => {
  return addon.atg__addmm_activation_out(out, self, mat1, mat2, beta, alpha, use_gelu)
}

export const atg_sparse_compressed_tensor = ({ compressed_indices, plain_indices, values, options }: { compressed_indices: CTensor; plain_indices: CTensor; values: CTensor; options: { device: number, dtype: number } }): CTensor => {
  return addon.atg_sparse_compressed_tensor(compressed_indices, plain_indices, values, options)
}

export const atg_sparse_compressed_tensor_comp_plain_value_size = ({ compressed_indices, plain_indices, values, size, options }: { compressed_indices: CTensor; plain_indices: CTensor; values: CTensor; size: number[]; options: { device: number, dtype: number } }): CTensor => {
  return addon.atg_sparse_compressed_tensor_comp_plain_value_size(compressed_indices, plain_indices, values, size, options)
}

export const atg_sparse_csr_tensor = ({ crow_indices, col_indices, values, options }: { crow_indices: CTensor; col_indices: CTensor; values: CTensor; options: { device: number, dtype: number } }): CTensor => {
  return addon.atg_sparse_csr_tensor(crow_indices, col_indices, values, options)
}

export const atg_sparse_csr_tensor_crow_col_value_size = ({ crow_indices, col_indices, values, size, options }: { crow_indices: CTensor; col_indices: CTensor; values: CTensor; size: number[]; options: { device: number, dtype: number } }): CTensor => {
  return addon.atg_sparse_csr_tensor_crow_col_value_size(crow_indices, col_indices, values, size, options)
}

export const atg_sparse_csc_tensor = ({ ccol_indices, row_indices, values, options }: { ccol_indices: CTensor; row_indices: CTensor; values: CTensor; options: { device: number, dtype: number } }): CTensor => {
  return addon.atg_sparse_csc_tensor(ccol_indices, row_indices, values, options)
}

export const atg_sparse_csc_tensor_ccol_row_value_size = ({ ccol_indices, row_indices, values, size, options }: { ccol_indices: CTensor; row_indices: CTensor; values: CTensor; size: number[]; options: { device: number, dtype: number } }): CTensor => {
  return addon.atg_sparse_csc_tensor_ccol_row_value_size(ccol_indices, row_indices, values, size, options)
}

export const atg_sparse_bsr_tensor = ({ crow_indices, col_indices, values, options }: { crow_indices: CTensor; col_indices: CTensor; values: CTensor; options: { device: number, dtype: number } }): CTensor => {
  return addon.atg_sparse_bsr_tensor(crow_indices, col_indices, values, options)
}

export const atg_sparse_bsr_tensor_crow_col_value_size = ({ crow_indices, col_indices, values, size, options }: { crow_indices: CTensor; col_indices: CTensor; values: CTensor; size: number[]; options: { device: number, dtype: number } }): CTensor => {
  return addon.atg_sparse_bsr_tensor_crow_col_value_size(crow_indices, col_indices, values, size, options)
}

export const atg_sparse_bsc_tensor = ({ ccol_indices, row_indices, values, options }: { ccol_indices: CTensor; row_indices: CTensor; values: CTensor; options: { device: number, dtype: number } }): CTensor => {
  return addon.atg_sparse_bsc_tensor(ccol_indices, row_indices, values, options)
}

export const atg_sparse_bsc_tensor_ccol_row_value_size = ({ ccol_indices, row_indices, values, size, options }: { ccol_indices: CTensor; row_indices: CTensor; values: CTensor; size: number[]; options: { device: number, dtype: number } }): CTensor => {
  return addon.atg_sparse_bsc_tensor_ccol_row_value_size(ccol_indices, row_indices, values, size, options)
}

export const atg__sparse_compressed_tensor_unsafe = ({ compressed_indices, plain_indices, values, size, options }: { compressed_indices: CTensor; plain_indices: CTensor; values: CTensor; size: number[]; options: { device: number, dtype: number } }): CTensor => {
  return addon.atg__sparse_compressed_tensor_unsafe(compressed_indices, plain_indices, values, size, options)
}

export const atg__sparse_csr_tensor_unsafe = ({ crow_indices, col_indices, values, size, options }: { crow_indices: CTensor; col_indices: CTensor; values: CTensor; size: number[]; options: { device: number, dtype: number } }): CTensor => {
  return addon.atg__sparse_csr_tensor_unsafe(crow_indices, col_indices, values, size, options)
}

export const atg__sparse_csc_tensor_unsafe = ({ ccol_indices, row_indices, values, size, options }: { ccol_indices: CTensor; row_indices: CTensor; values: CTensor; size: number[]; options: { device: number, dtype: number } }): CTensor => {
  return addon.atg__sparse_csc_tensor_unsafe(ccol_indices, row_indices, values, size, options)
}

export const atg__sparse_bsr_tensor_unsafe = ({ crow_indices, col_indices, values, size, options }: { crow_indices: CTensor; col_indices: CTensor; values: CTensor; size: number[]; options: { device: number, dtype: number } }): CTensor => {
  return addon.atg__sparse_bsr_tensor_unsafe(crow_indices, col_indices, values, size, options)
}

export const atg__sparse_bsc_tensor_unsafe = ({ ccol_indices, row_indices, values, size, options }: { ccol_indices: CTensor; row_indices: CTensor; values: CTensor; size: number[]; options: { device: number, dtype: number } }): CTensor => {
  return addon.atg__sparse_bsc_tensor_unsafe(ccol_indices, row_indices, values, size, options)
}

export const atg_sparse_coo_tensor = ({ size, options }: { size: number[]; options: { device: number, dtype: number } }): CTensor => {
  return addon.atg_sparse_coo_tensor(size, options)
}

export const atg_sparse_coo_tensor_indices = ({ indices, values, options }: { indices: CTensor; values: CTensor; options: { device: number, dtype: number } }): CTensor => {
  return addon.atg_sparse_coo_tensor_indices(indices, values, options)
}

export const atg_sparse_coo_tensor_indices_size = ({ indices, values, size, options }: { indices: CTensor; values: CTensor; size: number[]; options: { device: number, dtype: number } }): CTensor => {
  return addon.atg_sparse_coo_tensor_indices_size(indices, values, size, options)
}

export const atg_sparse_coo_tensor_size_out = ({ out, size }: { out: CTensor; size: number[] }): CTensor => {
  return addon.atg_sparse_coo_tensor_size_out(out, size)
}

export const atg__sparse_coo_tensor_unsafe = ({ indices, values, size, options }: { indices: CTensor; values: CTensor; size: number[]; options: { device: number, dtype: number } }): CTensor => {
  return addon.atg__sparse_coo_tensor_unsafe(indices, values, size, options)
}

export const atg__validate_sparse_compressed_tensor_args = ({ compressed_indices, plain_indices, values, size, layout }: { compressed_indices: CTensor; plain_indices: CTensor; values: CTensor; size: number[]; layout: number }): void => {
  return addon.atg__validate_sparse_compressed_tensor_args(compressed_indices, plain_indices, values, size, layout)
}

export const atg__validate_sparse_csr_tensor_args = ({ crow_indices, col_indices, values, size }: { crow_indices: CTensor; col_indices: CTensor; values: CTensor; size: number[] }): void => {
  return addon.atg__validate_sparse_csr_tensor_args(crow_indices, col_indices, values, size)
}

export const atg__validate_sparse_csc_tensor_args = ({ ccol_indices, row_indices, values, size }: { ccol_indices: CTensor; row_indices: CTensor; values: CTensor; size: number[] }): void => {
  return addon.atg__validate_sparse_csc_tensor_args(ccol_indices, row_indices, values, size)
}

export const atg__validate_sparse_bsr_tensor_args = ({ crow_indices, col_indices, values, size }: { crow_indices: CTensor; col_indices: CTensor; values: CTensor; size: number[] }): void => {
  return addon.atg__validate_sparse_bsr_tensor_args(crow_indices, col_indices, values, size)
}

export const atg__validate_sparse_bsc_tensor_args = ({ ccol_indices, row_indices, values, size }: { ccol_indices: CTensor; row_indices: CTensor; values: CTensor; size: number[] }): void => {
  return addon.atg__validate_sparse_bsc_tensor_args(ccol_indices, row_indices, values, size)
}

export const atg__sparse_coo_tensor_with_dims = ({ sparse_dim, dense_dim, size, options }: { sparse_dim: number; dense_dim: number; size: number[]; options: { device: number, dtype: number } }): CTensor => {
  return addon.atg__sparse_coo_tensor_with_dims(sparse_dim, dense_dim, size, options)
}

export const atg__sparse_coo_tensor_with_dims_out = ({ out, sparse_dim, dense_dim, size }: { out: CTensor; sparse_dim: number; dense_dim: number; size: number[] }): CTensor => {
  return addon.atg__sparse_coo_tensor_with_dims_out(out, sparse_dim, dense_dim, size)
}

export const atg__sparse_coo_tensor_with_dims_and_tensors = ({ sparse_dim, dense_dim, size, indices, values, options }: { sparse_dim: number; dense_dim: number; size: number[]; indices: CTensor; values: CTensor; options: { device: number, dtype: number } }): CTensor => {
  return addon.atg__sparse_coo_tensor_with_dims_and_tensors(sparse_dim, dense_dim, size, indices, values, options)
}

export const atg__sparse_coo_tensor_with_dims_and_tensors_out = ({ out, sparse_dim, dense_dim, size, indices, values }: { out: CTensor; sparse_dim: number; dense_dim: number; size: number[]; indices: CTensor; values: CTensor }): CTensor => {
  return addon.atg__sparse_coo_tensor_with_dims_and_tensors_out(out, sparse_dim, dense_dim, size, indices, values)
}

export const atg_sparse_resize_ = ({ self, size, sparse_dim, dense_dim }: { self: CTensor; size: number[]; sparse_dim: number; dense_dim: number }): CTensor => {
  return addon.atg_sparse_resize_(self, size, sparse_dim, dense_dim)
}

export const atg_sparse_resize_and_clear_ = ({ self, size, sparse_dim, dense_dim }: { self: CTensor; size: number[]; sparse_dim: number; dense_dim: number }): CTensor => {
  return addon.atg_sparse_resize_and_clear_(self, size, sparse_dim, dense_dim)
}

export const atg_sparse_mask = ({ self, mask }: { self: CTensor; mask: CTensor }): CTensor => {
  return addon.atg_sparse_mask(self, mask)
}

export const atg_sparse_mask_out = ({ out, self, mask }: { out: CTensor; self: CTensor; mask: CTensor }): CTensor => {
  return addon.atg_sparse_mask_out(out, self, mask)
}

export const atg_to_dense = ({ self, dtype }: { self: CTensor; dtype: number }): CTensor => {
  return addon.atg_to_dense(self, dtype)
}

export const atg__to_dense = ({ self, dtype }: { self: CTensor; dtype: number }): CTensor => {
  return addon.atg__to_dense(self, dtype)
}

export const atg__to_dense_out = ({ out, self, dtype }: { out: CTensor; self: CTensor; dtype: number }): CTensor => {
  return addon.atg__to_dense_out(out, self, dtype)
}

export const atg_to_dense_backward = ({ grad, input }: { grad: CTensor; input: CTensor }): CTensor => {
  return addon.atg_to_dense_backward(grad, input)
}

export const atg_sparse_dim = ({ self }: { self: CTensor }): number => {
  return addon.atg_sparse_dim(self)
}

export const atg__dimI = ({ self }: { self: CTensor }): number => {
  return addon.atg__dimI(self)
}

export const atg_dense_dim = ({ self }: { self: CTensor }): number => {
  return addon.atg_dense_dim(self)
}

export const atg__dimV = ({ self }: { self: CTensor }): number => {
  return addon.atg__dimV(self)
}

export const atg__nnz = ({ self }: { self: CTensor }): number => {
  return addon.atg__nnz(self)
}

export const atg_coalesce = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_coalesce(self)
}

export const atg__coalesce = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg__coalesce(self)
}

export const atg__coalesce_out = ({ out, self }: { out: CTensor; self: CTensor }): CTensor => {
  return addon.atg__coalesce_out(out, self)
}

export const atg_is_coalesced = ({ self }: { self: CTensor }): boolean => {
  return addon.atg_is_coalesced(self)
}

export const atg__indices = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg__indices(self)
}

export const atg__values = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg__values(self)
}

export const atg__coalesced_ = ({ self, coalesced }: { self: CTensor; coalesced: boolean }): CTensor => {
  return addon.atg__coalesced_(self, coalesced)
}

export const atg_indices = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_indices(self)
}

export const atg_values = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_values(self)
}

export const atg_crow_indices = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_crow_indices(self)
}

export const atg_col_indices = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_col_indices(self)
}

export const atg_ccol_indices = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_ccol_indices(self)
}

export const atg_row_indices = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_row_indices(self)
}

export const atg_hspmm = ({ mat1, mat2 }: { mat1: CTensor; mat2: CTensor }): CTensor => {
  return addon.atg_hspmm(mat1, mat2)
}

export const atg_hspmm_out = ({ out, mat1, mat2 }: { out: CTensor; mat1: CTensor; mat2: CTensor }): CTensor => {
  return addon.atg_hspmm_out(out, mat1, mat2)
}

export const atg_copy_sparse_to_sparse_ = ({ self, src, non_blocking }: { self: CTensor; src: CTensor; non_blocking: boolean }): CTensor => {
  return addon.atg_copy_sparse_to_sparse_(self, src, non_blocking)
}

export const atg_to_sparse_sparse_dim = ({ self, sparse_dim }: { self: CTensor; sparse_dim: number }): CTensor => {
  return addon.atg_to_sparse_sparse_dim(self, sparse_dim)
}

export const atg_to_sparse = ({ self, layout, blocksize, dense_dim }: { self: CTensor; layout: number; blocksize?: number[]; dense_dim?: number }): CTensor => {
  return addon.atg_to_sparse(self, layout, blocksize, dense_dim)
}

export const atg_to_sparse_sparse_dim_out = ({ out, self, sparse_dim }: { out: CTensor; self: CTensor; sparse_dim: number }): CTensor => {
  return addon.atg_to_sparse_sparse_dim_out(out, self, sparse_dim)
}

export const atg_to_sparse_out = ({ out, self, layout, blocksize, dense_dim }: { out: CTensor; self: CTensor; layout: number; blocksize?: number[]; dense_dim?: number }): CTensor => {
  return addon.atg_to_sparse_out(out, self, layout, blocksize, dense_dim)
}

export const atg_to_sparse_csr = ({ self, dense_dim }: { self: CTensor; dense_dim?: number }): CTensor => {
  return addon.atg_to_sparse_csr(self, dense_dim)
}

export const atg_to_sparse_csr_out = ({ out, self, dense_dim }: { out: CTensor; self: CTensor; dense_dim?: number }): CTensor => {
  return addon.atg_to_sparse_csr_out(out, self, dense_dim)
}

export const atg_to_sparse_csc = ({ self, dense_dim }: { self: CTensor; dense_dim?: number }): CTensor => {
  return addon.atg_to_sparse_csc(self, dense_dim)
}

export const atg_to_sparse_csc_out = ({ out, self, dense_dim }: { out: CTensor; self: CTensor; dense_dim?: number }): CTensor => {
  return addon.atg_to_sparse_csc_out(out, self, dense_dim)
}

export const atg_to_sparse_bsr = ({ self, blocksize, dense_dim }: { self: CTensor; blocksize: number[]; dense_dim?: number }): CTensor => {
  return addon.atg_to_sparse_bsr(self, blocksize, dense_dim)
}

export const atg_to_sparse_bsr_out = ({ out, self, blocksize, dense_dim }: { out: CTensor; self: CTensor; blocksize: number[]; dense_dim?: number }): CTensor => {
  return addon.atg_to_sparse_bsr_out(out, self, blocksize, dense_dim)
}

export const atg_to_sparse_bsc = ({ self, blocksize, dense_dim }: { self: CTensor; blocksize: number[]; dense_dim?: number }): CTensor => {
  return addon.atg_to_sparse_bsc(self, blocksize, dense_dim)
}

export const atg_to_sparse_bsc_out = ({ out, self, blocksize, dense_dim }: { out: CTensor; self: CTensor; blocksize: number[]; dense_dim?: number }): CTensor => {
  return addon.atg_to_sparse_bsc_out(out, self, blocksize, dense_dim)
}

export const atg_to_mkldnn = ({ self, dtype }: { self: CTensor; dtype: number }): CTensor => {
  return addon.atg_to_mkldnn(self, dtype)
}

export const atg_to_mkldnn_out = ({ out, self, dtype }: { out: CTensor; self: CTensor; dtype: number }): CTensor => {
  return addon.atg_to_mkldnn_out(out, self, dtype)
}

export const atg_mkldnn_reorder_conv2d_weight = ({ self, padding, stride, dilation, groups, input_size }: { self: CTensor; padding: number[]; stride: number[]; dilation: number[]; groups: number; input_size?: number[] }): CTensor => {
  return addon.atg_mkldnn_reorder_conv2d_weight(self, padding, stride, dilation, groups, input_size)
}

export const atg_mkldnn_reorder_conv2d_weight_out = ({ out, self, padding, stride, dilation, groups, input_size }: { out: CTensor; self: CTensor; padding: number[]; stride: number[]; dilation: number[]; groups: number; input_size?: number[] }): CTensor => {
  return addon.atg_mkldnn_reorder_conv2d_weight_out(out, self, padding, stride, dilation, groups, input_size)
}

export const atg_mkldnn_reorder_conv3d_weight = ({ self, padding, stride, dilation, groups }: { self: CTensor; padding: number[]; stride: number[]; dilation: number[]; groups: number }): CTensor => {
  return addon.atg_mkldnn_reorder_conv3d_weight(self, padding, stride, dilation, groups)
}

export const atg_mkldnn_reorder_conv3d_weight_out = ({ out, self, padding, stride, dilation, groups }: { out: CTensor; self: CTensor; padding: number[]; stride: number[]; dilation: number[]; groups: number }): CTensor => {
  return addon.atg_mkldnn_reorder_conv3d_weight_out(out, self, padding, stride, dilation, groups)
}

export const atg_to_mkldnn_backward = ({ grad, input }: { grad: CTensor; input: CTensor }): CTensor => {
  return addon.atg_to_mkldnn_backward(grad, input)
}

export const atg_quantize_per_tensor_dynamic = ({ self, dtype, reduce_range }: { self: CTensor; dtype: number; reduce_range: boolean }): CTensor => {
  return addon.atg_quantize_per_tensor_dynamic(self, dtype, reduce_range)
}

export const atg_quantize_per_tensor_dynamic_out = ({ out, self, dtype, reduce_range }: { out: CTensor; self: CTensor; dtype: number; reduce_range: boolean }): CTensor => {
  return addon.atg_quantize_per_tensor_dynamic_out(out, self, dtype, reduce_range)
}

export const atg_quantize_per_tensor = ({ self, scale, zero_point, dtype }: { self: CTensor; scale: number; zero_point: number; dtype: number }): CTensor => {
  return addon.atg_quantize_per_tensor(self, scale, zero_point, dtype)
}

export const atg_quantize_per_tensor_tensor_qparams = ({ self, scale, zero_point, dtype }: { self: CTensor; scale: CTensor; zero_point: CTensor; dtype: number }): CTensor => {
  return addon.atg_quantize_per_tensor_tensor_qparams(self, scale, zero_point, dtype)
}

export const atg_quantize_per_tensor_out = ({ out, self, scale, zero_point, dtype }: { out: CTensor; self: CTensor; scale: number; zero_point: number; dtype: number }): CTensor => {
  return addon.atg_quantize_per_tensor_out(out, self, scale, zero_point, dtype)
}

export const atg_quantize_per_tensor_tensor_qparams_out = ({ out, self, scale, zero_point, dtype }: { out: CTensor; self: CTensor; scale: CTensor; zero_point: CTensor; dtype: number }): CTensor => {
  return addon.atg_quantize_per_tensor_tensor_qparams_out(out, self, scale, zero_point, dtype)
}

export const atg_quantize_per_tensor_tensors_out = ({ out, tensors, scales, zero_points, dtype }: { out: CTensor[]; tensors: CTensor[]; scales: CTensor; zero_points: CTensor; dtype: number }): void => {
  return addon.atg_quantize_per_tensor_tensors_out(out, tensors, scales, zero_points, dtype)
}

export const atg_quantize_per_channel = ({ self, scales, zero_points, axis, dtype }: { self: CTensor; scales: CTensor; zero_points: CTensor; axis: number; dtype: number }): CTensor => {
  return addon.atg_quantize_per_channel(self, scales, zero_points, axis, dtype)
}

export const atg_quantize_per_channel_out = ({ out, self, scales, zero_points, axis, dtype }: { out: CTensor; self: CTensor; scales: CTensor; zero_points: CTensor; axis: number; dtype: number }): CTensor => {
  return addon.atg_quantize_per_channel_out(out, self, scales, zero_points, axis, dtype)
}

export const atg_dequantize = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_dequantize(self)
}

export const atg_dequantize_self_out = ({ out, self }: { out: CTensor; self: CTensor }): CTensor => {
  return addon.atg_dequantize_self_out(out, self)
}

export const atg_dequantize_tensors_out = ({ out, tensors }: { out: CTensor[]; tensors: CTensor[] }): void => {
  return addon.atg_dequantize_tensors_out(out, tensors)
}

export const atg_q_scale = ({ self }: { self: CTensor }): number => {
  return addon.atg_q_scale(self)
}

export const atg_q_zero_point = ({ self }: { self: CTensor }): number => {
  return addon.atg_q_zero_point(self)
}

export const atg_q_per_channel_scales = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_q_per_channel_scales(self)
}

export const atg_q_per_channel_scales_out = ({ out, self }: { out: CTensor; self: CTensor }): CTensor => {
  return addon.atg_q_per_channel_scales_out(out, self)
}

export const atg_q_per_channel_zero_points = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_q_per_channel_zero_points(self)
}

export const atg_q_per_channel_zero_points_out = ({ out, self }: { out: CTensor; self: CTensor }): CTensor => {
  return addon.atg_q_per_channel_zero_points_out(out, self)
}

export const atg_q_per_channel_axis = ({ self }: { self: CTensor }): number => {
  return addon.atg_q_per_channel_axis(self)
}

export const atg_int_repr = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_int_repr(self)
}

export const atg_int_repr_out = ({ out, self }: { out: CTensor; self: CTensor }): CTensor => {
  return addon.atg_int_repr_out(out, self)
}

export const atg__make_per_tensor_quantized_tensor = ({ self, scale, zero_point }: { self: CTensor; scale: number; zero_point: number }): CTensor => {
  return addon.atg__make_per_tensor_quantized_tensor(self, scale, zero_point)
}

export const atg__make_per_tensor_quantized_tensor_out = ({ out, self, scale, zero_point }: { out: CTensor; self: CTensor; scale: number; zero_point: number }): CTensor => {
  return addon.atg__make_per_tensor_quantized_tensor_out(out, self, scale, zero_point)
}

export const atg__make_per_channel_quantized_tensor = ({ self, scale, zero_point, axis }: { self: CTensor; scale: CTensor; zero_point: CTensor; axis: number }): CTensor => {
  return addon.atg__make_per_channel_quantized_tensor(self, scale, zero_point, axis)
}

export const atg__make_per_channel_quantized_tensor_out = ({ out, self, scale, zero_point, axis }: { out: CTensor; self: CTensor; scale: CTensor; zero_point: CTensor; axis: number }): CTensor => {
  return addon.atg__make_per_channel_quantized_tensor_out(out, self, scale, zero_point, axis)
}

export const atg_fake_quantize_per_tensor_affine = ({ self, scale, zero_point, quant_min, quant_max }: { self: CTensor; scale: number; zero_point: number; quant_min: number; quant_max: number }): CTensor => {
  return addon.atg_fake_quantize_per_tensor_affine(self, scale, zero_point, quant_min, quant_max)
}

export const atg_fake_quantize_per_tensor_affine_tensor_qparams = ({ self, scale, zero_point, quant_min, quant_max }: { self: CTensor; scale: CTensor; zero_point: CTensor; quant_min: number; quant_max: number }): CTensor => {
  return addon.atg_fake_quantize_per_tensor_affine_tensor_qparams(self, scale, zero_point, quant_min, quant_max)
}

export const atg_fake_quantize_per_tensor_affine_cachemask = ({ self, scale, zero_point, quant_min, quant_max }: { self: CTensor; scale: number; zero_point: number; quant_min: number; quant_max: number }): CTensor[] => {
  return addon.atg_fake_quantize_per_tensor_affine_cachemask(self, scale, zero_point, quant_min, quant_max)
}

export const atg_fake_quantize_per_tensor_affine_cachemask_out = ({ out0, out1, self, scale, zero_point, quant_min, quant_max }: { out0: CTensor; out1: CTensor; self: CTensor; scale: number; zero_point: number; quant_min: number; quant_max: number }): CTensor[] => {
  return addon.atg_fake_quantize_per_tensor_affine_cachemask_out(out0, out1, self, scale, zero_point, quant_min, quant_max)
}

export const atg__fake_quantize_per_tensor_affine_cachemask_tensor_qparams = ({ self, scale, zero_point, fake_quant_enabled, quant_min, quant_max }: { self: CTensor; scale: CTensor; zero_point: CTensor; fake_quant_enabled: CTensor; quant_min: number; quant_max: number }): CTensor[] => {
  return addon.atg__fake_quantize_per_tensor_affine_cachemask_tensor_qparams(self, scale, zero_point, fake_quant_enabled, quant_min, quant_max)
}

export const atg__fake_quantize_per_tensor_affine_cachemask_tensor_qparams_out = ({ out0, out1, self, scale, zero_point, fake_quant_enabled, quant_min, quant_max }: { out0: CTensor; out1: CTensor; self: CTensor; scale: CTensor; zero_point: CTensor; fake_quant_enabled: CTensor; quant_min: number; quant_max: number }): CTensor[] => {
  return addon.atg__fake_quantize_per_tensor_affine_cachemask_tensor_qparams_out(out0, out1, self, scale, zero_point, fake_quant_enabled, quant_min, quant_max)
}

export const atg_fake_quantize_per_tensor_affine_cachemask_backward = ({ grad, mask }: { grad: CTensor; mask: CTensor }): CTensor => {
  return addon.atg_fake_quantize_per_tensor_affine_cachemask_backward(grad, mask)
}

export const atg__fake_quantize_learnable_per_tensor_affine = ({ self, scale, zero_point, quant_min, quant_max, grad_factor }: { self: CTensor; scale: CTensor; zero_point: CTensor; quant_min: number; quant_max: number; grad_factor: number }): CTensor => {
  return addon.atg__fake_quantize_learnable_per_tensor_affine(self, scale, zero_point, quant_min, quant_max, grad_factor)
}

export const atg__fake_quantize_learnable_per_tensor_affine_out = ({ out, self, scale, zero_point, quant_min, quant_max, grad_factor }: { out: CTensor; self: CTensor; scale: CTensor; zero_point: CTensor; quant_min: number; quant_max: number; grad_factor: number }): CTensor => {
  return addon.atg__fake_quantize_learnable_per_tensor_affine_out(out, self, scale, zero_point, quant_min, quant_max, grad_factor)
}

export const atg__fake_quantize_learnable_per_tensor_affine_backward = ({ grad, self, scale, zero_point, quant_min, quant_max, grad_factor }: { grad: CTensor; self: CTensor; scale: CTensor; zero_point: CTensor; quant_min: number; quant_max: number; grad_factor: number }): CTensor[] => {
  return addon.atg__fake_quantize_learnable_per_tensor_affine_backward(grad, self, scale, zero_point, quant_min, quant_max, grad_factor)
}

export const atg_fake_quantize_per_channel_affine = ({ self, scale, zero_point, axis, quant_min, quant_max }: { self: CTensor; scale: CTensor; zero_point: CTensor; axis: number; quant_min: number; quant_max: number }): CTensor => {
  return addon.atg_fake_quantize_per_channel_affine(self, scale, zero_point, axis, quant_min, quant_max)
}

export const atg_fake_quantize_per_channel_affine_cachemask = ({ self, scale, zero_point, axis, quant_min, quant_max }: { self: CTensor; scale: CTensor; zero_point: CTensor; axis: number; quant_min: number; quant_max: number }): CTensor[] => {
  return addon.atg_fake_quantize_per_channel_affine_cachemask(self, scale, zero_point, axis, quant_min, quant_max)
}

export const atg_fake_quantize_per_channel_affine_cachemask_out = ({ out0, out1, self, scale, zero_point, axis, quant_min, quant_max }: { out0: CTensor; out1: CTensor; self: CTensor; scale: CTensor; zero_point: CTensor; axis: number; quant_min: number; quant_max: number }): CTensor[] => {
  return addon.atg_fake_quantize_per_channel_affine_cachemask_out(out0, out1, self, scale, zero_point, axis, quant_min, quant_max)
}

export const atg_fake_quantize_per_channel_affine_cachemask_backward = ({ grad, mask }: { grad: CTensor; mask: CTensor }): CTensor => {
  return addon.atg_fake_quantize_per_channel_affine_cachemask_backward(grad, mask)
}

export const atg__fake_quantize_learnable_per_channel_affine = ({ self, scale, zero_point, axis, quant_min, quant_max, grad_factor }: { self: CTensor; scale: CTensor; zero_point: CTensor; axis: number; quant_min: number; quant_max: number; grad_factor: number }): CTensor => {
  return addon.atg__fake_quantize_learnable_per_channel_affine(self, scale, zero_point, axis, quant_min, quant_max, grad_factor)
}

export const atg__fake_quantize_learnable_per_channel_affine_out = ({ out, self, scale, zero_point, axis, quant_min, quant_max, grad_factor }: { out: CTensor; self: CTensor; scale: CTensor; zero_point: CTensor; axis: number; quant_min: number; quant_max: number; grad_factor: number }): CTensor => {
  return addon.atg__fake_quantize_learnable_per_channel_affine_out(out, self, scale, zero_point, axis, quant_min, quant_max, grad_factor)
}

export const atg__fake_quantize_learnable_per_channel_affine_backward = ({ grad, self, scale, zero_point, axis, quant_min, quant_max, grad_factor }: { grad: CTensor; self: CTensor; scale: CTensor; zero_point: CTensor; axis: number; quant_min: number; quant_max: number; grad_factor: number }): CTensor[] => {
  return addon.atg__fake_quantize_learnable_per_channel_affine_backward(grad, self, scale, zero_point, axis, quant_min, quant_max, grad_factor)
}

export const atg_fused_moving_avg_obs_fake_quant = ({ self, observer_on, fake_quant_on, running_min, running_max, scale, zero_point, averaging_const, quant_min, quant_max, ch_axis, per_row_fake_quant, symmetric_quant }: { self: CTensor; observer_on: CTensor; fake_quant_on: CTensor; running_min: CTensor; running_max: CTensor; scale: CTensor; zero_point: CTensor; averaging_const: number; quant_min: number; quant_max: number; ch_axis: number; per_row_fake_quant: boolean; symmetric_quant: boolean }): CTensor => {
  return addon.atg_fused_moving_avg_obs_fake_quant(self, observer_on, fake_quant_on, running_min, running_max, scale, zero_point, averaging_const, quant_min, quant_max, ch_axis, per_row_fake_quant, symmetric_quant)
}

export const atg__fused_moving_avg_obs_fq_helper = ({ self, observer_on, fake_quant_on, running_min, running_max, scale, zero_point, averaging_const, quant_min, quant_max, ch_axis, per_row_fake_quant, symmetric_quant }: { self: CTensor; observer_on: CTensor; fake_quant_on: CTensor; running_min: CTensor; running_max: CTensor; scale: CTensor; zero_point: CTensor; averaging_const: number; quant_min: number; quant_max: number; ch_axis: number; per_row_fake_quant: boolean; symmetric_quant: boolean }): CTensor[] => {
  return addon.atg__fused_moving_avg_obs_fq_helper(self, observer_on, fake_quant_on, running_min, running_max, scale, zero_point, averaging_const, quant_min, quant_max, ch_axis, per_row_fake_quant, symmetric_quant)
}

export const atg__fused_moving_avg_obs_fq_helper_out = ({ out0, out1, self, observer_on, fake_quant_on, running_min, running_max, scale, zero_point, averaging_const, quant_min, quant_max, ch_axis, per_row_fake_quant, symmetric_quant }: { out0: CTensor; out1: CTensor; self: CTensor; observer_on: CTensor; fake_quant_on: CTensor; running_min: CTensor; running_max: CTensor; scale: CTensor; zero_point: CTensor; averaging_const: number; quant_min: number; quant_max: number; ch_axis: number; per_row_fake_quant: boolean; symmetric_quant: boolean }): CTensor[] => {
  return addon.atg__fused_moving_avg_obs_fq_helper_out(out0, out1, self, observer_on, fake_quant_on, running_min, running_max, scale, zero_point, averaging_const, quant_min, quant_max, ch_axis, per_row_fake_quant, symmetric_quant)
}

export const atg__saturate_weight_to_fp16 = ({ weight }: { weight: CTensor }): CTensor => {
  return addon.atg__saturate_weight_to_fp16(weight)
}

export const atg_choose_qparams_optimized = ({ input, numel, n_bins, ratio, bit_width }: { input: CTensor; numel: number; n_bins: number; ratio: number; bit_width: number }): CTensor[] => {
  return addon.atg_choose_qparams_optimized(input, numel, n_bins, ratio, bit_width)
}

export const atg__autocast_to_reduced_precision = ({ self, cuda_enabled, cpu_enabled, cuda_dtype, cpu_dtype }: { self: CTensor; cuda_enabled: boolean; cpu_enabled: boolean; cuda_dtype: number; cpu_dtype: number }): CTensor => {
  return addon.atg__autocast_to_reduced_precision(self, cuda_enabled, cpu_enabled, cuda_dtype, cpu_dtype)
}

export const atg__autocast_to_full_precision = ({ self, cuda_enabled, cpu_enabled }: { self: CTensor; cuda_enabled: boolean; cpu_enabled: boolean }): CTensor => {
  return addon.atg__autocast_to_full_precision(self, cuda_enabled, cpu_enabled)
}

export const atg__to_copy = ({ self, options, non_blocking, memory_format }: { self: CTensor; options: { device: number, dtype: number }; non_blocking: boolean; memory_format: number }): CTensor => {
  return addon.atg__to_copy(self, options, non_blocking, memory_format)
}

export const atg__to_copy_out = ({ out, self, non_blocking, memory_format }: { out: CTensor; self: CTensor; non_blocking: boolean; memory_format: number }): CTensor => {
  return addon.atg__to_copy_out(out, self, non_blocking, memory_format)
}

export const atg_to = ({ self, options, non_blocking, copy, memory_format }: { self: CTensor; options: { device: number, dtype: number }; non_blocking: boolean; copy: boolean; memory_format: number }): CTensor => {
  return addon.atg_to(self, options, non_blocking, copy, memory_format)
}

export const atg_to_dtype = ({ self, dtype, non_blocking, copy, memory_format }: { self: CTensor; dtype: number; non_blocking: boolean; copy: boolean; memory_format: number }): CTensor => {
  return addon.atg_to_dtype(self, dtype, non_blocking, copy, memory_format)
}

export const atg_to_other = ({ self, other, non_blocking, copy, memory_format }: { self: CTensor; other: CTensor; non_blocking: boolean; copy: boolean; memory_format: number }): CTensor => {
  return addon.atg_to_other(self, other, non_blocking, copy, memory_format)
}

export const atg_to_device = ({ self, device, dtype, non_blocking, copy, memory_format }: { self: CTensor; device: number; dtype: number; non_blocking: boolean; copy: boolean; memory_format: number }): CTensor => {
  return addon.atg_to_device(self, device, dtype, non_blocking, copy, memory_format)
}

export const atg_cartesian_prod = ({ tensors }: { tensors: CTensor[] }): CTensor => {
  return addon.atg_cartesian_prod(tensors)
}

export const atg_combinations = ({ self, r, with_replacement }: { self: CTensor; r: number; with_replacement: boolean }): CTensor => {
  return addon.atg_combinations(self, r, with_replacement)
}

export const atg_can_cast = ({ from, to }: { from: number; to: number }): boolean => {
  return addon.atg_can_cast(from, to)
}

export const atg__lstm_mps = ({ input, hx, params, has_biases, num_layers, dropout, train, bidirectional, batch_first }: { input: CTensor; hx: CTensor[]; params: CTensor[]; has_biases: boolean; num_layers: number; dropout: number; train: boolean; bidirectional: boolean; batch_first: boolean }): CTensor[] => {
  return addon.atg__lstm_mps(input, hx, params, has_biases, num_layers, dropout, train, bidirectional, batch_first)
}

export const atg__lstm_mps_out = ({ out0, out1, out2, out3, out4, out5, input, hx, params, has_biases, num_layers, dropout, train, bidirectional, batch_first }: { out0: CTensor; out1: CTensor; out2: CTensor; out3: CTensor; out4: CTensor; out5: CTensor; input: CTensor; hx: CTensor[]; params: CTensor[]; has_biases: boolean; num_layers: number; dropout: number; train: boolean; bidirectional: boolean; batch_first: boolean }): CTensor[] => {
  return addon.atg__lstm_mps_out(out0, out1, out2, out3, out4, out5, input, hx, params, has_biases, num_layers, dropout, train, bidirectional, batch_first)
}

export const atg_lstm = ({ input, hx, params, has_biases, num_layers, dropout, train, bidirectional, batch_first }: { input: CTensor; hx: CTensor[]; params: CTensor[]; has_biases: boolean; num_layers: number; dropout: number; train: boolean; bidirectional: boolean; batch_first: boolean }): CTensor[] => {
  return addon.atg_lstm(input, hx, params, has_biases, num_layers, dropout, train, bidirectional, batch_first)
}

export const atg_lstm_data = ({ data, batch_sizes, hx, params, has_biases, num_layers, dropout, train, bidirectional }: { data: CTensor; batch_sizes: CTensor; hx: CTensor[]; params: CTensor[]; has_biases: boolean; num_layers: number; dropout: number; train: boolean; bidirectional: boolean }): CTensor[] => {
  return addon.atg_lstm_data(data, batch_sizes, hx, params, has_biases, num_layers, dropout, train, bidirectional)
}

export const atg_gru = ({ input, hx, params, has_biases, num_layers, dropout, train, bidirectional, batch_first }: { input: CTensor; hx: CTensor; params: CTensor[]; has_biases: boolean; num_layers: number; dropout: number; train: boolean; bidirectional: boolean; batch_first: boolean }): CTensor[] => {
  return addon.atg_gru(input, hx, params, has_biases, num_layers, dropout, train, bidirectional, batch_first)
}

export const atg_gru_data = ({ data, batch_sizes, hx, params, has_biases, num_layers, dropout, train, bidirectional }: { data: CTensor; batch_sizes: CTensor; hx: CTensor; params: CTensor[]; has_biases: boolean; num_layers: number; dropout: number; train: boolean; bidirectional: boolean }): CTensor[] => {
  return addon.atg_gru_data(data, batch_sizes, hx, params, has_biases, num_layers, dropout, train, bidirectional)
}

export const atg_rnn_tanh = ({ input, hx, params, has_biases, num_layers, dropout, train, bidirectional, batch_first }: { input: CTensor; hx: CTensor; params: CTensor[]; has_biases: boolean; num_layers: number; dropout: number; train: boolean; bidirectional: boolean; batch_first: boolean }): CTensor[] => {
  return addon.atg_rnn_tanh(input, hx, params, has_biases, num_layers, dropout, train, bidirectional, batch_first)
}

export const atg_rnn_tanh_data = ({ data, batch_sizes, hx, params, has_biases, num_layers, dropout, train, bidirectional }: { data: CTensor; batch_sizes: CTensor; hx: CTensor; params: CTensor[]; has_biases: boolean; num_layers: number; dropout: number; train: boolean; bidirectional: boolean }): CTensor[] => {
  return addon.atg_rnn_tanh_data(data, batch_sizes, hx, params, has_biases, num_layers, dropout, train, bidirectional)
}

export const atg_rnn_relu = ({ input, hx, params, has_biases, num_layers, dropout, train, bidirectional, batch_first }: { input: CTensor; hx: CTensor; params: CTensor[]; has_biases: boolean; num_layers: number; dropout: number; train: boolean; bidirectional: boolean; batch_first: boolean }): CTensor[] => {
  return addon.atg_rnn_relu(input, hx, params, has_biases, num_layers, dropout, train, bidirectional, batch_first)
}

export const atg_rnn_relu_data = ({ data, batch_sizes, hx, params, has_biases, num_layers, dropout, train, bidirectional }: { data: CTensor; batch_sizes: CTensor; hx: CTensor; params: CTensor[]; has_biases: boolean; num_layers: number; dropout: number; train: boolean; bidirectional: boolean }): CTensor[] => {
  return addon.atg_rnn_relu_data(data, batch_sizes, hx, params, has_biases, num_layers, dropout, train, bidirectional)
}

export const atg_lstm_cell = ({ input, hx, w_ih, w_hh, b_ih, b_hh }: { input: CTensor; hx: CTensor[]; w_ih: CTensor; w_hh: CTensor; b_ih?: CTensor; b_hh?: CTensor }): CTensor[] => {
  return addon.atg_lstm_cell(input, hx, w_ih, w_hh, b_ih, b_hh)
}

export const atg_gru_cell = ({ input, hx, w_ih, w_hh, b_ih, b_hh }: { input: CTensor; hx: CTensor; w_ih: CTensor; w_hh: CTensor; b_ih?: CTensor; b_hh?: CTensor }): CTensor => {
  return addon.atg_gru_cell(input, hx, w_ih, w_hh, b_ih, b_hh)
}

export const atg_rnn_tanh_cell = ({ input, hx, w_ih, w_hh, b_ih, b_hh }: { input: CTensor; hx: CTensor; w_ih: CTensor; w_hh: CTensor; b_ih?: CTensor; b_hh?: CTensor }): CTensor => {
  return addon.atg_rnn_tanh_cell(input, hx, w_ih, w_hh, b_ih, b_hh)
}

export const atg_rnn_relu_cell = ({ input, hx, w_ih, w_hh, b_ih, b_hh }: { input: CTensor; hx: CTensor; w_ih: CTensor; w_hh: CTensor; b_ih?: CTensor; b_hh?: CTensor }): CTensor => {
  return addon.atg_rnn_relu_cell(input, hx, w_ih, w_hh, b_ih, b_hh)
}

export const atg_quantized_lstm_cell = ({ input, hx, w_ih, w_hh, b_ih, b_hh, packed_ih, packed_hh, col_offsets_ih, col_offsets_hh, scale_ih, scale_hh, zero_point_ih, zero_point_hh }: { input: CTensor; hx: CTensor[]; w_ih: CTensor; w_hh: CTensor; b_ih: CTensor; b_hh: CTensor; packed_ih: CTensor; packed_hh: CTensor; col_offsets_ih: CTensor; col_offsets_hh: CTensor; scale_ih: CScalar; scale_hh: CScalar; zero_point_ih: CScalar; zero_point_hh: CScalar }): CTensor[] => {
  return addon.atg_quantized_lstm_cell(input, hx, w_ih, w_hh, b_ih, b_hh, packed_ih, packed_hh, col_offsets_ih, col_offsets_hh, scale_ih, scale_hh, zero_point_ih, zero_point_hh)
}

export const atg_quantized_gru_cell = ({ input, hx, w_ih, w_hh, b_ih, b_hh, packed_ih, packed_hh, col_offsets_ih, col_offsets_hh, scale_ih, scale_hh, zero_point_ih, zero_point_hh }: { input: CTensor; hx: CTensor; w_ih: CTensor; w_hh: CTensor; b_ih: CTensor; b_hh: CTensor; packed_ih: CTensor; packed_hh: CTensor; col_offsets_ih: CTensor; col_offsets_hh: CTensor; scale_ih: CScalar; scale_hh: CScalar; zero_point_ih: CScalar; zero_point_hh: CScalar }): CTensor => {
  return addon.atg_quantized_gru_cell(input, hx, w_ih, w_hh, b_ih, b_hh, packed_ih, packed_hh, col_offsets_ih, col_offsets_hh, scale_ih, scale_hh, zero_point_ih, zero_point_hh)
}

export const atg_quantized_rnn_relu_cell = ({ input, hx, w_ih, w_hh, b_ih, b_hh, packed_ih, packed_hh, col_offsets_ih, col_offsets_hh, scale_ih, scale_hh, zero_point_ih, zero_point_hh }: { input: CTensor; hx: CTensor; w_ih: CTensor; w_hh: CTensor; b_ih: CTensor; b_hh: CTensor; packed_ih: CTensor; packed_hh: CTensor; col_offsets_ih: CTensor; col_offsets_hh: CTensor; scale_ih: CScalar; scale_hh: CScalar; zero_point_ih: CScalar; zero_point_hh: CScalar }): CTensor => {
  return addon.atg_quantized_rnn_relu_cell(input, hx, w_ih, w_hh, b_ih, b_hh, packed_ih, packed_hh, col_offsets_ih, col_offsets_hh, scale_ih, scale_hh, zero_point_ih, zero_point_hh)
}

export const atg_quantized_rnn_tanh_cell = ({ input, hx, w_ih, w_hh, b_ih, b_hh, packed_ih, packed_hh, col_offsets_ih, col_offsets_hh, scale_ih, scale_hh, zero_point_ih, zero_point_hh }: { input: CTensor; hx: CTensor; w_ih: CTensor; w_hh: CTensor; b_ih: CTensor; b_hh: CTensor; packed_ih: CTensor; packed_hh: CTensor; col_offsets_ih: CTensor; col_offsets_hh: CTensor; scale_ih: CScalar; scale_hh: CScalar; zero_point_ih: CScalar; zero_point_hh: CScalar }): CTensor => {
  return addon.atg_quantized_rnn_tanh_cell(input, hx, w_ih, w_hh, b_ih, b_hh, packed_ih, packed_hh, col_offsets_ih, col_offsets_hh, scale_ih, scale_hh, zero_point_ih, zero_point_hh)
}

export const atg__pack_padded_sequence = ({ input, lengths, batch_first }: { input: CTensor; lengths: CTensor; batch_first: boolean }): CTensor[] => {
  return addon.atg__pack_padded_sequence(input, lengths, batch_first)
}

export const atg__pack_padded_sequence_out = ({ out0, out1, input, lengths, batch_first }: { out0: CTensor; out1: CTensor; input: CTensor; lengths: CTensor; batch_first: boolean }): CTensor[] => {
  return addon.atg__pack_padded_sequence_out(out0, out1, input, lengths, batch_first)
}

export const atg__pack_padded_sequence_backward = ({ grad, input_size, batch_sizes, batch_first }: { grad: CTensor; input_size: number[]; batch_sizes: CTensor; batch_first: boolean }): CTensor => {
  return addon.atg__pack_padded_sequence_backward(grad, input_size, batch_sizes, batch_first)
}

export const atg__pad_packed_sequence = ({ data, batch_sizes, batch_first, padding_value, total_length }: { data: CTensor; batch_sizes: CTensor; batch_first: boolean; padding_value: CScalar; total_length: number }): CTensor[] => {
  return addon.atg__pad_packed_sequence(data, batch_sizes, batch_first, padding_value, total_length)
}

export const atg_set_ = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_set_(self)
}

export const atg_set_source_tensor_ = ({ self, source }: { self: CTensor; source: CTensor }): CTensor => {
  return addon.atg_set_source_tensor_(self, source)
}

export const atg_set_source_tensor_storage_offset_ = ({ self, source, storage_offset, size, stride }: { self: CTensor; source: CTensor; storage_offset: number; size: number[]; stride: number[] }): CTensor => {
  return addon.atg_set_source_tensor_storage_offset_(self, source, storage_offset, size, stride)
}

export const atg_lift = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_lift(self)
}

export const atg_lift_out = ({ out, self }: { out: CTensor; self: CTensor }): CTensor => {
  return addon.atg_lift_out(out, self)
}

export const atg_lift_fresh = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_lift_fresh(self)
}

export const atg_lift_fresh_copy = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_lift_fresh_copy(self)
}

export const atg_lift_fresh_copy_out = ({ out, self }: { out: CTensor; self: CTensor }): CTensor => {
  return addon.atg_lift_fresh_copy_out(out, self)
}

export const atg_is_set_to = ({ self, tensor }: { self: CTensor; tensor: CTensor }): boolean => {
  return addon.atg_is_set_to(self, tensor)
}

export const atg_masked_fill_ = ({ self, mask, value }: { self: CTensor; mask: CTensor; value: CScalar }): CTensor => {
  return addon.atg_masked_fill_(self, mask, value)
}

export const atg_masked_fill_tensor_ = ({ self, mask, value }: { self: CTensor; mask: CTensor; value: CTensor }): CTensor => {
  return addon.atg_masked_fill_tensor_(self, mask, value)
}

export const atg_masked_fill = ({ self, mask, value }: { self: CTensor; mask: CTensor; value: CScalar }): CTensor => {
  return addon.atg_masked_fill(self, mask, value)
}

export const atg_masked_fill_tensor = ({ self, mask, value }: { self: CTensor; mask: CTensor; value: CTensor }): CTensor => {
  return addon.atg_masked_fill_tensor(self, mask, value)
}

export const atg_masked_fill_scalar_out = ({ out, self, mask, value }: { out: CTensor; self: CTensor; mask: CTensor; value: CScalar }): CTensor => {
  return addon.atg_masked_fill_scalar_out(out, self, mask, value)
}

export const atg_masked_fill_tensor_out = ({ out, self, mask, value }: { out: CTensor; self: CTensor; mask: CTensor; value: CTensor }): CTensor => {
  return addon.atg_masked_fill_tensor_out(out, self, mask, value)
}

export const atg_masked_scatter_ = ({ self, mask, source }: { self: CTensor; mask: CTensor; source: CTensor }): CTensor => {
  return addon.atg_masked_scatter_(self, mask, source)
}

export const atg_masked_scatter = ({ self, mask, source }: { self: CTensor; mask: CTensor; source: CTensor }): CTensor => {
  return addon.atg_masked_scatter(self, mask, source)
}

export const atg_masked_scatter_out = ({ out, self, mask, source }: { out: CTensor; self: CTensor; mask: CTensor; source: CTensor }): CTensor => {
  return addon.atg_masked_scatter_out(out, self, mask, source)
}

export const atg__masked_softmax = ({ self, mask, dim, mask_type }: { self: CTensor; mask: CTensor; dim?: number; mask_type?: number }): CTensor => {
  return addon.atg__masked_softmax(self, mask, dim, mask_type)
}

export const atg__masked_softmax_out = ({ out, self, mask, dim, mask_type }: { out: CTensor; self: CTensor; mask: CTensor; dim?: number; mask_type?: number }): CTensor => {
  return addon.atg__masked_softmax_out(out, self, mask, dim, mask_type)
}

export const atg__masked_softmax_backward = ({ grad_output, output, mask, dim }: { grad_output: CTensor; output: CTensor; mask: CTensor; dim?: number }): CTensor => {
  return addon.atg__masked_softmax_backward(grad_output, output, mask, dim)
}

export const atg__masked_softmax_backward_out = ({ out, grad_output, output, mask, dim }: { out: CTensor; grad_output: CTensor; output: CTensor; mask: CTensor; dim?: number }): CTensor => {
  return addon.atg__masked_softmax_backward_out(out, grad_output, output, mask, dim)
}

export const atg_view = ({ self, size }: { self: CTensor; size: number[] }): CTensor => {
  return addon.atg_view(self, size)
}

export const atg_view_dtype = ({ self, dtype }: { self: CTensor; dtype: number }): CTensor => {
  return addon.atg_view_dtype(self, dtype)
}

export const atg_put_ = ({ self, index, source, accumulate }: { self: CTensor; index: CTensor; source: CTensor; accumulate: boolean }): CTensor => {
  return addon.atg_put_(self, index, source, accumulate)
}

export const atg_put = ({ self, index, source, accumulate }: { self: CTensor; index: CTensor; source: CTensor; accumulate: boolean }): CTensor => {
  return addon.atg_put(self, index, source, accumulate)
}

export const atg_put_out = ({ out, self, index, source, accumulate }: { out: CTensor; self: CTensor; index: CTensor; source: CTensor; accumulate: boolean }): CTensor => {
  return addon.atg_put_out(out, self, index, source, accumulate)
}

export const atg_index_add = ({ self, dim, index, source, alpha }: { self: CTensor; dim: number; index: CTensor; source: CTensor; alpha: CScalar }): CTensor => {
  return addon.atg_index_add(self, dim, index, source, alpha)
}

export const atg_index_add_out = ({ out, self, dim, index, source, alpha }: { out: CTensor; self: CTensor; dim: number; index: CTensor; source: CTensor; alpha: CScalar }): CTensor => {
  return addon.atg_index_add_out(out, self, dim, index, source, alpha)
}

export const atg_index_add_ = ({ self, dim, index, source, alpha }: { self: CTensor; dim: number; index: CTensor; source: CTensor; alpha: CScalar }): CTensor => {
  return addon.atg_index_add_(self, dim, index, source, alpha)
}

export const atg_index_reduce = ({ self, dim, index, source, reduce, include_self }: { self: CTensor; dim: number; index: CTensor; source: CTensor; reduce: string; include_self: boolean }): CTensor => {
  return addon.atg_index_reduce(self, dim, index, source, reduce, include_self)
}

export const atg_index_reduce_out = ({ out, self, dim, index, source, reduce, include_self }: { out: CTensor; self: CTensor; dim: number; index: CTensor; source: CTensor; reduce: string; include_self: boolean }): CTensor => {
  return addon.atg_index_reduce_out(out, self, dim, index, source, reduce, include_self)
}

export const atg_index_reduce_ = ({ self, dim, index, source, reduce, include_self }: { self: CTensor; dim: number; index: CTensor; source: CTensor; reduce: string; include_self: boolean }): CTensor => {
  return addon.atg_index_reduce_(self, dim, index, source, reduce, include_self)
}

export const atg_index_fill_ = ({ self, dim, index, value }: { self: CTensor; dim: number; index: CTensor; value: CScalar }): CTensor => {
  return addon.atg_index_fill_(self, dim, index, value)
}

export const atg_index_fill_int_tensor_ = ({ self, dim, index, value }: { self: CTensor; dim: number; index: CTensor; value: CTensor }): CTensor => {
  return addon.atg_index_fill_int_tensor_(self, dim, index, value)
}

export const atg_index_fill = ({ self, dim, index, value }: { self: CTensor; dim: number; index: CTensor; value: CScalar }): CTensor => {
  return addon.atg_index_fill(self, dim, index, value)
}

export const atg_index_fill_int_tensor = ({ self, dim, index, value }: { self: CTensor; dim: number; index: CTensor; value: CTensor }): CTensor => {
  return addon.atg_index_fill_int_tensor(self, dim, index, value)
}

export const atg_index_fill_int_scalar_out = ({ out, self, dim, index, value }: { out: CTensor; self: CTensor; dim: number; index: CTensor; value: CScalar }): CTensor => {
  return addon.atg_index_fill_int_scalar_out(out, self, dim, index, value)
}

export const atg_index_fill_int_tensor_out = ({ out, self, dim, index, value }: { out: CTensor; self: CTensor; dim: number; index: CTensor; value: CTensor }): CTensor => {
  return addon.atg_index_fill_int_tensor_out(out, self, dim, index, value)
}

export const atg_scatter = ({ self, dim, index, src }: { self: CTensor; dim: number; index: CTensor; src: CTensor }): CTensor => {
  return addon.atg_scatter(self, dim, index, src)
}

export const atg_scatter_value = ({ self, dim, index, value }: { self: CTensor; dim: number; index: CTensor; value: CScalar }): CTensor => {
  return addon.atg_scatter_value(self, dim, index, value)
}

export const atg_scatter_reduce = ({ self, dim, index, src, reduce, include_self }: { self: CTensor; dim: number; index: CTensor; src: CTensor; reduce: string; include_self: boolean }): CTensor => {
  return addon.atg_scatter_reduce(self, dim, index, src, reduce, include_self)
}

export const atg_scatter_value_reduce = ({ self, dim, index, value, reduce }: { self: CTensor; dim: number; index: CTensor; value: CScalar; reduce: string }): CTensor => {
  return addon.atg_scatter_value_reduce(self, dim, index, value, reduce)
}

export const atg_scatter_src_out = ({ out, self, dim, index, src }: { out: CTensor; self: CTensor; dim: number; index: CTensor; src: CTensor }): CTensor => {
  return addon.atg_scatter_src_out(out, self, dim, index, src)
}

export const atg_scatter_value_out = ({ out, self, dim, index, value }: { out: CTensor; self: CTensor; dim: number; index: CTensor; value: CScalar }): CTensor => {
  return addon.atg_scatter_value_out(out, self, dim, index, value)
}

export const atg_scatter_reduce_out = ({ out, self, dim, index, src, reduce }: { out: CTensor; self: CTensor; dim: number; index: CTensor; src: CTensor; reduce: string }): CTensor => {
  return addon.atg_scatter_reduce_out(out, self, dim, index, src, reduce)
}

export const atg_scatter_value_reduce_out = ({ out, self, dim, index, value, reduce }: { out: CTensor; self: CTensor; dim: number; index: CTensor; value: CScalar; reduce: string }): CTensor => {
  return addon.atg_scatter_value_reduce_out(out, self, dim, index, value, reduce)
}

export const atg_scatter_ = ({ self, dim, index, src }: { self: CTensor; dim: number; index: CTensor; src: CTensor }): CTensor => {
  return addon.atg_scatter_(self, dim, index, src)
}

export const atg_scatter_value_ = ({ self, dim, index, value }: { self: CTensor; dim: number; index: CTensor; value: CScalar }): CTensor => {
  return addon.atg_scatter_value_(self, dim, index, value)
}

export const atg_scatter_reduce_ = ({ self, dim, index, src, reduce }: { self: CTensor; dim: number; index: CTensor; src: CTensor; reduce: string }): CTensor => {
  return addon.atg_scatter_reduce_(self, dim, index, src, reduce)
}

export const atg_scatter_value_reduce_ = ({ self, dim, index, value, reduce }: { self: CTensor; dim: number; index: CTensor; value: CScalar; reduce: string }): CTensor => {
  return addon.atg_scatter_value_reduce_(self, dim, index, value, reduce)
}

export const atg_scatter_add = ({ self, dim, index, src }: { self: CTensor; dim: number; index: CTensor; src: CTensor }): CTensor => {
  return addon.atg_scatter_add(self, dim, index, src)
}

export const atg_scatter_add_out = ({ out, self, dim, index, src }: { out: CTensor; self: CTensor; dim: number; index: CTensor; src: CTensor }): CTensor => {
  return addon.atg_scatter_add_out(out, self, dim, index, src)
}

export const atg_scatter_add_ = ({ self, dim, index, src }: { self: CTensor; dim: number; index: CTensor; src: CTensor }): CTensor => {
  return addon.atg_scatter_add_(self, dim, index, src)
}

export const atg_scatter_reduce_two_out = ({ out, self, dim, index, src, reduce, include_self }: { out: CTensor; self: CTensor; dim: number; index: CTensor; src: CTensor; reduce: string; include_self: boolean }): CTensor => {
  return addon.atg_scatter_reduce_two_out(out, self, dim, index, src, reduce, include_self)
}

export const atg__scatter_reduce_ = ({ self, dim, index, src, reduce, include_self }: { self: CTensor; dim: number; index: CTensor; src: CTensor; reduce: string; include_self: boolean }): CTensor => {
  return addon.atg__scatter_reduce_(self, dim, index, src, reduce, include_self)
}

export const atg_eq_ = ({ self, other }: { self: CTensor; other: CScalar }): CTensor => {
  return addon.atg_eq_(self, other)
}

export const atg_eq_tensor_ = ({ self, other }: { self: CTensor; other: CTensor }): CTensor => {
  return addon.atg_eq_tensor_(self, other)
}

export const atg_bitwise_and = ({ self, other }: { self: CTensor; other: CScalar }): CTensor => {
  return addon.atg_bitwise_and(self, other)
}

export const atg_bitwise_and_scalar_tensor = ({ self_scalar, other }: { self_scalar: CScalar; other: CTensor }): CTensor => {
  return addon.atg_bitwise_and_scalar_tensor(self_scalar, other)
}

export const atg_bitwise_and_tensor = ({ self, other }: { self: CTensor; other: CTensor }): CTensor => {
  return addon.atg_bitwise_and_tensor(self, other)
}

export const atg_bitwise_and_tensor_out = ({ out, self, other }: { out: CTensor; self: CTensor; other: CTensor }): CTensor => {
  return addon.atg_bitwise_and_tensor_out(out, self, other)
}

export const atg_bitwise_and_scalar_out = ({ out, self, other }: { out: CTensor; self: CTensor; other: CScalar }): CTensor => {
  return addon.atg_bitwise_and_scalar_out(out, self, other)
}

export const atg_bitwise_and_scalar_tensor_out = ({ out, self_scalar, other }: { out: CTensor; self_scalar: CScalar; other: CTensor }): CTensor => {
  return addon.atg_bitwise_and_scalar_tensor_out(out, self_scalar, other)
}

export const atg_bitwise_and_ = ({ self, other }: { self: CTensor; other: CScalar }): CTensor => {
  return addon.atg_bitwise_and_(self, other)
}

export const atg_bitwise_and_tensor_ = ({ self, other }: { self: CTensor; other: CTensor }): CTensor => {
  return addon.atg_bitwise_and_tensor_(self, other)
}

export const atg___and__ = ({ self, other }: { self: CTensor; other: CScalar }): CTensor => {
  return addon.atg___and__(self, other)
}

export const atg___and__tensor_ = ({ self, other }: { self: CTensor; other: CTensor }): CTensor => {
  return addon.atg___and__tensor_(self, other)
}

export const atg___iand__ = ({ self, other }: { self: CTensor; other: CScalar }): CTensor => {
  return addon.atg___iand__(self, other)
}

export const atg___iand__tensor_ = ({ self, other }: { self: CTensor; other: CTensor }): CTensor => {
  return addon.atg___iand__tensor_(self, other)
}

export const atg_bitwise_or = ({ self, other }: { self: CTensor; other: CScalar }): CTensor => {
  return addon.atg_bitwise_or(self, other)
}

export const atg_bitwise_or_scalar_tensor = ({ self_scalar, other }: { self_scalar: CScalar; other: CTensor }): CTensor => {
  return addon.atg_bitwise_or_scalar_tensor(self_scalar, other)
}

export const atg_bitwise_or_tensor = ({ self, other }: { self: CTensor; other: CTensor }): CTensor => {
  return addon.atg_bitwise_or_tensor(self, other)
}

export const atg_bitwise_or_tensor_out = ({ out, self, other }: { out: CTensor; self: CTensor; other: CTensor }): CTensor => {
  return addon.atg_bitwise_or_tensor_out(out, self, other)
}

export const atg_bitwise_or_scalar_out = ({ out, self, other }: { out: CTensor; self: CTensor; other: CScalar }): CTensor => {
  return addon.atg_bitwise_or_scalar_out(out, self, other)
}

export const atg_bitwise_or_scalar_tensor_out = ({ out, self_scalar, other }: { out: CTensor; self_scalar: CScalar; other: CTensor }): CTensor => {
  return addon.atg_bitwise_or_scalar_tensor_out(out, self_scalar, other)
}

export const atg_bitwise_or_ = ({ self, other }: { self: CTensor; other: CScalar }): CTensor => {
  return addon.atg_bitwise_or_(self, other)
}

export const atg_bitwise_or_tensor_ = ({ self, other }: { self: CTensor; other: CTensor }): CTensor => {
  return addon.atg_bitwise_or_tensor_(self, other)
}

export const atg___or__ = ({ self, other }: { self: CTensor; other: CScalar }): CTensor => {
  return addon.atg___or__(self, other)
}

export const atg___or__tensor_ = ({ self, other }: { self: CTensor; other: CTensor }): CTensor => {
  return addon.atg___or__tensor_(self, other)
}

export const atg___ior__ = ({ self, other }: { self: CTensor; other: CScalar }): CTensor => {
  return addon.atg___ior__(self, other)
}

export const atg___ior__tensor_ = ({ self, other }: { self: CTensor; other: CTensor }): CTensor => {
  return addon.atg___ior__tensor_(self, other)
}

export const atg_bitwise_xor = ({ self, other }: { self: CTensor; other: CScalar }): CTensor => {
  return addon.atg_bitwise_xor(self, other)
}

export const atg_bitwise_xor_scalar_tensor = ({ self_scalar, other }: { self_scalar: CScalar; other: CTensor }): CTensor => {
  return addon.atg_bitwise_xor_scalar_tensor(self_scalar, other)
}

export const atg_bitwise_xor_tensor = ({ self, other }: { self: CTensor; other: CTensor }): CTensor => {
  return addon.atg_bitwise_xor_tensor(self, other)
}

export const atg_bitwise_xor_tensor_out = ({ out, self, other }: { out: CTensor; self: CTensor; other: CTensor }): CTensor => {
  return addon.atg_bitwise_xor_tensor_out(out, self, other)
}

export const atg_bitwise_xor_scalar_out = ({ out, self, other }: { out: CTensor; self: CTensor; other: CScalar }): CTensor => {
  return addon.atg_bitwise_xor_scalar_out(out, self, other)
}

export const atg_bitwise_xor_scalar_tensor_out = ({ out, self_scalar, other }: { out: CTensor; self_scalar: CScalar; other: CTensor }): CTensor => {
  return addon.atg_bitwise_xor_scalar_tensor_out(out, self_scalar, other)
}

export const atg_bitwise_xor_ = ({ self, other }: { self: CTensor; other: CScalar }): CTensor => {
  return addon.atg_bitwise_xor_(self, other)
}

export const atg_bitwise_xor_tensor_ = ({ self, other }: { self: CTensor; other: CTensor }): CTensor => {
  return addon.atg_bitwise_xor_tensor_(self, other)
}

export const atg___xor__ = ({ self, other }: { self: CTensor; other: CScalar }): CTensor => {
  return addon.atg___xor__(self, other)
}

export const atg___xor__tensor_ = ({ self, other }: { self: CTensor; other: CTensor }): CTensor => {
  return addon.atg___xor__tensor_(self, other)
}

export const atg___ixor__ = ({ self, other }: { self: CTensor; other: CScalar }): CTensor => {
  return addon.atg___ixor__(self, other)
}

export const atg___ixor__tensor_ = ({ self, other }: { self: CTensor; other: CTensor }): CTensor => {
  return addon.atg___ixor__tensor_(self, other)
}

export const atg___lshift__ = ({ self, other }: { self: CTensor; other: CScalar }): CTensor => {
  return addon.atg___lshift__(self, other)
}

export const atg___lshift__tensor_ = ({ self, other }: { self: CTensor; other: CTensor }): CTensor => {
  return addon.atg___lshift__tensor_(self, other)
}

export const atg___lshift__scalar_out_ = ({ out, self, other }: { out: CTensor; self: CTensor; other: CScalar }): CTensor => {
  return addon.atg___lshift__scalar_out_(out, self, other)
}

export const atg___lshift__tensor_out_ = ({ out, self, other }: { out: CTensor; self: CTensor; other: CTensor }): CTensor => {
  return addon.atg___lshift__tensor_out_(out, self, other)
}

export const atg___ilshift__ = ({ self, other }: { self: CTensor; other: CScalar }): CTensor => {
  return addon.atg___ilshift__(self, other)
}

export const atg___ilshift__tensor_ = ({ self, other }: { self: CTensor; other: CTensor }): CTensor => {
  return addon.atg___ilshift__tensor_(self, other)
}

export const atg_bitwise_left_shift = ({ self, other }: { self: CTensor; other: CTensor }): CTensor => {
  return addon.atg_bitwise_left_shift(self, other)
}

export const atg_bitwise_left_shift_tensor_scalar = ({ self, other }: { self: CTensor; other: CScalar }): CTensor => {
  return addon.atg_bitwise_left_shift_tensor_scalar(self, other)
}

export const atg_bitwise_left_shift_scalar_tensor = ({ self_scalar, other }: { self_scalar: CScalar; other: CTensor }): CTensor => {
  return addon.atg_bitwise_left_shift_scalar_tensor(self_scalar, other)
}

export const atg_bitwise_left_shift_tensor_out = ({ out, self, other }: { out: CTensor; self: CTensor; other: CTensor }): CTensor => {
  return addon.atg_bitwise_left_shift_tensor_out(out, self, other)
}

export const atg_bitwise_left_shift_tensor_scalar_out = ({ out, self, other }: { out: CTensor; self: CTensor; other: CScalar }): CTensor => {
  return addon.atg_bitwise_left_shift_tensor_scalar_out(out, self, other)
}

export const atg_bitwise_left_shift_scalar_tensor_out = ({ out, self_scalar, other }: { out: CTensor; self_scalar: CScalar; other: CTensor }): CTensor => {
  return addon.atg_bitwise_left_shift_scalar_tensor_out(out, self_scalar, other)
}

export const atg_bitwise_left_shift_ = ({ self, other }: { self: CTensor; other: CTensor }): CTensor => {
  return addon.atg_bitwise_left_shift_(self, other)
}

export const atg_bitwise_left_shift_tensor_scalar_ = ({ self, other }: { self: CTensor; other: CScalar }): CTensor => {
  return addon.atg_bitwise_left_shift_tensor_scalar_(self, other)
}

export const atg___rshift__ = ({ self, other }: { self: CTensor; other: CScalar }): CTensor => {
  return addon.atg___rshift__(self, other)
}

export const atg___rshift__tensor_ = ({ self, other }: { self: CTensor; other: CTensor }): CTensor => {
  return addon.atg___rshift__tensor_(self, other)
}

export const atg___rshift__scalar_out_ = ({ out, self, other }: { out: CTensor; self: CTensor; other: CScalar }): CTensor => {
  return addon.atg___rshift__scalar_out_(out, self, other)
}

export const atg___rshift__tensor_out_ = ({ out, self, other }: { out: CTensor; self: CTensor; other: CTensor }): CTensor => {
  return addon.atg___rshift__tensor_out_(out, self, other)
}

export const atg___irshift__ = ({ self, other }: { self: CTensor; other: CScalar }): CTensor => {
  return addon.atg___irshift__(self, other)
}

export const atg___irshift__tensor_ = ({ self, other }: { self: CTensor; other: CTensor }): CTensor => {
  return addon.atg___irshift__tensor_(self, other)
}

export const atg_bitwise_right_shift = ({ self, other }: { self: CTensor; other: CTensor }): CTensor => {
  return addon.atg_bitwise_right_shift(self, other)
}

export const atg_bitwise_right_shift_tensor_scalar = ({ self, other }: { self: CTensor; other: CScalar }): CTensor => {
  return addon.atg_bitwise_right_shift_tensor_scalar(self, other)
}

export const atg_bitwise_right_shift_scalar_tensor = ({ self_scalar, other }: { self_scalar: CScalar; other: CTensor }): CTensor => {
  return addon.atg_bitwise_right_shift_scalar_tensor(self_scalar, other)
}

export const atg_bitwise_right_shift_tensor_out = ({ out, self, other }: { out: CTensor; self: CTensor; other: CTensor }): CTensor => {
  return addon.atg_bitwise_right_shift_tensor_out(out, self, other)
}

export const atg_bitwise_right_shift_tensor_scalar_out = ({ out, self, other }: { out: CTensor; self: CTensor; other: CScalar }): CTensor => {
  return addon.atg_bitwise_right_shift_tensor_scalar_out(out, self, other)
}

export const atg_bitwise_right_shift_scalar_tensor_out = ({ out, self_scalar, other }: { out: CTensor; self_scalar: CScalar; other: CTensor }): CTensor => {
  return addon.atg_bitwise_right_shift_scalar_tensor_out(out, self_scalar, other)
}

export const atg_bitwise_right_shift_ = ({ self, other }: { self: CTensor; other: CTensor }): CTensor => {
  return addon.atg_bitwise_right_shift_(self, other)
}

export const atg_bitwise_right_shift_tensor_scalar_ = ({ self, other }: { self: CTensor; other: CScalar }): CTensor => {
  return addon.atg_bitwise_right_shift_tensor_scalar_(self, other)
}

export const atg_tril_ = ({ self, diagonal }: { self: CTensor; diagonal: number }): CTensor => {
  return addon.atg_tril_(self, diagonal)
}

export const atg_triu_ = ({ self, diagonal }: { self: CTensor; diagonal: number }): CTensor => {
  return addon.atg_triu_(self, diagonal)
}

export const atg_digamma_ = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_digamma_(self)
}

export const atg_lerp_ = ({ self, end, weight }: { self: CTensor; end: CTensor; weight: CScalar }): CTensor => {
  return addon.atg_lerp_(self, end, weight)
}

export const atg_lerp_tensor_ = ({ self, end, weight }: { self: CTensor; end: CTensor; weight: CTensor }): CTensor => {
  return addon.atg_lerp_tensor_(self, end, weight)
}

export const atg_addbmm_ = ({ self, batch1, batch2, beta, alpha }: { self: CTensor; batch1: CTensor; batch2: CTensor; beta: CScalar; alpha: CScalar }): CTensor => {
  return addon.atg_addbmm_(self, batch1, batch2, beta, alpha)
}

export const atg_addbmm = ({ self, batch1, batch2, beta, alpha }: { self: CTensor; batch1: CTensor; batch2: CTensor; beta: CScalar; alpha: CScalar }): CTensor => {
  return addon.atg_addbmm(self, batch1, batch2, beta, alpha)
}

export const atg_addbmm_out = ({ out, self, batch1, batch2, beta, alpha }: { out: CTensor; self: CTensor; batch1: CTensor; batch2: CTensor; beta: CScalar; alpha: CScalar }): CTensor => {
  return addon.atg_addbmm_out(out, self, batch1, batch2, beta, alpha)
}

export const atg_random_ = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_random_(self)
}

export const atg_random_to_ = ({ self, to }: { self: CTensor; to: number }): CTensor => {
  return addon.atg_random_to_(self, to)
}

export const atg_random_from_ = ({ self, from, to }: { self: CTensor; from: number; to?: number }): CTensor => {
  return addon.atg_random_from_(self, from, to)
}

export const atg_uniform_ = ({ self, from, to }: { self: CTensor; from: number; to: number }): CTensor => {
  return addon.atg_uniform_(self, from, to)
}

export const atg_cauchy_ = ({ self, median, sigma }: { self: CTensor; median: number; sigma: number }): CTensor => {
  return addon.atg_cauchy_(self, median, sigma)
}

export const atg_log_normal_ = ({ self, mean, std }: { self: CTensor; mean: number; std: number }): CTensor => {
  return addon.atg_log_normal_(self, mean, std)
}

export const atg_exponential_ = ({ self, lambd }: { self: CTensor; lambd: number }): CTensor => {
  return addon.atg_exponential_(self, lambd)
}

export const atg_geometric_ = ({ self, p }: { self: CTensor; p: number }): CTensor => {
  return addon.atg_geometric_(self, p)
}

export const atg_diag = ({ self, diagonal }: { self: CTensor; diagonal: number }): CTensor => {
  return addon.atg_diag(self, diagonal)
}

export const atg_diag_out = ({ out, self, diagonal }: { out: CTensor; self: CTensor; diagonal: number }): CTensor => {
  return addon.atg_diag_out(out, self, diagonal)
}

export const atg_cross = ({ self, other, dim }: { self: CTensor; other: CTensor; dim?: number }): CTensor => {
  return addon.atg_cross(self, other, dim)
}

export const atg_cross_out = ({ out, self, other, dim }: { out: CTensor; self: CTensor; other: CTensor; dim?: number }): CTensor => {
  return addon.atg_cross_out(out, self, other, dim)
}

export const atg_triu = ({ self, diagonal }: { self: CTensor; diagonal: number }): CTensor => {
  return addon.atg_triu(self, diagonal)
}

export const atg_triu_out = ({ out, self, diagonal }: { out: CTensor; self: CTensor; diagonal: number }): CTensor => {
  return addon.atg_triu_out(out, self, diagonal)
}

export const atg_tril = ({ self, diagonal }: { self: CTensor; diagonal: number }): CTensor => {
  return addon.atg_tril(self, diagonal)
}

export const atg_tril_out = ({ out, self, diagonal }: { out: CTensor; self: CTensor; diagonal: number }): CTensor => {
  return addon.atg_tril_out(out, self, diagonal)
}

export const atg_tril_indices = ({ row, col, offset, options }: { row: number; col: number; offset: number; options: { device: number, dtype: number } }): CTensor => {
  return addon.atg_tril_indices(row, col, offset, options)
}

export const atg_tril_indices_out = ({ out, row, col, offset }: { out: CTensor; row: number; col: number; offset: number }): CTensor => {
  return addon.atg_tril_indices_out(out, row, col, offset)
}

export const atg_triu_indices = ({ row, col, offset, options }: { row: number; col: number; offset: number; options: { device: number, dtype: number } }): CTensor => {
  return addon.atg_triu_indices(row, col, offset, options)
}

export const atg_triu_indices_out = ({ out, row, col, offset }: { out: CTensor; row: number; col: number; offset: number }): CTensor => {
  return addon.atg_triu_indices_out(out, row, col, offset)
}

export const atg_trace = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_trace(self)
}

export const atg_trace_out = ({ out, self }: { out: CTensor; self: CTensor }): CTensor => {
  return addon.atg_trace_out(out, self)
}

export const atg_trace_backward = ({ grad, sizes }: { grad: CTensor; sizes: number[] }): CTensor => {
  return addon.atg_trace_backward(grad, sizes)
}

export const atg_ne = ({ self, other }: { self: CTensor; other: CScalar }): CTensor => {
  return addon.atg_ne(self, other)
}

export const atg_ne_tensor = ({ self, other }: { self: CTensor; other: CTensor }): CTensor => {
  return addon.atg_ne_tensor(self, other)
}

export const atg_ne_scalar_out = ({ out, self, other }: { out: CTensor; self: CTensor; other: CScalar }): CTensor => {
  return addon.atg_ne_scalar_out(out, self, other)
}

export const atg_ne_tensor_out = ({ out, self, other }: { out: CTensor; self: CTensor; other: CTensor }): CTensor => {
  return addon.atg_ne_tensor_out(out, self, other)
}

export const atg_ne_ = ({ self, other }: { self: CTensor; other: CScalar }): CTensor => {
  return addon.atg_ne_(self, other)
}

export const atg_ne_tensor_ = ({ self, other }: { self: CTensor; other: CTensor }): CTensor => {
  return addon.atg_ne_tensor_(self, other)
}

export const atg_not_equal = ({ self, other }: { self: CTensor; other: CScalar }): CTensor => {
  return addon.atg_not_equal(self, other)
}

export const atg_not_equal_tensor = ({ self, other }: { self: CTensor; other: CTensor }): CTensor => {
  return addon.atg_not_equal_tensor(self, other)
}

export const atg_not_equal_scalar_out = ({ out, self, other }: { out: CTensor; self: CTensor; other: CScalar }): CTensor => {
  return addon.atg_not_equal_scalar_out(out, self, other)
}

export const atg_not_equal_tensor_out = ({ out, self, other }: { out: CTensor; self: CTensor; other: CTensor }): CTensor => {
  return addon.atg_not_equal_tensor_out(out, self, other)
}

export const atg_not_equal_ = ({ self, other }: { self: CTensor; other: CScalar }): CTensor => {
  return addon.atg_not_equal_(self, other)
}

export const atg_not_equal_tensor_ = ({ self, other }: { self: CTensor; other: CTensor }): CTensor => {
  return addon.atg_not_equal_tensor_(self, other)
}

export const atg_eq = ({ self, other }: { self: CTensor; other: CScalar }): CTensor => {
  return addon.atg_eq(self, other)
}

export const atg_eq_tensor = ({ self, other }: { self: CTensor; other: CTensor }): CTensor => {
  return addon.atg_eq_tensor(self, other)
}

export const atg_eq_scalar_out = ({ out, self, other }: { out: CTensor; self: CTensor; other: CScalar }): CTensor => {
  return addon.atg_eq_scalar_out(out, self, other)
}

export const atg_eq_tensor_out = ({ out, self, other }: { out: CTensor; self: CTensor; other: CTensor }): CTensor => {
  return addon.atg_eq_tensor_out(out, self, other)
}

export const atg_ge = ({ self, other }: { self: CTensor; other: CScalar }): CTensor => {
  return addon.atg_ge(self, other)
}

export const atg_ge_tensor = ({ self, other }: { self: CTensor; other: CTensor }): CTensor => {
  return addon.atg_ge_tensor(self, other)
}

export const atg_ge_scalar_out = ({ out, self, other }: { out: CTensor; self: CTensor; other: CScalar }): CTensor => {
  return addon.atg_ge_scalar_out(out, self, other)
}

export const atg_ge_tensor_out = ({ out, self, other }: { out: CTensor; self: CTensor; other: CTensor }): CTensor => {
  return addon.atg_ge_tensor_out(out, self, other)
}

export const atg_ge_ = ({ self, other }: { self: CTensor; other: CScalar }): CTensor => {
  return addon.atg_ge_(self, other)
}

export const atg_ge_tensor_ = ({ self, other }: { self: CTensor; other: CTensor }): CTensor => {
  return addon.atg_ge_tensor_(self, other)
}

export const atg_greater_equal = ({ self, other }: { self: CTensor; other: CScalar }): CTensor => {
  return addon.atg_greater_equal(self, other)
}

export const atg_greater_equal_tensor = ({ self, other }: { self: CTensor; other: CTensor }): CTensor => {
  return addon.atg_greater_equal_tensor(self, other)
}

export const atg_greater_equal_scalar_out = ({ out, self, other }: { out: CTensor; self: CTensor; other: CScalar }): CTensor => {
  return addon.atg_greater_equal_scalar_out(out, self, other)
}

export const atg_greater_equal_tensor_out = ({ out, self, other }: { out: CTensor; self: CTensor; other: CTensor }): CTensor => {
  return addon.atg_greater_equal_tensor_out(out, self, other)
}

export const atg_greater_equal_ = ({ self, other }: { self: CTensor; other: CScalar }): CTensor => {
  return addon.atg_greater_equal_(self, other)
}

export const atg_greater_equal_tensor_ = ({ self, other }: { self: CTensor; other: CTensor }): CTensor => {
  return addon.atg_greater_equal_tensor_(self, other)
}

export const atg_le = ({ self, other }: { self: CTensor; other: CScalar }): CTensor => {
  return addon.atg_le(self, other)
}

export const atg_le_tensor = ({ self, other }: { self: CTensor; other: CTensor }): CTensor => {
  return addon.atg_le_tensor(self, other)
}

export const atg_le_scalar_out = ({ out, self, other }: { out: CTensor; self: CTensor; other: CScalar }): CTensor => {
  return addon.atg_le_scalar_out(out, self, other)
}

export const atg_le_tensor_out = ({ out, self, other }: { out: CTensor; self: CTensor; other: CTensor }): CTensor => {
  return addon.atg_le_tensor_out(out, self, other)
}

export const atg_le_ = ({ self, other }: { self: CTensor; other: CScalar }): CTensor => {
  return addon.atg_le_(self, other)
}

export const atg_le_tensor_ = ({ self, other }: { self: CTensor; other: CTensor }): CTensor => {
  return addon.atg_le_tensor_(self, other)
}

export const atg_less_equal = ({ self, other }: { self: CTensor; other: CScalar }): CTensor => {
  return addon.atg_less_equal(self, other)
}

export const atg_less_equal_tensor = ({ self, other }: { self: CTensor; other: CTensor }): CTensor => {
  return addon.atg_less_equal_tensor(self, other)
}

export const atg_less_equal_scalar_out = ({ out, self, other }: { out: CTensor; self: CTensor; other: CScalar }): CTensor => {
  return addon.atg_less_equal_scalar_out(out, self, other)
}

export const atg_less_equal_tensor_out = ({ out, self, other }: { out: CTensor; self: CTensor; other: CTensor }): CTensor => {
  return addon.atg_less_equal_tensor_out(out, self, other)
}

export const atg_less_equal_ = ({ self, other }: { self: CTensor; other: CScalar }): CTensor => {
  return addon.atg_less_equal_(self, other)
}

export const atg_less_equal_tensor_ = ({ self, other }: { self: CTensor; other: CTensor }): CTensor => {
  return addon.atg_less_equal_tensor_(self, other)
}

export const atg_gt = ({ self, other }: { self: CTensor; other: CScalar }): CTensor => {
  return addon.atg_gt(self, other)
}

export const atg_gt_tensor = ({ self, other }: { self: CTensor; other: CTensor }): CTensor => {
  return addon.atg_gt_tensor(self, other)
}

export const atg_gt_scalar_out = ({ out, self, other }: { out: CTensor; self: CTensor; other: CScalar }): CTensor => {
  return addon.atg_gt_scalar_out(out, self, other)
}

export const atg_gt_tensor_out = ({ out, self, other }: { out: CTensor; self: CTensor; other: CTensor }): CTensor => {
  return addon.atg_gt_tensor_out(out, self, other)
}

export const atg_gt_ = ({ self, other }: { self: CTensor; other: CScalar }): CTensor => {
  return addon.atg_gt_(self, other)
}

export const atg_gt_tensor_ = ({ self, other }: { self: CTensor; other: CTensor }): CTensor => {
  return addon.atg_gt_tensor_(self, other)
}

export const atg_greater = ({ self, other }: { self: CTensor; other: CScalar }): CTensor => {
  return addon.atg_greater(self, other)
}

export const atg_greater_tensor = ({ self, other }: { self: CTensor; other: CTensor }): CTensor => {
  return addon.atg_greater_tensor(self, other)
}

export const atg_greater_scalar_out = ({ out, self, other }: { out: CTensor; self: CTensor; other: CScalar }): CTensor => {
  return addon.atg_greater_scalar_out(out, self, other)
}

export const atg_greater_tensor_out = ({ out, self, other }: { out: CTensor; self: CTensor; other: CTensor }): CTensor => {
  return addon.atg_greater_tensor_out(out, self, other)
}

export const atg_greater_ = ({ self, other }: { self: CTensor; other: CScalar }): CTensor => {
  return addon.atg_greater_(self, other)
}

export const atg_greater_tensor_ = ({ self, other }: { self: CTensor; other: CTensor }): CTensor => {
  return addon.atg_greater_tensor_(self, other)
}

export const atg_lt = ({ self, other }: { self: CTensor; other: CScalar }): CTensor => {
  return addon.atg_lt(self, other)
}

export const atg_lt_tensor = ({ self, other }: { self: CTensor; other: CTensor }): CTensor => {
  return addon.atg_lt_tensor(self, other)
}

export const atg_lt_scalar_out = ({ out, self, other }: { out: CTensor; self: CTensor; other: CScalar }): CTensor => {
  return addon.atg_lt_scalar_out(out, self, other)
}

export const atg_lt_tensor_out = ({ out, self, other }: { out: CTensor; self: CTensor; other: CTensor }): CTensor => {
  return addon.atg_lt_tensor_out(out, self, other)
}

export const atg_lt_ = ({ self, other }: { self: CTensor; other: CScalar }): CTensor => {
  return addon.atg_lt_(self, other)
}

export const atg_lt_tensor_ = ({ self, other }: { self: CTensor; other: CTensor }): CTensor => {
  return addon.atg_lt_tensor_(self, other)
}

export const atg_less = ({ self, other }: { self: CTensor; other: CScalar }): CTensor => {
  return addon.atg_less(self, other)
}

export const atg_less_tensor = ({ self, other }: { self: CTensor; other: CTensor }): CTensor => {
  return addon.atg_less_tensor(self, other)
}

export const atg_less_scalar_out = ({ out, self, other }: { out: CTensor; self: CTensor; other: CScalar }): CTensor => {
  return addon.atg_less_scalar_out(out, self, other)
}

export const atg_less_tensor_out = ({ out, self, other }: { out: CTensor; self: CTensor; other: CTensor }): CTensor => {
  return addon.atg_less_tensor_out(out, self, other)
}

export const atg_less_ = ({ self, other }: { self: CTensor; other: CScalar }): CTensor => {
  return addon.atg_less_(self, other)
}

export const atg_less_tensor_ = ({ self, other }: { self: CTensor; other: CTensor }): CTensor => {
  return addon.atg_less_tensor_(self, other)
}

export const atg_take = ({ self, index }: { self: CTensor; index: CTensor }): CTensor => {
  return addon.atg_take(self, index)
}

export const atg_take_out = ({ out, self, index }: { out: CTensor; self: CTensor; index: CTensor }): CTensor => {
  return addon.atg_take_out(out, self, index)
}

export const atg_take_along_dim = ({ self, indices, dim }: { self: CTensor; indices: CTensor; dim?: number }): CTensor => {
  return addon.atg_take_along_dim(self, indices, dim)
}

export const atg_take_along_dim_out = ({ out, self, indices, dim }: { out: CTensor; self: CTensor; indices: CTensor; dim?: number }): CTensor => {
  return addon.atg_take_along_dim_out(out, self, indices, dim)
}

export const atg_index_select = ({ self, dim, index }: { self: CTensor; dim: number; index: CTensor }): CTensor => {
  return addon.atg_index_select(self, dim, index)
}

export const atg_index_select_out = ({ out, self, dim, index }: { out: CTensor; self: CTensor; dim: number; index: CTensor }): CTensor => {
  return addon.atg_index_select_out(out, self, dim, index)
}

export const atg_index_select_backward = ({ grad, self_sizes, dim, index }: { grad: CTensor; self_sizes: number[]; dim: number; index: CTensor }): CTensor => {
  return addon.atg_index_select_backward(grad, self_sizes, dim, index)
}

export const atg_masked_select = ({ self, mask }: { self: CTensor; mask: CTensor }): CTensor => {
  return addon.atg_masked_select(self, mask)
}

export const atg_masked_select_out = ({ out, self, mask }: { out: CTensor; self: CTensor; mask: CTensor }): CTensor => {
  return addon.atg_masked_select_out(out, self, mask)
}

export const atg_masked_select_backward = ({ grad, input, mask }: { grad: CTensor; input: CTensor; mask: CTensor }): CTensor => {
  return addon.atg_masked_select_backward(grad, input, mask)
}

export const atg_nonzero = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_nonzero(self)
}

export const atg_nonzero_out = ({ out, self }: { out: CTensor; self: CTensor }): CTensor => {
  return addon.atg_nonzero_out(out, self)
}

export const atg_argwhere = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_argwhere(self)
}

export const atg_gather = ({ self, dim, index, sparse_grad }: { self: CTensor; dim: number; index: CTensor; sparse_grad: boolean }): CTensor => {
  return addon.atg_gather(self, dim, index, sparse_grad)
}

export const atg_gather_out = ({ out, self, dim, index, sparse_grad }: { out: CTensor; self: CTensor; dim: number; index: CTensor; sparse_grad: boolean }): CTensor => {
  return addon.atg_gather_out(out, self, dim, index, sparse_grad)
}

export const atg_gather_backward = ({ grad, self, dim, index, sparse_grad }: { grad: CTensor; self: CTensor; dim: number; index: CTensor; sparse_grad: boolean }): CTensor => {
  return addon.atg_gather_backward(grad, self, dim, index, sparse_grad)
}

export const atg__gather_sparse_backward = ({ self, dim, index, grad }: { self: CTensor; dim: number; index: CTensor; grad: CTensor }): CTensor => {
  return addon.atg__gather_sparse_backward(self, dim, index, grad)
}

export const atg_addcmul = ({ self, tensor1, tensor2, value }: { self: CTensor; tensor1: CTensor; tensor2: CTensor; value: CScalar }): CTensor => {
  return addon.atg_addcmul(self, tensor1, tensor2, value)
}

export const atg_addcmul_out = ({ out, self, tensor1, tensor2, value }: { out: CTensor; self: CTensor; tensor1: CTensor; tensor2: CTensor; value: CScalar }): CTensor => {
  return addon.atg_addcmul_out(out, self, tensor1, tensor2, value)
}

export const atg_addcmul_ = ({ self, tensor1, tensor2, value }: { self: CTensor; tensor1: CTensor; tensor2: CTensor; value: CScalar }): CTensor => {
  return addon.atg_addcmul_(self, tensor1, tensor2, value)
}

export const atg_addcdiv = ({ self, tensor1, tensor2, value }: { self: CTensor; tensor1: CTensor; tensor2: CTensor; value: CScalar }): CTensor => {
  return addon.atg_addcdiv(self, tensor1, tensor2, value)
}

export const atg_addcdiv_out = ({ out, self, tensor1, tensor2, value }: { out: CTensor; self: CTensor; tensor1: CTensor; tensor2: CTensor; value: CScalar }): CTensor => {
  return addon.atg_addcdiv_out(out, self, tensor1, tensor2, value)
}

export const atg_addcdiv_ = ({ self, tensor1, tensor2, value }: { self: CTensor; tensor1: CTensor; tensor2: CTensor; value: CScalar }): CTensor => {
  return addon.atg_addcdiv_(self, tensor1, tensor2, value)
}

export const atg_cross_entropy_loss = ({ self, target, weight, reduction, ignore_index, label_smoothing }: { self: CTensor; target: CTensor; weight?: CTensor; reduction: number; ignore_index: number; label_smoothing: number }): CTensor => {
  return addon.atg_cross_entropy_loss(self, target, weight, reduction, ignore_index, label_smoothing)
}

export const atg_triangular_solve = ({ self, A, upper, transpose, unitriangular }: { self: CTensor; A: CTensor; upper: boolean; transpose: boolean; unitriangular: boolean }): CTensor[] => {
  return addon.atg_triangular_solve(self, A, upper, transpose, unitriangular)
}

export const atg_triangular_solve_x = ({ X, M, self, A, upper, transpose, unitriangular }: { X: CTensor; M: CTensor; self: CTensor; A: CTensor; upper: boolean; transpose: boolean; unitriangular: boolean }): CTensor[] => {
  return addon.atg_triangular_solve_x(X, M, self, A, upper, transpose, unitriangular)
}

export const atg__linalg_check_errors = ({ info, api_name, is_matrix }: { info: CTensor; api_name: string; is_matrix: boolean }): void => {
  return addon.atg__linalg_check_errors(info, api_name, is_matrix)
}

export const atg_linalg_solve_triangular = ({ self, B, upper, left, unitriangular }: { self: CTensor; B: CTensor; upper: boolean; left: boolean; unitriangular: boolean }): CTensor => {
  return addon.atg_linalg_solve_triangular(self, B, upper, left, unitriangular)
}

export const atg_linalg_solve_triangular_out = ({ out, self, B, upper, left, unitriangular }: { out: CTensor; self: CTensor; B: CTensor; upper: boolean; left: boolean; unitriangular: boolean }): CTensor => {
  return addon.atg_linalg_solve_triangular_out(out, self, B, upper, left, unitriangular)
}

export const atg_linalg_vander = ({ x, N }: { x: CTensor; N?: number }): CTensor => {
  return addon.atg_linalg_vander(x, N)
}

export const atg_svd = ({ self, some, compute_uv }: { self: CTensor; some: boolean; compute_uv: boolean }): CTensor[] => {
  return addon.atg_svd(self, some, compute_uv)
}

export const atg_svd_u = ({ U, S, V, self, some, compute_uv }: { U: CTensor; S: CTensor; V: CTensor; self: CTensor; some: boolean; compute_uv: boolean }): CTensor[] => {
  return addon.atg_svd_u(U, S, V, self, some, compute_uv)
}

export const atg_swapaxes = ({ self, axis0, axis1 }: { self: CTensor; axis0: number; axis1: number }): CTensor => {
  return addon.atg_swapaxes(self, axis0, axis1)
}

export const atg_swapaxes_ = ({ self, axis0, axis1 }: { self: CTensor; axis0: number; axis1: number }): CTensor => {
  return addon.atg_swapaxes_(self, axis0, axis1)
}

export const atg_swapdims = ({ self, dim0, dim1 }: { self: CTensor; dim0: number; dim1: number }): CTensor => {
  return addon.atg_swapdims(self, dim0, dim1)
}

export const atg_swapdims_ = ({ self, dim0, dim1 }: { self: CTensor; dim0: number; dim1: number }): CTensor => {
  return addon.atg_swapdims_(self, dim0, dim1)
}

export const atg_cholesky = ({ self, upper }: { self: CTensor; upper: boolean }): CTensor => {
  return addon.atg_cholesky(self, upper)
}

export const atg_cholesky_out = ({ out, self, upper }: { out: CTensor; self: CTensor; upper: boolean }): CTensor => {
  return addon.atg_cholesky_out(out, self, upper)
}

export const atg_cholesky_solve = ({ self, input2, upper }: { self: CTensor; input2: CTensor; upper: boolean }): CTensor => {
  return addon.atg_cholesky_solve(self, input2, upper)
}

export const atg_cholesky_solve_out = ({ out, self, input2, upper }: { out: CTensor; self: CTensor; input2: CTensor; upper: boolean }): CTensor => {
  return addon.atg_cholesky_solve_out(out, self, input2, upper)
}

export const atg__cholesky_solve_helper = ({ self, A, upper }: { self: CTensor; A: CTensor; upper: boolean }): CTensor => {
  return addon.atg__cholesky_solve_helper(self, A, upper)
}

export const atg__cholesky_solve_helper_out = ({ out, self, A, upper }: { out: CTensor; self: CTensor; A: CTensor; upper: boolean }): CTensor => {
  return addon.atg__cholesky_solve_helper_out(out, self, A, upper)
}

export const atg_cholesky_inverse = ({ self, upper }: { self: CTensor; upper: boolean }): CTensor => {
  return addon.atg_cholesky_inverse(self, upper)
}

export const atg_cholesky_inverse_out = ({ out, self, upper }: { out: CTensor; self: CTensor; upper: boolean }): CTensor => {
  return addon.atg_cholesky_inverse_out(out, self, upper)
}

export const atg_qr = ({ self, some }: { self: CTensor; some: boolean }): CTensor[] => {
  return addon.atg_qr(self, some)
}

export const atg_qr_q = ({ Q, R, self, some }: { Q: CTensor; R: CTensor; self: CTensor; some: boolean }): CTensor[] => {
  return addon.atg_qr_q(Q, R, self, some)
}

export const atg_geqrf = ({ self }: { self: CTensor }): CTensor[] => {
  return addon.atg_geqrf(self)
}

export const atg_geqrf_a = ({ a, tau, self }: { a: CTensor; tau: CTensor; self: CTensor }): CTensor[] => {
  return addon.atg_geqrf_a(a, tau, self)
}

export const atg_orgqr = ({ self, input2 }: { self: CTensor; input2: CTensor }): CTensor => {
  return addon.atg_orgqr(self, input2)
}

export const atg_orgqr_out = ({ out, self, input2 }: { out: CTensor; self: CTensor; input2: CTensor }): CTensor => {
  return addon.atg_orgqr_out(out, self, input2)
}

export const atg_ormqr = ({ self, input2, input3, left, transpose }: { self: CTensor; input2: CTensor; input3: CTensor; left: boolean; transpose: boolean }): CTensor => {
  return addon.atg_ormqr(self, input2, input3, left, transpose)
}

export const atg_ormqr_out = ({ out, self, input2, input3, left, transpose }: { out: CTensor; self: CTensor; input2: CTensor; input3: CTensor; left: boolean; transpose: boolean }): CTensor => {
  return addon.atg_ormqr_out(out, self, input2, input3, left, transpose)
}

export const atg__lu_with_info = ({ self, pivot, check_errors }: { self: CTensor; pivot: boolean; check_errors: boolean }): CTensor[] => {
  return addon.atg__lu_with_info(self, pivot, check_errors)
}

export const atg_lu_solve = ({ self, LU_data, LU_pivots }: { self: CTensor; LU_data: CTensor; LU_pivots: CTensor }): CTensor => {
  return addon.atg_lu_solve(self, LU_data, LU_pivots)
}

export const atg_lu_solve_out = ({ out, self, LU_data, LU_pivots }: { out: CTensor; self: CTensor; LU_data: CTensor; LU_pivots: CTensor }): CTensor => {
  return addon.atg_lu_solve_out(out, self, LU_data, LU_pivots)
}

export const atg_lu_unpack = ({ LU_data, LU_pivots, unpack_data, unpack_pivots }: { LU_data: CTensor; LU_pivots: CTensor; unpack_data: boolean; unpack_pivots: boolean }): CTensor[] => {
  return addon.atg_lu_unpack(LU_data, LU_pivots, unpack_data, unpack_pivots)
}

export const atg_lu_unpack_out = ({ P, L, U, LU_data, LU_pivots, unpack_data, unpack_pivots }: { P: CTensor; L: CTensor; U: CTensor; LU_data: CTensor; LU_pivots: CTensor; unpack_data: boolean; unpack_pivots: boolean }): CTensor[] => {
  return addon.atg_lu_unpack_out(P, L, U, LU_data, LU_pivots, unpack_data, unpack_pivots)
}

export const atg_multinomial = ({ self, num_samples, replacement }: { self: CTensor; num_samples: number; replacement: boolean }): CTensor => {
  return addon.atg_multinomial(self, num_samples, replacement)
}

export const atg_multinomial_out = ({ out, self, num_samples, replacement }: { out: CTensor; self: CTensor; num_samples: number; replacement: boolean }): CTensor => {
  return addon.atg_multinomial_out(out, self, num_samples, replacement)
}

export const atg_lgamma = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_lgamma(self)
}

export const atg_lgamma_out = ({ out, self }: { out: CTensor; self: CTensor }): CTensor => {
  return addon.atg_lgamma_out(out, self)
}

export const atg_lgamma_ = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_lgamma_(self)
}

export const atg_digamma = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_digamma(self)
}

export const atg_digamma_out = ({ out, self }: { out: CTensor; self: CTensor }): CTensor => {
  return addon.atg_digamma_out(out, self)
}

export const atg_polygamma = ({ n, self }: { n: number; self: CTensor }): CTensor => {
  return addon.atg_polygamma(n, self)
}

export const atg_polygamma_out = ({ out, n, self }: { out: CTensor; n: number; self: CTensor }): CTensor => {
  return addon.atg_polygamma_out(out, n, self)
}

export const atg_polygamma_ = ({ self, n }: { self: CTensor; n: number }): CTensor => {
  return addon.atg_polygamma_(self, n)
}

export const atg_erfinv = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_erfinv(self)
}

export const atg_erfinv_out = ({ out, self }: { out: CTensor; self: CTensor }): CTensor => {
  return addon.atg_erfinv_out(out, self)
}

export const atg_erfinv_ = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_erfinv_(self)
}

export const atg_i0 = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_i0(self)
}

export const atg_i0_out = ({ out, self }: { out: CTensor; self: CTensor }): CTensor => {
  return addon.atg_i0_out(out, self)
}

export const atg_i0_ = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_i0_(self)
}

export const atg_sign = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_sign(self)
}

export const atg_sign_out = ({ out, self }: { out: CTensor; self: CTensor }): CTensor => {
  return addon.atg_sign_out(out, self)
}

export const atg_sign_ = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_sign_(self)
}

export const atg_signbit = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_signbit(self)
}

export const atg_signbit_out = ({ out, self }: { out: CTensor; self: CTensor }): CTensor => {
  return addon.atg_signbit_out(out, self)
}

export const atg_dist = ({ self, other, p }: { self: CTensor; other: CTensor; p: CScalar }): CTensor => {
  return addon.atg_dist(self, other, p)
}

export const atg_dist_out = ({ out, self, other, p }: { out: CTensor; self: CTensor; other: CTensor; p: CScalar }): CTensor => {
  return addon.atg_dist_out(out, self, other, p)
}

export const atg_atan2 = ({ self, other }: { self: CTensor; other: CTensor }): CTensor => {
  return addon.atg_atan2(self, other)
}

export const atg_atan2_out = ({ out, self, other }: { out: CTensor; self: CTensor; other: CTensor }): CTensor => {
  return addon.atg_atan2_out(out, self, other)
}

export const atg_atan2_ = ({ self, other }: { self: CTensor; other: CTensor }): CTensor => {
  return addon.atg_atan2_(self, other)
}

export const atg_arctan2 = ({ self, other }: { self: CTensor; other: CTensor }): CTensor => {
  return addon.atg_arctan2(self, other)
}

export const atg_arctan2_out = ({ out, self, other }: { out: CTensor; self: CTensor; other: CTensor }): CTensor => {
  return addon.atg_arctan2_out(out, self, other)
}

export const atg_arctan2_ = ({ self, other }: { self: CTensor; other: CTensor }): CTensor => {
  return addon.atg_arctan2_(self, other)
}

export const atg_lerp = ({ self, end, weight }: { self: CTensor; end: CTensor; weight: CScalar }): CTensor => {
  return addon.atg_lerp(self, end, weight)
}

export const atg_lerp_tensor = ({ self, end, weight }: { self: CTensor; end: CTensor; weight: CTensor }): CTensor => {
  return addon.atg_lerp_tensor(self, end, weight)
}

export const atg_lerp_scalar_out = ({ out, self, end, weight }: { out: CTensor; self: CTensor; end: CTensor; weight: CScalar }): CTensor => {
  return addon.atg_lerp_scalar_out(out, self, end, weight)
}

export const atg_lerp_tensor_out = ({ out, self, end, weight }: { out: CTensor; self: CTensor; end: CTensor; weight: CTensor }): CTensor => {
  return addon.atg_lerp_tensor_out(out, self, end, weight)
}

export const atg_histc = ({ self, bins, min, max }: { self: CTensor; bins: number; min: CScalar; max: CScalar }): CTensor => {
  return addon.atg_histc(self, bins, min, max)
}

export const atg_histc_out = ({ out, self, bins, min, max }: { out: CTensor; self: CTensor; bins: number; min: CScalar; max: CScalar }): CTensor => {
  return addon.atg_histc_out(out, self, bins, min, max)
}

export const atg_histogram = ({ self, bins, weight, density }: { self: CTensor; bins: CTensor; weight?: CTensor; density: boolean }): CTensor[] => {
  return addon.atg_histogram(self, bins, weight, density)
}

export const atg_histogram_bin_ct = ({ self, bins, range, weight, density }: { self: CTensor; bins: number; range: number[]; weight?: CTensor; density: boolean }): CTensor[] => {
  return addon.atg_histogram_bin_ct(self, bins, range, weight, density)
}

export const atg_histogram_bins_tensor_out = ({ hist, bin_edges, self, bins, weight, density }: { hist: CTensor; bin_edges: CTensor; self: CTensor; bins: CTensor; weight?: CTensor; density: boolean }): CTensor[] => {
  return addon.atg_histogram_bins_tensor_out(hist, bin_edges, self, bins, weight, density)
}

export const atg_histogram_bin_ct_out = ({ hist, bin_edges, self, bins, range, weight, density }: { hist: CTensor; bin_edges: CTensor; self: CTensor; bins: number; range: number[]; weight?: CTensor; density: boolean }): CTensor[] => {
  return addon.atg_histogram_bin_ct_out(hist, bin_edges, self, bins, range, weight, density)
}

export const atg__histogramdd_from_bin_cts = ({ self, bins, range, weight, density }: { self: CTensor; bins: number[]; range: number[]; weight?: CTensor; density: boolean }): CTensor => {
  return addon.atg__histogramdd_from_bin_cts(self, bins, range, weight, density)
}

export const atg__histogramdd_from_bin_cts_out = ({ out, self, bins, range, weight, density }: { out: CTensor; self: CTensor; bins: number[]; range: number[]; weight?: CTensor; density: boolean }): CTensor => {
  return addon.atg__histogramdd_from_bin_cts_out(out, self, bins, range, weight, density)
}

export const atg__histogramdd_from_bin_tensors = ({ self, bins, weight, density }: { self: CTensor; bins: CTensor[]; weight?: CTensor; density: boolean }): CTensor => {
  return addon.atg__histogramdd_from_bin_tensors(self, bins, weight, density)
}

export const atg__histogramdd_from_bin_tensors_out = ({ out, self, bins, weight, density }: { out: CTensor; self: CTensor; bins: CTensor[]; weight?: CTensor; density: boolean }): CTensor => {
  return addon.atg__histogramdd_from_bin_tensors_out(out, self, bins, weight, density)
}

export const atg_fmod = ({ self, other }: { self: CTensor; other: CScalar }): CTensor => {
  return addon.atg_fmod(self, other)
}

export const atg_fmod_tensor = ({ self, other }: { self: CTensor; other: CTensor }): CTensor => {
  return addon.atg_fmod_tensor(self, other)
}

export const atg_fmod_scalar_out = ({ out, self, other }: { out: CTensor; self: CTensor; other: CScalar }): CTensor => {
  return addon.atg_fmod_scalar_out(out, self, other)
}

export const atg_fmod_tensor_out = ({ out, self, other }: { out: CTensor; self: CTensor; other: CTensor }): CTensor => {
  return addon.atg_fmod_tensor_out(out, self, other)
}

export const atg_fmod_ = ({ self, other }: { self: CTensor; other: CScalar }): CTensor => {
  return addon.atg_fmod_(self, other)
}

export const atg_fmod_tensor_ = ({ self, other }: { self: CTensor; other: CTensor }): CTensor => {
  return addon.atg_fmod_tensor_(self, other)
}

export const atg_hypot = ({ self, other }: { self: CTensor; other: CTensor }): CTensor => {
  return addon.atg_hypot(self, other)
}

export const atg_hypot_out = ({ out, self, other }: { out: CTensor; self: CTensor; other: CTensor }): CTensor => {
  return addon.atg_hypot_out(out, self, other)
}

export const atg_hypot_ = ({ self, other }: { self: CTensor; other: CTensor }): CTensor => {
  return addon.atg_hypot_(self, other)
}

export const atg_igamma = ({ self, other }: { self: CTensor; other: CTensor }): CTensor => {
  return addon.atg_igamma(self, other)
}

export const atg_igamma_out = ({ out, self, other }: { out: CTensor; self: CTensor; other: CTensor }): CTensor => {
  return addon.atg_igamma_out(out, self, other)
}

export const atg_igamma_ = ({ self, other }: { self: CTensor; other: CTensor }): CTensor => {
  return addon.atg_igamma_(self, other)
}

export const atg_igammac = ({ self, other }: { self: CTensor; other: CTensor }): CTensor => {
  return addon.atg_igammac(self, other)
}

export const atg_igammac_out = ({ out, self, other }: { out: CTensor; self: CTensor; other: CTensor }): CTensor => {
  return addon.atg_igammac_out(out, self, other)
}

export const atg_igammac_ = ({ self, other }: { self: CTensor; other: CTensor }): CTensor => {
  return addon.atg_igammac_(self, other)
}

export const atg_nextafter = ({ self, other }: { self: CTensor; other: CTensor }): CTensor => {
  return addon.atg_nextafter(self, other)
}

export const atg_nextafter_out = ({ out, self, other }: { out: CTensor; self: CTensor; other: CTensor }): CTensor => {
  return addon.atg_nextafter_out(out, self, other)
}

export const atg_nextafter_ = ({ self, other }: { self: CTensor; other: CTensor }): CTensor => {
  return addon.atg_nextafter_(self, other)
}

export const atg_remainder = ({ self, other }: { self: CTensor; other: CScalar }): CTensor => {
  return addon.atg_remainder(self, other)
}

export const atg_remainder_tensor = ({ self, other }: { self: CTensor; other: CTensor }): CTensor => {
  return addon.atg_remainder_tensor(self, other)
}

export const atg_remainder_scalar_tensor = ({ self_scalar, other }: { self_scalar: CScalar; other: CTensor }): CTensor => {
  return addon.atg_remainder_scalar_tensor(self_scalar, other)
}

export const atg_remainder_scalar_out = ({ out, self, other }: { out: CTensor; self: CTensor; other: CScalar }): CTensor => {
  return addon.atg_remainder_scalar_out(out, self, other)
}

export const atg_remainder_tensor_out = ({ out, self, other }: { out: CTensor; self: CTensor; other: CTensor }): CTensor => {
  return addon.atg_remainder_tensor_out(out, self, other)
}

export const atg_remainder_scalar_tensor_out = ({ out, self_scalar, other }: { out: CTensor; self_scalar: CScalar; other: CTensor }): CTensor => {
  return addon.atg_remainder_scalar_tensor_out(out, self_scalar, other)
}

export const atg_remainder_ = ({ self, other }: { self: CTensor; other: CScalar }): CTensor => {
  return addon.atg_remainder_(self, other)
}

export const atg_remainder_tensor_ = ({ self, other }: { self: CTensor; other: CTensor }): CTensor => {
  return addon.atg_remainder_tensor_(self, other)
}

export const atg_fmin = ({ self, other }: { self: CTensor; other: CTensor }): CTensor => {
  return addon.atg_fmin(self, other)
}

export const atg_fmin_out = ({ out, self, other }: { out: CTensor; self: CTensor; other: CTensor }): CTensor => {
  return addon.atg_fmin_out(out, self, other)
}

export const atg_fmax = ({ self, other }: { self: CTensor; other: CTensor }): CTensor => {
  return addon.atg_fmax(self, other)
}

export const atg_fmax_out = ({ out, self, other }: { out: CTensor; self: CTensor; other: CTensor }): CTensor => {
  return addon.atg_fmax_out(out, self, other)
}

export const atg_maximum = ({ self, other }: { self: CTensor; other: CTensor }): CTensor => {
  return addon.atg_maximum(self, other)
}

export const atg_maximum_out = ({ out, self, other }: { out: CTensor; self: CTensor; other: CTensor }): CTensor => {
  return addon.atg_maximum_out(out, self, other)
}

export const atg_minimum = ({ self, other }: { self: CTensor; other: CTensor }): CTensor => {
  return addon.atg_minimum(self, other)
}

export const atg_minimum_out = ({ out, self, other }: { out: CTensor; self: CTensor; other: CTensor }): CTensor => {
  return addon.atg_minimum_out(out, self, other)
}

export const atg_quantile = ({ self, q, dim, keepdim, interpolation }: { self: CTensor; q: CTensor; dim?: number; keepdim: boolean; interpolation: string }): CTensor => {
  return addon.atg_quantile(self, q, dim, keepdim, interpolation)
}

export const atg_quantile_scalar = ({ self, q, dim, keepdim, interpolation }: { self: CTensor; q: number; dim?: number; keepdim: boolean; interpolation: string }): CTensor => {
  return addon.atg_quantile_scalar(self, q, dim, keepdim, interpolation)
}

export const atg_quantile_out = ({ out, self, q, dim, keepdim, interpolation }: { out: CTensor; self: CTensor; q: CTensor; dim?: number; keepdim: boolean; interpolation: string }): CTensor => {
  return addon.atg_quantile_out(out, self, q, dim, keepdim, interpolation)
}

export const atg_quantile_scalar_out = ({ out, self, q, dim, keepdim, interpolation }: { out: CTensor; self: CTensor; q: number; dim?: number; keepdim: boolean; interpolation: string }): CTensor => {
  return addon.atg_quantile_scalar_out(out, self, q, dim, keepdim, interpolation)
}

export const atg_nanquantile = ({ self, q, dim, keepdim, interpolation }: { self: CTensor; q: CTensor; dim?: number; keepdim: boolean; interpolation: string }): CTensor => {
  return addon.atg_nanquantile(self, q, dim, keepdim, interpolation)
}

export const atg_nanquantile_scalar = ({ self, q, dim, keepdim, interpolation }: { self: CTensor; q: number; dim?: number; keepdim: boolean; interpolation: string }): CTensor => {
  return addon.atg_nanquantile_scalar(self, q, dim, keepdim, interpolation)
}

export const atg_nanquantile_out = ({ out, self, q, dim, keepdim, interpolation }: { out: CTensor; self: CTensor; q: CTensor; dim?: number; keepdim: boolean; interpolation: string }): CTensor => {
  return addon.atg_nanquantile_out(out, self, q, dim, keepdim, interpolation)
}

export const atg_nanquantile_scalar_out = ({ out, self, q, dim, keepdim, interpolation }: { out: CTensor; self: CTensor; q: number; dim?: number; keepdim: boolean; interpolation: string }): CTensor => {
  return addon.atg_nanquantile_scalar_out(out, self, q, dim, keepdim, interpolation)
}

export const atg_sort = ({ self, dim, descending }: { self: CTensor; dim: number; descending: boolean }): CTensor[] => {
  return addon.atg_sort(self, dim, descending)
}

export const atg_sort_stable = ({ self, stable, dim, descending }: { self: CTensor; stable: boolean; dim: number; descending: boolean }): CTensor[] => {
  return addon.atg_sort_stable(self, stable, dim, descending)
}

export const atg_sort_values = ({ values, indices, self, dim, descending }: { values: CTensor; indices: CTensor; self: CTensor; dim: number; descending: boolean }): CTensor[] => {
  return addon.atg_sort_values(values, indices, self, dim, descending)
}

export const atg_sort_values_stable = ({ values, indices, self, stable, dim, descending }: { values: CTensor; indices: CTensor; self: CTensor; stable: boolean; dim: number; descending: boolean }): CTensor[] => {
  return addon.atg_sort_values_stable(values, indices, self, stable, dim, descending)
}

export const atg_msort = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_msort(self)
}

export const atg_msort_out = ({ out, self }: { out: CTensor; self: CTensor }): CTensor => {
  return addon.atg_msort_out(out, self)
}

export const atg_argsort = ({ self, dim, descending }: { self: CTensor; dim: number; descending: boolean }): CTensor => {
  return addon.atg_argsort(self, dim, descending)
}

export const atg_argsort_stable = ({ self, stable, dim, descending }: { self: CTensor; stable: boolean; dim: number; descending: boolean }): CTensor => {
  return addon.atg_argsort_stable(self, stable, dim, descending)
}

export const atg_argsort_stable_out = ({ out, self, stable, dim, descending }: { out: CTensor; self: CTensor; stable: boolean; dim: number; descending: boolean }): CTensor => {
  return addon.atg_argsort_stable_out(out, self, stable, dim, descending)
}

export const atg_topk = ({ self, k, dim, largest, sorted }: { self: CTensor; k: number; dim: number; largest: boolean; sorted: boolean }): CTensor[] => {
  return addon.atg_topk(self, k, dim, largest, sorted)
}

export const atg_topk_values = ({ values, indices, self, k, dim, largest, sorted }: { values: CTensor; indices: CTensor; self: CTensor; k: number; dim: number; largest: boolean; sorted: boolean }): CTensor[] => {
  return addon.atg_topk_values(values, indices, self, k, dim, largest, sorted)
}

export const atg_renorm = ({ self, p, dim, maxnorm }: { self: CTensor; p: CScalar; dim: number; maxnorm: CScalar }): CTensor => {
  return addon.atg_renorm(self, p, dim, maxnorm)
}

export const atg_renorm_out = ({ out, self, p, dim, maxnorm }: { out: CTensor; self: CTensor; p: CScalar; dim: number; maxnorm: CScalar }): CTensor => {
  return addon.atg_renorm_out(out, self, p, dim, maxnorm)
}

export const atg_renorm_ = ({ self, p, dim, maxnorm }: { self: CTensor; p: CScalar; dim: number; maxnorm: CScalar }): CTensor => {
  return addon.atg_renorm_(self, p, dim, maxnorm)
}

export const atg_unfold = ({ self, dimension, size, step }: { self: CTensor; dimension: number; size: number; step: number }): CTensor => {
  return addon.atg_unfold(self, dimension, size, step)
}

export const atg_unfold_backward = ({ grad_in, input_sizes, dim, size, step }: { grad_in: CTensor; input_sizes: number[]; dim: number; size: number; step: number }): CTensor => {
  return addon.atg_unfold_backward(grad_in, input_sizes, dim, size, step)
}

export const atg_unfold_backward_out = ({ out, grad_in, input_sizes, dim, size, step }: { out: CTensor; grad_in: CTensor; input_sizes: number[]; dim: number; size: number; step: number }): CTensor => {
  return addon.atg_unfold_backward_out(out, grad_in, input_sizes, dim, size, step)
}

export const atg_equal = ({ self, other }: { self: CTensor; other: CTensor }): boolean => {
  return addon.atg_equal(self, other)
}

export const atg_pow = ({ self, exponent }: { self: CTensor; exponent: CTensor }): CTensor => {
  return addon.atg_pow(self, exponent)
}

export const atg_pow_scalar = ({ self_scalar, exponent }: { self_scalar: CScalar; exponent: CTensor }): CTensor => {
  return addon.atg_pow_scalar(self_scalar, exponent)
}

export const atg_pow_tensor_scalar = ({ self, exponent }: { self: CTensor; exponent: CScalar }): CTensor => {
  return addon.atg_pow_tensor_scalar(self, exponent)
}

export const atg_pow_tensor_tensor_out = ({ out, self, exponent }: { out: CTensor; self: CTensor; exponent: CTensor }): CTensor => {
  return addon.atg_pow_tensor_tensor_out(out, self, exponent)
}

export const atg_pow_scalar_out = ({ out, self_scalar, exponent }: { out: CTensor; self_scalar: CScalar; exponent: CTensor }): CTensor => {
  return addon.atg_pow_scalar_out(out, self_scalar, exponent)
}

export const atg_pow_tensor_scalar_out = ({ out, self, exponent }: { out: CTensor; self: CTensor; exponent: CScalar }): CTensor => {
  return addon.atg_pow_tensor_scalar_out(out, self, exponent)
}

export const atg_pow_ = ({ self, exponent }: { self: CTensor; exponent: CScalar }): CTensor => {
  return addon.atg_pow_(self, exponent)
}

export const atg_pow_tensor_ = ({ self, exponent }: { self: CTensor; exponent: CTensor }): CTensor => {
  return addon.atg_pow_tensor_(self, exponent)
}

export const atg_float_power = ({ self, exponent }: { self: CTensor; exponent: CTensor }): CTensor => {
  return addon.atg_float_power(self, exponent)
}

export const atg_float_power_scalar = ({ self_scalar, exponent }: { self_scalar: CScalar; exponent: CTensor }): CTensor => {
  return addon.atg_float_power_scalar(self_scalar, exponent)
}

export const atg_float_power_tensor_scalar = ({ self, exponent }: { self: CTensor; exponent: CScalar }): CTensor => {
  return addon.atg_float_power_tensor_scalar(self, exponent)
}

export const atg_float_power_tensor_tensor_out = ({ out, self, exponent }: { out: CTensor; self: CTensor; exponent: CTensor }): CTensor => {
  return addon.atg_float_power_tensor_tensor_out(out, self, exponent)
}

export const atg_float_power_scalar_out = ({ out, self_scalar, exponent }: { out: CTensor; self_scalar: CScalar; exponent: CTensor }): CTensor => {
  return addon.atg_float_power_scalar_out(out, self_scalar, exponent)
}

export const atg_float_power_tensor_scalar_out = ({ out, self, exponent }: { out: CTensor; self: CTensor; exponent: CScalar }): CTensor => {
  return addon.atg_float_power_tensor_scalar_out(out, self, exponent)
}

export const atg_float_power_ = ({ self, exponent }: { self: CTensor; exponent: CScalar }): CTensor => {
  return addon.atg_float_power_(self, exponent)
}

export const atg_float_power_tensor_ = ({ self, exponent }: { self: CTensor; exponent: CTensor }): CTensor => {
  return addon.atg_float_power_tensor_(self, exponent)
}

export const atg_normal_ = ({ self, mean, std }: { self: CTensor; mean: number; std: number }): CTensor => {
  return addon.atg_normal_(self, mean, std)
}

export const atg_normal_functional = ({ self, mean, std }: { self: CTensor; mean: number; std: number }): CTensor => {
  return addon.atg_normal_functional(self, mean, std)
}

export const atg_alias = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_alias(self)
}

export const atg__amp_update_scale_ = ({ self, growth_tracker, found_inf, scale_growth_factor, scale_backoff_factor, growth_interval }: { self: CTensor; growth_tracker: CTensor; found_inf: CTensor; scale_growth_factor: number; scale_backoff_factor: number; growth_interval: number }): CTensor => {
  return addon.atg__amp_update_scale_(self, growth_tracker, found_inf, scale_growth_factor, scale_backoff_factor, growth_interval)
}

export const atg_bucketize = ({ self, boundaries, out_int32, right }: { self: CTensor; boundaries: CTensor; out_int32: boolean; right: boolean }): CTensor => {
  return addon.atg_bucketize(self, boundaries, out_int32, right)
}

export const atg_bucketize_scalar = ({ self_scalar, boundaries, out_int32, right }: { self_scalar: CScalar; boundaries: CTensor; out_int32: boolean; right: boolean }): CTensor => {
  return addon.atg_bucketize_scalar(self_scalar, boundaries, out_int32, right)
}

export const atg_bucketize_tensor_out = ({ out, self, boundaries, out_int32, right }: { out: CTensor; self: CTensor; boundaries: CTensor; out_int32: boolean; right: boolean }): CTensor => {
  return addon.atg_bucketize_tensor_out(out, self, boundaries, out_int32, right)
}

export const atg_bucketize_scalar_out = ({ out, self_scalar, boundaries, out_int32, right }: { out: CTensor; self_scalar: CScalar; boundaries: CTensor; out_int32: boolean; right: boolean }): CTensor => {
  return addon.atg_bucketize_scalar_out(out, self_scalar, boundaries, out_int32, right)
}

export const atg_searchsorted = ({ sorted_sequence, self, out_int32, right, side, sorter }: { sorted_sequence: CTensor; self: CTensor; out_int32: boolean; right: boolean; side: string; sorter?: CTensor }): CTensor => {
  return addon.atg_searchsorted(sorted_sequence, self, out_int32, right, side, sorter)
}

export const atg_searchsorted_scalar = ({ sorted_sequence, self_scalar, out_int32, right, side, sorter }: { sorted_sequence: CTensor; self_scalar: CScalar; out_int32: boolean; right: boolean; side: string; sorter?: CTensor }): CTensor => {
  return addon.atg_searchsorted_scalar(sorted_sequence, self_scalar, out_int32, right, side, sorter)
}

export const atg_searchsorted_tensor_out = ({ out, sorted_sequence, self, out_int32, right, side, sorter }: { out: CTensor; sorted_sequence: CTensor; self: CTensor; out_int32: boolean; right: boolean; side: string; sorter?: CTensor }): CTensor => {
  return addon.atg_searchsorted_tensor_out(out, sorted_sequence, self, out_int32, right, side, sorter)
}

export const atg_searchsorted_scalar_out = ({ out, sorted_sequence, self_scalar, out_int32, right, side, sorter }: { out: CTensor; sorted_sequence: CTensor; self_scalar: CScalar; out_int32: boolean; right: boolean; side: string; sorter?: CTensor }): CTensor => {
  return addon.atg_searchsorted_scalar_out(out, sorted_sequence, self_scalar, out_int32, right, side, sorter)
}

export const atg__convert_indices_from_coo_to_csr = ({ self, size, out_int32 }: { self: CTensor; size: number; out_int32: boolean }): CTensor => {
  return addon.atg__convert_indices_from_coo_to_csr(self, size, out_int32)
}

export const atg__convert_indices_from_coo_to_csr_out = ({ out, self, size, out_int32 }: { out: CTensor; self: CTensor; size: number; out_int32: boolean }): CTensor => {
  return addon.atg__convert_indices_from_coo_to_csr_out(out, self, size, out_int32)
}

export const atg__convert_indices_from_csr_to_coo = ({ crow_indices, col_indices, out_int32, transpose }: { crow_indices: CTensor; col_indices: CTensor; out_int32: boolean; transpose: boolean }): CTensor => {
  return addon.atg__convert_indices_from_csr_to_coo(crow_indices, col_indices, out_int32, transpose)
}

export const atg__convert_indices_from_csr_to_coo_out = ({ out, crow_indices, col_indices, out_int32, transpose }: { out: CTensor; crow_indices: CTensor; col_indices: CTensor; out_int32: boolean; transpose: boolean }): CTensor => {
  return addon.atg__convert_indices_from_csr_to_coo_out(out, crow_indices, col_indices, out_int32, transpose)
}

export const atg_mse_loss = ({ self, target, reduction }: { self: CTensor; target: CTensor; reduction: number }): CTensor => {
  return addon.atg_mse_loss(self, target, reduction)
}

export const atg_mse_loss_out = ({ out, self, target, reduction }: { out: CTensor; self: CTensor; target: CTensor; reduction: number }): CTensor => {
  return addon.atg_mse_loss_out(out, self, target, reduction)
}

export const atg_mse_loss_backward = ({ grad_output, self, target, reduction }: { grad_output: CTensor; self: CTensor; target: CTensor; reduction: number }): CTensor => {
  return addon.atg_mse_loss_backward(grad_output, self, target, reduction)
}

export const atg_mse_loss_backward_grad_input = ({ grad_input, grad_output, self, target, reduction }: { grad_input: CTensor; grad_output: CTensor; self: CTensor; target: CTensor; reduction: number }): CTensor => {
  return addon.atg_mse_loss_backward_grad_input(grad_input, grad_output, self, target, reduction)
}

export const atg_l1_loss = ({ self, target, reduction }: { self: CTensor; target: CTensor; reduction: number }): CTensor => {
  return addon.atg_l1_loss(self, target, reduction)
}

export const atg_multi_margin_loss_backward = ({ grad_output, self, target, p, margin, weight, reduction }: { grad_output: CTensor; self: CTensor; target: CTensor; p: CScalar; margin: CScalar; weight?: CTensor; reduction: number }): CTensor => {
  return addon.atg_multi_margin_loss_backward(grad_output, self, target, p, margin, weight, reduction)
}

export const atg_multi_margin_loss_backward_grad_input = ({ grad_input, grad_output, self, target, p, margin, weight, reduction }: { grad_input: CTensor; grad_output: CTensor; self: CTensor; target: CTensor; p: CScalar; margin: CScalar; weight?: CTensor; reduction: number }): CTensor => {
  return addon.atg_multi_margin_loss_backward_grad_input(grad_input, grad_output, self, target, p, margin, weight, reduction)
}

export const atg_multilabel_margin_loss = ({ self, target, reduction }: { self: CTensor; target: CTensor; reduction: number }): CTensor => {
  return addon.atg_multilabel_margin_loss(self, target, reduction)
}

export const atg_multilabel_margin_loss_out = ({ out, self, target, reduction }: { out: CTensor; self: CTensor; target: CTensor; reduction: number }): CTensor => {
  return addon.atg_multilabel_margin_loss_out(out, self, target, reduction)
}

export const atg_multilabel_margin_loss_backward = ({ grad_output, self, target, reduction, is_target }: { grad_output: CTensor; self: CTensor; target: CTensor; reduction: number; is_target: CTensor }): CTensor => {
  return addon.atg_multilabel_margin_loss_backward(grad_output, self, target, reduction, is_target)
}

export const atg_multilabel_margin_loss_backward_grad_input = ({ grad_input, grad_output, self, target, reduction, is_target }: { grad_input: CTensor; grad_output: CTensor; self: CTensor; target: CTensor; reduction: number; is_target: CTensor }): CTensor => {
  return addon.atg_multilabel_margin_loss_backward_grad_input(grad_input, grad_output, self, target, reduction, is_target)
}

export const atg_nll_loss = ({ self, target, weight, reduction, ignore_index }: { self: CTensor; target: CTensor; weight?: CTensor; reduction: number; ignore_index: number }): CTensor => {
  return addon.atg_nll_loss(self, target, weight, reduction, ignore_index)
}

export const atg_nll_loss_out = ({ out, self, target, weight, reduction, ignore_index }: { out: CTensor; self: CTensor; target: CTensor; weight?: CTensor; reduction: number; ignore_index: number }): CTensor => {
  return addon.atg_nll_loss_out(out, self, target, weight, reduction, ignore_index)
}

export const atg_nll_loss_nd = ({ self, target, weight, reduction, ignore_index }: { self: CTensor; target: CTensor; weight?: CTensor; reduction: number; ignore_index: number }): CTensor => {
  return addon.atg_nll_loss_nd(self, target, weight, reduction, ignore_index)
}

export const atg_nll_loss_backward = ({ grad_output, self, target, weight, reduction, ignore_index, total_weight }: { grad_output: CTensor; self: CTensor; target: CTensor; weight?: CTensor; reduction: number; ignore_index: number; total_weight: CTensor }): CTensor => {
  return addon.atg_nll_loss_backward(grad_output, self, target, weight, reduction, ignore_index, total_weight)
}

export const atg_nll_loss_backward_grad_input = ({ grad_input, grad_output, self, target, weight, reduction, ignore_index, total_weight }: { grad_input: CTensor; grad_output: CTensor; self: CTensor; target: CTensor; weight?: CTensor; reduction: number; ignore_index: number; total_weight: CTensor }): CTensor => {
  return addon.atg_nll_loss_backward_grad_input(grad_input, grad_output, self, target, weight, reduction, ignore_index, total_weight)
}

export const atg_nll_loss2d = ({ self, target, weight, reduction, ignore_index }: { self: CTensor; target: CTensor; weight?: CTensor; reduction: number; ignore_index: number }): CTensor => {
  return addon.atg_nll_loss2d(self, target, weight, reduction, ignore_index)
}

export const atg_nll_loss2d_out = ({ out, self, target, weight, reduction, ignore_index }: { out: CTensor; self: CTensor; target: CTensor; weight?: CTensor; reduction: number; ignore_index: number }): CTensor => {
  return addon.atg_nll_loss2d_out(out, self, target, weight, reduction, ignore_index)
}

export const atg_nll_loss2d_backward = ({ grad_output, self, target, weight, reduction, ignore_index, total_weight }: { grad_output: CTensor; self: CTensor; target: CTensor; weight?: CTensor; reduction: number; ignore_index: number; total_weight: CTensor }): CTensor => {
  return addon.atg_nll_loss2d_backward(grad_output, self, target, weight, reduction, ignore_index, total_weight)
}

export const atg_nll_loss2d_backward_grad_input = ({ grad_input, grad_output, self, target, weight, reduction, ignore_index, total_weight }: { grad_input: CTensor; grad_output: CTensor; self: CTensor; target: CTensor; weight?: CTensor; reduction: number; ignore_index: number; total_weight: CTensor }): CTensor => {
  return addon.atg_nll_loss2d_backward_grad_input(grad_input, grad_output, self, target, weight, reduction, ignore_index, total_weight)
}

export const atg_smooth_l1_loss = ({ self, target, reduction, beta }: { self: CTensor; target: CTensor; reduction: number; beta: number }): CTensor => {
  return addon.atg_smooth_l1_loss(self, target, reduction, beta)
}

export const atg_smooth_l1_loss_out = ({ out, self, target, reduction, beta }: { out: CTensor; self: CTensor; target: CTensor; reduction: number; beta: number }): CTensor => {
  return addon.atg_smooth_l1_loss_out(out, self, target, reduction, beta)
}

export const atg_smooth_l1_loss_backward = ({ grad_output, self, target, reduction, beta }: { grad_output: CTensor; self: CTensor; target: CTensor; reduction: number; beta: number }): CTensor => {
  return addon.atg_smooth_l1_loss_backward(grad_output, self, target, reduction, beta)
}

export const atg_smooth_l1_loss_backward_grad_input = ({ grad_input, grad_output, self, target, reduction, beta }: { grad_input: CTensor; grad_output: CTensor; self: CTensor; target: CTensor; reduction: number; beta: number }): CTensor => {
  return addon.atg_smooth_l1_loss_backward_grad_input(grad_input, grad_output, self, target, reduction, beta)
}

export const atg_huber_loss = ({ self, target, reduction, delta }: { self: CTensor; target: CTensor; reduction: number; delta: number }): CTensor => {
  return addon.atg_huber_loss(self, target, reduction, delta)
}

export const atg_huber_loss_out = ({ out, self, target, reduction, delta }: { out: CTensor; self: CTensor; target: CTensor; reduction: number; delta: number }): CTensor => {
  return addon.atg_huber_loss_out(out, self, target, reduction, delta)
}

export const atg_huber_loss_backward = ({ grad_output, self, target, reduction, delta }: { grad_output: CTensor; self: CTensor; target: CTensor; reduction: number; delta: number }): CTensor => {
  return addon.atg_huber_loss_backward(grad_output, self, target, reduction, delta)
}

export const atg_huber_loss_backward_out = ({ grad_input, grad_output, self, target, reduction, delta }: { grad_input: CTensor; grad_output: CTensor; self: CTensor; target: CTensor; reduction: number; delta: number }): CTensor => {
  return addon.atg_huber_loss_backward_out(grad_input, grad_output, self, target, reduction, delta)
}

export const atg_soft_margin_loss = ({ self, target, reduction }: { self: CTensor; target: CTensor; reduction: number }): CTensor => {
  return addon.atg_soft_margin_loss(self, target, reduction)
}

export const atg_soft_margin_loss_out = ({ out, self, target, reduction }: { out: CTensor; self: CTensor; target: CTensor; reduction: number }): CTensor => {
  return addon.atg_soft_margin_loss_out(out, self, target, reduction)
}

export const atg_soft_margin_loss_backward = ({ grad_output, self, target, reduction }: { grad_output: CTensor; self: CTensor; target: CTensor; reduction: number }): CTensor => {
  return addon.atg_soft_margin_loss_backward(grad_output, self, target, reduction)
}

export const atg_soft_margin_loss_backward_grad_input = ({ grad_input, grad_output, self, target, reduction }: { grad_input: CTensor; grad_output: CTensor; self: CTensor; target: CTensor; reduction: number }): CTensor => {
  return addon.atg_soft_margin_loss_backward_grad_input(grad_input, grad_output, self, target, reduction)
}

export const atg_elu = ({ self, alpha, scale, input_scale }: { self: CTensor; alpha: CScalar; scale: CScalar; input_scale: CScalar }): CTensor => {
  return addon.atg_elu(self, alpha, scale, input_scale)
}

export const atg_elu_out = ({ out, self, alpha, scale, input_scale }: { out: CTensor; self: CTensor; alpha: CScalar; scale: CScalar; input_scale: CScalar }): CTensor => {
  return addon.atg_elu_out(out, self, alpha, scale, input_scale)
}

export const atg_elu_backward = ({ grad_output, alpha, scale, input_scale, is_result, self_or_result }: { grad_output: CTensor; alpha: CScalar; scale: CScalar; input_scale: CScalar; is_result: boolean; self_or_result: CTensor }): CTensor => {
  return addon.atg_elu_backward(grad_output, alpha, scale, input_scale, is_result, self_or_result)
}

export const atg_elu_backward_grad_input = ({ grad_input, grad_output, alpha, scale, input_scale, is_result, self_or_result }: { grad_input: CTensor; grad_output: CTensor; alpha: CScalar; scale: CScalar; input_scale: CScalar; is_result: boolean; self_or_result: CTensor }): CTensor => {
  return addon.atg_elu_backward_grad_input(grad_input, grad_output, alpha, scale, input_scale, is_result, self_or_result)
}

export const atg_elu_ = ({ self, alpha, scale, input_scale }: { self: CTensor; alpha: CScalar; scale: CScalar; input_scale: CScalar }): CTensor => {
  return addon.atg_elu_(self, alpha, scale, input_scale)
}

export const atg_glu = ({ self, dim }: { self: CTensor; dim: number }): CTensor => {
  return addon.atg_glu(self, dim)
}

export const atg_glu_out = ({ out, self, dim }: { out: CTensor; self: CTensor; dim: number }): CTensor => {
  return addon.atg_glu_out(out, self, dim)
}

export const atg_glu_backward = ({ grad_output, self, dim }: { grad_output: CTensor; self: CTensor; dim: number }): CTensor => {
  return addon.atg_glu_backward(grad_output, self, dim)
}

export const atg_glu_backward_grad_input = ({ grad_input, grad_output, self, dim }: { grad_input: CTensor; grad_output: CTensor; self: CTensor; dim: number }): CTensor => {
  return addon.atg_glu_backward_grad_input(grad_input, grad_output, self, dim)
}

export const atg_glu_jvp = ({ glu, x, dx, dim }: { glu: CTensor; x: CTensor; dx: CTensor; dim: number }): CTensor => {
  return addon.atg_glu_jvp(glu, x, dx, dim)
}

export const atg_glu_jvp_out = ({ out, glu, x, dx, dim }: { out: CTensor; glu: CTensor; x: CTensor; dx: CTensor; dim: number }): CTensor => {
  return addon.atg_glu_jvp_out(out, glu, x, dx, dim)
}

export const atg_glu_backward_jvp = ({ grad_x, grad_glu, x, dgrad_glu, dx, dim }: { grad_x: CTensor; grad_glu: CTensor; x: CTensor; dgrad_glu: CTensor; dx: CTensor; dim: number }): CTensor => {
  return addon.atg_glu_backward_jvp(grad_x, grad_glu, x, dgrad_glu, dx, dim)
}

export const atg_glu_backward_jvp_out = ({ out, grad_x, grad_glu, x, dgrad_glu, dx, dim }: { out: CTensor; grad_x: CTensor; grad_glu: CTensor; x: CTensor; dgrad_glu: CTensor; dx: CTensor; dim: number }): CTensor => {
  return addon.atg_glu_backward_jvp_out(out, grad_x, grad_glu, x, dgrad_glu, dx, dim)
}

export const atg_hardsigmoid = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_hardsigmoid(self)
}

export const atg_hardsigmoid_out = ({ out, self }: { out: CTensor; self: CTensor }): CTensor => {
  return addon.atg_hardsigmoid_out(out, self)
}

export const atg_hardsigmoid_ = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_hardsigmoid_(self)
}

export const atg_hardsigmoid_backward = ({ grad_output, self }: { grad_output: CTensor; self: CTensor }): CTensor => {
  return addon.atg_hardsigmoid_backward(grad_output, self)
}

export const atg_hardsigmoid_backward_grad_input = ({ grad_input, grad_output, self }: { grad_input: CTensor; grad_output: CTensor; self: CTensor }): CTensor => {
  return addon.atg_hardsigmoid_backward_grad_input(grad_input, grad_output, self)
}

export const atg_hardtanh = ({ self, min_val, max_val }: { self: CTensor; min_val: CScalar; max_val: CScalar }): CTensor => {
  return addon.atg_hardtanh(self, min_val, max_val)
}

export const atg_hardtanh_out = ({ out, self, min_val, max_val }: { out: CTensor; self: CTensor; min_val: CScalar; max_val: CScalar }): CTensor => {
  return addon.atg_hardtanh_out(out, self, min_val, max_val)
}

export const atg_hardtanh_backward = ({ grad_output, self, min_val, max_val }: { grad_output: CTensor; self: CTensor; min_val: CScalar; max_val: CScalar }): CTensor => {
  return addon.atg_hardtanh_backward(grad_output, self, min_val, max_val)
}

export const atg_hardtanh_backward_grad_input = ({ grad_input, grad_output, self, min_val, max_val }: { grad_input: CTensor; grad_output: CTensor; self: CTensor; min_val: CScalar; max_val: CScalar }): CTensor => {
  return addon.atg_hardtanh_backward_grad_input(grad_input, grad_output, self, min_val, max_val)
}

export const atg_hardtanh_ = ({ self, min_val, max_val }: { self: CTensor; min_val: CScalar; max_val: CScalar }): CTensor => {
  return addon.atg_hardtanh_(self, min_val, max_val)
}

export const atg_hardswish = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_hardswish(self)
}

export const atg_hardswish_out = ({ out, self }: { out: CTensor; self: CTensor }): CTensor => {
  return addon.atg_hardswish_out(out, self)
}

export const atg_hardswish_ = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_hardswish_(self)
}

export const atg_hardswish_backward = ({ grad_output, self }: { grad_output: CTensor; self: CTensor }): CTensor => {
  return addon.atg_hardswish_backward(grad_output, self)
}

export const atg_hardswish_backward_out = ({ out, grad_output, self }: { out: CTensor; grad_output: CTensor; self: CTensor }): CTensor => {
  return addon.atg_hardswish_backward_out(out, grad_output, self)
}

export const atg_leaky_relu = ({ self, negative_slope }: { self: CTensor; negative_slope: CScalar }): CTensor => {
  return addon.atg_leaky_relu(self, negative_slope)
}

export const atg_leaky_relu_out = ({ out, self, negative_slope }: { out: CTensor; self: CTensor; negative_slope: CScalar }): CTensor => {
  return addon.atg_leaky_relu_out(out, self, negative_slope)
}

export const atg_leaky_relu_backward = ({ grad_output, self, negative_slope, self_is_result }: { grad_output: CTensor; self: CTensor; negative_slope: CScalar; self_is_result: boolean }): CTensor => {
  return addon.atg_leaky_relu_backward(grad_output, self, negative_slope, self_is_result)
}

export const atg_leaky_relu_backward_grad_input = ({ grad_input, grad_output, self, negative_slope, self_is_result }: { grad_input: CTensor; grad_output: CTensor; self: CTensor; negative_slope: CScalar; self_is_result: boolean }): CTensor => {
  return addon.atg_leaky_relu_backward_grad_input(grad_input, grad_output, self, negative_slope, self_is_result)
}

export const atg_leaky_relu_ = ({ self, negative_slope }: { self: CTensor; negative_slope: CScalar }): CTensor => {
  return addon.atg_leaky_relu_(self, negative_slope)
}

export const atg_log_sigmoid = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_log_sigmoid(self)
}

export const atg_log_sigmoid_out = ({ out, self }: { out: CTensor; self: CTensor }): CTensor => {
  return addon.atg_log_sigmoid_out(out, self)
}

export const atg_log_sigmoid_backward = ({ grad_output, self, buffer }: { grad_output: CTensor; self: CTensor; buffer: CTensor }): CTensor => {
  return addon.atg_log_sigmoid_backward(grad_output, self, buffer)
}

export const atg_log_sigmoid_backward_grad_input = ({ grad_input, grad_output, self, buffer }: { grad_input: CTensor; grad_output: CTensor; self: CTensor; buffer: CTensor }): CTensor => {
  return addon.atg_log_sigmoid_backward_grad_input(grad_input, grad_output, self, buffer)
}

export const atg_rrelu_with_noise = ({ self, noise, lower, upper, training }: { self: CTensor; noise: CTensor; lower: CScalar; upper: CScalar; training: boolean }): CTensor => {
  return addon.atg_rrelu_with_noise(self, noise, lower, upper, training)
}

export const atg_rrelu_with_noise_out = ({ out, self, noise, lower, upper, training }: { out: CTensor; self: CTensor; noise: CTensor; lower: CScalar; upper: CScalar; training: boolean }): CTensor => {
  return addon.atg_rrelu_with_noise_out(out, self, noise, lower, upper, training)
}

export const atg_rrelu_with_noise_backward = ({ grad_output, self, noise, lower, upper, training, self_is_result }: { grad_output: CTensor; self: CTensor; noise: CTensor; lower: CScalar; upper: CScalar; training: boolean; self_is_result: boolean }): CTensor => {
  return addon.atg_rrelu_with_noise_backward(grad_output, self, noise, lower, upper, training, self_is_result)
}

export const atg_rrelu_with_noise_backward_out = ({ out, grad_output, self, noise, lower, upper, training, self_is_result }: { out: CTensor; grad_output: CTensor; self: CTensor; noise: CTensor; lower: CScalar; upper: CScalar; training: boolean; self_is_result: boolean }): CTensor => {
  return addon.atg_rrelu_with_noise_backward_out(out, grad_output, self, noise, lower, upper, training, self_is_result)
}

export const atg_rrelu_with_noise_ = ({ self, noise, lower, upper, training }: { self: CTensor; noise: CTensor; lower: CScalar; upper: CScalar; training: boolean }): CTensor => {
  return addon.atg_rrelu_with_noise_(self, noise, lower, upper, training)
}

export const atg_softplus = ({ self, beta, threshold }: { self: CTensor; beta: CScalar; threshold: CScalar }): CTensor => {
  return addon.atg_softplus(self, beta, threshold)
}

export const atg_softplus_out = ({ out, self, beta, threshold }: { out: CTensor; self: CTensor; beta: CScalar; threshold: CScalar }): CTensor => {
  return addon.atg_softplus_out(out, self, beta, threshold)
}

export const atg_softplus_backward = ({ grad_output, self, beta, threshold }: { grad_output: CTensor; self: CTensor; beta: CScalar; threshold: CScalar }): CTensor => {
  return addon.atg_softplus_backward(grad_output, self, beta, threshold)
}

export const atg_softplus_backward_grad_input = ({ grad_input, grad_output, self, beta, threshold }: { grad_input: CTensor; grad_output: CTensor; self: CTensor; beta: CScalar; threshold: CScalar }): CTensor => {
  return addon.atg_softplus_backward_grad_input(grad_input, grad_output, self, beta, threshold)
}

export const atg_softshrink = ({ self, lambd }: { self: CTensor; lambd: CScalar }): CTensor => {
  return addon.atg_softshrink(self, lambd)
}

export const atg_softshrink_out = ({ out, self, lambd }: { out: CTensor; self: CTensor; lambd: CScalar }): CTensor => {
  return addon.atg_softshrink_out(out, self, lambd)
}

export const atg_softshrink_backward = ({ grad_output, self, lambd }: { grad_output: CTensor; self: CTensor; lambd: CScalar }): CTensor => {
  return addon.atg_softshrink_backward(grad_output, self, lambd)
}

export const atg_softshrink_backward_grad_input = ({ grad_input, grad_output, self, lambd }: { grad_input: CTensor; grad_output: CTensor; self: CTensor; lambd: CScalar }): CTensor => {
  return addon.atg_softshrink_backward_grad_input(grad_input, grad_output, self, lambd)
}

export const atg_adaptive_avg_pool2d = ({ self, output_size }: { self: CTensor; output_size: number[] }): CTensor => {
  return addon.atg_adaptive_avg_pool2d(self, output_size)
}

export const atg_adaptive_avg_pool2d_out = ({ out, self, output_size }: { out: CTensor; self: CTensor; output_size: number[] }): CTensor => {
  return addon.atg_adaptive_avg_pool2d_out(out, self, output_size)
}

export const atg_mkldnn_adaptive_avg_pool2d = ({ self, output_size }: { self: CTensor; output_size: number[] }): CTensor => {
  return addon.atg_mkldnn_adaptive_avg_pool2d(self, output_size)
}

export const atg_mkldnn_adaptive_avg_pool2d_out = ({ out, self, output_size }: { out: CTensor; self: CTensor; output_size: number[] }): CTensor => {
  return addon.atg_mkldnn_adaptive_avg_pool2d_out(out, self, output_size)
}

export const atg_mkldnn_adaptive_avg_pool2d_backward = ({ grad_output, self }: { grad_output: CTensor; self: CTensor }): CTensor => {
  return addon.atg_mkldnn_adaptive_avg_pool2d_backward(grad_output, self)
}

export const atg_mkldnn_adaptive_avg_pool2d_backward_out = ({ out, grad_output, self }: { out: CTensor; grad_output: CTensor; self: CTensor }): CTensor => {
  return addon.atg_mkldnn_adaptive_avg_pool2d_backward_out(out, grad_output, self)
}

export const atg__adaptive_avg_pool2d = ({ self, output_size }: { self: CTensor; output_size: number[] }): CTensor => {
  return addon.atg__adaptive_avg_pool2d(self, output_size)
}

export const atg__adaptive_avg_pool2d_out = ({ out, self, output_size }: { out: CTensor; self: CTensor; output_size: number[] }): CTensor => {
  return addon.atg__adaptive_avg_pool2d_out(out, self, output_size)
}

export const atg__adaptive_avg_pool2d_backward = ({ grad_output, self }: { grad_output: CTensor; self: CTensor }): CTensor => {
  return addon.atg__adaptive_avg_pool2d_backward(grad_output, self)
}

export const atg__adaptive_avg_pool2d_backward_out = ({ out, grad_output, self }: { out: CTensor; grad_output: CTensor; self: CTensor }): CTensor => {
  return addon.atg__adaptive_avg_pool2d_backward_out(out, grad_output, self)
}

export const atg_adaptive_avg_pool3d = ({ self, output_size }: { self: CTensor; output_size: number[] }): CTensor => {
  return addon.atg_adaptive_avg_pool3d(self, output_size)
}

export const atg_adaptive_avg_pool3d_out = ({ out, self, output_size }: { out: CTensor; self: CTensor; output_size: number[] }): CTensor => {
  return addon.atg_adaptive_avg_pool3d_out(out, self, output_size)
}

export const atg__adaptive_avg_pool3d = ({ self, output_size }: { self: CTensor; output_size: number[] }): CTensor => {
  return addon.atg__adaptive_avg_pool3d(self, output_size)
}

export const atg__adaptive_avg_pool3d_out = ({ out, self, output_size }: { out: CTensor; self: CTensor; output_size: number[] }): CTensor => {
  return addon.atg__adaptive_avg_pool3d_out(out, self, output_size)
}

export const atg_adaptive_avg_pool3d_backward = ({ grad_input, grad_output, self }: { grad_input: CTensor; grad_output: CTensor; self: CTensor }): CTensor => {
  return addon.atg_adaptive_avg_pool3d_backward(grad_input, grad_output, self)
}

export const atg__adaptive_avg_pool3d_backward = ({ grad_output, self }: { grad_output: CTensor; self: CTensor }): CTensor => {
  return addon.atg__adaptive_avg_pool3d_backward(grad_output, self)
}

export const atg__adaptive_avg_pool3d_backward_out = ({ out, grad_output, self }: { out: CTensor; grad_output: CTensor; self: CTensor }): CTensor => {
  return addon.atg__adaptive_avg_pool3d_backward_out(out, grad_output, self)
}

export const atg_adaptive_max_pool2d = ({ self, output_size }: { self: CTensor; output_size: number[] }): CTensor[] => {
  return addon.atg_adaptive_max_pool2d(self, output_size)
}

export const atg_adaptive_max_pool2d_out = ({ out, indices, self, output_size }: { out: CTensor; indices: CTensor; self: CTensor; output_size: number[] }): CTensor[] => {
  return addon.atg_adaptive_max_pool2d_out(out, indices, self, output_size)
}

export const atg_adaptive_max_pool2d_backward = ({ grad_output, self, indices }: { grad_output: CTensor; self: CTensor; indices: CTensor }): CTensor => {
  return addon.atg_adaptive_max_pool2d_backward(grad_output, self, indices)
}

export const atg_adaptive_max_pool2d_backward_grad_input = ({ grad_input, grad_output, self, indices }: { grad_input: CTensor; grad_output: CTensor; self: CTensor; indices: CTensor }): CTensor => {
  return addon.atg_adaptive_max_pool2d_backward_grad_input(grad_input, grad_output, self, indices)
}

export const atg_adaptive_max_pool3d = ({ self, output_size }: { self: CTensor; output_size: number[] }): CTensor[] => {
  return addon.atg_adaptive_max_pool3d(self, output_size)
}

export const atg_adaptive_max_pool3d_out = ({ out, indices, self, output_size }: { out: CTensor; indices: CTensor; self: CTensor; output_size: number[] }): CTensor[] => {
  return addon.atg_adaptive_max_pool3d_out(out, indices, self, output_size)
}

export const atg_adaptive_max_pool3d_backward = ({ grad_output, self, indices }: { grad_output: CTensor; self: CTensor; indices: CTensor }): CTensor => {
  return addon.atg_adaptive_max_pool3d_backward(grad_output, self, indices)
}

export const atg_adaptive_max_pool3d_backward_grad_input = ({ grad_input, grad_output, self, indices }: { grad_input: CTensor; grad_output: CTensor; self: CTensor; indices: CTensor }): CTensor => {
  return addon.atg_adaptive_max_pool3d_backward_grad_input(grad_input, grad_output, self, indices)
}

export const atg_avg_pool2d = ({ self, kernel_size, stride, padding, ceil_mode, count_include_pad, divisor_override }: { self: CTensor; kernel_size: number[]; stride: number[]; padding: number[]; ceil_mode: boolean; count_include_pad: boolean; divisor_override?: number }): CTensor => {
  return addon.atg_avg_pool2d(self, kernel_size, stride, padding, ceil_mode, count_include_pad, divisor_override)
}

export const atg_avg_pool2d_out = ({ out, self, kernel_size, stride, padding, ceil_mode, count_include_pad, divisor_override }: { out: CTensor; self: CTensor; kernel_size: number[]; stride: number[]; padding: number[]; ceil_mode: boolean; count_include_pad: boolean; divisor_override?: number }): CTensor => {
  return addon.atg_avg_pool2d_out(out, self, kernel_size, stride, padding, ceil_mode, count_include_pad, divisor_override)
}

export const atg_avg_pool2d_backward = ({ grad_output, self, kernel_size, stride, padding, ceil_mode, count_include_pad, divisor_override }: { grad_output: CTensor; self: CTensor; kernel_size: number[]; stride: number[]; padding: number[]; ceil_mode: boolean; count_include_pad: boolean; divisor_override?: number }): CTensor => {
  return addon.atg_avg_pool2d_backward(grad_output, self, kernel_size, stride, padding, ceil_mode, count_include_pad, divisor_override)
}

export const atg_avg_pool2d_backward_grad_input = ({ grad_input, grad_output, self, kernel_size, stride, padding, ceil_mode, count_include_pad, divisor_override }: { grad_input: CTensor; grad_output: CTensor; self: CTensor; kernel_size: number[]; stride: number[]; padding: number[]; ceil_mode: boolean; count_include_pad: boolean; divisor_override?: number }): CTensor => {
  return addon.atg_avg_pool2d_backward_grad_input(grad_input, grad_output, self, kernel_size, stride, padding, ceil_mode, count_include_pad, divisor_override)
}

export const atg_avg_pool3d = ({ self, kernel_size, stride, padding, ceil_mode, count_include_pad, divisor_override }: { self: CTensor; kernel_size: number[]; stride: number[]; padding: number[]; ceil_mode: boolean; count_include_pad: boolean; divisor_override?: number }): CTensor => {
  return addon.atg_avg_pool3d(self, kernel_size, stride, padding, ceil_mode, count_include_pad, divisor_override)
}

export const atg_avg_pool3d_out = ({ out, self, kernel_size, stride, padding, ceil_mode, count_include_pad, divisor_override }: { out: CTensor; self: CTensor; kernel_size: number[]; stride: number[]; padding: number[]; ceil_mode: boolean; count_include_pad: boolean; divisor_override?: number }): CTensor => {
  return addon.atg_avg_pool3d_out(out, self, kernel_size, stride, padding, ceil_mode, count_include_pad, divisor_override)
}

export const atg_avg_pool3d_backward = ({ grad_output, self, kernel_size, stride, padding, ceil_mode, count_include_pad, divisor_override }: { grad_output: CTensor; self: CTensor; kernel_size: number[]; stride: number[]; padding: number[]; ceil_mode: boolean; count_include_pad: boolean; divisor_override?: number }): CTensor => {
  return addon.atg_avg_pool3d_backward(grad_output, self, kernel_size, stride, padding, ceil_mode, count_include_pad, divisor_override)
}

export const atg_avg_pool3d_backward_grad_input = ({ grad_input, grad_output, self, kernel_size, stride, padding, ceil_mode, count_include_pad, divisor_override }: { grad_input: CTensor; grad_output: CTensor; self: CTensor; kernel_size: number[]; stride: number[]; padding: number[]; ceil_mode: boolean; count_include_pad: boolean; divisor_override?: number }): CTensor => {
  return addon.atg_avg_pool3d_backward_grad_input(grad_input, grad_output, self, kernel_size, stride, padding, ceil_mode, count_include_pad, divisor_override)
}

export const atg_fractional_max_pool2d = ({ self, kernel_size, output_size, random_samples }: { self: CTensor; kernel_size: number[]; output_size: number[]; random_samples: CTensor }): CTensor[] => {
  return addon.atg_fractional_max_pool2d(self, kernel_size, output_size, random_samples)
}

export const atg_fractional_max_pool2d_output = ({ output, indices, self, kernel_size, output_size, random_samples }: { output: CTensor; indices: CTensor; self: CTensor; kernel_size: number[]; output_size: number[]; random_samples: CTensor }): CTensor[] => {
  return addon.atg_fractional_max_pool2d_output(output, indices, self, kernel_size, output_size, random_samples)
}

export const atg_fractional_max_pool2d_backward = ({ grad_output, self, kernel_size, output_size, indices }: { grad_output: CTensor; self: CTensor; kernel_size: number[]; output_size: number[]; indices: CTensor }): CTensor => {
  return addon.atg_fractional_max_pool2d_backward(grad_output, self, kernel_size, output_size, indices)
}

export const atg_fractional_max_pool2d_backward_grad_input = ({ grad_input, grad_output, self, kernel_size, output_size, indices }: { grad_input: CTensor; grad_output: CTensor; self: CTensor; kernel_size: number[]; output_size: number[]; indices: CTensor }): CTensor => {
  return addon.atg_fractional_max_pool2d_backward_grad_input(grad_input, grad_output, self, kernel_size, output_size, indices)
}

export const atg_fractional_max_pool3d = ({ self, kernel_size, output_size, random_samples }: { self: CTensor; kernel_size: number[]; output_size: number[]; random_samples: CTensor }): CTensor[] => {
  return addon.atg_fractional_max_pool3d(self, kernel_size, output_size, random_samples)
}

export const atg_fractional_max_pool3d_output = ({ output, indices, self, kernel_size, output_size, random_samples }: { output: CTensor; indices: CTensor; self: CTensor; kernel_size: number[]; output_size: number[]; random_samples: CTensor }): CTensor[] => {
  return addon.atg_fractional_max_pool3d_output(output, indices, self, kernel_size, output_size, random_samples)
}

export const atg_fractional_max_pool3d_backward = ({ grad_output, self, kernel_size, output_size, indices }: { grad_output: CTensor; self: CTensor; kernel_size: number[]; output_size: number[]; indices: CTensor }): CTensor => {
  return addon.atg_fractional_max_pool3d_backward(grad_output, self, kernel_size, output_size, indices)
}

export const atg_fractional_max_pool3d_backward_grad_input = ({ grad_input, grad_output, self, kernel_size, output_size, indices }: { grad_input: CTensor; grad_output: CTensor; self: CTensor; kernel_size: number[]; output_size: number[]; indices: CTensor }): CTensor => {
  return addon.atg_fractional_max_pool3d_backward_grad_input(grad_input, grad_output, self, kernel_size, output_size, indices)
}

export const atg_max_pool2d_with_indices = ({ self, kernel_size, stride, padding, dilation, ceil_mode }: { self: CTensor; kernel_size: number[]; stride: number[]; padding: number[]; dilation: number[]; ceil_mode: boolean }): CTensor[] => {
  return addon.atg_max_pool2d_with_indices(self, kernel_size, stride, padding, dilation, ceil_mode)
}

export const atg_max_pool2d_with_indices_out = ({ out, indices, self, kernel_size, stride, padding, dilation, ceil_mode }: { out: CTensor; indices: CTensor; self: CTensor; kernel_size: number[]; stride: number[]; padding: number[]; dilation: number[]; ceil_mode: boolean }): CTensor[] => {
  return addon.atg_max_pool2d_with_indices_out(out, indices, self, kernel_size, stride, padding, dilation, ceil_mode)
}

export const atg_max_pool2d_with_indices_backward = ({ grad_output, self, kernel_size, stride, padding, dilation, ceil_mode, indices }: { grad_output: CTensor; self: CTensor; kernel_size: number[]; stride: number[]; padding: number[]; dilation: number[]; ceil_mode: boolean; indices: CTensor }): CTensor => {
  return addon.atg_max_pool2d_with_indices_backward(grad_output, self, kernel_size, stride, padding, dilation, ceil_mode, indices)
}

export const atg_max_pool2d_with_indices_backward_grad_input = ({ grad_input, grad_output, self, kernel_size, stride, padding, dilation, ceil_mode, indices }: { grad_input: CTensor; grad_output: CTensor; self: CTensor; kernel_size: number[]; stride: number[]; padding: number[]; dilation: number[]; ceil_mode: boolean; indices: CTensor }): CTensor => {
  return addon.atg_max_pool2d_with_indices_backward_grad_input(grad_input, grad_output, self, kernel_size, stride, padding, dilation, ceil_mode, indices)
}

export const atg_max_pool3d_with_indices = ({ self, kernel_size, stride, padding, dilation, ceil_mode }: { self: CTensor; kernel_size: number[]; stride: number[]; padding: number[]; dilation: number[]; ceil_mode: boolean }): CTensor[] => {
  return addon.atg_max_pool3d_with_indices(self, kernel_size, stride, padding, dilation, ceil_mode)
}

export const atg_max_pool3d_with_indices_out = ({ out, indices, self, kernel_size, stride, padding, dilation, ceil_mode }: { out: CTensor; indices: CTensor; self: CTensor; kernel_size: number[]; stride: number[]; padding: number[]; dilation: number[]; ceil_mode: boolean }): CTensor[] => {
  return addon.atg_max_pool3d_with_indices_out(out, indices, self, kernel_size, stride, padding, dilation, ceil_mode)
}

export const atg_max_pool3d_with_indices_backward = ({ grad_output, self, kernel_size, stride, padding, dilation, ceil_mode, indices }: { grad_output: CTensor; self: CTensor; kernel_size: number[]; stride: number[]; padding: number[]; dilation: number[]; ceil_mode: boolean; indices: CTensor }): CTensor => {
  return addon.atg_max_pool3d_with_indices_backward(grad_output, self, kernel_size, stride, padding, dilation, ceil_mode, indices)
}

export const atg_max_pool3d_with_indices_backward_grad_input = ({ grad_input, grad_output, self, kernel_size, stride, padding, dilation, ceil_mode, indices }: { grad_input: CTensor; grad_output: CTensor; self: CTensor; kernel_size: number[]; stride: number[]; padding: number[]; dilation: number[]; ceil_mode: boolean; indices: CTensor }): CTensor => {
  return addon.atg_max_pool3d_with_indices_backward_grad_input(grad_input, grad_output, self, kernel_size, stride, padding, dilation, ceil_mode, indices)
}

export const atg_max_unpool2d = ({ self, indices, output_size }: { self: CTensor; indices: CTensor; output_size: number[] }): CTensor => {
  return addon.atg_max_unpool2d(self, indices, output_size)
}

export const atg_max_unpool2d_out = ({ out, self, indices, output_size }: { out: CTensor; self: CTensor; indices: CTensor; output_size: number[] }): CTensor => {
  return addon.atg_max_unpool2d_out(out, self, indices, output_size)
}

export const atg_max_unpool3d = ({ self, indices, output_size, stride, padding }: { self: CTensor; indices: CTensor; output_size: number[]; stride: number[]; padding: number[] }): CTensor => {
  return addon.atg_max_unpool3d(self, indices, output_size, stride, padding)
}

export const atg_max_unpool3d_out = ({ out, self, indices, output_size, stride, padding }: { out: CTensor; self: CTensor; indices: CTensor; output_size: number[]; stride: number[]; padding: number[] }): CTensor => {
  return addon.atg_max_unpool3d_out(out, self, indices, output_size, stride, padding)
}

export const atg_reflection_pad1d = ({ self, padding }: { self: CTensor; padding: number[] }): CTensor => {
  return addon.atg_reflection_pad1d(self, padding)
}

export const atg_reflection_pad1d_out = ({ out, self, padding }: { out: CTensor; self: CTensor; padding: number[] }): CTensor => {
  return addon.atg_reflection_pad1d_out(out, self, padding)
}

export const atg_reflection_pad1d_backward = ({ grad_output, self, padding }: { grad_output: CTensor; self: CTensor; padding: number[] }): CTensor => {
  return addon.atg_reflection_pad1d_backward(grad_output, self, padding)
}

export const atg_reflection_pad1d_backward_grad_input = ({ grad_input, grad_output, self, padding }: { grad_input: CTensor; grad_output: CTensor; self: CTensor; padding: number[] }): CTensor => {
  return addon.atg_reflection_pad1d_backward_grad_input(grad_input, grad_output, self, padding)
}

export const atg_reflection_pad2d = ({ self, padding }: { self: CTensor; padding: number[] }): CTensor => {
  return addon.atg_reflection_pad2d(self, padding)
}

export const atg_reflection_pad2d_out = ({ out, self, padding }: { out: CTensor; self: CTensor; padding: number[] }): CTensor => {
  return addon.atg_reflection_pad2d_out(out, self, padding)
}

export const atg_reflection_pad2d_backward = ({ grad_output, self, padding }: { grad_output: CTensor; self: CTensor; padding: number[] }): CTensor => {
  return addon.atg_reflection_pad2d_backward(grad_output, self, padding)
}

export const atg_reflection_pad2d_backward_grad_input = ({ grad_input, grad_output, self, padding }: { grad_input: CTensor; grad_output: CTensor; self: CTensor; padding: number[] }): CTensor => {
  return addon.atg_reflection_pad2d_backward_grad_input(grad_input, grad_output, self, padding)
}

export const atg_reflection_pad3d = ({ self, padding }: { self: CTensor; padding: number[] }): CTensor => {
  return addon.atg_reflection_pad3d(self, padding)
}

export const atg_reflection_pad3d_out = ({ out, self, padding }: { out: CTensor; self: CTensor; padding: number[] }): CTensor => {
  return addon.atg_reflection_pad3d_out(out, self, padding)
}

export const atg_reflection_pad3d_backward = ({ grad_output, self, padding }: { grad_output: CTensor; self: CTensor; padding: number[] }): CTensor => {
  return addon.atg_reflection_pad3d_backward(grad_output, self, padding)
}

export const atg_reflection_pad3d_backward_grad_input = ({ grad_input, grad_output, self, padding }: { grad_input: CTensor; grad_output: CTensor; self: CTensor; padding: number[] }): CTensor => {
  return addon.atg_reflection_pad3d_backward_grad_input(grad_input, grad_output, self, padding)
}

export const atg_replication_pad1d = ({ self, padding }: { self: CTensor; padding: number[] }): CTensor => {
  return addon.atg_replication_pad1d(self, padding)
}

export const atg_replication_pad1d_out = ({ out, self, padding }: { out: CTensor; self: CTensor; padding: number[] }): CTensor => {
  return addon.atg_replication_pad1d_out(out, self, padding)
}

export const atg_replication_pad1d_backward = ({ grad_output, self, padding }: { grad_output: CTensor; self: CTensor; padding: number[] }): CTensor => {
  return addon.atg_replication_pad1d_backward(grad_output, self, padding)
}

export const atg_replication_pad1d_backward_grad_input = ({ grad_input, grad_output, self, padding }: { grad_input: CTensor; grad_output: CTensor; self: CTensor; padding: number[] }): CTensor => {
  return addon.atg_replication_pad1d_backward_grad_input(grad_input, grad_output, self, padding)
}

export const atg_replication_pad2d = ({ self, padding }: { self: CTensor; padding: number[] }): CTensor => {
  return addon.atg_replication_pad2d(self, padding)
}

export const atg_replication_pad2d_out = ({ out, self, padding }: { out: CTensor; self: CTensor; padding: number[] }): CTensor => {
  return addon.atg_replication_pad2d_out(out, self, padding)
}

export const atg_replication_pad2d_backward = ({ grad_output, self, padding }: { grad_output: CTensor; self: CTensor; padding: number[] }): CTensor => {
  return addon.atg_replication_pad2d_backward(grad_output, self, padding)
}

export const atg_replication_pad2d_backward_grad_input = ({ grad_input, grad_output, self, padding }: { grad_input: CTensor; grad_output: CTensor; self: CTensor; padding: number[] }): CTensor => {
  return addon.atg_replication_pad2d_backward_grad_input(grad_input, grad_output, self, padding)
}

export const atg_replication_pad3d = ({ self, padding }: { self: CTensor; padding: number[] }): CTensor => {
  return addon.atg_replication_pad3d(self, padding)
}

export const atg_replication_pad3d_out = ({ out, self, padding }: { out: CTensor; self: CTensor; padding: number[] }): CTensor => {
  return addon.atg_replication_pad3d_out(out, self, padding)
}

export const atg_replication_pad3d_backward = ({ grad_output, self, padding }: { grad_output: CTensor; self: CTensor; padding: number[] }): CTensor => {
  return addon.atg_replication_pad3d_backward(grad_output, self, padding)
}

export const atg_replication_pad3d_backward_grad_input = ({ grad_input, grad_output, self, padding }: { grad_input: CTensor; grad_output: CTensor; self: CTensor; padding: number[] }): CTensor => {
  return addon.atg_replication_pad3d_backward_grad_input(grad_input, grad_output, self, padding)
}

export const atg__pad_circular = ({ self, pad }: { self: CTensor; pad: number[] }): CTensor => {
  return addon.atg__pad_circular(self, pad)
}

export const atg__pad_enum = ({ self, pad, mode, value }: { self: CTensor; pad: number[]; mode: number; value?: number }): CTensor => {
  return addon.atg__pad_enum(self, pad, mode, value)
}

export const atg_pad = ({ self, pad, mode, value }: { self: CTensor; pad: number[]; mode: string; value?: number }): CTensor => {
  return addon.atg_pad(self, pad, mode, value)
}

export const atg_upsample_linear1d_vec = ({ input, output_size, align_corners, scale_factors }: { input: CTensor; output_size?: number[]; align_corners: boolean; scale_factors: number[] }): CTensor => {
  return addon.atg_upsample_linear1d_vec(input, output_size, align_corners, scale_factors)
}

export const atg_upsample_linear1d = ({ self, output_size, align_corners, scales }: { self: CTensor; output_size: number[]; align_corners: boolean; scales?: number }): CTensor => {
  return addon.atg_upsample_linear1d(self, output_size, align_corners, scales)
}

export const atg_upsample_linear1d_out = ({ out, self, output_size, align_corners, scales }: { out: CTensor; self: CTensor; output_size: number[]; align_corners: boolean; scales?: number }): CTensor => {
  return addon.atg_upsample_linear1d_out(out, self, output_size, align_corners, scales)
}

export const atg_upsample_bilinear2d_vec = ({ input, output_size, align_corners, scale_factors }: { input: CTensor; output_size?: number[]; align_corners: boolean; scale_factors: number[] }): CTensor => {
  return addon.atg_upsample_bilinear2d_vec(input, output_size, align_corners, scale_factors)
}

export const atg_upsample_bilinear2d = ({ self, output_size, align_corners, scales_h, scales_w }: { self: CTensor; output_size: number[]; align_corners: boolean; scales_h?: number; scales_w?: number }): CTensor => {
  return addon.atg_upsample_bilinear2d(self, output_size, align_corners, scales_h, scales_w)
}

export const atg_upsample_bilinear2d_out = ({ out, self, output_size, align_corners, scales_h, scales_w }: { out: CTensor; self: CTensor; output_size: number[]; align_corners: boolean; scales_h?: number; scales_w?: number }): CTensor => {
  return addon.atg_upsample_bilinear2d_out(out, self, output_size, align_corners, scales_h, scales_w)
}

export const atg__upsample_bilinear2d_aa_vec = ({ input, output_size, align_corners, scale_factors }: { input: CTensor; output_size?: number[]; align_corners: boolean; scale_factors: number[] }): CTensor => {
  return addon.atg__upsample_bilinear2d_aa_vec(input, output_size, align_corners, scale_factors)
}

export const atg__upsample_bilinear2d_aa = ({ self, output_size, align_corners, scales_h, scales_w }: { self: CTensor; output_size: number[]; align_corners: boolean; scales_h?: number; scales_w?: number }): CTensor => {
  return addon.atg__upsample_bilinear2d_aa(self, output_size, align_corners, scales_h, scales_w)
}

export const atg__upsample_bilinear2d_aa_out = ({ out, self, output_size, align_corners, scales_h, scales_w }: { out: CTensor; self: CTensor; output_size: number[]; align_corners: boolean; scales_h?: number; scales_w?: number }): CTensor => {
  return addon.atg__upsample_bilinear2d_aa_out(out, self, output_size, align_corners, scales_h, scales_w)
}

export const atg_upsample_trilinear3d_vec = ({ input, output_size, align_corners, scale_factors }: { input: CTensor; output_size?: number[]; align_corners: boolean; scale_factors: number[] }): CTensor => {
  return addon.atg_upsample_trilinear3d_vec(input, output_size, align_corners, scale_factors)
}

export const atg_upsample_trilinear3d = ({ self, output_size, align_corners, scales_d, scales_h, scales_w }: { self: CTensor; output_size: number[]; align_corners: boolean; scales_d?: number; scales_h?: number; scales_w?: number }): CTensor => {
  return addon.atg_upsample_trilinear3d(self, output_size, align_corners, scales_d, scales_h, scales_w)
}

export const atg_upsample_trilinear3d_out = ({ out, self, output_size, align_corners, scales_d, scales_h, scales_w }: { out: CTensor; self: CTensor; output_size: number[]; align_corners: boolean; scales_d?: number; scales_h?: number; scales_w?: number }): CTensor => {
  return addon.atg_upsample_trilinear3d_out(out, self, output_size, align_corners, scales_d, scales_h, scales_w)
}

export const atg_upsample_bicubic2d_vec = ({ input, output_size, align_corners, scale_factors }: { input: CTensor; output_size?: number[]; align_corners: boolean; scale_factors: number[] }): CTensor => {
  return addon.atg_upsample_bicubic2d_vec(input, output_size, align_corners, scale_factors)
}

export const atg_upsample_bicubic2d = ({ self, output_size, align_corners, scales_h, scales_w }: { self: CTensor; output_size: number[]; align_corners: boolean; scales_h?: number; scales_w?: number }): CTensor => {
  return addon.atg_upsample_bicubic2d(self, output_size, align_corners, scales_h, scales_w)
}

export const atg_upsample_bicubic2d_out = ({ out, self, output_size, align_corners, scales_h, scales_w }: { out: CTensor; self: CTensor; output_size: number[]; align_corners: boolean; scales_h?: number; scales_w?: number }): CTensor => {
  return addon.atg_upsample_bicubic2d_out(out, self, output_size, align_corners, scales_h, scales_w)
}

export const atg__upsample_bicubic2d_aa_vec = ({ input, output_size, align_corners, scale_factors }: { input: CTensor; output_size?: number[]; align_corners: boolean; scale_factors: number[] }): CTensor => {
  return addon.atg__upsample_bicubic2d_aa_vec(input, output_size, align_corners, scale_factors)
}

export const atg__upsample_bicubic2d_aa = ({ self, output_size, align_corners, scales_h, scales_w }: { self: CTensor; output_size: number[]; align_corners: boolean; scales_h?: number; scales_w?: number }): CTensor => {
  return addon.atg__upsample_bicubic2d_aa(self, output_size, align_corners, scales_h, scales_w)
}

export const atg__upsample_bicubic2d_aa_out = ({ out, self, output_size, align_corners, scales_h, scales_w }: { out: CTensor; self: CTensor; output_size: number[]; align_corners: boolean; scales_h?: number; scales_w?: number }): CTensor => {
  return addon.atg__upsample_bicubic2d_aa_out(out, self, output_size, align_corners, scales_h, scales_w)
}

export const atg_upsample_nearest1d_vec = ({ input, output_size, scale_factors }: { input: CTensor; output_size?: number[]; scale_factors: number[] }): CTensor => {
  return addon.atg_upsample_nearest1d_vec(input, output_size, scale_factors)
}

export const atg_upsample_nearest1d = ({ self, output_size, scales }: { self: CTensor; output_size: number[]; scales?: number }): CTensor => {
  return addon.atg_upsample_nearest1d(self, output_size, scales)
}

export const atg_upsample_nearest1d_out = ({ out, self, output_size, scales }: { out: CTensor; self: CTensor; output_size: number[]; scales?: number }): CTensor => {
  return addon.atg_upsample_nearest1d_out(out, self, output_size, scales)
}

export const atg__upsample_nearest_exact1d_vec = ({ input, output_size, scale_factors }: { input: CTensor; output_size?: number[]; scale_factors: number[] }): CTensor => {
  return addon.atg__upsample_nearest_exact1d_vec(input, output_size, scale_factors)
}

export const atg__upsample_nearest_exact1d = ({ self, output_size, scales }: { self: CTensor; output_size: number[]; scales?: number }): CTensor => {
  return addon.atg__upsample_nearest_exact1d(self, output_size, scales)
}

export const atg__upsample_nearest_exact1d_out = ({ out, self, output_size, scales }: { out: CTensor; self: CTensor; output_size: number[]; scales?: number }): CTensor => {
  return addon.atg__upsample_nearest_exact1d_out(out, self, output_size, scales)
}

export const atg_upsample_nearest2d_vec = ({ input, output_size, scale_factors }: { input: CTensor; output_size?: number[]; scale_factors: number[] }): CTensor => {
  return addon.atg_upsample_nearest2d_vec(input, output_size, scale_factors)
}

export const atg_upsample_nearest2d = ({ self, output_size, scales_h, scales_w }: { self: CTensor; output_size: number[]; scales_h?: number; scales_w?: number }): CTensor => {
  return addon.atg_upsample_nearest2d(self, output_size, scales_h, scales_w)
}

export const atg_upsample_nearest2d_out = ({ out, self, output_size, scales_h, scales_w }: { out: CTensor; self: CTensor; output_size: number[]; scales_h?: number; scales_w?: number }): CTensor => {
  return addon.atg_upsample_nearest2d_out(out, self, output_size, scales_h, scales_w)
}

export const atg__upsample_nearest_exact2d_vec = ({ input, output_size, scale_factors }: { input: CTensor; output_size?: number[]; scale_factors: number[] }): CTensor => {
  return addon.atg__upsample_nearest_exact2d_vec(input, output_size, scale_factors)
}

export const atg__upsample_nearest_exact2d = ({ self, output_size, scales_h, scales_w }: { self: CTensor; output_size: number[]; scales_h?: number; scales_w?: number }): CTensor => {
  return addon.atg__upsample_nearest_exact2d(self, output_size, scales_h, scales_w)
}

export const atg__upsample_nearest_exact2d_out = ({ out, self, output_size, scales_h, scales_w }: { out: CTensor; self: CTensor; output_size: number[]; scales_h?: number; scales_w?: number }): CTensor => {
  return addon.atg__upsample_nearest_exact2d_out(out, self, output_size, scales_h, scales_w)
}

export const atg_upsample_nearest3d_vec = ({ input, output_size, scale_factors }: { input: CTensor; output_size?: number[]; scale_factors: number[] }): CTensor => {
  return addon.atg_upsample_nearest3d_vec(input, output_size, scale_factors)
}

export const atg_upsample_nearest3d = ({ self, output_size, scales_d, scales_h, scales_w }: { self: CTensor; output_size: number[]; scales_d?: number; scales_h?: number; scales_w?: number }): CTensor => {
  return addon.atg_upsample_nearest3d(self, output_size, scales_d, scales_h, scales_w)
}

export const atg_upsample_nearest3d_out = ({ out, self, output_size, scales_d, scales_h, scales_w }: { out: CTensor; self: CTensor; output_size: number[]; scales_d?: number; scales_h?: number; scales_w?: number }): CTensor => {
  return addon.atg_upsample_nearest3d_out(out, self, output_size, scales_d, scales_h, scales_w)
}

export const atg__upsample_nearest_exact3d_vec = ({ input, output_size, scale_factors }: { input: CTensor; output_size?: number[]; scale_factors: number[] }): CTensor => {
  return addon.atg__upsample_nearest_exact3d_vec(input, output_size, scale_factors)
}

export const atg__upsample_nearest_exact3d = ({ self, output_size, scales_d, scales_h, scales_w }: { self: CTensor; output_size: number[]; scales_d?: number; scales_h?: number; scales_w?: number }): CTensor => {
  return addon.atg__upsample_nearest_exact3d(self, output_size, scales_d, scales_h, scales_w)
}

export const atg__upsample_nearest_exact3d_out = ({ out, self, output_size, scales_d, scales_h, scales_w }: { out: CTensor; self: CTensor; output_size: number[]; scales_d?: number; scales_h?: number; scales_w?: number }): CTensor => {
  return addon.atg__upsample_nearest_exact3d_out(out, self, output_size, scales_d, scales_h, scales_w)
}

export const atg_upsample_linear1d_backward = ({ grad_output, output_size, input_size, align_corners, scales }: { grad_output: CTensor; output_size: number[]; input_size: number[]; align_corners: boolean; scales?: number }): CTensor => {
  return addon.atg_upsample_linear1d_backward(grad_output, output_size, input_size, align_corners, scales)
}

export const atg_upsample_linear1d_backward_grad_input = ({ grad_input, grad_output, output_size, input_size, align_corners, scales }: { grad_input: CTensor; grad_output: CTensor; output_size: number[]; input_size: number[]; align_corners: boolean; scales?: number }): CTensor => {
  return addon.atg_upsample_linear1d_backward_grad_input(grad_input, grad_output, output_size, input_size, align_corners, scales)
}

export const atg_upsample_bilinear2d_backward = ({ grad_output, output_size, input_size, align_corners, scales_h, scales_w }: { grad_output: CTensor; output_size: number[]; input_size: number[]; align_corners: boolean; scales_h?: number; scales_w?: number }): CTensor => {
  return addon.atg_upsample_bilinear2d_backward(grad_output, output_size, input_size, align_corners, scales_h, scales_w)
}

export const atg_upsample_bilinear2d_backward_grad_input = ({ grad_input, grad_output, output_size, input_size, align_corners, scales_h, scales_w }: { grad_input: CTensor; grad_output: CTensor; output_size: number[]; input_size: number[]; align_corners: boolean; scales_h?: number; scales_w?: number }): CTensor => {
  return addon.atg_upsample_bilinear2d_backward_grad_input(grad_input, grad_output, output_size, input_size, align_corners, scales_h, scales_w)
}

export const atg__upsample_bilinear2d_aa_backward = ({ grad_output, output_size, input_size, align_corners, scales_h, scales_w }: { grad_output: CTensor; output_size: number[]; input_size: number[]; align_corners: boolean; scales_h?: number; scales_w?: number }): CTensor => {
  return addon.atg__upsample_bilinear2d_aa_backward(grad_output, output_size, input_size, align_corners, scales_h, scales_w)
}

export const atg__upsample_bilinear2d_aa_backward_grad_input = ({ grad_input, grad_output, output_size, input_size, align_corners, scales_h, scales_w }: { grad_input: CTensor; grad_output: CTensor; output_size: number[]; input_size: number[]; align_corners: boolean; scales_h?: number; scales_w?: number }): CTensor => {
  return addon.atg__upsample_bilinear2d_aa_backward_grad_input(grad_input, grad_output, output_size, input_size, align_corners, scales_h, scales_w)
}

export const atg_upsample_bicubic2d_backward = ({ grad_output, output_size, input_size, align_corners, scales_h, scales_w }: { grad_output: CTensor; output_size: number[]; input_size: number[]; align_corners: boolean; scales_h?: number; scales_w?: number }): CTensor => {
  return addon.atg_upsample_bicubic2d_backward(grad_output, output_size, input_size, align_corners, scales_h, scales_w)
}

export const atg_upsample_bicubic2d_backward_grad_input = ({ grad_input, grad_output, output_size, input_size, align_corners, scales_h, scales_w }: { grad_input: CTensor; grad_output: CTensor; output_size: number[]; input_size: number[]; align_corners: boolean; scales_h?: number; scales_w?: number }): CTensor => {
  return addon.atg_upsample_bicubic2d_backward_grad_input(grad_input, grad_output, output_size, input_size, align_corners, scales_h, scales_w)
}

export const atg__upsample_bicubic2d_aa_backward = ({ grad_output, output_size, input_size, align_corners, scales_h, scales_w }: { grad_output: CTensor; output_size: number[]; input_size: number[]; align_corners: boolean; scales_h?: number; scales_w?: number }): CTensor => {
  return addon.atg__upsample_bicubic2d_aa_backward(grad_output, output_size, input_size, align_corners, scales_h, scales_w)
}

export const atg__upsample_bicubic2d_aa_backward_grad_input = ({ grad_input, grad_output, output_size, input_size, align_corners, scales_h, scales_w }: { grad_input: CTensor; grad_output: CTensor; output_size: number[]; input_size: number[]; align_corners: boolean; scales_h?: number; scales_w?: number }): CTensor => {
  return addon.atg__upsample_bicubic2d_aa_backward_grad_input(grad_input, grad_output, output_size, input_size, align_corners, scales_h, scales_w)
}

export const atg_upsample_trilinear3d_backward = ({ grad_output, output_size, input_size, align_corners, scales_d, scales_h, scales_w }: { grad_output: CTensor; output_size: number[]; input_size: number[]; align_corners: boolean; scales_d?: number; scales_h?: number; scales_w?: number }): CTensor => {
  return addon.atg_upsample_trilinear3d_backward(grad_output, output_size, input_size, align_corners, scales_d, scales_h, scales_w)
}

export const atg_upsample_trilinear3d_backward_grad_input = ({ grad_input, grad_output, output_size, input_size, align_corners, scales_d, scales_h, scales_w }: { grad_input: CTensor; grad_output: CTensor; output_size: number[]; input_size: number[]; align_corners: boolean; scales_d?: number; scales_h?: number; scales_w?: number }): CTensor => {
  return addon.atg_upsample_trilinear3d_backward_grad_input(grad_input, grad_output, output_size, input_size, align_corners, scales_d, scales_h, scales_w)
}

export const atg_upsample_nearest1d_backward = ({ grad_output, output_size, input_size, scales }: { grad_output: CTensor; output_size: number[]; input_size: number[]; scales?: number }): CTensor => {
  return addon.atg_upsample_nearest1d_backward(grad_output, output_size, input_size, scales)
}

export const atg_upsample_nearest1d_backward_grad_input = ({ grad_input, grad_output, output_size, input_size, scales }: { grad_input: CTensor; grad_output: CTensor; output_size: number[]; input_size: number[]; scales?: number }): CTensor => {
  return addon.atg_upsample_nearest1d_backward_grad_input(grad_input, grad_output, output_size, input_size, scales)
}

export const atg__upsample_nearest_exact1d_backward = ({ grad_output, output_size, input_size, scales }: { grad_output: CTensor; output_size: number[]; input_size: number[]; scales?: number }): CTensor => {
  return addon.atg__upsample_nearest_exact1d_backward(grad_output, output_size, input_size, scales)
}

export const atg__upsample_nearest_exact1d_backward_grad_input = ({ grad_input, grad_output, output_size, input_size, scales }: { grad_input: CTensor; grad_output: CTensor; output_size: number[]; input_size: number[]; scales?: number }): CTensor => {
  return addon.atg__upsample_nearest_exact1d_backward_grad_input(grad_input, grad_output, output_size, input_size, scales)
}

export const atg_upsample_nearest2d_backward = ({ grad_output, output_size, input_size, scales_h, scales_w }: { grad_output: CTensor; output_size: number[]; input_size: number[]; scales_h?: number; scales_w?: number }): CTensor => {
  return addon.atg_upsample_nearest2d_backward(grad_output, output_size, input_size, scales_h, scales_w)
}

export const atg_upsample_nearest2d_backward_grad_input = ({ grad_input, grad_output, output_size, input_size, scales_h, scales_w }: { grad_input: CTensor; grad_output: CTensor; output_size: number[]; input_size: number[]; scales_h?: number; scales_w?: number }): CTensor => {
  return addon.atg_upsample_nearest2d_backward_grad_input(grad_input, grad_output, output_size, input_size, scales_h, scales_w)
}

export const atg__upsample_nearest_exact2d_backward = ({ grad_output, output_size, input_size, scales_h, scales_w }: { grad_output: CTensor; output_size: number[]; input_size: number[]; scales_h?: number; scales_w?: number }): CTensor => {
  return addon.atg__upsample_nearest_exact2d_backward(grad_output, output_size, input_size, scales_h, scales_w)
}

export const atg__upsample_nearest_exact2d_backward_grad_input = ({ grad_input, grad_output, output_size, input_size, scales_h, scales_w }: { grad_input: CTensor; grad_output: CTensor; output_size: number[]; input_size: number[]; scales_h?: number; scales_w?: number }): CTensor => {
  return addon.atg__upsample_nearest_exact2d_backward_grad_input(grad_input, grad_output, output_size, input_size, scales_h, scales_w)
}

export const atg_upsample_nearest3d_backward = ({ grad_output, output_size, input_size, scales_d, scales_h, scales_w }: { grad_output: CTensor; output_size: number[]; input_size: number[]; scales_d?: number; scales_h?: number; scales_w?: number }): CTensor => {
  return addon.atg_upsample_nearest3d_backward(grad_output, output_size, input_size, scales_d, scales_h, scales_w)
}

export const atg_upsample_nearest3d_backward_grad_input = ({ grad_input, grad_output, output_size, input_size, scales_d, scales_h, scales_w }: { grad_input: CTensor; grad_output: CTensor; output_size: number[]; input_size: number[]; scales_d?: number; scales_h?: number; scales_w?: number }): CTensor => {
  return addon.atg_upsample_nearest3d_backward_grad_input(grad_input, grad_output, output_size, input_size, scales_d, scales_h, scales_w)
}

export const atg__upsample_nearest_exact3d_backward = ({ grad_output, output_size, input_size, scales_d, scales_h, scales_w }: { grad_output: CTensor; output_size: number[]; input_size: number[]; scales_d?: number; scales_h?: number; scales_w?: number }): CTensor => {
  return addon.atg__upsample_nearest_exact3d_backward(grad_output, output_size, input_size, scales_d, scales_h, scales_w)
}

export const atg__upsample_nearest_exact3d_backward_grad_input = ({ grad_input, grad_output, output_size, input_size, scales_d, scales_h, scales_w }: { grad_input: CTensor; grad_output: CTensor; output_size: number[]; input_size: number[]; scales_d?: number; scales_h?: number; scales_w?: number }): CTensor => {
  return addon.atg__upsample_nearest_exact3d_backward_grad_input(grad_input, grad_output, output_size, input_size, scales_d, scales_h, scales_w)
}

export const atg_sigmoid_backward = ({ grad_output, output }: { grad_output: CTensor; output: CTensor }): CTensor => {
  return addon.atg_sigmoid_backward(grad_output, output)
}

export const atg_sigmoid_backward_grad_input = ({ grad_input, grad_output, output }: { grad_input: CTensor; grad_output: CTensor; output: CTensor }): CTensor => {
  return addon.atg_sigmoid_backward_grad_input(grad_input, grad_output, output)
}

export const atg_logit_backward = ({ grad_output, self, eps }: { grad_output: CTensor; self: CTensor; eps?: number }): CTensor => {
  return addon.atg_logit_backward(grad_output, self, eps)
}

export const atg_logit_backward_grad_input = ({ grad_input, grad_output, self, eps }: { grad_input: CTensor; grad_output: CTensor; self: CTensor; eps?: number }): CTensor => {
  return addon.atg_logit_backward_grad_input(grad_input, grad_output, self, eps)
}

export const atg_tanh_backward = ({ grad_output, output }: { grad_output: CTensor; output: CTensor }): CTensor => {
  return addon.atg_tanh_backward(grad_output, output)
}

export const atg_tanh_backward_grad_input = ({ grad_input, grad_output, output }: { grad_input: CTensor; grad_output: CTensor; output: CTensor }): CTensor => {
  return addon.atg_tanh_backward_grad_input(grad_input, grad_output, output)
}

export const atg_slow_conv_transpose2d = ({ self, weight, kernel_size, bias, stride, padding, output_padding, dilation }: { self: CTensor; weight: CTensor; kernel_size: number[]; bias?: CTensor; stride: number[]; padding: number[]; output_padding: number[]; dilation: number[] }): CTensor => {
  return addon.atg_slow_conv_transpose2d(self, weight, kernel_size, bias, stride, padding, output_padding, dilation)
}

export const atg_slow_conv_transpose2d_out = ({ out, self, weight, kernel_size, bias, stride, padding, output_padding, dilation }: { out: CTensor; self: CTensor; weight: CTensor; kernel_size: number[]; bias?: CTensor; stride: number[]; padding: number[]; output_padding: number[]; dilation: number[] }): CTensor => {
  return addon.atg_slow_conv_transpose2d_out(out, self, weight, kernel_size, bias, stride, padding, output_padding, dilation)
}

export const atg_slow_conv_transpose3d = ({ self, weight, kernel_size, bias, stride, padding, output_padding, dilation }: { self: CTensor; weight: CTensor; kernel_size: number[]; bias?: CTensor; stride: number[]; padding: number[]; output_padding: number[]; dilation: number[] }): CTensor => {
  return addon.atg_slow_conv_transpose3d(self, weight, kernel_size, bias, stride, padding, output_padding, dilation)
}

export const atg_slow_conv_transpose3d_out = ({ out, self, weight, kernel_size, bias, stride, padding, output_padding, dilation }: { out: CTensor; self: CTensor; weight: CTensor; kernel_size: number[]; bias?: CTensor; stride: number[]; padding: number[]; output_padding: number[]; dilation: number[] }): CTensor => {
  return addon.atg_slow_conv_transpose3d_out(out, self, weight, kernel_size, bias, stride, padding, output_padding, dilation)
}

export const atg__slow_conv2d_backward = ({ grad_input, grad_weight, grad_bias, grad_output, self, weight, kernel_size, stride, padding }: { grad_input: CTensor; grad_weight: CTensor; grad_bias: CTensor; grad_output: CTensor; self: CTensor; weight: CTensor; kernel_size: number[]; stride: number[]; padding: number[] }): CTensor[] => {
  return addon.atg__slow_conv2d_backward(grad_input, grad_weight, grad_bias, grad_output, self, weight, kernel_size, stride, padding)
}

export const atg__conv_depthwise2d = ({ self, weight, kernel_size, bias, stride, padding, dilation }: { self: CTensor; weight: CTensor; kernel_size: number[]; bias?: CTensor; stride: number[]; padding: number[]; dilation: number[] }): CTensor => {
  return addon.atg__conv_depthwise2d(self, weight, kernel_size, bias, stride, padding, dilation)
}

export const atg__conv_depthwise2d_out = ({ out, self, weight, kernel_size, bias, stride, padding, dilation }: { out: CTensor; self: CTensor; weight: CTensor; kernel_size: number[]; bias?: CTensor; stride: number[]; padding: number[]; dilation: number[] }): CTensor => {
  return addon.atg__conv_depthwise2d_out(out, self, weight, kernel_size, bias, stride, padding, dilation)
}

export const atg_conv_depthwise3d = ({ self, weight, kernel_size, bias, stride, padding, dilation }: { self: CTensor; weight: CTensor; kernel_size: number[]; bias?: CTensor; stride: number[]; padding: number[]; dilation: number[] }): CTensor => {
  return addon.atg_conv_depthwise3d(self, weight, kernel_size, bias, stride, padding, dilation)
}

export const atg_conv_depthwise3d_out = ({ out, self, weight, kernel_size, bias, stride, padding, dilation }: { out: CTensor; self: CTensor; weight: CTensor; kernel_size: number[]; bias?: CTensor; stride: number[]; padding: number[]; dilation: number[] }): CTensor => {
  return addon.atg_conv_depthwise3d_out(out, self, weight, kernel_size, bias, stride, padding, dilation)
}

export const atg_slow_conv3d = ({ self, weight, kernel_size, bias, stride, padding }: { self: CTensor; weight: CTensor; kernel_size: number[]; bias?: CTensor; stride: number[]; padding: number[] }): CTensor => {
  return addon.atg_slow_conv3d(self, weight, kernel_size, bias, stride, padding)
}

export const atg_slow_conv3d_out = ({ out, self, weight, kernel_size, bias, stride, padding }: { out: CTensor; self: CTensor; weight: CTensor; kernel_size: number[]; bias?: CTensor; stride: number[]; padding: number[] }): CTensor => {
  return addon.atg_slow_conv3d_out(out, self, weight, kernel_size, bias, stride, padding)
}

export const atg_slow_conv_dilated2d = ({ self, weight, kernel_size, bias, stride, padding, dilation }: { self: CTensor; weight: CTensor; kernel_size: number[]; bias?: CTensor; stride: number[]; padding: number[]; dilation: number[] }): CTensor => {
  return addon.atg_slow_conv_dilated2d(self, weight, kernel_size, bias, stride, padding, dilation)
}

export const atg_slow_conv_dilated2d_out = ({ out, self, weight, kernel_size, bias, stride, padding, dilation }: { out: CTensor; self: CTensor; weight: CTensor; kernel_size: number[]; bias?: CTensor; stride: number[]; padding: number[]; dilation: number[] }): CTensor => {
  return addon.atg_slow_conv_dilated2d_out(out, self, weight, kernel_size, bias, stride, padding, dilation)
}

export const atg_slow_conv_dilated3d = ({ self, weight, kernel_size, bias, stride, padding, dilation }: { self: CTensor; weight: CTensor; kernel_size: number[]; bias?: CTensor; stride: number[]; padding: number[]; dilation: number[] }): CTensor => {
  return addon.atg_slow_conv_dilated3d(self, weight, kernel_size, bias, stride, padding, dilation)
}

export const atg_slow_conv_dilated3d_out = ({ out, self, weight, kernel_size, bias, stride, padding, dilation }: { out: CTensor; self: CTensor; weight: CTensor; kernel_size: number[]; bias?: CTensor; stride: number[]; padding: number[]; dilation: number[] }): CTensor => {
  return addon.atg_slow_conv_dilated3d_out(out, self, weight, kernel_size, bias, stride, padding, dilation)
}

export const atg_col2im = ({ self, output_size, kernel_size, dilation, padding, stride }: { self: CTensor; output_size: number[]; kernel_size: number[]; dilation: number[]; padding: number[]; stride: number[] }): CTensor => {
  return addon.atg_col2im(self, output_size, kernel_size, dilation, padding, stride)
}

export const atg_col2im_out = ({ out, self, output_size, kernel_size, dilation, padding, stride }: { out: CTensor; self: CTensor; output_size: number[]; kernel_size: number[]; dilation: number[]; padding: number[]; stride: number[] }): CTensor => {
  return addon.atg_col2im_out(out, self, output_size, kernel_size, dilation, padding, stride)
}

export const atg_column_stack = ({ tensors }: { tensors: CTensor[] }): CTensor => {
  return addon.atg_column_stack(tensors)
}

export const atg_column_stack_out = ({ out, tensors }: { out: CTensor; tensors: CTensor[] }): CTensor => {
  return addon.atg_column_stack_out(out, tensors)
}

export const atg_im2col = ({ self, kernel_size, dilation, padding, stride }: { self: CTensor; kernel_size: number[]; dilation: number[]; padding: number[]; stride: number[] }): CTensor => {
  return addon.atg_im2col(self, kernel_size, dilation, padding, stride)
}

export const atg_im2col_out = ({ out, self, kernel_size, dilation, padding, stride }: { out: CTensor; self: CTensor; kernel_size: number[]; dilation: number[]; padding: number[]; stride: number[] }): CTensor => {
  return addon.atg_im2col_out(out, self, kernel_size, dilation, padding, stride)
}

export const atg_isfinite = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_isfinite(self)
}

export const atg_isinf = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_isinf(self)
}

export const atg_isinf_out = ({ out, self }: { out: CTensor; self: CTensor }): CTensor => {
  return addon.atg_isinf_out(out, self)
}

export const atg_isposinf = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_isposinf(self)
}

export const atg_isposinf_out = ({ out, self }: { out: CTensor; self: CTensor }): CTensor => {
  return addon.atg_isposinf_out(out, self)
}

export const atg_isneginf = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_isneginf(self)
}

export const atg_isneginf_out = ({ out, self }: { out: CTensor; self: CTensor }): CTensor => {
  return addon.atg_isneginf_out(out, self)
}

export const atg__add_batch_dim = ({ self, batch_dim, level }: { self: CTensor; batch_dim: number; level: number }): CTensor => {
  return addon.atg__add_batch_dim(self, batch_dim, level)
}

export const atg__remove_batch_dim = ({ self, level, batch_size, out_dim }: { self: CTensor; level: number; batch_size: number; out_dim: number }): CTensor => {
  return addon.atg__remove_batch_dim(self, level, batch_size, out_dim)
}

export const atg_special_entr = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_special_entr(self)
}

export const atg_special_entr_out = ({ out, self }: { out: CTensor; self: CTensor }): CTensor => {
  return addon.atg_special_entr_out(out, self)
}

export const atg_special_ndtri = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_special_ndtri(self)
}

export const atg_special_ndtri_out = ({ out, self }: { out: CTensor; self: CTensor }): CTensor => {
  return addon.atg_special_ndtri_out(out, self)
}

export const atg_special_log_ndtr = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_special_log_ndtr(self)
}

export const atg_special_log_ndtr_out = ({ out, self }: { out: CTensor; self: CTensor }): CTensor => {
  return addon.atg_special_log_ndtr_out(out, self)
}

export const atg_special_expm1 = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_special_expm1(self)
}

export const atg_special_expm1_out = ({ out, self }: { out: CTensor; self: CTensor }): CTensor => {
  return addon.atg_special_expm1_out(out, self)
}

export const atg_special_exp2 = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_special_exp2(self)
}

export const atg_special_exp2_out = ({ out, self }: { out: CTensor; self: CTensor }): CTensor => {
  return addon.atg_special_exp2_out(out, self)
}

export const atg_special_psi = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_special_psi(self)
}

export const atg_special_psi_out = ({ out, self }: { out: CTensor; self: CTensor }): CTensor => {
  return addon.atg_special_psi_out(out, self)
}

export const atg_special_digamma = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_special_digamma(self)
}

export const atg_special_digamma_out = ({ out, self }: { out: CTensor; self: CTensor }): CTensor => {
  return addon.atg_special_digamma_out(out, self)
}

export const atg_special_gammaln = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_special_gammaln(self)
}

export const atg_special_gammaln_out = ({ out, self }: { out: CTensor; self: CTensor }): CTensor => {
  return addon.atg_special_gammaln_out(out, self)
}

export const atg_special_erf = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_special_erf(self)
}

export const atg_special_erf_out = ({ out, self }: { out: CTensor; self: CTensor }): CTensor => {
  return addon.atg_special_erf_out(out, self)
}

export const atg_special_erfc = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_special_erfc(self)
}

export const atg_special_erfc_out = ({ out, self }: { out: CTensor; self: CTensor }): CTensor => {
  return addon.atg_special_erfc_out(out, self)
}

export const atg_special_erfcx = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_special_erfcx(self)
}

export const atg_special_erfcx_out = ({ out, self }: { out: CTensor; self: CTensor }): CTensor => {
  return addon.atg_special_erfcx_out(out, self)
}

export const atg_special_erfinv = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_special_erfinv(self)
}

export const atg_special_erfinv_out = ({ out, self }: { out: CTensor; self: CTensor }): CTensor => {
  return addon.atg_special_erfinv_out(out, self)
}

export const atg_special_ndtr = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_special_ndtr(self)
}

export const atg_special_ndtr_out = ({ out, self }: { out: CTensor; self: CTensor }): CTensor => {
  return addon.atg_special_ndtr_out(out, self)
}

export const atg_special_xlog1py = ({ self, other }: { self: CTensor; other: CTensor }): CTensor => {
  return addon.atg_special_xlog1py(self, other)
}

export const atg_special_xlog1py_self_scalar = ({ self_scalar, other }: { self_scalar: CScalar; other: CTensor }): CTensor => {
  return addon.atg_special_xlog1py_self_scalar(self_scalar, other)
}

export const atg_special_xlog1py_other_scalar = ({ self, other }: { self: CTensor; other: CScalar }): CTensor => {
  return addon.atg_special_xlog1py_other_scalar(self, other)
}

export const atg_special_xlog1py_out = ({ out, self, other }: { out: CTensor; self: CTensor; other: CTensor }): CTensor => {
  return addon.atg_special_xlog1py_out(out, self, other)
}

export const atg_special_xlog1py_self_scalar_out = ({ out, self_scalar, other }: { out: CTensor; self_scalar: CScalar; other: CTensor }): CTensor => {
  return addon.atg_special_xlog1py_self_scalar_out(out, self_scalar, other)
}

export const atg_special_xlog1py_other_scalar_out = ({ out, self, other }: { out: CTensor; self: CTensor; other: CScalar }): CTensor => {
  return addon.atg_special_xlog1py_other_scalar_out(out, self, other)
}

export const atg_special_xlogy = ({ self, other }: { self: CTensor; other: CTensor }): CTensor => {
  return addon.atg_special_xlogy(self, other)
}

export const atg_special_xlogy_self_scalar = ({ self_scalar, other }: { self_scalar: CScalar; other: CTensor }): CTensor => {
  return addon.atg_special_xlogy_self_scalar(self_scalar, other)
}

export const atg_special_xlogy_other_scalar = ({ self, other }: { self: CTensor; other: CScalar }): CTensor => {
  return addon.atg_special_xlogy_other_scalar(self, other)
}

export const atg_special_xlogy_out = ({ out, self, other }: { out: CTensor; self: CTensor; other: CTensor }): CTensor => {
  return addon.atg_special_xlogy_out(out, self, other)
}

export const atg_special_xlogy_self_scalar_out = ({ out, self_scalar, other }: { out: CTensor; self_scalar: CScalar; other: CTensor }): CTensor => {
  return addon.atg_special_xlogy_self_scalar_out(out, self_scalar, other)
}

export const atg_special_xlogy_other_scalar_out = ({ out, self, other }: { out: CTensor; self: CTensor; other: CScalar }): CTensor => {
  return addon.atg_special_xlogy_other_scalar_out(out, self, other)
}

export const atg_special_zeta = ({ self, other }: { self: CTensor; other: CTensor }): CTensor => {
  return addon.atg_special_zeta(self, other)
}

export const atg_special_zeta_self_scalar = ({ self_scalar, other }: { self_scalar: CScalar; other: CTensor }): CTensor => {
  return addon.atg_special_zeta_self_scalar(self_scalar, other)
}

export const atg_special_zeta_other_scalar = ({ self, other }: { self: CTensor; other: CScalar }): CTensor => {
  return addon.atg_special_zeta_other_scalar(self, other)
}

export const atg_special_zeta_out = ({ out, self, other }: { out: CTensor; self: CTensor; other: CTensor }): CTensor => {
  return addon.atg_special_zeta_out(out, self, other)
}

export const atg_special_zeta_self_scalar_out = ({ out, self_scalar, other }: { out: CTensor; self_scalar: CScalar; other: CTensor }): CTensor => {
  return addon.atg_special_zeta_self_scalar_out(out, self_scalar, other)
}

export const atg_special_zeta_other_scalar_out = ({ out, self, other }: { out: CTensor; self: CTensor; other: CScalar }): CTensor => {
  return addon.atg_special_zeta_other_scalar_out(out, self, other)
}

export const atg_special_i0 = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_special_i0(self)
}

export const atg_special_i0_out = ({ out, self }: { out: CTensor; self: CTensor }): CTensor => {
  return addon.atg_special_i0_out(out, self)
}

export const atg_special_i0e = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_special_i0e(self)
}

export const atg_special_i0e_out = ({ out, self }: { out: CTensor; self: CTensor }): CTensor => {
  return addon.atg_special_i0e_out(out, self)
}

export const atg_special_i1 = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_special_i1(self)
}

export const atg_special_i1_out = ({ out, self }: { out: CTensor; self: CTensor }): CTensor => {
  return addon.atg_special_i1_out(out, self)
}

export const atg_special_i1e = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_special_i1e(self)
}

export const atg_special_i1e_out = ({ out, self }: { out: CTensor; self: CTensor }): CTensor => {
  return addon.atg_special_i1e_out(out, self)
}

export const atg_special_logit = ({ self, eps }: { self: CTensor; eps?: number }): CTensor => {
  return addon.atg_special_logit(self, eps)
}

export const atg_special_logit_out = ({ out, self, eps }: { out: CTensor; self: CTensor; eps?: number }): CTensor => {
  return addon.atg_special_logit_out(out, self, eps)
}

export const atg_special_polygamma = ({ n, self }: { n: number; self: CTensor }): CTensor => {
  return addon.atg_special_polygamma(n, self)
}

export const atg_special_polygamma_out = ({ out, n, self }: { out: CTensor; n: number; self: CTensor }): CTensor => {
  return addon.atg_special_polygamma_out(out, n, self)
}

export const atg_special_logsumexp = ({ self, dim, keepdim }: { self: CTensor; dim: number[]; keepdim: boolean }): CTensor => {
  return addon.atg_special_logsumexp(self, dim, keepdim)
}

export const atg_special_logsumexp_out = ({ out, self, dim, keepdim }: { out: CTensor; self: CTensor; dim: number[]; keepdim: boolean }): CTensor => {
  return addon.atg_special_logsumexp_out(out, self, dim, keepdim)
}

export const atg_special_expit = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_special_expit(self)
}

export const atg_special_expit_out = ({ out, self }: { out: CTensor; self: CTensor }): CTensor => {
  return addon.atg_special_expit_out(out, self)
}

export const atg_special_sinc = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_special_sinc(self)
}

export const atg_special_sinc_out = ({ out, self }: { out: CTensor; self: CTensor }): CTensor => {
  return addon.atg_special_sinc_out(out, self)
}

export const atg_special_round = ({ self, decimals }: { self: CTensor; decimals: number }): CTensor => {
  return addon.atg_special_round(self, decimals)
}

export const atg_special_round_out = ({ out, self, decimals }: { out: CTensor; self: CTensor; decimals: number }): CTensor => {
  return addon.atg_special_round_out(out, self, decimals)
}

export const atg_special_log1p = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_special_log1p(self)
}

export const atg_special_log1p_out = ({ out, self }: { out: CTensor; self: CTensor }): CTensor => {
  return addon.atg_special_log1p_out(out, self)
}

export const atg_special_log_softmax = ({ self, dim, dtype }: { self: CTensor; dim: number; dtype: number }): CTensor => {
  return addon.atg_special_log_softmax(self, dim, dtype)
}

export const atg_special_gammainc = ({ self, other }: { self: CTensor; other: CTensor }): CTensor => {
  return addon.atg_special_gammainc(self, other)
}

export const atg_special_gammainc_out = ({ out, self, other }: { out: CTensor; self: CTensor; other: CTensor }): CTensor => {
  return addon.atg_special_gammainc_out(out, self, other)
}

export const atg_special_gammaincc = ({ self, other }: { self: CTensor; other: CTensor }): CTensor => {
  return addon.atg_special_gammaincc(self, other)
}

export const atg_special_gammaincc_out = ({ out, self, other }: { out: CTensor; self: CTensor; other: CTensor }): CTensor => {
  return addon.atg_special_gammaincc_out(out, self, other)
}

export const atg_special_multigammaln = ({ self, p }: { self: CTensor; p: number }): CTensor => {
  return addon.atg_special_multigammaln(self, p)
}

export const atg_special_multigammaln_out = ({ out, self, p }: { out: CTensor; self: CTensor; p: number }): CTensor => {
  return addon.atg_special_multigammaln_out(out, self, p)
}

export const atg_special_softmax = ({ self, dim, dtype }: { self: CTensor; dim: number; dtype: number }): CTensor => {
  return addon.atg_special_softmax(self, dim, dtype)
}

export const atg_fft_fft = ({ self, n, dim, norm }: { self: CTensor; n?: number; dim: number; norm: string }): CTensor => {
  return addon.atg_fft_fft(self, n, dim, norm)
}

export const atg_fft_fft_out = ({ out, self, n, dim, norm }: { out: CTensor; self: CTensor; n?: number; dim: number; norm: string }): CTensor => {
  return addon.atg_fft_fft_out(out, self, n, dim, norm)
}

export const atg_fft_ifft = ({ self, n, dim, norm }: { self: CTensor; n?: number; dim: number; norm: string }): CTensor => {
  return addon.atg_fft_ifft(self, n, dim, norm)
}

export const atg_fft_ifft_out = ({ out, self, n, dim, norm }: { out: CTensor; self: CTensor; n?: number; dim: number; norm: string }): CTensor => {
  return addon.atg_fft_ifft_out(out, self, n, dim, norm)
}

export const atg_fft_rfft = ({ self, n, dim, norm }: { self: CTensor; n?: number; dim: number; norm: string }): CTensor => {
  return addon.atg_fft_rfft(self, n, dim, norm)
}

export const atg_fft_rfft_out = ({ out, self, n, dim, norm }: { out: CTensor; self: CTensor; n?: number; dim: number; norm: string }): CTensor => {
  return addon.atg_fft_rfft_out(out, self, n, dim, norm)
}

export const atg_fft_irfft = ({ self, n, dim, norm }: { self: CTensor; n?: number; dim: number; norm: string }): CTensor => {
  return addon.atg_fft_irfft(self, n, dim, norm)
}

export const atg_fft_irfft_out = ({ out, self, n, dim, norm }: { out: CTensor; self: CTensor; n?: number; dim: number; norm: string }): CTensor => {
  return addon.atg_fft_irfft_out(out, self, n, dim, norm)
}

export const atg_fft_hfft = ({ self, n, dim, norm }: { self: CTensor; n?: number; dim: number; norm: string }): CTensor => {
  return addon.atg_fft_hfft(self, n, dim, norm)
}

export const atg_fft_hfft_out = ({ out, self, n, dim, norm }: { out: CTensor; self: CTensor; n?: number; dim: number; norm: string }): CTensor => {
  return addon.atg_fft_hfft_out(out, self, n, dim, norm)
}

export const atg_fft_ihfft = ({ self, n, dim, norm }: { self: CTensor; n?: number; dim: number; norm: string }): CTensor => {
  return addon.atg_fft_ihfft(self, n, dim, norm)
}

export const atg_fft_ihfft_out = ({ out, self, n, dim, norm }: { out: CTensor; self: CTensor; n?: number; dim: number; norm: string }): CTensor => {
  return addon.atg_fft_ihfft_out(out, self, n, dim, norm)
}

export const atg_fft_fft2 = ({ self, s, dim, norm }: { self: CTensor; s?: number[]; dim: number[]; norm: string }): CTensor => {
  return addon.atg_fft_fft2(self, s, dim, norm)
}

export const atg_fft_fft2_out = ({ out, self, s, dim, norm }: { out: CTensor; self: CTensor; s?: number[]; dim: number[]; norm: string }): CTensor => {
  return addon.atg_fft_fft2_out(out, self, s, dim, norm)
}

export const atg_fft_ifft2 = ({ self, s, dim, norm }: { self: CTensor; s?: number[]; dim: number[]; norm: string }): CTensor => {
  return addon.atg_fft_ifft2(self, s, dim, norm)
}

export const atg_fft_ifft2_out = ({ out, self, s, dim, norm }: { out: CTensor; self: CTensor; s?: number[]; dim: number[]; norm: string }): CTensor => {
  return addon.atg_fft_ifft2_out(out, self, s, dim, norm)
}

export const atg_fft_rfft2 = ({ self, s, dim, norm }: { self: CTensor; s?: number[]; dim: number[]; norm: string }): CTensor => {
  return addon.atg_fft_rfft2(self, s, dim, norm)
}

export const atg_fft_rfft2_out = ({ out, self, s, dim, norm }: { out: CTensor; self: CTensor; s?: number[]; dim: number[]; norm: string }): CTensor => {
  return addon.atg_fft_rfft2_out(out, self, s, dim, norm)
}

export const atg_fft_irfft2 = ({ self, s, dim, norm }: { self: CTensor; s?: number[]; dim: number[]; norm: string }): CTensor => {
  return addon.atg_fft_irfft2(self, s, dim, norm)
}

export const atg_fft_irfft2_out = ({ out, self, s, dim, norm }: { out: CTensor; self: CTensor; s?: number[]; dim: number[]; norm: string }): CTensor => {
  return addon.atg_fft_irfft2_out(out, self, s, dim, norm)
}

export const atg_fft_hfft2 = ({ self, s, dim, norm }: { self: CTensor; s?: number[]; dim: number[]; norm: string }): CTensor => {
  return addon.atg_fft_hfft2(self, s, dim, norm)
}

export const atg_fft_hfft2_out = ({ out, self, s, dim, norm }: { out: CTensor; self: CTensor; s?: number[]; dim: number[]; norm: string }): CTensor => {
  return addon.atg_fft_hfft2_out(out, self, s, dim, norm)
}

export const atg_fft_ihfft2 = ({ self, s, dim, norm }: { self: CTensor; s?: number[]; dim: number[]; norm: string }): CTensor => {
  return addon.atg_fft_ihfft2(self, s, dim, norm)
}

export const atg_fft_ihfft2_out = ({ out, self, s, dim, norm }: { out: CTensor; self: CTensor; s?: number[]; dim: number[]; norm: string }): CTensor => {
  return addon.atg_fft_ihfft2_out(out, self, s, dim, norm)
}

export const atg_fft_fftn = ({ self, s, dim, norm }: { self: CTensor; s?: number[]; dim?: number[]; norm: string }): CTensor => {
  return addon.atg_fft_fftn(self, s, dim, norm)
}

export const atg_fft_fftn_out = ({ out, self, s, dim, norm }: { out: CTensor; self: CTensor; s?: number[]; dim?: number[]; norm: string }): CTensor => {
  return addon.atg_fft_fftn_out(out, self, s, dim, norm)
}

export const atg_fft_ifftn = ({ self, s, dim, norm }: { self: CTensor; s?: number[]; dim?: number[]; norm: string }): CTensor => {
  return addon.atg_fft_ifftn(self, s, dim, norm)
}

export const atg_fft_ifftn_out = ({ out, self, s, dim, norm }: { out: CTensor; self: CTensor; s?: number[]; dim?: number[]; norm: string }): CTensor => {
  return addon.atg_fft_ifftn_out(out, self, s, dim, norm)
}

export const atg_fft_rfftn = ({ self, s, dim, norm }: { self: CTensor; s?: number[]; dim?: number[]; norm: string }): CTensor => {
  return addon.atg_fft_rfftn(self, s, dim, norm)
}

export const atg_fft_rfftn_out = ({ out, self, s, dim, norm }: { out: CTensor; self: CTensor; s?: number[]; dim?: number[]; norm: string }): CTensor => {
  return addon.atg_fft_rfftn_out(out, self, s, dim, norm)
}

export const atg_fft_irfftn = ({ self, s, dim, norm }: { self: CTensor; s?: number[]; dim?: number[]; norm: string }): CTensor => {
  return addon.atg_fft_irfftn(self, s, dim, norm)
}

export const atg_fft_irfftn_out = ({ out, self, s, dim, norm }: { out: CTensor; self: CTensor; s?: number[]; dim?: number[]; norm: string }): CTensor => {
  return addon.atg_fft_irfftn_out(out, self, s, dim, norm)
}

export const atg_fft_hfftn = ({ self, s, dim, norm }: { self: CTensor; s?: number[]; dim?: number[]; norm: string }): CTensor => {
  return addon.atg_fft_hfftn(self, s, dim, norm)
}

export const atg_fft_hfftn_out = ({ out, self, s, dim, norm }: { out: CTensor; self: CTensor; s?: number[]; dim?: number[]; norm: string }): CTensor => {
  return addon.atg_fft_hfftn_out(out, self, s, dim, norm)
}

export const atg_fft_ihfftn = ({ self, s, dim, norm }: { self: CTensor; s?: number[]; dim?: number[]; norm: string }): CTensor => {
  return addon.atg_fft_ihfftn(self, s, dim, norm)
}

export const atg_fft_ihfftn_out = ({ out, self, s, dim, norm }: { out: CTensor; self: CTensor; s?: number[]; dim?: number[]; norm: string }): CTensor => {
  return addon.atg_fft_ihfftn_out(out, self, s, dim, norm)
}

export const atg_fft_fftfreq = ({ n, d, options }: { n: number; d: number; options: { device: number, dtype: number } }): CTensor => {
  return addon.atg_fft_fftfreq(n, d, options)
}

export const atg_fft_fftfreq_out = ({ out, n, d }: { out: CTensor; n: number; d: number }): CTensor => {
  return addon.atg_fft_fftfreq_out(out, n, d)
}

export const atg_fft_rfftfreq = ({ n, d, options }: { n: number; d: number; options: { device: number, dtype: number } }): CTensor => {
  return addon.atg_fft_rfftfreq(n, d, options)
}

export const atg_fft_rfftfreq_out = ({ out, n, d }: { out: CTensor; n: number; d: number }): CTensor => {
  return addon.atg_fft_rfftfreq_out(out, n, d)
}

export const atg_fft_fftshift = ({ self, dim }: { self: CTensor; dim?: number[] }): CTensor => {
  return addon.atg_fft_fftshift(self, dim)
}

export const atg_fft_ifftshift = ({ self, dim }: { self: CTensor; dim?: number[] }): CTensor => {
  return addon.atg_fft_ifftshift(self, dim)
}

export const atg_linalg_cholesky_ex = ({ self, upper, check_errors }: { self: CTensor; upper: boolean; check_errors: boolean }): CTensor[] => {
  return addon.atg_linalg_cholesky_ex(self, upper, check_errors)
}

export const atg_linalg_cholesky_ex_l = ({ L, info, self, upper, check_errors }: { L: CTensor; info: CTensor; self: CTensor; upper: boolean; check_errors: boolean }): CTensor[] => {
  return addon.atg_linalg_cholesky_ex_l(L, info, self, upper, check_errors)
}

export const atg_linalg_cholesky = ({ self, upper }: { self: CTensor; upper: boolean }): CTensor => {
  return addon.atg_linalg_cholesky(self, upper)
}

export const atg_linalg_cholesky_out = ({ out, self, upper }: { out: CTensor; self: CTensor; upper: boolean }): CTensor => {
  return addon.atg_linalg_cholesky_out(out, self, upper)
}

export const atg_linalg_cross = ({ self, other, dim }: { self: CTensor; other: CTensor; dim: number }): CTensor => {
  return addon.atg_linalg_cross(self, other, dim)
}

export const atg_linalg_cross_out = ({ out, self, other, dim }: { out: CTensor; self: CTensor; other: CTensor; dim: number }): CTensor => {
  return addon.atg_linalg_cross_out(out, self, other, dim)
}

export const atg_linalg_lu_factor = ({ A, pivot }: { A: CTensor; pivot: boolean }): CTensor[] => {
  return addon.atg_linalg_lu_factor(A, pivot)
}

export const atg_linalg_lu_factor_out = ({ LU, pivots, A, pivot }: { LU: CTensor; pivots: CTensor; A: CTensor; pivot: boolean }): CTensor[] => {
  return addon.atg_linalg_lu_factor_out(LU, pivots, A, pivot)
}

export const atg_linalg_lu_factor_ex = ({ A, pivot, check_errors }: { A: CTensor; pivot: boolean; check_errors: boolean }): CTensor[] => {
  return addon.atg_linalg_lu_factor_ex(A, pivot, check_errors)
}

export const atg_linalg_lu_factor_ex_out = ({ LU, pivots, info, A, pivot, check_errors }: { LU: CTensor; pivots: CTensor; info: CTensor; A: CTensor; pivot: boolean; check_errors: boolean }): CTensor[] => {
  return addon.atg_linalg_lu_factor_ex_out(LU, pivots, info, A, pivot, check_errors)
}

export const atg_linalg_lu = ({ A, pivot }: { A: CTensor; pivot: boolean }): CTensor[] => {
  return addon.atg_linalg_lu(A, pivot)
}

export const atg_linalg_lu_out = ({ P, L, U, A, pivot }: { P: CTensor; L: CTensor; U: CTensor; A: CTensor; pivot: boolean }): CTensor[] => {
  return addon.atg_linalg_lu_out(P, L, U, A, pivot)
}

export const atg_linalg_lu_solve = ({ LU, pivots, B, left, adjoint }: { LU: CTensor; pivots: CTensor; B: CTensor; left: boolean; adjoint: boolean }): CTensor => {
  return addon.atg_linalg_lu_solve(LU, pivots, B, left, adjoint)
}

export const atg_linalg_lu_solve_out = ({ out, LU, pivots, B, left, adjoint }: { out: CTensor; LU: CTensor; pivots: CTensor; B: CTensor; left: boolean; adjoint: boolean }): CTensor => {
  return addon.atg_linalg_lu_solve_out(out, LU, pivots, B, left, adjoint)
}

export const atg__linalg_det = ({ A }: { A: CTensor }): CTensor[] => {
  return addon.atg__linalg_det(A)
}

export const atg__linalg_det_result = ({ result, LU, pivots, A }: { result: CTensor; LU: CTensor; pivots: CTensor; A: CTensor }): CTensor[] => {
  return addon.atg__linalg_det_result(result, LU, pivots, A)
}

export const atg_linalg_det = ({ A }: { A: CTensor }): CTensor => {
  return addon.atg_linalg_det(A)
}

export const atg_linalg_det_out = ({ out, A }: { out: CTensor; A: CTensor }): CTensor => {
  return addon.atg_linalg_det_out(out, A)
}

export const atg_det = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_det(self)
}

export const atg_linalg_ldl_factor_ex = ({ self, hermitian, check_errors }: { self: CTensor; hermitian: boolean; check_errors: boolean }): CTensor[] => {
  return addon.atg_linalg_ldl_factor_ex(self, hermitian, check_errors)
}

export const atg_linalg_ldl_factor_ex_out = ({ LD, pivots, info, self, hermitian, check_errors }: { LD: CTensor; pivots: CTensor; info: CTensor; self: CTensor; hermitian: boolean; check_errors: boolean }): CTensor[] => {
  return addon.atg_linalg_ldl_factor_ex_out(LD, pivots, info, self, hermitian, check_errors)
}

export const atg_linalg_ldl_factor = ({ self, hermitian }: { self: CTensor; hermitian: boolean }): CTensor[] => {
  return addon.atg_linalg_ldl_factor(self, hermitian)
}

export const atg_linalg_ldl_factor_out = ({ LD, pivots, self, hermitian }: { LD: CTensor; pivots: CTensor; self: CTensor; hermitian: boolean }): CTensor[] => {
  return addon.atg_linalg_ldl_factor_out(LD, pivots, self, hermitian)
}

export const atg_linalg_ldl_solve = ({ LD, pivots, B, hermitian }: { LD: CTensor; pivots: CTensor; B: CTensor; hermitian: boolean }): CTensor => {
  return addon.atg_linalg_ldl_solve(LD, pivots, B, hermitian)
}

export const atg_linalg_ldl_solve_out = ({ out, LD, pivots, B, hermitian }: { out: CTensor; LD: CTensor; pivots: CTensor; B: CTensor; hermitian: boolean }): CTensor => {
  return addon.atg_linalg_ldl_solve_out(out, LD, pivots, B, hermitian)
}

export const atg_linalg_lstsq = ({ self, b, rcond, driver }: { self: CTensor; b: CTensor; rcond?: number; driver: string }): CTensor[] => {
  return addon.atg_linalg_lstsq(self, b, rcond, driver)
}

export const atg_linalg_lstsq_out = ({ solution, residuals, rank, singular_values, self, b, rcond, driver }: { solution: CTensor; residuals: CTensor; rank: CTensor; singular_values: CTensor; self: CTensor; b: CTensor; rcond?: number; driver: string }): CTensor[] => {
  return addon.atg_linalg_lstsq_out(solution, residuals, rank, singular_values, self, b, rcond, driver)
}

export const atg_linalg_matmul = ({ self, other }: { self: CTensor; other: CTensor }): CTensor => {
  return addon.atg_linalg_matmul(self, other)
}

export const atg_linalg_matmul_out = ({ out, self, other }: { out: CTensor; self: CTensor; other: CTensor }): CTensor => {
  return addon.atg_linalg_matmul_out(out, self, other)
}

export const atg_linalg_vecdot = ({ x, y, dim }: { x: CTensor; y: CTensor; dim: number }): CTensor => {
  return addon.atg_linalg_vecdot(x, y, dim)
}

export const atg_linalg_vecdot_out = ({ out, x, y, dim }: { out: CTensor; x: CTensor; y: CTensor; dim: number }): CTensor => {
  return addon.atg_linalg_vecdot_out(out, x, y, dim)
}

export const atg_linalg_matrix_exp = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_linalg_matrix_exp(self)
}

export const atg_linalg_matrix_exp_out = ({ out, self }: { out: CTensor; self: CTensor }): CTensor => {
  return addon.atg_linalg_matrix_exp_out(out, self)
}

export const atg__linalg_slogdet = ({ A }: { A: CTensor }): CTensor[] => {
  return addon.atg__linalg_slogdet(A)
}

export const atg__linalg_slogdet_sign = ({ sign, logabsdet, LU, pivots, A }: { sign: CTensor; logabsdet: CTensor; LU: CTensor; pivots: CTensor; A: CTensor }): CTensor[] => {
  return addon.atg__linalg_slogdet_sign(sign, logabsdet, LU, pivots, A)
}

export const atg_linalg_slogdet = ({ A }: { A: CTensor }): CTensor[] => {
  return addon.atg_linalg_slogdet(A)
}

export const atg_linalg_slogdet_out = ({ sign, logabsdet, A }: { sign: CTensor; logabsdet: CTensor; A: CTensor }): CTensor[] => {
  return addon.atg_linalg_slogdet_out(sign, logabsdet, A)
}

export const atg_slogdet = ({ self }: { self: CTensor }): CTensor[] => {
  return addon.atg_slogdet(self)
}

export const atg_slogdet_out = ({ sign, logabsdet, self }: { sign: CTensor; logabsdet: CTensor; self: CTensor }): CTensor[] => {
  return addon.atg_slogdet_out(sign, logabsdet, self)
}

export const atg_logdet = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_logdet(self)
}

export const atg_linalg_eig = ({ self }: { self: CTensor }): CTensor[] => {
  return addon.atg_linalg_eig(self)
}

export const atg_linalg_eig_out = ({ eigenvalues, eigenvectors, self }: { eigenvalues: CTensor; eigenvectors: CTensor; self: CTensor }): CTensor[] => {
  return addon.atg_linalg_eig_out(eigenvalues, eigenvectors, self)
}

export const atg_linalg_eigvals = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_linalg_eigvals(self)
}

export const atg_linalg_eigvals_out = ({ out, self }: { out: CTensor; self: CTensor }): CTensor => {
  return addon.atg_linalg_eigvals_out(out, self)
}

export const atg__linalg_eigh = ({ A, UPLO, compute_v }: { A: CTensor; UPLO: string; compute_v: boolean }): CTensor[] => {
  return addon.atg__linalg_eigh(A, UPLO, compute_v)
}

export const atg__linalg_eigh_eigenvalues = ({ eigenvalues, eigenvectors, A, UPLO, compute_v }: { eigenvalues: CTensor; eigenvectors: CTensor; A: CTensor; UPLO: string; compute_v: boolean }): CTensor[] => {
  return addon.atg__linalg_eigh_eigenvalues(eigenvalues, eigenvectors, A, UPLO, compute_v)
}

export const atg_linalg_eigh = ({ self, UPLO }: { self: CTensor; UPLO: string }): CTensor[] => {
  return addon.atg_linalg_eigh(self, UPLO)
}

export const atg_linalg_eigh_eigvals = ({ eigvals, eigvecs, self, UPLO }: { eigvals: CTensor; eigvecs: CTensor; self: CTensor; UPLO: string }): CTensor[] => {
  return addon.atg_linalg_eigh_eigvals(eigvals, eigvecs, self, UPLO)
}

export const atg_linalg_eigvalsh = ({ self, UPLO }: { self: CTensor; UPLO: string }): CTensor => {
  return addon.atg_linalg_eigvalsh(self, UPLO)
}

export const atg_linalg_eigvalsh_out = ({ out, self, UPLO }: { out: CTensor; self: CTensor; UPLO: string }): CTensor => {
  return addon.atg_linalg_eigvalsh_out(out, self, UPLO)
}

export const atg_linalg_householder_product = ({ input, tau }: { input: CTensor; tau: CTensor }): CTensor => {
  return addon.atg_linalg_householder_product(input, tau)
}

export const atg_linalg_householder_product_out = ({ out, input, tau }: { out: CTensor; input: CTensor; tau: CTensor }): CTensor => {
  return addon.atg_linalg_householder_product_out(out, input, tau)
}

export const atg_linalg_inv_ex = ({ A, check_errors }: { A: CTensor; check_errors: boolean }): CTensor[] => {
  return addon.atg_linalg_inv_ex(A, check_errors)
}

export const atg_linalg_inv_ex_inverse = ({ inverse, info, A, check_errors }: { inverse: CTensor; info: CTensor; A: CTensor; check_errors: boolean }): CTensor[] => {
  return addon.atg_linalg_inv_ex_inverse(inverse, info, A, check_errors)
}

export const atg_linalg_inv = ({ A }: { A: CTensor }): CTensor => {
  return addon.atg_linalg_inv(A)
}

export const atg_linalg_inv_out = ({ out, A }: { out: CTensor; A: CTensor }): CTensor => {
  return addon.atg_linalg_inv_out(out, A)
}

export const atg_inverse = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_inverse(self)
}

export const atg_inverse_out = ({ out, self }: { out: CTensor; self: CTensor }): CTensor => {
  return addon.atg_inverse_out(out, self)
}

export const atg_inner = ({ self, other }: { self: CTensor; other: CTensor }): CTensor => {
  return addon.atg_inner(self, other)
}

export const atg_inner_out = ({ out, self, other }: { out: CTensor; self: CTensor; other: CTensor }): CTensor => {
  return addon.atg_inner_out(out, self, other)
}

export const atg_outer = ({ self, vec2 }: { self: CTensor; vec2: CTensor }): CTensor => {
  return addon.atg_outer(self, vec2)
}

export const atg_outer_out = ({ out, self, vec2 }: { out: CTensor; self: CTensor; vec2: CTensor }): CTensor => {
  return addon.atg_outer_out(out, self, vec2)
}

export const atg_ger = ({ self, vec2 }: { self: CTensor; vec2: CTensor }): CTensor => {
  return addon.atg_ger(self, vec2)
}

export const atg_ger_out = ({ out, self, vec2 }: { out: CTensor; self: CTensor; vec2: CTensor }): CTensor => {
  return addon.atg_ger_out(out, self, vec2)
}

export const atg_linalg_norm = ({ self, ord, dim, keepdim, dtype }: { self: CTensor; ord: CScalar; dim?: number[]; keepdim: boolean; dtype: number }): CTensor => {
  return addon.atg_linalg_norm(self, ord, dim, keepdim, dtype)
}

export const atg_linalg_norm_ord_str = ({ self, ord, dim, keepdim, dtype }: { self: CTensor; ord: string; dim?: number[]; keepdim: boolean; dtype: number }): CTensor => {
  return addon.atg_linalg_norm_ord_str(self, ord, dim, keepdim, dtype)
}

export const atg_linalg_norm_out = ({ out, self, ord, dim, keepdim, dtype }: { out: CTensor; self: CTensor; ord: CScalar; dim?: number[]; keepdim: boolean; dtype: number }): CTensor => {
  return addon.atg_linalg_norm_out(out, self, ord, dim, keepdim, dtype)
}

export const atg_linalg_norm_ord_str_out = ({ out, self, ord, dim, keepdim, dtype }: { out: CTensor; self: CTensor; ord: string; dim?: number[]; keepdim: boolean; dtype: number }): CTensor => {
  return addon.atg_linalg_norm_ord_str_out(out, self, ord, dim, keepdim, dtype)
}

export const atg__linalg_svd = ({ A, full_matrices, compute_uv, driver }: { A: CTensor; full_matrices: boolean; compute_uv: boolean; driver: string }): CTensor[] => {
  return addon.atg__linalg_svd(A, full_matrices, compute_uv, driver)
}

export const atg__linalg_svd_u = ({ U, S, Vh, A, full_matrices, compute_uv, driver }: { U: CTensor; S: CTensor; Vh: CTensor; A: CTensor; full_matrices: boolean; compute_uv: boolean; driver: string }): CTensor[] => {
  return addon.atg__linalg_svd_u(U, S, Vh, A, full_matrices, compute_uv, driver)
}

export const atg_linalg_svd = ({ A, full_matrices, driver }: { A: CTensor; full_matrices: boolean; driver: string }): CTensor[] => {
  return addon.atg_linalg_svd(A, full_matrices, driver)
}

export const atg_linalg_svd_u = ({ U, S, Vh, A, full_matrices, driver }: { U: CTensor; S: CTensor; Vh: CTensor; A: CTensor; full_matrices: boolean; driver: string }): CTensor[] => {
  return addon.atg_linalg_svd_u(U, S, Vh, A, full_matrices, driver)
}

export const atg_linalg_svdvals = ({ A, driver }: { A: CTensor; driver: string }): CTensor => {
  return addon.atg_linalg_svdvals(A, driver)
}

export const atg_linalg_svdvals_out = ({ out, A, driver }: { out: CTensor; A: CTensor; driver: string }): CTensor => {
  return addon.atg_linalg_svdvals_out(out, A, driver)
}

export const atg_linalg_cond = ({ self, p }: { self: CTensor; p: CScalar }): CTensor => {
  return addon.atg_linalg_cond(self, p)
}

export const atg_linalg_cond_p_str = ({ self, p }: { self: CTensor; p: string }): CTensor => {
  return addon.atg_linalg_cond_p_str(self, p)
}

export const atg_linalg_cond_out = ({ out, self, p }: { out: CTensor; self: CTensor; p: CScalar }): CTensor => {
  return addon.atg_linalg_cond_out(out, self, p)
}

export const atg_linalg_cond_p_str_out = ({ out, self, p }: { out: CTensor; self: CTensor; p: string }): CTensor => {
  return addon.atg_linalg_cond_p_str_out(out, self, p)
}

export const atg_linalg_pinv = ({ self, rcond, hermitian }: { self: CTensor; rcond: number; hermitian: boolean }): CTensor => {
  return addon.atg_linalg_pinv(self, rcond, hermitian)
}

export const atg_linalg_pinv_rcond_tensor = ({ self, rcond, hermitian }: { self: CTensor; rcond: CTensor; hermitian: boolean }): CTensor => {
  return addon.atg_linalg_pinv_rcond_tensor(self, rcond, hermitian)
}

export const atg_linalg_pinv_atol_rtol_tensor = ({ self, atol, rtol, hermitian }: { self: CTensor; atol?: CTensor; rtol?: CTensor; hermitian: boolean }): CTensor => {
  return addon.atg_linalg_pinv_atol_rtol_tensor(self, atol, rtol, hermitian)
}

export const atg_linalg_pinv_atol_rtol_float = ({ self, atol, rtol, hermitian }: { self: CTensor; atol?: number; rtol?: number; hermitian: boolean }): CTensor => {
  return addon.atg_linalg_pinv_atol_rtol_float(self, atol, rtol, hermitian)
}

export const atg_linalg_pinv_out = ({ out, self, rcond, hermitian }: { out: CTensor; self: CTensor; rcond: number; hermitian: boolean }): CTensor => {
  return addon.atg_linalg_pinv_out(out, self, rcond, hermitian)
}

export const atg_linalg_pinv_out_rcond_tensor = ({ out, self, rcond, hermitian }: { out: CTensor; self: CTensor; rcond: CTensor; hermitian: boolean }): CTensor => {
  return addon.atg_linalg_pinv_out_rcond_tensor(out, self, rcond, hermitian)
}

export const atg_linalg_pinv_atol_rtol_tensor_out = ({ out, self, atol, rtol, hermitian }: { out: CTensor; self: CTensor; atol?: CTensor; rtol?: CTensor; hermitian: boolean }): CTensor => {
  return addon.atg_linalg_pinv_atol_rtol_tensor_out(out, self, atol, rtol, hermitian)
}

export const atg_linalg_pinv_atol_rtol_float_out = ({ out, self, atol, rtol, hermitian }: { out: CTensor; self: CTensor; atol?: number; rtol?: number; hermitian: boolean }): CTensor => {
  return addon.atg_linalg_pinv_atol_rtol_float_out(out, self, atol, rtol, hermitian)
}

export const atg__linalg_solve_ex = ({ A, B, left, check_errors }: { A: CTensor; B: CTensor; left: boolean; check_errors: boolean }): CTensor[] => {
  return addon.atg__linalg_solve_ex(A, B, left, check_errors)
}

export const atg__linalg_solve_ex_result = ({ result, LU, pivots, info, A, B, left, check_errors }: { result: CTensor; LU: CTensor; pivots: CTensor; info: CTensor; A: CTensor; B: CTensor; left: boolean; check_errors: boolean }): CTensor[] => {
  return addon.atg__linalg_solve_ex_result(result, LU, pivots, info, A, B, left, check_errors)
}

export const atg_linalg_solve_ex = ({ A, B, left, check_errors }: { A: CTensor; B: CTensor; left: boolean; check_errors: boolean }): CTensor[] => {
  return addon.atg_linalg_solve_ex(A, B, left, check_errors)
}

export const atg_linalg_solve_ex_out = ({ result, info, A, B, left, check_errors }: { result: CTensor; info: CTensor; A: CTensor; B: CTensor; left: boolean; check_errors: boolean }): CTensor[] => {
  return addon.atg_linalg_solve_ex_out(result, info, A, B, left, check_errors)
}

export const atg_linalg_solve = ({ A, B, left }: { A: CTensor; B: CTensor; left: boolean }): CTensor => {
  return addon.atg_linalg_solve(A, B, left)
}

export const atg_linalg_solve_out = ({ out, A, B, left }: { out: CTensor; A: CTensor; B: CTensor; left: boolean }): CTensor => {
  return addon.atg_linalg_solve_out(out, A, B, left)
}

export const atg_linalg_tensorinv = ({ self, ind }: { self: CTensor; ind: number }): CTensor => {
  return addon.atg_linalg_tensorinv(self, ind)
}

export const atg_linalg_tensorinv_out = ({ out, self, ind }: { out: CTensor; self: CTensor; ind: number }): CTensor => {
  return addon.atg_linalg_tensorinv_out(out, self, ind)
}

export const atg_linalg_tensorsolve = ({ self, other, dims }: { self: CTensor; other: CTensor; dims?: number[] }): CTensor => {
  return addon.atg_linalg_tensorsolve(self, other, dims)
}

export const atg_linalg_tensorsolve_out = ({ out, self, other, dims }: { out: CTensor; self: CTensor; other: CTensor; dims?: number[] }): CTensor => {
  return addon.atg_linalg_tensorsolve_out(out, self, other, dims)
}

export const atg_linalg_qr = ({ A, mode }: { A: CTensor; mode: string }): CTensor[] => {
  return addon.atg_linalg_qr(A, mode)
}

export const atg_linalg_qr_out = ({ Q, R, A, mode }: { Q: CTensor; R: CTensor; A: CTensor; mode: string }): CTensor[] => {
  return addon.atg_linalg_qr_out(Q, R, A, mode)
}

export const atg_linalg_matrix_power = ({ self, n }: { self: CTensor; n: number }): CTensor => {
  return addon.atg_linalg_matrix_power(self, n)
}

export const atg_linalg_matrix_power_out = ({ out, self, n }: { out: CTensor; self: CTensor; n: number }): CTensor => {
  return addon.atg_linalg_matrix_power_out(out, self, n)
}

export const atg_linalg_matrix_rank = ({ self, tol, hermitian }: { self: CTensor; tol: number; hermitian: boolean }): CTensor => {
  return addon.atg_linalg_matrix_rank(self, tol, hermitian)
}

export const atg_linalg_matrix_rank_tol_tensor = ({ input, tol, hermitian }: { input: CTensor; tol: CTensor; hermitian: boolean }): CTensor => {
  return addon.atg_linalg_matrix_rank_tol_tensor(input, tol, hermitian)
}

export const atg_linalg_matrix_rank_atol_rtol_tensor = ({ input, atol, rtol, hermitian }: { input: CTensor; atol?: CTensor; rtol?: CTensor; hermitian: boolean }): CTensor => {
  return addon.atg_linalg_matrix_rank_atol_rtol_tensor(input, atol, rtol, hermitian)
}

export const atg_linalg_matrix_rank_atol_rtol_float = ({ self, atol, rtol, hermitian }: { self: CTensor; atol?: number; rtol?: number; hermitian: boolean }): CTensor => {
  return addon.atg_linalg_matrix_rank_atol_rtol_float(self, atol, rtol, hermitian)
}

export const atg_linalg_matrix_rank_out = ({ out, self, tol, hermitian }: { out: CTensor; self: CTensor; tol: number; hermitian: boolean }): CTensor => {
  return addon.atg_linalg_matrix_rank_out(out, self, tol, hermitian)
}

export const atg_linalg_matrix_rank_out_tol_tensor = ({ out, input, tol, hermitian }: { out: CTensor; input: CTensor; tol: CTensor; hermitian: boolean }): CTensor => {
  return addon.atg_linalg_matrix_rank_out_tol_tensor(out, input, tol, hermitian)
}

export const atg_linalg_matrix_rank_atol_rtol_tensor_out = ({ out, input, atol, rtol, hermitian }: { out: CTensor; input: CTensor; atol?: CTensor; rtol?: CTensor; hermitian: boolean }): CTensor => {
  return addon.atg_linalg_matrix_rank_atol_rtol_tensor_out(out, input, atol, rtol, hermitian)
}

export const atg_linalg_matrix_rank_atol_rtol_float_out = ({ out, self, atol, rtol, hermitian }: { out: CTensor; self: CTensor; atol?: number; rtol?: number; hermitian: boolean }): CTensor => {
  return addon.atg_linalg_matrix_rank_atol_rtol_float_out(out, self, atol, rtol, hermitian)
}

export const atg_linalg_multi_dot = ({ tensors }: { tensors: CTensor[] }): CTensor => {
  return addon.atg_linalg_multi_dot(tensors)
}

export const atg_linalg_multi_dot_out = ({ out, tensors }: { out: CTensor; tensors: CTensor[] }): CTensor => {
  return addon.atg_linalg_multi_dot_out(out, tensors)
}

export const atg_nested_to_padded_tensor = ({ self, padding, output_size }: { self: CTensor; padding: number; output_size?: number[] }): CTensor => {
  return addon.atg_nested_to_padded_tensor(self, padding, output_size)
}

export const atg__test_serialization_subcmul = ({ self, other, alpha }: { self: CTensor; other: CTensor; alpha: CScalar }): CTensor => {
  return addon.atg__test_serialization_subcmul(self, other, alpha)
}

export const atg__test_optional_intlist = ({ values, addends }: { values: CTensor; addends?: number[] }): CTensor => {
  return addon.atg__test_optional_intlist(values, addends)
}

export const atg__test_optional_intlist_out = ({ out, values, addends }: { out: CTensor; values: CTensor; addends?: number[] }): CTensor => {
  return addon.atg__test_optional_intlist_out(out, values, addends)
}

export const atg__test_optional_filled_intlist = ({ values, addends }: { values: CTensor; addends?: number[] }): CTensor => {
  return addon.atg__test_optional_filled_intlist(values, addends)
}

export const atg__test_optional_filled_intlist_out = ({ out, values, addends }: { out: CTensor; values: CTensor; addends?: number[] }): CTensor => {
  return addon.atg__test_optional_filled_intlist_out(out, values, addends)
}

export const atg__test_optional_floatlist = ({ values, addends }: { values: CTensor; addends: number[] }): CTensor => {
  return addon.atg__test_optional_floatlist(values, addends)
}

export const atg__test_optional_floatlist_out = ({ out, values, addends }: { out: CTensor; values: CTensor; addends: number[] }): CTensor => {
  return addon.atg__test_optional_floatlist_out(out, values, addends)
}

export const atg__test_string_default = ({ dummy, a, b }: { dummy: CTensor; a: string; b: string }): CTensor => {
  return addon.atg__test_string_default(dummy, a, b)
}

export const atg__test_ambiguous_defaults = ({ dummy, a, b }: { dummy: CTensor; a: number; b: number }): CTensor => {
  return addon.atg__test_ambiguous_defaults(dummy, a, b)
}

export const atg__test_ambiguous_defaults_b = ({ dummy, a, b }: { dummy: CTensor; a: number; b: string }): CTensor => {
  return addon.atg__test_ambiguous_defaults_b(dummy, a, b)
}

export const atg__test_warn_in_autograd = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg__test_warn_in_autograd(self)
}

export const atg__test_warn_in_autograd_out = ({ out, self }: { out: CTensor; self: CTensor }): CTensor => {
  return addon.atg__test_warn_in_autograd_out(out, self)
}

export const atg__test_autograd_multiple_dispatch = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg__test_autograd_multiple_dispatch(self)
}

export const atg__test_autograd_multiple_dispatch_ntonly = ({ self, b }: { self: CTensor; b: boolean }): CTensor => {
  return addon.atg__test_autograd_multiple_dispatch_ntonly(self, b)
}

export const atg__test_autograd_multiple_dispatch_fullcoverage_out = ({ out, self }: { out: CTensor; self: CTensor }): CTensor => {
  return addon.atg__test_autograd_multiple_dispatch_fullcoverage_out(out, self)
}

export const atg__test_autograd_multiple_dispatch_view = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg__test_autograd_multiple_dispatch_view(self)
}

export const atg__test_autograd_multiple_dispatch_view_copy = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg__test_autograd_multiple_dispatch_view_copy(self)
}

export const atg__test_autograd_multiple_dispatch_view_copy_out = ({ out, self }: { out: CTensor; self: CTensor }): CTensor => {
  return addon.atg__test_autograd_multiple_dispatch_view_copy_out(out, self)
}

export const atg_segment_reduce = ({ data, reduce, lengths, indices, offsets, axis, unsafe, initial }: { data: CTensor; reduce: string; lengths?: CTensor; indices?: CTensor; offsets?: CTensor; axis: number; unsafe: boolean; initial: CScalar }): CTensor => {
  return addon.atg_segment_reduce(data, reduce, lengths, indices, offsets, axis, unsafe, initial)
}

export const atg_segment_reduce_out = ({ out, data, reduce, lengths, indices, offsets, axis, unsafe, initial }: { out: CTensor; data: CTensor; reduce: string; lengths?: CTensor; indices?: CTensor; offsets?: CTensor; axis: number; unsafe: boolean; initial: CScalar }): CTensor => {
  return addon.atg_segment_reduce_out(out, data, reduce, lengths, indices, offsets, axis, unsafe, initial)
}

export const atg__segment_reduce_backward = ({ grad, output, data, reduce, lengths, offsets, axis, initial }: { grad: CTensor; output: CTensor; data: CTensor; reduce: string; lengths?: CTensor; offsets?: CTensor; axis: number; initial: CScalar }): CTensor => {
  return addon.atg__segment_reduce_backward(grad, output, data, reduce, lengths, offsets, axis, initial)
}

export const atg__segment_reduce_backward_out = ({ out, grad, output, data, reduce, lengths, offsets, axis, initial }: { out: CTensor; grad: CTensor; output: CTensor; data: CTensor; reduce: string; lengths?: CTensor; offsets?: CTensor; axis: number; initial: CScalar }): CTensor => {
  return addon.atg__segment_reduce_backward_out(out, grad, output, data, reduce, lengths, offsets, axis, initial)
}

export const atg_pad_sequence = ({ sequences, batch_first, padding_value }: { sequences: CTensor[]; batch_first: boolean; padding_value: number }): CTensor => {
  return addon.atg_pad_sequence(sequences, batch_first, padding_value)
}

export const atg_flatten_dense_tensors = ({ tensors }: { tensors: CTensor[] }): CTensor => {
  return addon.atg_flatten_dense_tensors(tensors)
}

export const atg__fw_primal_copy = ({ self, level }: { self: CTensor; level: number }): CTensor => {
  return addon.atg__fw_primal_copy(self, level)
}

export const atg__fw_primal_copy_out = ({ out, self, level }: { out: CTensor; self: CTensor; level: number }): CTensor => {
  return addon.atg__fw_primal_copy_out(out, self, level)
}

export const atg__make_dual_copy = ({ primal, tangent, level }: { primal: CTensor; tangent: CTensor; level: number }): CTensor => {
  return addon.atg__make_dual_copy(primal, tangent, level)
}

export const atg__make_dual_copy_out = ({ out, primal, tangent, level }: { out: CTensor; primal: CTensor; tangent: CTensor; level: number }): CTensor => {
  return addon.atg__make_dual_copy_out(out, primal, tangent, level)
}

export const atg_view_as_real_copy = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_view_as_real_copy(self)
}

export const atg_view_as_real_copy_out = ({ out, self }: { out: CTensor; self: CTensor }): CTensor => {
  return addon.atg_view_as_real_copy_out(out, self)
}

export const atg_view_as_complex_copy = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_view_as_complex_copy(self)
}

export const atg_view_as_complex_copy_out = ({ out, self }: { out: CTensor; self: CTensor }): CTensor => {
  return addon.atg_view_as_complex_copy_out(out, self)
}

export const atg__conj_copy = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg__conj_copy(self)
}

export const atg__conj_copy_out = ({ out, self }: { out: CTensor; self: CTensor }): CTensor => {
  return addon.atg__conj_copy_out(out, self)
}

export const atg__neg_view_copy = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg__neg_view_copy(self)
}

export const atg__neg_view_copy_out = ({ out, self }: { out: CTensor; self: CTensor }): CTensor => {
  return addon.atg__neg_view_copy_out(out, self)
}

export const atg_as_strided_copy = ({ self, size, stride, storage_offset }: { self: CTensor; size: number[]; stride: number[]; storage_offset?: number }): CTensor => {
  return addon.atg_as_strided_copy(self, size, stride, storage_offset)
}

export const atg_as_strided_copy_out = ({ out, self, size, stride, storage_offset }: { out: CTensor; self: CTensor; size: number[]; stride: number[]; storage_offset?: number }): CTensor => {
  return addon.atg_as_strided_copy_out(out, self, size, stride, storage_offset)
}

export const atg__sparse_broadcast_to_copy = ({ self, size }: { self: CTensor; size: number[] }): CTensor => {
  return addon.atg__sparse_broadcast_to_copy(self, size)
}

export const atg__sparse_broadcast_to_copy_out = ({ out, self, size }: { out: CTensor; self: CTensor; size: number[] }): CTensor => {
  return addon.atg__sparse_broadcast_to_copy_out(out, self, size)
}

export const atg_diagonal_copy = ({ self, offset, dim1, dim2 }: { self: CTensor; offset: number; dim1: number; dim2: number }): CTensor => {
  return addon.atg_diagonal_copy(self, offset, dim1, dim2)
}

export const atg_diagonal_copy_out = ({ out, self, offset, dim1, dim2 }: { out: CTensor; self: CTensor; offset: number; dim1: number; dim2: number }): CTensor => {
  return addon.atg_diagonal_copy_out(out, self, offset, dim1, dim2)
}

export const atg_expand_copy = ({ self, size, implicit }: { self: CTensor; size: number[]; implicit: boolean }): CTensor => {
  return addon.atg_expand_copy(self, size, implicit)
}

export const atg_expand_copy_out = ({ out, self, size, implicit }: { out: CTensor; self: CTensor; size: number[]; implicit: boolean }): CTensor => {
  return addon.atg_expand_copy_out(out, self, size, implicit)
}

export const atg_permute_copy = ({ self, dims }: { self: CTensor; dims: number[] }): CTensor => {
  return addon.atg_permute_copy(self, dims)
}

export const atg_permute_copy_out = ({ out, self, dims }: { out: CTensor; self: CTensor; dims: number[] }): CTensor => {
  return addon.atg_permute_copy_out(out, self, dims)
}

export const atg__reshape_alias_copy = ({ self, size, stride }: { self: CTensor; size: number[]; stride: number[] }): CTensor => {
  return addon.atg__reshape_alias_copy(self, size, stride)
}

export const atg__reshape_alias_copy_out = ({ out, self, size, stride }: { out: CTensor; self: CTensor; size: number[]; stride: number[] }): CTensor => {
  return addon.atg__reshape_alias_copy_out(out, self, size, stride)
}

export const atg_select_copy = ({ self, dim, index }: { self: CTensor; dim: number; index: number }): CTensor => {
  return addon.atg_select_copy(self, dim, index)
}

export const atg_select_copy_int_out = ({ out, self, dim, index }: { out: CTensor; self: CTensor; dim: number; index: number }): CTensor => {
  return addon.atg_select_copy_int_out(out, self, dim, index)
}

export const atg_detach_copy = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_detach_copy(self)
}

export const atg_detach_copy_out = ({ out, self }: { out: CTensor; self: CTensor }): CTensor => {
  return addon.atg_detach_copy_out(out, self)
}

export const atg_slice_copy = ({ self, dim, start, end, step }: { self: CTensor; dim: number; start?: number; end?: number; step: number }): CTensor => {
  return addon.atg_slice_copy(self, dim, start, end, step)
}

export const atg_slice_copy_tensor_out = ({ out, self, dim, start, end, step }: { out: CTensor; self: CTensor; dim: number; start?: number; end?: number; step: number }): CTensor => {
  return addon.atg_slice_copy_tensor_out(out, self, dim, start, end, step)
}

export const atg_squeeze_copy = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_squeeze_copy(self)
}

export const atg_squeeze_copy_dim = ({ self, dim }: { self: CTensor; dim: number }): CTensor => {
  return addon.atg_squeeze_copy_dim(self, dim)
}

export const atg_squeeze_copy_dims = ({ self, dim }: { self: CTensor; dim: number[] }): CTensor => {
  return addon.atg_squeeze_copy_dims(self, dim)
}

export const atg_squeeze_copy_out = ({ out, self }: { out: CTensor; self: CTensor }): CTensor => {
  return addon.atg_squeeze_copy_out(out, self)
}

export const atg_squeeze_copy_dim_out = ({ out, self, dim }: { out: CTensor; self: CTensor; dim: number }): CTensor => {
  return addon.atg_squeeze_copy_dim_out(out, self, dim)
}

export const atg_squeeze_copy_dims_out = ({ out, self, dim }: { out: CTensor; self: CTensor; dim: number[] }): CTensor => {
  return addon.atg_squeeze_copy_dims_out(out, self, dim)
}

export const atg_t_copy = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_t_copy(self)
}

export const atg_t_copy_out = ({ out, self }: { out: CTensor; self: CTensor }): CTensor => {
  return addon.atg_t_copy_out(out, self)
}

export const atg_transpose_copy = ({ self, dim0, dim1 }: { self: CTensor; dim0: number; dim1: number }): CTensor => {
  return addon.atg_transpose_copy(self, dim0, dim1)
}

export const atg_transpose_copy_int_out = ({ out, self, dim0, dim1 }: { out: CTensor; self: CTensor; dim0: number; dim1: number }): CTensor => {
  return addon.atg_transpose_copy_int_out(out, self, dim0, dim1)
}

export const atg_unsqueeze_copy = ({ self, dim }: { self: CTensor; dim: number }): CTensor => {
  return addon.atg_unsqueeze_copy(self, dim)
}

export const atg_unsqueeze_copy_out = ({ out, self, dim }: { out: CTensor; self: CTensor; dim: number }): CTensor => {
  return addon.atg_unsqueeze_copy_out(out, self, dim)
}

export const atg__indices_copy = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg__indices_copy(self)
}

export const atg__indices_copy_out = ({ out, self }: { out: CTensor; self: CTensor }): CTensor => {
  return addon.atg__indices_copy_out(out, self)
}

export const atg__values_copy = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg__values_copy(self)
}

export const atg__values_copy_out = ({ out, self }: { out: CTensor; self: CTensor }): CTensor => {
  return addon.atg__values_copy_out(out, self)
}

export const atg_indices_copy = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_indices_copy(self)
}

export const atg_indices_copy_out = ({ out, self }: { out: CTensor; self: CTensor }): CTensor => {
  return addon.atg_indices_copy_out(out, self)
}

export const atg_values_copy = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_values_copy(self)
}

export const atg_values_copy_out = ({ out, self }: { out: CTensor; self: CTensor }): CTensor => {
  return addon.atg_values_copy_out(out, self)
}

export const atg_crow_indices_copy = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_crow_indices_copy(self)
}

export const atg_crow_indices_copy_out = ({ out, self }: { out: CTensor; self: CTensor }): CTensor => {
  return addon.atg_crow_indices_copy_out(out, self)
}

export const atg_col_indices_copy = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_col_indices_copy(self)
}

export const atg_col_indices_copy_out = ({ out, self }: { out: CTensor; self: CTensor }): CTensor => {
  return addon.atg_col_indices_copy_out(out, self)
}

export const atg_ccol_indices_copy = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_ccol_indices_copy(self)
}

export const atg_ccol_indices_copy_out = ({ out, self }: { out: CTensor; self: CTensor }): CTensor => {
  return addon.atg_ccol_indices_copy_out(out, self)
}

export const atg_row_indices_copy = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_row_indices_copy(self)
}

export const atg_row_indices_copy_out = ({ out, self }: { out: CTensor; self: CTensor }): CTensor => {
  return addon.atg_row_indices_copy_out(out, self)
}

export const atg_unbind_copy = ({ out, self, dim }: { out: CTensor[]; self: CTensor; dim: number }): void => {
  return addon.atg_unbind_copy(out, self, dim)
}

export const atg_split_copy = ({ out, self, split_size, dim }: { out: CTensor[]; self: CTensor; split_size: number; dim: number }): void => {
  return addon.atg_split_copy(out, self, split_size, dim)
}

export const atg_split_with_sizes_copy = ({ out, self, split_sizes, dim }: { out: CTensor[]; self: CTensor; split_sizes: number[]; dim: number }): void => {
  return addon.atg_split_with_sizes_copy(out, self, split_sizes, dim)
}

export const atg_view_copy = ({ self, size }: { self: CTensor; size: number[] }): CTensor => {
  return addon.atg_view_copy(self, size)
}

export const atg_view_copy_dtype = ({ self, dtype }: { self: CTensor; dtype: number }): CTensor => {
  return addon.atg_view_copy_dtype(self, dtype)
}

export const atg_view_copy_out = ({ out, self, size }: { out: CTensor; self: CTensor; size: number[] }): CTensor => {
  return addon.atg_view_copy_out(out, self, size)
}

export const atg_view_copy_dtype_out = ({ out, self, dtype }: { out: CTensor; self: CTensor; dtype: number }): CTensor => {
  return addon.atg_view_copy_dtype_out(out, self, dtype)
}

export const atg_unfold_copy = ({ self, dimension, size, step }: { self: CTensor; dimension: number; size: number; step: number }): CTensor => {
  return addon.atg_unfold_copy(self, dimension, size, step)
}

export const atg_unfold_copy_out = ({ out, self, dimension, size, step }: { out: CTensor; self: CTensor; dimension: number; size: number; step: number }): CTensor => {
  return addon.atg_unfold_copy_out(out, self, dimension, size, step)
}

export const atg_alias_copy = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_alias_copy(self)
}

export const atg_alias_copy_out = ({ out, self }: { out: CTensor; self: CTensor }): CTensor => {
  return addon.atg_alias_copy_out(out, self)
}

export const atg_to_padded_tensor = ({ self, padding, output_size }: { self: CTensor; padding: number; output_size?: number[] }): CTensor => {
  return addon.atg_to_padded_tensor(self, padding, output_size)
}

export const atg_to_padded_tensor_out = ({ out, self, padding, output_size }: { out: CTensor; self: CTensor; padding: number; output_size?: number[] }): CTensor => {
  return addon.atg_to_padded_tensor_out(out, self, padding, output_size)
}

export const atg__nested_tensor_softmax_with_shape = ({ self, query }: { self: CTensor; query: CTensor }): CTensor => {
  return addon.atg__nested_tensor_softmax_with_shape(self, query)
}

export const atg__transformer_encoder_layer_fwd = ({ src, embed_dim, num_heads, qkv_weight, qkv_bias, proj_weight, proj_bias, use_gelu, norm_first, eps, norm_weight_1, norm_bias_1, norm_weight_2, norm_bias_2, ffn_weight_1, ffn_bias_1, ffn_weight_2, ffn_bias_2, mask, mask_type }: { src: CTensor; embed_dim: number; num_heads: number; qkv_weight: CTensor; qkv_bias: CTensor; proj_weight: CTensor; proj_bias: CTensor; use_gelu: boolean; norm_first: boolean; eps: number; norm_weight_1: CTensor; norm_bias_1: CTensor; norm_weight_2: CTensor; norm_bias_2: CTensor; ffn_weight_1: CTensor; ffn_bias_1: CTensor; ffn_weight_2: CTensor; ffn_bias_2: CTensor; mask?: CTensor; mask_type?: number }): CTensor => {
  return addon.atg__transformer_encoder_layer_fwd(src, embed_dim, num_heads, qkv_weight, qkv_bias, proj_weight, proj_bias, use_gelu, norm_first, eps, norm_weight_1, norm_bias_1, norm_weight_2, norm_bias_2, ffn_weight_1, ffn_bias_1, ffn_weight_2, ffn_bias_2, mask, mask_type)
}

export const atg__transformer_encoder_layer_fwd_out = ({ out, src, embed_dim, num_heads, qkv_weight, qkv_bias, proj_weight, proj_bias, use_gelu, norm_first, eps, norm_weight_1, norm_bias_1, norm_weight_2, norm_bias_2, ffn_weight_1, ffn_bias_1, ffn_weight_2, ffn_bias_2, mask, mask_type }: { out: CTensor; src: CTensor; embed_dim: number; num_heads: number; qkv_weight: CTensor; qkv_bias: CTensor; proj_weight: CTensor; proj_bias: CTensor; use_gelu: boolean; norm_first: boolean; eps: number; norm_weight_1: CTensor; norm_bias_1: CTensor; norm_weight_2: CTensor; norm_bias_2: CTensor; ffn_weight_1: CTensor; ffn_bias_1: CTensor; ffn_weight_2: CTensor; ffn_bias_2: CTensor; mask?: CTensor; mask_type?: number }): CTensor => {
  return addon.atg__transformer_encoder_layer_fwd_out(out, src, embed_dim, num_heads, qkv_weight, qkv_bias, proj_weight, proj_bias, use_gelu, norm_first, eps, norm_weight_1, norm_bias_1, norm_weight_2, norm_bias_2, ffn_weight_1, ffn_bias_1, ffn_weight_2, ffn_bias_2, mask, mask_type)
}

export const atg__native_multi_head_attention = ({ query, key, value, embed_dim, num_head, qkv_weight, qkv_bias, proj_weight, proj_bias, mask, need_weights, average_attn_weights, mask_type }: { query: CTensor; key: CTensor; value: CTensor; embed_dim: number; num_head: number; qkv_weight: CTensor; qkv_bias: CTensor; proj_weight: CTensor; proj_bias: CTensor; mask?: CTensor; need_weights: boolean; average_attn_weights: boolean; mask_type?: number }): CTensor[] => {
  return addon.atg__native_multi_head_attention(query, key, value, embed_dim, num_head, qkv_weight, qkv_bias, proj_weight, proj_bias, mask, need_weights, average_attn_weights, mask_type)
}

export const atg__native_multi_head_attention_out = ({ out0, out1, query, key, value, embed_dim, num_head, qkv_weight, qkv_bias, proj_weight, proj_bias, mask, need_weights, average_attn_weights, mask_type }: { out0: CTensor; out1: CTensor; query: CTensor; key: CTensor; value: CTensor; embed_dim: number; num_head: number; qkv_weight: CTensor; qkv_bias: CTensor; proj_weight: CTensor; proj_bias: CTensor; mask?: CTensor; need_weights: boolean; average_attn_weights: boolean; mask_type?: number }): CTensor[] => {
  return addon.atg__native_multi_head_attention_out(out0, out1, query, key, value, embed_dim, num_head, qkv_weight, qkv_bias, proj_weight, proj_bias, mask, need_weights, average_attn_weights, mask_type)
}

export const atg_scaled_dot_product_attention = ({ query, key, value, attn_mask, dropout_p, is_causal }: { query: CTensor; key: CTensor; value: CTensor; attn_mask?: CTensor; dropout_p: number; is_causal: boolean }): CTensor => {
  return addon.atg_scaled_dot_product_attention(query, key, value, attn_mask, dropout_p, is_causal)
}

export const atg__scaled_dot_product_attention = ({ query, key, value, attn_mask, dropout_p, need_attn_weights, is_causal }: { query: CTensor; key: CTensor; value: CTensor; attn_mask?: CTensor; dropout_p: number; need_attn_weights: boolean; is_causal: boolean }): CTensor[] => {
  return addon.atg__scaled_dot_product_attention(query, key, value, attn_mask, dropout_p, need_attn_weights, is_causal)
}

export const atg__fused_sdp_choice = ({ query, key, value, attn_mask, dropout_p, is_causal }: { query: CTensor; key: CTensor; value: CTensor; attn_mask?: CTensor; dropout_p: number; is_causal: boolean }): number => {
  return addon.atg__fused_sdp_choice(query, key, value, attn_mask, dropout_p, is_causal)
}

export const atg__scaled_dot_product_attention_math = ({ query, key, value, attn_mask, dropout_p, is_causal, dropout_mask }: { query: CTensor; key: CTensor; value: CTensor; attn_mask?: CTensor; dropout_p: number; is_causal: boolean; dropout_mask?: CTensor }): CTensor[] => {
  return addon.atg__scaled_dot_product_attention_math(query, key, value, attn_mask, dropout_p, is_causal, dropout_mask)
}

export const atg__scaled_dot_product_flash_attention_backward = ({ grad_out, query, key, value, out, logsumexp, cum_seq_q, cum_seq_k, max_q, max_k, dropout_p, is_causal, philox_seed, philox_offset }: { grad_out: CTensor; query: CTensor; key: CTensor; value: CTensor; out: CTensor; logsumexp: CTensor; cum_seq_q: CTensor; cum_seq_k: CTensor; max_q: number; max_k: number; dropout_p: number; is_causal: boolean; philox_seed: number; philox_offset: number }): CTensor[] => {
  return addon.atg__scaled_dot_product_flash_attention_backward(grad_out, query, key, value, out, logsumexp, cum_seq_q, cum_seq_k, max_q, max_k, dropout_p, is_causal, philox_seed, philox_offset)
}

export const atg__scaled_dot_product_efficient_attention = ({ query, key, value, compute_log_sumexp, is_causal }: { query: CTensor; key: CTensor; value: CTensor; compute_log_sumexp: boolean; is_causal: boolean }): CTensor[] => {
  return addon.atg__scaled_dot_product_efficient_attention(query, key, value, compute_log_sumexp, is_causal)
}

export const atg__scaled_dot_product_efficient_attention_backward = ({ grad_out_, query, key, value, out, logsumexp, is_causal, chunk_grad_outputs }: { grad_out_: CTensor; query: CTensor; key: CTensor; value: CTensor; out: CTensor; logsumexp: CTensor; is_causal: boolean; chunk_grad_outputs: boolean }): CTensor[] => {
  return addon.atg__scaled_dot_product_efficient_attention_backward(grad_out_, query, key, value, out, logsumexp, is_causal, chunk_grad_outputs)
}

export const atg__chunk_grad_outputs_efficient_attention = ({ query, key, value, is_causal }: { query: CTensor; key: CTensor; value: CTensor; is_causal: boolean }): boolean => {
  return addon.atg__chunk_grad_outputs_efficient_attention(query, key, value, is_causal)
}

export const atg__flash_attention_backward = ({ grad_out, query, key, value, out, logsumexp, cum_seq_q, cum_seq_k, max_q, max_k, dropout_p, is_causal, philox_seed, philox_offset }: { grad_out: CTensor; query: CTensor; key: CTensor; value: CTensor; out: CTensor; logsumexp: CTensor; cum_seq_q: CTensor; cum_seq_k: CTensor; max_q: number; max_k: number; dropout_p: number; is_causal: boolean; philox_seed: number; philox_offset: number }): CTensor[] => {
  return addon.atg__flash_attention_backward(grad_out, query, key, value, out, logsumexp, cum_seq_q, cum_seq_k, max_q, max_k, dropout_p, is_causal, philox_seed, philox_offset)
}

export const atg__efficient_attention_backward = ({ grad_out_, query, key, value, out, logsumexp, is_causal, chunk_grad_outputs }: { grad_out_: CTensor; query: CTensor; key: CTensor; value: CTensor; out: CTensor; logsumexp: CTensor; is_causal: boolean; chunk_grad_outputs: boolean }): CTensor[] => {
  return addon.atg__efficient_attention_backward(grad_out_, query, key, value, out, logsumexp, is_causal, chunk_grad_outputs)
}

export const atg__triton_scaled_dot_attention = ({ q, k, v, dropout_p }: { q: CTensor; k: CTensor; v: CTensor; dropout_p: number }): CTensor => {
  return addon.atg__triton_scaled_dot_attention(q, k, v, dropout_p)
}

export const atg__triton_scaled_dot_attention_out = ({ out, q, k, v, dropout_p }: { out: CTensor; q: CTensor; k: CTensor; v: CTensor; dropout_p: number }): CTensor => {
  return addon.atg__triton_scaled_dot_attention_out(out, q, k, v, dropout_p)
}

export const atg__triton_multi_head_attention = ({ query, key, value, embed_dim, num_head, qkv_weight, qkv_bias, proj_weight, proj_bias, mask }: { query: CTensor; key: CTensor; value: CTensor; embed_dim: number; num_head: number; qkv_weight: CTensor; qkv_bias: CTensor; proj_weight: CTensor; proj_bias: CTensor; mask?: CTensor }): CTensor => {
  return addon.atg__triton_multi_head_attention(query, key, value, embed_dim, num_head, qkv_weight, qkv_bias, proj_weight, proj_bias, mask)
}

export const atg__triton_multi_head_attention_out = ({ out, query, key, value, embed_dim, num_head, qkv_weight, qkv_bias, proj_weight, proj_bias, mask }: { out: CTensor; query: CTensor; key: CTensor; value: CTensor; embed_dim: number; num_head: number; qkv_weight: CTensor; qkv_bias: CTensor; proj_weight: CTensor; proj_bias: CTensor; mask?: CTensor }): CTensor => {
  return addon.atg__triton_multi_head_attention_out(out, query, key, value, embed_dim, num_head, qkv_weight, qkv_bias, proj_weight, proj_bias, mask)
}

export const atg_special_airy_ai = ({ x }: { x: CTensor }): CTensor => {
  return addon.atg_special_airy_ai(x)
}

export const atg_special_airy_ai_out = ({ out, x }: { out: CTensor; x: CTensor }): CTensor => {
  return addon.atg_special_airy_ai_out(out, x)
}

export const atg__transformer_decoder_only_layer_fwd = ({ src, embed_dim, num_heads, qkv_weight, qkv_bias, proj_weight, proj_bias, use_gelu, norm_first, eps, norm_weight_1, norm_bias_1, norm_weight_2, norm_bias_2, ffn_weight_1, ffn_bias_1, ffn_weight_2, ffn_bias_2, mask, incr_key, incr_value }: { src: CTensor; embed_dim: number; num_heads: number; qkv_weight: CTensor; qkv_bias: CTensor; proj_weight: CTensor; proj_bias: CTensor; use_gelu: boolean; norm_first: boolean; eps: number; norm_weight_1: CTensor; norm_bias_1: CTensor; norm_weight_2: CTensor; norm_bias_2: CTensor; ffn_weight_1: CTensor; ffn_bias_1: CTensor; ffn_weight_2: CTensor; ffn_bias_2: CTensor; mask?: CTensor; incr_key?: CTensor; incr_value?: CTensor }): CTensor[] => {
  return addon.atg__transformer_decoder_only_layer_fwd(src, embed_dim, num_heads, qkv_weight, qkv_bias, proj_weight, proj_bias, use_gelu, norm_first, eps, norm_weight_1, norm_bias_1, norm_weight_2, norm_bias_2, ffn_weight_1, ffn_bias_1, ffn_weight_2, ffn_bias_2, mask, incr_key, incr_value)
}

export const atg__transformer_decoder_only_layer_fwd_out = ({ out0, out1, out2, src, embed_dim, num_heads, qkv_weight, qkv_bias, proj_weight, proj_bias, use_gelu, norm_first, eps, norm_weight_1, norm_bias_1, norm_weight_2, norm_bias_2, ffn_weight_1, ffn_bias_1, ffn_weight_2, ffn_bias_2, mask, incr_key, incr_value }: { out0: CTensor; out1: CTensor; out2: CTensor; src: CTensor; embed_dim: number; num_heads: number; qkv_weight: CTensor; qkv_bias: CTensor; proj_weight: CTensor; proj_bias: CTensor; use_gelu: boolean; norm_first: boolean; eps: number; norm_weight_1: CTensor; norm_bias_1: CTensor; norm_weight_2: CTensor; norm_bias_2: CTensor; ffn_weight_1: CTensor; ffn_bias_1: CTensor; ffn_weight_2: CTensor; ffn_bias_2: CTensor; mask?: CTensor; incr_key?: CTensor; incr_value?: CTensor }): CTensor[] => {
  return addon.atg__transformer_decoder_only_layer_fwd_out(out0, out1, out2, src, embed_dim, num_heads, qkv_weight, qkv_bias, proj_weight, proj_bias, use_gelu, norm_first, eps, norm_weight_1, norm_bias_1, norm_weight_2, norm_bias_2, ffn_weight_1, ffn_bias_1, ffn_weight_2, ffn_bias_2, mask, incr_key, incr_value)
}

export const atg__native_decoder_only_multi_head_attention = ({ query, key, value, embed_dim, num_head, qkv_weight, qkv_bias, proj_weight, proj_bias, mask, incr_key, incr_value, need_weights, average_attn_weights }: { query: CTensor; key: CTensor; value: CTensor; embed_dim: number; num_head: number; qkv_weight: CTensor; qkv_bias: CTensor; proj_weight: CTensor; proj_bias: CTensor; mask?: CTensor; incr_key?: CTensor; incr_value?: CTensor; need_weights: boolean; average_attn_weights: boolean }): CTensor[] => {
  return addon.atg__native_decoder_only_multi_head_attention(query, key, value, embed_dim, num_head, qkv_weight, qkv_bias, proj_weight, proj_bias, mask, incr_key, incr_value, need_weights, average_attn_weights)
}

export const atg__native_decoder_only_multi_head_attention_out = ({ out0, out1, out2, out3, query, key, value, embed_dim, num_head, qkv_weight, qkv_bias, proj_weight, proj_bias, mask, incr_key, incr_value, need_weights, average_attn_weights }: { out0: CTensor; out1: CTensor; out2: CTensor; out3: CTensor; query: CTensor; key: CTensor; value: CTensor; embed_dim: number; num_head: number; qkv_weight: CTensor; qkv_bias: CTensor; proj_weight: CTensor; proj_bias: CTensor; mask?: CTensor; incr_key?: CTensor; incr_value?: CTensor; need_weights: boolean; average_attn_weights: boolean }): CTensor[] => {
  return addon.atg__native_decoder_only_multi_head_attention_out(out0, out1, out2, out3, query, key, value, embed_dim, num_head, qkv_weight, qkv_bias, proj_weight, proj_bias, mask, incr_key, incr_value, need_weights, average_attn_weights)
}

export const atg_special_bessel_j0 = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_special_bessel_j0(self)
}

export const atg_special_bessel_j0_out = ({ out, self }: { out: CTensor; self: CTensor }): CTensor => {
  return addon.atg_special_bessel_j0_out(out, self)
}

export const atg_special_bessel_j1 = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_special_bessel_j1(self)
}

export const atg_special_bessel_j1_out = ({ out, self }: { out: CTensor; self: CTensor }): CTensor => {
  return addon.atg_special_bessel_j1_out(out, self)
}

export const atg_special_bessel_y0 = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_special_bessel_y0(self)
}

export const atg_special_bessel_y0_out = ({ out, self }: { out: CTensor; self: CTensor }): CTensor => {
  return addon.atg_special_bessel_y0_out(out, self)
}

export const atg_special_bessel_y1 = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_special_bessel_y1(self)
}

export const atg_special_bessel_y1_out = ({ out, self }: { out: CTensor; self: CTensor }): CTensor => {
  return addon.atg_special_bessel_y1_out(out, self)
}

export const atg_special_chebyshev_polynomial_t = ({ x, n }: { x: CTensor; n: CTensor }): CTensor => {
  return addon.atg_special_chebyshev_polynomial_t(x, n)
}

export const atg_special_chebyshev_polynomial_t_x_scalar = ({ x, n }: { x: CScalar; n: CTensor }): CTensor => {
  return addon.atg_special_chebyshev_polynomial_t_x_scalar(x, n)
}

export const atg_special_chebyshev_polynomial_t_n_scalar = ({ x, n }: { x: CTensor; n: CScalar }): CTensor => {
  return addon.atg_special_chebyshev_polynomial_t_n_scalar(x, n)
}

export const atg_special_chebyshev_polynomial_t_out = ({ out, x, n }: { out: CTensor; x: CTensor; n: CTensor }): CTensor => {
  return addon.atg_special_chebyshev_polynomial_t_out(out, x, n)
}

export const atg_special_chebyshev_polynomial_t_x_scalar_out = ({ out, x, n }: { out: CTensor; x: CScalar; n: CTensor }): CTensor => {
  return addon.atg_special_chebyshev_polynomial_t_x_scalar_out(out, x, n)
}

export const atg_special_chebyshev_polynomial_t_n_scalar_out = ({ out, x, n }: { out: CTensor; x: CTensor; n: CScalar }): CTensor => {
  return addon.atg_special_chebyshev_polynomial_t_n_scalar_out(out, x, n)
}

export const atg_special_chebyshev_polynomial_u = ({ x, n }: { x: CTensor; n: CTensor }): CTensor => {
  return addon.atg_special_chebyshev_polynomial_u(x, n)
}

export const atg_special_chebyshev_polynomial_u_x_scalar = ({ x, n }: { x: CScalar; n: CTensor }): CTensor => {
  return addon.atg_special_chebyshev_polynomial_u_x_scalar(x, n)
}

export const atg_special_chebyshev_polynomial_u_n_scalar = ({ x, n }: { x: CTensor; n: CScalar }): CTensor => {
  return addon.atg_special_chebyshev_polynomial_u_n_scalar(x, n)
}

export const atg_special_chebyshev_polynomial_u_out = ({ out, x, n }: { out: CTensor; x: CTensor; n: CTensor }): CTensor => {
  return addon.atg_special_chebyshev_polynomial_u_out(out, x, n)
}

export const atg_special_chebyshev_polynomial_u_x_scalar_out = ({ out, x, n }: { out: CTensor; x: CScalar; n: CTensor }): CTensor => {
  return addon.atg_special_chebyshev_polynomial_u_x_scalar_out(out, x, n)
}

export const atg_special_chebyshev_polynomial_u_n_scalar_out = ({ out, x, n }: { out: CTensor; x: CTensor; n: CScalar }): CTensor => {
  return addon.atg_special_chebyshev_polynomial_u_n_scalar_out(out, x, n)
}

export const atg_special_chebyshev_polynomial_v = ({ x, n }: { x: CTensor; n: CTensor }): CTensor => {
  return addon.atg_special_chebyshev_polynomial_v(x, n)
}

export const atg_special_chebyshev_polynomial_v_x_scalar = ({ x, n }: { x: CScalar; n: CTensor }): CTensor => {
  return addon.atg_special_chebyshev_polynomial_v_x_scalar(x, n)
}

export const atg_special_chebyshev_polynomial_v_n_scalar = ({ x, n }: { x: CTensor; n: CScalar }): CTensor => {
  return addon.atg_special_chebyshev_polynomial_v_n_scalar(x, n)
}

export const atg_special_chebyshev_polynomial_v_out = ({ out, x, n }: { out: CTensor; x: CTensor; n: CTensor }): CTensor => {
  return addon.atg_special_chebyshev_polynomial_v_out(out, x, n)
}

export const atg_special_chebyshev_polynomial_v_x_scalar_out = ({ out, x, n }: { out: CTensor; x: CScalar; n: CTensor }): CTensor => {
  return addon.atg_special_chebyshev_polynomial_v_x_scalar_out(out, x, n)
}

export const atg_special_chebyshev_polynomial_v_n_scalar_out = ({ out, x, n }: { out: CTensor; x: CTensor; n: CScalar }): CTensor => {
  return addon.atg_special_chebyshev_polynomial_v_n_scalar_out(out, x, n)
}

export const atg_special_chebyshev_polynomial_w = ({ x, n }: { x: CTensor; n: CTensor }): CTensor => {
  return addon.atg_special_chebyshev_polynomial_w(x, n)
}

export const atg_special_chebyshev_polynomial_w_x_scalar = ({ x, n }: { x: CScalar; n: CTensor }): CTensor => {
  return addon.atg_special_chebyshev_polynomial_w_x_scalar(x, n)
}

export const atg_special_chebyshev_polynomial_w_n_scalar = ({ x, n }: { x: CTensor; n: CScalar }): CTensor => {
  return addon.atg_special_chebyshev_polynomial_w_n_scalar(x, n)
}

export const atg_special_chebyshev_polynomial_w_out = ({ out, x, n }: { out: CTensor; x: CTensor; n: CTensor }): CTensor => {
  return addon.atg_special_chebyshev_polynomial_w_out(out, x, n)
}

export const atg_special_chebyshev_polynomial_w_x_scalar_out = ({ out, x, n }: { out: CTensor; x: CScalar; n: CTensor }): CTensor => {
  return addon.atg_special_chebyshev_polynomial_w_x_scalar_out(out, x, n)
}

export const atg_special_chebyshev_polynomial_w_n_scalar_out = ({ out, x, n }: { out: CTensor; x: CTensor; n: CScalar }): CTensor => {
  return addon.atg_special_chebyshev_polynomial_w_n_scalar_out(out, x, n)
}

export const atg_special_hermite_polynomial_h = ({ x, n }: { x: CTensor; n: CTensor }): CTensor => {
  return addon.atg_special_hermite_polynomial_h(x, n)
}

export const atg_special_hermite_polynomial_h_x_scalar = ({ x, n }: { x: CScalar; n: CTensor }): CTensor => {
  return addon.atg_special_hermite_polynomial_h_x_scalar(x, n)
}

export const atg_special_hermite_polynomial_h_n_scalar = ({ x, n }: { x: CTensor; n: CScalar }): CTensor => {
  return addon.atg_special_hermite_polynomial_h_n_scalar(x, n)
}

export const atg_special_hermite_polynomial_h_out = ({ out, x, n }: { out: CTensor; x: CTensor; n: CTensor }): CTensor => {
  return addon.atg_special_hermite_polynomial_h_out(out, x, n)
}

export const atg_special_hermite_polynomial_h_x_scalar_out = ({ out, x, n }: { out: CTensor; x: CScalar; n: CTensor }): CTensor => {
  return addon.atg_special_hermite_polynomial_h_x_scalar_out(out, x, n)
}

export const atg_special_hermite_polynomial_h_n_scalar_out = ({ out, x, n }: { out: CTensor; x: CTensor; n: CScalar }): CTensor => {
  return addon.atg_special_hermite_polynomial_h_n_scalar_out(out, x, n)
}

export const atg_special_hermite_polynomial_he = ({ x, n }: { x: CTensor; n: CTensor }): CTensor => {
  return addon.atg_special_hermite_polynomial_he(x, n)
}

export const atg_special_hermite_polynomial_he_x_scalar = ({ x, n }: { x: CScalar; n: CTensor }): CTensor => {
  return addon.atg_special_hermite_polynomial_he_x_scalar(x, n)
}

export const atg_special_hermite_polynomial_he_n_scalar = ({ x, n }: { x: CTensor; n: CScalar }): CTensor => {
  return addon.atg_special_hermite_polynomial_he_n_scalar(x, n)
}

export const atg_special_hermite_polynomial_he_out = ({ out, x, n }: { out: CTensor; x: CTensor; n: CTensor }): CTensor => {
  return addon.atg_special_hermite_polynomial_he_out(out, x, n)
}

export const atg_special_hermite_polynomial_he_x_scalar_out = ({ out, x, n }: { out: CTensor; x: CScalar; n: CTensor }): CTensor => {
  return addon.atg_special_hermite_polynomial_he_x_scalar_out(out, x, n)
}

export const atg_special_hermite_polynomial_he_n_scalar_out = ({ out, x, n }: { out: CTensor; x: CTensor; n: CScalar }): CTensor => {
  return addon.atg_special_hermite_polynomial_he_n_scalar_out(out, x, n)
}

export const atg_special_laguerre_polynomial_l = ({ x, n }: { x: CTensor; n: CTensor }): CTensor => {
  return addon.atg_special_laguerre_polynomial_l(x, n)
}

export const atg_special_laguerre_polynomial_l_x_scalar = ({ x, n }: { x: CScalar; n: CTensor }): CTensor => {
  return addon.atg_special_laguerre_polynomial_l_x_scalar(x, n)
}

export const atg_special_laguerre_polynomial_l_n_scalar = ({ x, n }: { x: CTensor; n: CScalar }): CTensor => {
  return addon.atg_special_laguerre_polynomial_l_n_scalar(x, n)
}

export const atg_special_laguerre_polynomial_l_out = ({ out, x, n }: { out: CTensor; x: CTensor; n: CTensor }): CTensor => {
  return addon.atg_special_laguerre_polynomial_l_out(out, x, n)
}

export const atg_special_laguerre_polynomial_l_x_scalar_out = ({ out, x, n }: { out: CTensor; x: CScalar; n: CTensor }): CTensor => {
  return addon.atg_special_laguerre_polynomial_l_x_scalar_out(out, x, n)
}

export const atg_special_laguerre_polynomial_l_n_scalar_out = ({ out, x, n }: { out: CTensor; x: CTensor; n: CScalar }): CTensor => {
  return addon.atg_special_laguerre_polynomial_l_n_scalar_out(out, x, n)
}

export const atg_special_legendre_polynomial_p = ({ x, n }: { x: CTensor; n: CTensor }): CTensor => {
  return addon.atg_special_legendre_polynomial_p(x, n)
}

export const atg_special_legendre_polynomial_p_x_scalar = ({ x, n }: { x: CScalar; n: CTensor }): CTensor => {
  return addon.atg_special_legendre_polynomial_p_x_scalar(x, n)
}

export const atg_special_legendre_polynomial_p_n_scalar = ({ x, n }: { x: CTensor; n: CScalar }): CTensor => {
  return addon.atg_special_legendre_polynomial_p_n_scalar(x, n)
}

export const atg_special_legendre_polynomial_p_out = ({ out, x, n }: { out: CTensor; x: CTensor; n: CTensor }): CTensor => {
  return addon.atg_special_legendre_polynomial_p_out(out, x, n)
}

export const atg_special_legendre_polynomial_p_x_scalar_out = ({ out, x, n }: { out: CTensor; x: CScalar; n: CTensor }): CTensor => {
  return addon.atg_special_legendre_polynomial_p_x_scalar_out(out, x, n)
}

export const atg_special_legendre_polynomial_p_n_scalar_out = ({ out, x, n }: { out: CTensor; x: CTensor; n: CScalar }): CTensor => {
  return addon.atg_special_legendre_polynomial_p_n_scalar_out(out, x, n)
}

export const atg_special_modified_bessel_i0 = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_special_modified_bessel_i0(self)
}

export const atg_special_modified_bessel_i0_out = ({ out, self }: { out: CTensor; self: CTensor }): CTensor => {
  return addon.atg_special_modified_bessel_i0_out(out, self)
}

export const atg_special_modified_bessel_i1 = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_special_modified_bessel_i1(self)
}

export const atg_special_modified_bessel_i1_out = ({ out, self }: { out: CTensor; self: CTensor }): CTensor => {
  return addon.atg_special_modified_bessel_i1_out(out, self)
}

export const atg_special_modified_bessel_k0 = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_special_modified_bessel_k0(self)
}

export const atg_special_modified_bessel_k0_out = ({ out, self }: { out: CTensor; self: CTensor }): CTensor => {
  return addon.atg_special_modified_bessel_k0_out(out, self)
}

export const atg_special_modified_bessel_k1 = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_special_modified_bessel_k1(self)
}

export const atg_special_modified_bessel_k1_out = ({ out, self }: { out: CTensor; self: CTensor }): CTensor => {
  return addon.atg_special_modified_bessel_k1_out(out, self)
}

export const atg_special_scaled_modified_bessel_k0 = ({ x }: { x: CTensor }): CTensor => {
  return addon.atg_special_scaled_modified_bessel_k0(x)
}

export const atg_special_scaled_modified_bessel_k0_out = ({ out, x }: { out: CTensor; x: CTensor }): CTensor => {
  return addon.atg_special_scaled_modified_bessel_k0_out(out, x)
}

export const atg_special_scaled_modified_bessel_k1 = ({ x }: { x: CTensor }): CTensor => {
  return addon.atg_special_scaled_modified_bessel_k1(x)
}

export const atg_special_scaled_modified_bessel_k1_out = ({ out, x }: { out: CTensor; x: CTensor }): CTensor => {
  return addon.atg_special_scaled_modified_bessel_k1_out(out, x)
}

export const atg_special_shifted_chebyshev_polynomial_t = ({ x, n }: { x: CTensor; n: CTensor }): CTensor => {
  return addon.atg_special_shifted_chebyshev_polynomial_t(x, n)
}

export const atg_special_shifted_chebyshev_polynomial_t_x_scalar = ({ x, n }: { x: CScalar; n: CTensor }): CTensor => {
  return addon.atg_special_shifted_chebyshev_polynomial_t_x_scalar(x, n)
}

export const atg_special_shifted_chebyshev_polynomial_t_n_scalar = ({ x, n }: { x: CTensor; n: CScalar }): CTensor => {
  return addon.atg_special_shifted_chebyshev_polynomial_t_n_scalar(x, n)
}

export const atg_special_shifted_chebyshev_polynomial_t_out = ({ out, x, n }: { out: CTensor; x: CTensor; n: CTensor }): CTensor => {
  return addon.atg_special_shifted_chebyshev_polynomial_t_out(out, x, n)
}

export const atg_special_shifted_chebyshev_polynomial_t_x_scalar_out = ({ out, x, n }: { out: CTensor; x: CScalar; n: CTensor }): CTensor => {
  return addon.atg_special_shifted_chebyshev_polynomial_t_x_scalar_out(out, x, n)
}

export const atg_special_shifted_chebyshev_polynomial_t_n_scalar_out = ({ out, x, n }: { out: CTensor; x: CTensor; n: CScalar }): CTensor => {
  return addon.atg_special_shifted_chebyshev_polynomial_t_n_scalar_out(out, x, n)
}

export const atg_special_shifted_chebyshev_polynomial_u = ({ x, n }: { x: CTensor; n: CTensor }): CTensor => {
  return addon.atg_special_shifted_chebyshev_polynomial_u(x, n)
}

export const atg_special_shifted_chebyshev_polynomial_u_x_scalar = ({ x, n }: { x: CScalar; n: CTensor }): CTensor => {
  return addon.atg_special_shifted_chebyshev_polynomial_u_x_scalar(x, n)
}

export const atg_special_shifted_chebyshev_polynomial_u_n_scalar = ({ x, n }: { x: CTensor; n: CScalar }): CTensor => {
  return addon.atg_special_shifted_chebyshev_polynomial_u_n_scalar(x, n)
}

export const atg_special_shifted_chebyshev_polynomial_u_out = ({ out, x, n }: { out: CTensor; x: CTensor; n: CTensor }): CTensor => {
  return addon.atg_special_shifted_chebyshev_polynomial_u_out(out, x, n)
}

export const atg_special_shifted_chebyshev_polynomial_u_x_scalar_out = ({ out, x, n }: { out: CTensor; x: CScalar; n: CTensor }): CTensor => {
  return addon.atg_special_shifted_chebyshev_polynomial_u_x_scalar_out(out, x, n)
}

export const atg_special_shifted_chebyshev_polynomial_u_n_scalar_out = ({ out, x, n }: { out: CTensor; x: CTensor; n: CScalar }): CTensor => {
  return addon.atg_special_shifted_chebyshev_polynomial_u_n_scalar_out(out, x, n)
}

export const atg_special_shifted_chebyshev_polynomial_v = ({ x, n }: { x: CTensor; n: CTensor }): CTensor => {
  return addon.atg_special_shifted_chebyshev_polynomial_v(x, n)
}

export const atg_special_shifted_chebyshev_polynomial_v_x_scalar = ({ x, n }: { x: CScalar; n: CTensor }): CTensor => {
  return addon.atg_special_shifted_chebyshev_polynomial_v_x_scalar(x, n)
}

export const atg_special_shifted_chebyshev_polynomial_v_n_scalar = ({ x, n }: { x: CTensor; n: CScalar }): CTensor => {
  return addon.atg_special_shifted_chebyshev_polynomial_v_n_scalar(x, n)
}

export const atg_special_shifted_chebyshev_polynomial_v_out = ({ out, x, n }: { out: CTensor; x: CTensor; n: CTensor }): CTensor => {
  return addon.atg_special_shifted_chebyshev_polynomial_v_out(out, x, n)
}

export const atg_special_shifted_chebyshev_polynomial_v_x_scalar_out = ({ out, x, n }: { out: CTensor; x: CScalar; n: CTensor }): CTensor => {
  return addon.atg_special_shifted_chebyshev_polynomial_v_x_scalar_out(out, x, n)
}

export const atg_special_shifted_chebyshev_polynomial_v_n_scalar_out = ({ out, x, n }: { out: CTensor; x: CTensor; n: CScalar }): CTensor => {
  return addon.atg_special_shifted_chebyshev_polynomial_v_n_scalar_out(out, x, n)
}

export const atg_special_shifted_chebyshev_polynomial_w = ({ x, n }: { x: CTensor; n: CTensor }): CTensor => {
  return addon.atg_special_shifted_chebyshev_polynomial_w(x, n)
}

export const atg_special_shifted_chebyshev_polynomial_w_x_scalar = ({ x, n }: { x: CScalar; n: CTensor }): CTensor => {
  return addon.atg_special_shifted_chebyshev_polynomial_w_x_scalar(x, n)
}

export const atg_special_shifted_chebyshev_polynomial_w_n_scalar = ({ x, n }: { x: CTensor; n: CScalar }): CTensor => {
  return addon.atg_special_shifted_chebyshev_polynomial_w_n_scalar(x, n)
}

export const atg_special_shifted_chebyshev_polynomial_w_out = ({ out, x, n }: { out: CTensor; x: CTensor; n: CTensor }): CTensor => {
  return addon.atg_special_shifted_chebyshev_polynomial_w_out(out, x, n)
}

export const atg_special_shifted_chebyshev_polynomial_w_x_scalar_out = ({ out, x, n }: { out: CTensor; x: CScalar; n: CTensor }): CTensor => {
  return addon.atg_special_shifted_chebyshev_polynomial_w_x_scalar_out(out, x, n)
}

export const atg_special_shifted_chebyshev_polynomial_w_n_scalar_out = ({ out, x, n }: { out: CTensor; x: CTensor; n: CScalar }): CTensor => {
  return addon.atg_special_shifted_chebyshev_polynomial_w_n_scalar_out(out, x, n)
}

export const atg_special_spherical_bessel_j0 = ({ x }: { x: CTensor }): CTensor => {
  return addon.atg_special_spherical_bessel_j0(x)
}

export const atg_special_spherical_bessel_j0_out = ({ out, x }: { out: CTensor; x: CTensor }): CTensor => {
  return addon.atg_special_spherical_bessel_j0_out(out, x)
}

export const atg__foobar = ({ self, arg1, arg2, arg3 }: { self: CTensor; arg1: boolean; arg2: boolean; arg3: boolean }): CTensor => {
  return addon.atg__foobar(self, arg1, arg2, arg3)
}

export const atg__foobar_out = ({ out, self, arg1, arg2, arg3 }: { out: CTensor; self: CTensor; arg1: boolean; arg2: boolean; arg3: boolean }): CTensor => {
  return addon.atg__foobar_out(out, self, arg1, arg2, arg3)
}

export const atg__fused_adam_ = ({ self, grads, exp_avgs, exp_avg_sqs, max_exp_avg_sqs, state_steps, lr, beta1, beta2, weight_decay, eps, amsgrad, maximize, grad_scale, found_inf }: { self: CTensor[]; grads: CTensor[]; exp_avgs: CTensor[]; exp_avg_sqs: CTensor[]; max_exp_avg_sqs: CTensor[]; state_steps: CTensor[]; lr: number; beta1: number; beta2: number; weight_decay: number; eps: number; amsgrad: boolean; maximize: boolean; grad_scale?: CTensor; found_inf?: CTensor }): void => {
  return addon.atg__fused_adam_(self, grads, exp_avgs, exp_avg_sqs, max_exp_avg_sqs, state_steps, lr, beta1, beta2, weight_decay, eps, amsgrad, maximize, grad_scale, found_inf)
}

export const atg__fused_adamw_ = ({ self, grads, exp_avgs, exp_avg_sqs, max_exp_avg_sqs, state_steps, lr, beta1, beta2, weight_decay, eps, amsgrad, maximize, grad_scale, found_inf }: { self: CTensor[]; grads: CTensor[]; exp_avgs: CTensor[]; exp_avg_sqs: CTensor[]; max_exp_avg_sqs: CTensor[]; state_steps: CTensor[]; lr: number; beta1: number; beta2: number; weight_decay: number; eps: number; amsgrad: boolean; maximize: boolean; grad_scale?: CTensor; found_inf?: CTensor }): void => {
  return addon.atg__fused_adamw_(self, grads, exp_avgs, exp_avg_sqs, max_exp_avg_sqs, state_steps, lr, beta1, beta2, weight_decay, eps, amsgrad, maximize, grad_scale, found_inf)
}

export const atg_embedding_renorm = ({ self, indices, max_norm, norm_type }: { self: CTensor; indices: CTensor; max_norm: number; norm_type: number }): CTensor => {
  return addon.atg_embedding_renorm(self, indices, max_norm, norm_type)
}

export const atg_embedding_renorm_out = ({ out, self, indices, max_norm, norm_type }: { out: CTensor; self: CTensor; indices: CTensor; max_norm: number; norm_type: number }): CTensor => {
  return addon.atg_embedding_renorm_out(out, self, indices, max_norm, norm_type)
}

export const atg_resize = ({ self, size, memory_format }: { self: CTensor; size: number[]; memory_format: number }): CTensor => {
  return addon.atg_resize(self, size, memory_format)
}

export const atg_resize_out = ({ out, self, size, memory_format }: { out: CTensor; self: CTensor; size: number[]; memory_format: number }): CTensor => {
  return addon.atg_resize_out(out, self, size, memory_format)
}

export const atg__resize_output = ({ self, size, device }: { self: CTensor; size: number[]; device: number }): CTensor => {
  return addon.atg__resize_output(self, size, device)
}

export const atg__resize_output_out = ({ out, self, size, device }: { out: CTensor; self: CTensor; size: number[]; device: number }): CTensor => {
  return addon.atg__resize_output_out(out, self, size, device)
}

export const atg__index_put_impl = ({ self, indices, values, accumulate, unsafe }: { self: CTensor; indices: CTensor[]; values: CTensor; accumulate: boolean; unsafe: boolean }): CTensor => {
  return addon.atg__index_put_impl(self, indices, values, accumulate, unsafe)
}

export const atg__index_put_impl_out = ({ out, self, indices, values, accumulate, unsafe }: { out: CTensor; self: CTensor; indices: CTensor[]; values: CTensor; accumulate: boolean; unsafe: boolean }): CTensor => {
  return addon.atg__index_put_impl_out(out, self, indices, values, accumulate, unsafe)
}

export const atg__native_batch_norm_legit_functional = ({ input, weight, bias, running_mean, running_var, training, momentum, eps }: { input: CTensor; weight?: CTensor; bias?: CTensor; running_mean: CTensor; running_var: CTensor; training: boolean; momentum: number; eps: number }): CTensor[] => {
  return addon.atg__native_batch_norm_legit_functional(input, weight, bias, running_mean, running_var, training, momentum, eps)
}

export const atg_unsafe_split = ({ out, self, split_size, dim }: { out: CTensor[]; self: CTensor; split_size: number; dim: number }): void => {
  return addon.atg_unsafe_split(out, self, split_size, dim)
}

export const atg_unsafe_split_with_sizes = ({ out, self, split_sizes, dim }: { out: CTensor[]; self: CTensor; split_sizes: number[]; dim: number }): void => {
  return addon.atg_unsafe_split_with_sizes(out, self, split_sizes, dim)
}

export const atg_clone = ({ out, self, memory_format }: { out: CTensor; self: CTensor; memory_format: number }): CTensor => {
  return addon.atg_clone(out, self, memory_format)
}

export const atg_resize_as = ({ self, the_template, memory_format }: { self: CTensor; the_template: CTensor; memory_format: number }): CTensor => {
  return addon.atg_resize_as(self, the_template, memory_format)
}

export const atg_resize_as_out = ({ out, self, the_template, memory_format }: { out: CTensor; self: CTensor; the_template: CTensor; memory_format: number }): CTensor => {
  return addon.atg_resize_as_out(out, self, the_template, memory_format)
}

export const atg_resize_as_sparse = ({ self, the_template }: { self: CTensor; the_template: CTensor }): CTensor => {
  return addon.atg_resize_as_sparse(self, the_template)
}

export const atg_resize_as_sparse_out = ({ out, self, the_template }: { out: CTensor; self: CTensor; the_template: CTensor }): CTensor => {
  return addon.atg_resize_as_sparse_out(out, self, the_template)
}

export const atg_zero = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_zero(self)
}

export const atg_zero_out = ({ out, self }: { out: CTensor; self: CTensor }): CTensor => {
  return addon.atg_zero_out(out, self)
}

export const atg_sparse_resize = ({ self, size, sparse_dim, dense_dim }: { self: CTensor; size: number[]; sparse_dim: number; dense_dim: number }): CTensor => {
  return addon.atg_sparse_resize(self, size, sparse_dim, dense_dim)
}

export const atg_sparse_resize_out = ({ out, self, size, sparse_dim, dense_dim }: { out: CTensor; self: CTensor; size: number[]; sparse_dim: number; dense_dim: number }): CTensor => {
  return addon.atg_sparse_resize_out(out, self, size, sparse_dim, dense_dim)
}

export const atg_sparse_resize_and_clear = ({ self, size, sparse_dim, dense_dim }: { self: CTensor; size: number[]; sparse_dim: number; dense_dim: number }): CTensor => {
  return addon.atg_sparse_resize_and_clear(self, size, sparse_dim, dense_dim)
}

export const atg_sparse_resize_and_clear_out = ({ out, self, size, sparse_dim, dense_dim }: { out: CTensor; self: CTensor; size: number[]; sparse_dim: number; dense_dim: number }): CTensor => {
  return addon.atg_sparse_resize_and_clear_out(out, self, size, sparse_dim, dense_dim)
}

export const atg__coalesced = ({ self, coalesced }: { self: CTensor; coalesced: boolean }): CTensor => {
  return addon.atg__coalesced(self, coalesced)
}

export const atg__coalesced_out = ({ out, self, coalesced }: { out: CTensor; self: CTensor; coalesced: boolean }): CTensor => {
  return addon.atg__coalesced_out(out, self, coalesced)
}

export const atg_copy_sparse_to_sparse = ({ self, src, non_blocking }: { self: CTensor; src: CTensor; non_blocking: boolean }): CTensor => {
  return addon.atg_copy_sparse_to_sparse(self, src, non_blocking)
}

export const atg_copy_sparse_to_sparse_out = ({ out, self, src, non_blocking }: { out: CTensor; self: CTensor; src: CTensor; non_blocking: boolean }): CTensor => {
  return addon.atg_copy_sparse_to_sparse_out(out, self, src, non_blocking)
}

export const atg__fused_moving_avg_obs_fq_helper_functional = ({ self, observer_on, fake_quant_on, running_min, running_max, scale, zero_point, averaging_const, quant_min, quant_max, ch_axis, per_row_fake_quant, symmetric_quant }: { self: CTensor; observer_on: CTensor; fake_quant_on: CTensor; running_min: CTensor; running_max: CTensor; scale: CTensor; zero_point: CTensor; averaging_const: number; quant_min: number; quant_max: number; ch_axis: number; per_row_fake_quant: boolean; symmetric_quant: boolean }): CTensor[] => {
  return addon.atg__fused_moving_avg_obs_fq_helper_functional(self, observer_on, fake_quant_on, running_min, running_max, scale, zero_point, averaging_const, quant_min, quant_max, ch_axis, per_row_fake_quant, symmetric_quant)
}

export const atg_lstm_mps_backward = ({ out0, out1, out2, grad_y, grad_hy, grad_cy, z_state, cell_state_fwd, input, layersOutputs, hx, params, has_biases, num_layers, dropout, train, bidirectional, batch_first }: { out0: CTensor; out1: CTensor[]; out2: CTensor[]; grad_y: CTensor; grad_hy?: CTensor; grad_cy?: CTensor; z_state: CTensor; cell_state_fwd: CTensor; input: CTensor; layersOutputs: CTensor; hx: CTensor[]; params: CTensor[]; has_biases: boolean; num_layers: number; dropout: number; train: boolean; bidirectional: boolean; batch_first: boolean }): void => {
  return addon.atg_lstm_mps_backward(out0, out1, out2, grad_y, grad_hy, grad_cy, z_state, cell_state_fwd, input, layersOutputs, hx, params, has_biases, num_layers, dropout, train, bidirectional, batch_first)
}

export const atg_set = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_set(self)
}

export const atg_set_source_tensor = ({ self, source }: { self: CTensor; source: CTensor }): CTensor => {
  return addon.atg_set_source_tensor(self, source)
}

export const atg_set_out = ({ out, self }: { out: CTensor; self: CTensor }): CTensor => {
  return addon.atg_set_out(out, self)
}

export const atg_set_source_tensor_out = ({ out, self, source }: { out: CTensor; self: CTensor; source: CTensor }): CTensor => {
  return addon.atg_set_source_tensor_out(out, self, source)
}

export const atg_random = ({ self }: { self: CTensor }): CTensor => {
  return addon.atg_random(self)
}

export const atg_random_to = ({ self, to }: { self: CTensor; to: number }): CTensor => {
  return addon.atg_random_to(self, to)
}

export const atg_random_from = ({ self, from, to }: { self: CTensor; from: number; to?: number }): CTensor => {
  return addon.atg_random_from(self, from, to)
}

export const atg_random_out = ({ out, self }: { out: CTensor; self: CTensor }): CTensor => {
  return addon.atg_random_out(out, self)
}

export const atg_random_to_out = ({ out, self, to }: { out: CTensor; self: CTensor; to: number }): CTensor => {
  return addon.atg_random_to_out(out, self, to)
}

export const atg_random_from_out = ({ out, self, from, to }: { out: CTensor; self: CTensor; from: number; to?: number }): CTensor => {
  return addon.atg_random_from_out(out, self, from, to)
}

export const atg_uniform = ({ self, from, to }: { self: CTensor; from: number; to: number }): CTensor => {
  return addon.atg_uniform(self, from, to)
}

export const atg_uniform_out = ({ out, self, from, to }: { out: CTensor; self: CTensor; from: number; to: number }): CTensor => {
  return addon.atg_uniform_out(out, self, from, to)
}

export const atg_cauchy = ({ self, median, sigma }: { self: CTensor; median: number; sigma: number }): CTensor => {
  return addon.atg_cauchy(self, median, sigma)
}

export const atg_cauchy_out = ({ out, self, median, sigma }: { out: CTensor; self: CTensor; median: number; sigma: number }): CTensor => {
  return addon.atg_cauchy_out(out, self, median, sigma)
}

export const atg_log_normal = ({ self, mean, std }: { self: CTensor; mean: number; std: number }): CTensor => {
  return addon.atg_log_normal(self, mean, std)
}

export const atg_log_normal_out = ({ out, self, mean, std }: { out: CTensor; self: CTensor; mean: number; std: number }): CTensor => {
  return addon.atg_log_normal_out(out, self, mean, std)
}

export const atg_exponential = ({ self, lambd }: { self: CTensor; lambd: number }): CTensor => {
  return addon.atg_exponential(self, lambd)
}

export const atg_exponential_out = ({ out, self, lambd }: { out: CTensor; self: CTensor; lambd: number }): CTensor => {
  return addon.atg_exponential_out(out, self, lambd)
}

export const atg_geometric = ({ self, p }: { self: CTensor; p: number }): CTensor => {
  return addon.atg_geometric(self, p)
}

export const atg_geometric_out = ({ out, self, p }: { out: CTensor; self: CTensor; p: number }): CTensor => {
  return addon.atg_geometric_out(out, self, p)
}

export const atg__histogramdd_bin_edges = ({ out, self, bins, range, weight, density }: { out: CTensor[]; self: CTensor; bins: number[]; range: number[]; weight?: CTensor; density: boolean }): void => {
  return addon.atg__histogramdd_bin_edges(out, self, bins, range, weight, density)
}

export const atg__amp_update_scale = ({ self, growth_tracker, found_inf, scale_growth_factor, scale_backoff_factor, growth_interval }: { self: CTensor; growth_tracker: CTensor; found_inf: CTensor; scale_growth_factor: number; scale_backoff_factor: number; growth_interval: number }): CTensor[] => {
  return addon.atg__amp_update_scale(self, growth_tracker, found_inf, scale_growth_factor, scale_backoff_factor, growth_interval)
}

export const atg__amp_update_scale_out = ({ out, self, growth_tracker, found_inf, scale_growth_factor, scale_backoff_factor, growth_interval }: { out: CTensor; self: CTensor; growth_tracker: CTensor; found_inf: CTensor; scale_growth_factor: number; scale_backoff_factor: number; growth_interval: number }): CTensor => {
  return addon.atg__amp_update_scale_out(out, self, growth_tracker, found_inf, scale_growth_factor, scale_backoff_factor, growth_interval)
}

export const atg__fused_adam = ({ out, self, grads, exp_avgs, exp_avg_sqs, max_exp_avg_sqs, state_steps, lr, beta1, beta2, weight_decay, eps, amsgrad, maximize, grad_scale, found_inf }: { out: CTensor[]; self: CTensor[]; grads: CTensor[]; exp_avgs: CTensor[]; exp_avg_sqs: CTensor[]; max_exp_avg_sqs: CTensor[]; state_steps: CTensor[]; lr: number; beta1: number; beta2: number; weight_decay: number; eps: number; amsgrad: boolean; maximize: boolean; grad_scale?: CTensor; found_inf?: CTensor }): void => {
  return addon.atg__fused_adam(out, self, grads, exp_avgs, exp_avg_sqs, max_exp_avg_sqs, state_steps, lr, beta1, beta2, weight_decay, eps, amsgrad, maximize, grad_scale, found_inf)
}

export const atg__fused_adamw = ({ out, self, grads, exp_avgs, exp_avg_sqs, max_exp_avg_sqs, state_steps, lr, beta1, beta2, weight_decay, eps, amsgrad, maximize, grad_scale, found_inf }: { out: CTensor[]; self: CTensor[]; grads: CTensor[]; exp_avgs: CTensor[]; exp_avg_sqs: CTensor[]; max_exp_avg_sqs: CTensor[]; state_steps: CTensor[]; lr: number; beta1: number; beta2: number; weight_decay: number; eps: number; amsgrad: boolean; maximize: boolean; grad_scale?: CTensor; found_inf?: CTensor }): void => {
  return addon.atg__fused_adamw(out, self, grads, exp_avgs, exp_avg_sqs, max_exp_avg_sqs, state_steps, lr, beta1, beta2, weight_decay, eps, amsgrad, maximize, grad_scale, found_inf)
}

